/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
export function PositionPathBuilderOptions() { }
if (false) {
    /**
     * The minimum distnace the next point must be from the previous point to count
     * as a new point (in meters).
     * @type {?|undefined}
     */
    PositionPathBuilderOptions.prototype.minimumVertexDistanceMeters;
    /**
     * When true, will use the "minimumVertexDistanceMeters" setting to filter out points
     * that are not far enough away from the previous point.
     * @type {?|undefined}
     */
    PositionPathBuilderOptions.prototype.requireMinimumVertexDistance;
    /**
     * The accuracy (in meters) that must be met in order for it to be an acceptable point.
     * If the accuracy of a given point does not meet this standard it will not be added
     * to the point collection.
     * @type {?|undefined}
     */
    PositionPathBuilderOptions.prototype.gpsRequiredAccuracyMeters;
    /**
     * When true, will use the "gpsRequiredAccuracyMeters" setting to filter out points
     * that are do not meet the required accuracy threshold.
     * @type {?|undefined}
     */
    PositionPathBuilderOptions.prototype.requireAccuracy;
    /**
     * The required precision to determine that two points are at the same location.
     * @type {?|undefined}
     */
    PositionPathBuilderOptions.prototype.pointEquivalencyPrecision;
    /**
     * Includes z values (altitude) in exported geometry.
     * @type {?|undefined}
     */
    PositionPathBuilderOptions.prototype.returnZValues;
    /**
     * Includes m values (measure) in exported geometry.
     * @type {?|undefined}
     */
    PositionPathBuilderOptions.prototype.returnMValues;
    /**
     * The unit to calculate distance between verticees on (if returnMValues property is set to true).
     * @type {?|undefined}
     */
    PositionPathBuilderOptions.prototype.mValueUnit;
    /**
     * Stores every point that is added to the path in the native order it was added.
     * This option is typically used for analysis or debugging purposes.
     * @type {?|undefined}
     */
    PositionPathBuilderOptions.prototype.storeUnfilteredPath;
    /**
     * The distance threshold at which a calibration point measure will try to create a new vertex in the path.
     * The vertex will be placed based on the interpolated value between the last two vertices (based on timestamp).
     * For example, if the "calibrationMeasureSnappingDistanceDelta" value is
     * @type {?|undefined}
     */
    PositionPathBuilderOptions.prototype.calibrationMeasureSnappingDistanceDelta;
    /**
     * The units of the "calibrationMeasureSnappingDistanceDelta" value.
     * @type {?|undefined}
     */
    PositionPathBuilderOptions.prototype.calibrationMeasureSnappingDistanceDeltaUnit;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zaXRpb24tcGF0aC1idWlsZGVyLW9wdGlvbnMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdHNzL3Nkay8iLCJzb3VyY2VzIjpbImxpYi9nZW9sb2NhdGlvbi9wb3NpdGlvbi1wYXRoLWJ1aWxkZXItb3B0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBS0EsZ0RBK0RDOzs7Ozs7O0lBMURDLGlFQUE0Qzs7Ozs7O0lBTTVDLGtFQUE4Qzs7Ozs7OztJQU85QywrREFBd0M7Ozs7OztJQU14QyxxREFBaUM7Ozs7O0lBS2pDLCtEQUF1Qzs7Ozs7SUFLdkMsbURBQStCOzs7OztJQUsvQixtREFBK0I7Ozs7O0lBSy9CLGdEQUF5Qzs7Ozs7O0lBTXpDLHlEQUFzQzs7Ozs7OztJQU90Qyw2RUFBcUQ7Ozs7O0lBS3JELGlGQUEyRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExlbmd0aFVuaXQgfSBmcm9tICcuLi9jb3JlL3VuaXRzL2xlbmd0aC11bml0JztcblxuXG5leHBvcnQgdHlwZSBUdXJmRGlzdGFuY2VVbml0cyA9ICdtaWxlcycgfCAna2lsb21ldGVycycgfCAncmFkaWFucycgfCAnZGVncmVlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9zaXRpb25QYXRoQnVpbGRlck9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIG1pbmltdW0gZGlzdG5hY2UgdGhlIG5leHQgcG9pbnQgbXVzdCBiZSBmcm9tIHRoZSBwcmV2aW91cyBwb2ludCB0byBjb3VudFxuICAgKiBhcyBhIG5ldyBwb2ludCAoaW4gbWV0ZXJzKS5cbiAgICovXG4gIG1pbmltdW1WZXJ0ZXhEaXN0YW5jZU1ldGVycz86IG51bWJlciB8IDAuMjU7XG5cbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgd2lsbCB1c2UgdGhlIFwibWluaW11bVZlcnRleERpc3RhbmNlTWV0ZXJzXCIgc2V0dGluZyB0byBmaWx0ZXIgb3V0IHBvaW50c1xuICAgKiB0aGF0IGFyZSBub3QgZmFyIGVub3VnaCBhd2F5IGZyb20gdGhlIHByZXZpb3VzIHBvaW50LlxuICAgKi9cbiAgcmVxdWlyZU1pbmltdW1WZXJ0ZXhEaXN0YW5jZT86IGJvb2xlYW4gfCB0cnVlO1xuXG4gIC8qKlxuICAgKiBUaGUgYWNjdXJhY3kgKGluIG1ldGVycykgdGhhdCBtdXN0IGJlIG1ldCBpbiBvcmRlciBmb3IgaXQgdG8gYmUgYW4gYWNjZXB0YWJsZSBwb2ludC5cbiAgICogSWYgdGhlIGFjY3VyYWN5IG9mIGEgZ2l2ZW4gcG9pbnQgZG9lcyBub3QgbWVldCB0aGlzIHN0YW5kYXJkIGl0IHdpbGwgbm90IGJlIGFkZGVkXG4gICAqIHRvIHRoZSBwb2ludCBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZ3BzUmVxdWlyZWRBY2N1cmFjeU1ldGVycz86IG51bWJlciB8IDEwO1xuXG4gIC8qKlxuICAgKiBXaGVuIHRydWUsIHdpbGwgdXNlIHRoZSBcImdwc1JlcXVpcmVkQWNjdXJhY3lNZXRlcnNcIiBzZXR0aW5nIHRvIGZpbHRlciBvdXQgcG9pbnRzXG4gICAqIHRoYXQgYXJlIGRvIG5vdCBtZWV0IHRoZSByZXF1aXJlZCBhY2N1cmFjeSB0aHJlc2hvbGQuXG4gICAqL1xuICByZXF1aXJlQWNjdXJhY3k/OiBib29sZWFuIHwgdHJ1ZTtcblxuICAvKipcbiAgICogVGhlIHJlcXVpcmVkIHByZWNpc2lvbiB0byBkZXRlcm1pbmUgdGhhdCB0d28gcG9pbnRzIGFyZSBhdCB0aGUgc2FtZSBsb2NhdGlvbi5cbiAgICovXG4gIHBvaW50RXF1aXZhbGVuY3lQcmVjaXNpb24/OiBudW1iZXIgfCA4O1xuXG4gIC8qKlxuICAgKiBJbmNsdWRlcyB6IHZhbHVlcyAoYWx0aXR1ZGUpIGluIGV4cG9ydGVkIGdlb21ldHJ5LlxuICAgKi9cbiAgcmV0dXJuWlZhbHVlcz86IGJvb2xlYW4gfCB0cnVlO1xuXG4gIC8qKlxuICAgKiBJbmNsdWRlcyBtIHZhbHVlcyAobWVhc3VyZSkgaW4gZXhwb3J0ZWQgZ2VvbWV0cnkuXG4gICAqL1xuICByZXR1cm5NVmFsdWVzPzogYm9vbGVhbiB8IHRydWU7XG5cbiAgLyoqXG4gICAqIFRoZSB1bml0IHRvIGNhbGN1bGF0ZSBkaXN0YW5jZSBiZXR3ZWVuIHZlcnRpY2VlcyBvbiAoaWYgcmV0dXJuTVZhbHVlcyBwcm9wZXJ0eSBpcyBzZXQgdG8gdHJ1ZSkuXG4gICAqL1xuICBtVmFsdWVVbml0PzogVHVyZkRpc3RhbmNlVW5pdHMgfCAnbWlsZXMnO1xuXG4gIC8qKlxuICAgKiBTdG9yZXMgZXZlcnkgcG9pbnQgdGhhdCBpcyBhZGRlZCB0byB0aGUgcGF0aCBpbiB0aGUgbmF0aXZlIG9yZGVyIGl0IHdhcyBhZGRlZC5cbiAgICogVGhpcyBvcHRpb24gaXMgdHlwaWNhbGx5IHVzZWQgZm9yIGFuYWx5c2lzIG9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICovXG4gIHN0b3JlVW5maWx0ZXJlZFBhdGg/OiBib29sZWFuIHwgZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBkaXN0YW5jZSB0aHJlc2hvbGQgYXQgd2hpY2ggYSBjYWxpYnJhdGlvbiBwb2ludCBtZWFzdXJlIHdpbGwgdHJ5IHRvIGNyZWF0ZSBhIG5ldyB2ZXJ0ZXggaW4gdGhlIHBhdGguXG4gICAqIFRoZSB2ZXJ0ZXggd2lsbCBiZSBwbGFjZWQgYmFzZWQgb24gdGhlIGludGVycG9sYXRlZCB2YWx1ZSBiZXR3ZWVuIHRoZSBsYXN0IHR3byB2ZXJ0aWNlcyAoYmFzZWQgb24gdGltZXN0YW1wKS5cbiAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBcImNhbGlicmF0aW9uTWVhc3VyZVNuYXBwaW5nRGlzdGFuY2VEZWx0YVwiIHZhbHVlIGlzXG4gICAqL1xuICBjYWxpYnJhdGlvbk1lYXN1cmVTbmFwcGluZ0Rpc3RhbmNlRGVsdGE/OiBudW1iZXIgfCAyO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pdHMgb2YgdGhlIFwiY2FsaWJyYXRpb25NZWFzdXJlU25hcHBpbmdEaXN0YW5jZURlbHRhXCIgdmFsdWUuXG4gICAqL1xuICBjYWxpYnJhdGlvbk1lYXN1cmVTbmFwcGluZ0Rpc3RhbmNlRGVsdGFVbml0PzogTGVuZ3RoVW5pdCB8IExlbmd0aFVuaXQuRm9vdDtcbn1cbiJdfQ==