/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Angular.
import { Injectable } from '@angular/core';
import { GeolocatorAccuracyUnit } from './geolocator-accuracy-unit';
import { Logger } from '../../core/logging/logger.service';
import * as i0 from "@angular/core";
import * as i1 from "../../core/logging/logger.service";
/**
 * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
 * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
 * @abstract
 */
var BaseGeolocator = /** @class */ (function () {
    function BaseGeolocator(log) {
        this.log = log;
        this.capabilities = [];
        this.accuracyUnit = GeolocatorAccuracyUnit.Meter;
    }
    /**
     * @param {?} capability
     * @return {?}
     */
    BaseGeolocator.prototype.hasCapability = /**
     * @param {?} capability
     * @return {?}
     */
    function (capability) {
        return this.capabilities.indexOf(capability) > -1;
    };
    BaseGeolocator.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    BaseGeolocator.ctorParameters = function () { return [
        { type: Logger }
    ]; };
    /** @nocollapse */ BaseGeolocator.ngInjectableDef = i0.defineInjectable({ factory: function BaseGeolocator_Factory() { return new BaseGeolocator(i0.inject(i1.Logger)); }, token: BaseGeolocator, providedIn: "root" });
    return BaseGeolocator;
}());
export { BaseGeolocator };
if (false) {
    /** @type {?} */
    BaseGeolocator.prototype.capabilities;
    /** @type {?} */
    BaseGeolocator.prototype.accuracyUnit;
    /**
     * @type {?}
     * @protected
     */
    BaseGeolocator.prototype.log;
    /**
     * @abstract
     * @return {?}
     */
    BaseGeolocator.prototype.name = function () { };
    /**
     * @abstract
     * @return {?}
     */
    BaseGeolocator.prototype.description = function () { };
    /**
     * Get the device's current position.
     * @abstract
     * @param {?=} options
     * @return {?}
     */
    BaseGeolocator.prototype.getCurrentPosition = function (options) { };
    /**
     * Watch the current device's position.  Clear the watch by unsubscribing from
     * Observable changes.
     *
     * ```typescript
     * const subscription = this.geolocation.watchPosition()
     *                               .filter(p => Boolean(p.coords)) //Filter Out Errors
     *                               .subscribe(position =>
     *   console.log(position.coords.longitude + ' ' + position.coords.latitude)
     * );
     *
     * // To stop notifications
     * subscription.unsubscribe();
     * ```
     * @abstract
     * @param {?=} options
     * @return {?}
     */
    BaseGeolocator.prototype.watchPosition = function (options) { };
    /**
     * @abstract
     * @return {?}
     */
    BaseGeolocator.prototype.isAvailable = function () { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1nZW9sb2NhdG9yLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdHNzL3Nkay8iLCJzb3VyY2VzIjpbImxpYi9nZW9sb2NhdGlvbi9nZW9sb2NhdG9yL2Jhc2UtZ2VvbG9jYXRvci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUkzQyxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUdwRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sbUNBQW1DLENBQUM7Ozs7Ozs7O0FBUTNEO0lBU0Usd0JBQStCLEdBQVc7UUFBWCxRQUFHLEdBQUgsR0FBRyxDQUFRO1FBTDFDLGlCQUFZLEdBQTJCLEVBQUUsQ0FBQztRQUMxQyxpQkFBWSxHQUEyQixzQkFBc0IsQ0FBQyxLQUFLLENBQUM7SUFLcEUsQ0FBQzs7Ozs7SUF5QkQsc0NBQWE7Ozs7SUFBYixVQUFjLFVBQWdDO1FBQzVDLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDcEQsQ0FBQzs7Z0JBckNGLFVBQVUsU0FBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkI7Ozs7Z0JBVlEsTUFBTTs7O3lCQVJmO0NBc0RDLEFBdENELElBc0NDO1NBbkNxQixjQUFjOzs7SUFDbEMsc0NBQTBDOztJQUMxQyxzQ0FBb0U7Ozs7O0lBSXhELDZCQUE4Qjs7Ozs7SUFIMUMsZ0RBQTRCOzs7OztJQUM1Qix1REFBbUM7Ozs7Ozs7SUFRbkMscUVBQTZFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBaUI3RSxnRUFBMkU7Ozs7O0lBQzNFLHVEQUE0QyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEFuZ3VsYXIuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8vIDNyZCBQYXJ0eS5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEdlb2xvY2F0b3JBY2N1cmFjeVVuaXQgfSBmcm9tICcuL2dlb2xvY2F0b3ItYWNjdXJhY3ktdW5pdCc7XG5pbXBvcnQgeyBHcHNQb3NpdGlvbiB9IGZyb20gJy4uL2dwcy1wb3NpdGlvbi9ncHMtcG9zaXRpb24nO1xuaW1wb3J0IHsgR2VvbG9jYXRvckNhcGFiaWxpdHkgfSBmcm9tICcuL2dlb2xvY2F0b3ItY2FwYWJpbGl0eSc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi8uLi9jb3JlL2xvZ2dpbmcvbG9nZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgR2VvbG9jYXRvciB9IGZyb20gJy4vZ2VvbG9jYXRvcic7XG5cblxuLyoqXG4gKiBXcmFwcGVyIGZvciBnZW9sb2NhdGlvbiBzZXJ2aWNlLiBUaGUgd3JhcHBlciBwcmltYXJpbHkgZXhpc3RzIHRvIGFic3RyYWN0IHRoZSBkaXJlY3QgaW50ZXJhY3Rpb24gd2l0aFxuICogdGhlIFwibmF2aWdhdG9yXCIgb2JqZWN0IGFuZCB0byBhbGxvdyBmb3IgaW5qZWN0aW5nIG90aGVyIGltcGxlbWVudGF0aW9ucyBvZiBnZW9sb2NhdGlvbiBmdW5jdGlvbmFsaXR5LlxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlR2VvbG9jYXRvciBpbXBsZW1lbnRzIEdlb2xvY2F0b3Ige1xuICBjYXBhYmlsaXRpZXM6IEdlb2xvY2F0b3JDYXBhYmlsaXR5W10gPSBbXTtcbiAgYWNjdXJhY3lVbml0OiBHZW9sb2NhdG9yQWNjdXJhY3lVbml0ID0gR2VvbG9jYXRvckFjY3VyYWN5VW5pdC5NZXRlcjtcbiAgYWJzdHJhY3QgZ2V0IG5hbWUoKTogc3RyaW5nO1xuICBhYnN0cmFjdCBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBsb2c6IExvZ2dlcikge1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGV2aWNlJ3MgY3VycmVudCBwb3NpdGlvbi5cbiAgICovXG4gIGFic3RyYWN0IGdldEN1cnJlbnRQb3NpdGlvbihvcHRpb25zPzogUG9zaXRpb25PcHRpb25zKTogUHJvbWlzZTxHcHNQb3NpdGlvbj47XG5cbiAgLyoqXG4gICAqIFdhdGNoIHRoZSBjdXJyZW50IGRldmljZSdzIHBvc2l0aW9uLiAgQ2xlYXIgdGhlIHdhdGNoIGJ5IHVuc3Vic2NyaWJpbmcgZnJvbVxuICAgKiBPYnNlcnZhYmxlIGNoYW5nZXMuXG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKClcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihwID0+IEJvb2xlYW4ocC5jb29yZHMpKSAvL0ZpbHRlciBPdXQgRXJyb3JzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUocG9zaXRpb24gPT5cbiAgICogICBjb25zb2xlLmxvZyhwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlICsgJyAnICsgcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlKVxuICAgKiApO1xuICAgKlxuICAgKiAvLyBUbyBzdG9wIG5vdGlmaWNhdGlvbnNcbiAgICogc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAqIGBgYFxuICAgKi9cbiAgYWJzdHJhY3Qgd2F0Y2hQb3NpdGlvbihvcHRpb25zPzogUG9zaXRpb25PcHRpb25zKTogT2JzZXJ2YWJsZTxHcHNQb3NpdGlvbj47XG4gIGFic3RyYWN0IGlzQXZhaWxhYmxlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj47XG5cbiAgaGFzQ2FwYWJpbGl0eShjYXBhYmlsaXR5OiBHZW9sb2NhdG9yQ2FwYWJpbGl0eSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNhcGFiaWxpdGllcy5pbmRleE9mKGNhcGFiaWxpdHkpID4gLTE7XG4gIH1cbn1cbiJdfQ==