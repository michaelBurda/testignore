/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// 3rd Party.
import { Subject, of, iif } from 'rxjs';
import { takeWhile, tap, filter, mergeMap, map } from 'rxjs/operators';
import { QueueWorkerToken } from './queue-worker-token';
import { WorkQueueStatusEventType } from './work-queue-status-event-type';
import { WorkQueueStatusTracker } from './work-queue-status-tracker';
import { isValue } from '../core/type-check/is-value.function';
import { isNotValue } from '../core/type-check/is-not-value.function';
/** @type {?} */
export var DEFAULT_WORK_QUEUE_OPTIONS = {
    autoStartWorkers: true,
    workerCount: 1,
};
/**
 * Provides the core queueing workflow for basic unit of work queues.
 * High Priority Todos:
 * * Implement worker cancelation into the worker token - RG.
 *
 * Low Priority Todos:
 * * Add queue prioritization - a queue priority flag to pull those items first from the queue - RG.
 * * Change overriding of methods to use metho attributes instead. Example: \@OnWorkComplete.
 * @abstract
 * @template TInput, TOutput
 */
var /**
 * Provides the core queueing workflow for basic unit of work queues.
 * High Priority Todos:
 * * Implement worker cancelation into the worker token - RG.
 *
 * Low Priority Todos:
 * * Add queue prioritization - a queue priority flag to pull those items first from the queue - RG.
 * * Change overriding of methods to use metho attributes instead. Example: \@OnWorkComplete.
 * @abstract
 * @template TInput, TOutput
 */
WorkQueueManager = /** @class */ (function () {
    function WorkQueueManager(log, options) {
        var _this = this;
        this.log = log;
        this.workerTokens = [];
        this.tracker = new WorkQueueStatusTracker();
        this.options = Object.assign({}, DEFAULT_WORK_QUEUE_OPTIONS);
        this.setOptions(options);
        this.queueChangeObserver = new Subject();
        this.queueChange = this.queueChangeObserver.pipe();
        this.queueStarted = this.queueChangeObserver.pipe(filter((/**
         * @param {?} change
         * @return {?}
         */
        function (change) { return change.event === WorkQueueStatusEventType.QueueStarted; })));
        this.queueComplete = this.queueChangeObserver.pipe(filter((/**
         * @param {?} change
         * @return {?}
         */
        function (change) { return change.event === WorkQueueStatusEventType.QueueComplete; })));
        if (this.options.autoStartWorkers) {
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.startWork(); }));
        }
    }
    Object.defineProperty(WorkQueueManager.prototype, "isWorking", {
        get: /**
         * @return {?}
         */
        function () {
            return this.tracker.isWorking;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorkQueueManager.prototype, "status", {
        get: /**
         * @return {?}
         */
        function () {
            return this.tracker.getStatus();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Overrides default options.
     * @param options Options to override the defaults.
     */
    /**
     * Overrides default options.
     * @param {?} options Options to override the defaults.
     * @return {?}
     */
    WorkQueueManager.prototype.setOptions = /**
     * Overrides default options.
     * @param {?} options Options to override the defaults.
     * @return {?}
     */
    function (options) {
        Object.assign(this.options, options);
        return this;
    };
    /**
     * Kicks off the queue workflow with the specified number of workers. If
     * the maximum number of workers are currently running, no additional workers
     * will be created (only the delta of allowed and running will be started).
     */
    /**
     * Kicks off the queue workflow with the specified number of workers. If
     * the maximum number of workers are currently running, no additional workers
     * will be created (only the delta of allowed and running will be started).
     * @return {?}
     */
    WorkQueueManager.prototype.startWork = /**
     * Kicks off the queue workflow with the specified number of workers. If
     * the maximum number of workers are currently running, no additional workers
     * will be created (only the delta of allowed and running will be started).
     * @return {?}
     */
    function () {
        var _this = this;
        // We dont' want to change the queue size if the queue is already working
        // because it will mess up the statistics (percent copmlete, etc).
        /** @type {?} */
        var starterSource = iif((/**
         * @return {?}
         */
        function () { return !_this.isWorking; }), this.getRemainingQueueCount()
            .pipe(tap((/**
         * @param {?} queueCount
         * @return {?}
         */
        function (queueCount) { return _this.tracker.setQueueSize(queueCount); }))));
        this.onReady()
            .pipe(mergeMap((/**
         * @return {?}
         */
        function () { return starterSource; })))
            .subscribe((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var workersToStart = _this.options.workerCount - _this.workerTokens.length;
            if (workersToStart > 0) {
                _this.emitQueueChange(null, WorkQueueStatusEventType.QueueStarted);
            }
            for (var i = 0; i < workersToStart; i++) {
                /** @type {?} */
                var token = new QueueWorkerToken().start();
                _this.tracker.addWorker(token);
                _this.workerTokens.push(token);
                _this.emitQueueChange(token, WorkQueueStatusEventType.QueueWorkerStarted);
                _this.getNextAndDoWork(token);
            }
        }));
    };
    /**
     * Stops all workers from processing the queue.
     */
    /**
     * Stops all workers from processing the queue.
     * @return {?}
     */
    WorkQueueManager.prototype.stopWork = /**
     * Stops all workers from processing the queue.
     * @return {?}
     */
    function () {
        this.workerTokens.forEach((/**
         * @param {?} token
         * @return {?}
         */
        function (token) { return token.cancel(); }));
    };
    /**
     * Method that determines that the workers are ready to be started. Note, in this implementation it
     * makes use of an empty promise. The main reason for this is to provide a hook for other implementers
     * to setup/initialize the queue before starting the workers. Additionaly, this practices provides a
     * way to run the workers asynchronously.
     */
    /**
     * Method that determines that the workers are ready to be started. Note, in this implementation it
     * makes use of an empty promise. The main reason for this is to provide a hook for other implementers
     * to setup/initialize the queue before starting the workers. Additionaly, this practices provides a
     * way to run the workers asynchronously.
     * @protected
     * @return {?}
     */
    WorkQueueManager.prototype.onReady = /**
     * Method that determines that the workers are ready to be started. Note, in this implementation it
     * makes use of an empty promise. The main reason for this is to provide a hook for other implementers
     * to setup/initialize the queue before starting the workers. Additionaly, this practices provides a
     * way to run the workers asynchronously.
     * @protected
     * @return {?}
     */
    function () {
        return of(null);
    };
    /**
     * @protected
     * @param {?} input
     * @return {?}
     */
    WorkQueueManager.prototype.onBeforeWorkStarted = /**
     * @protected
     * @param {?} input
     * @return {?}
     */
    function (input) {
        return of(input);
    };
    /**
     * @protected
     * @param {?} data
     * @return {?}
     */
    WorkQueueManager.prototype.onWorkComplete = /**
     * @protected
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return of(data);
    };
    /**
     * @protected
     * @param {?} data
     * @param {?} error
     * @return {?}
     */
    WorkQueueManager.prototype.onWorkFailed = /**
     * @protected
     * @param {?} data
     * @param {?} error
     * @return {?}
     */
    function (data, error) {
        return of(data, error);
    };
    /**
     * @protected
     * @return {?}
     */
    WorkQueueManager.prototype.getRemainingQueueCount = /**
     * @protected
     * @return {?}
     */
    function () {
        return of(-1);
    };
    /**
     * @protected
     * @param {?} token
     * @param {?} event
     * @param {?=} input
     * @param {?=} output
     * @return {?}
     */
    WorkQueueManager.prototype.emitQueueChange = /**
     * @protected
     * @param {?} token
     * @param {?} event
     * @param {?=} input
     * @param {?=} output
     * @return {?}
     */
    function (token, event, input, output) {
        this.queueChangeObserver.next({
            event: event,
            input: input,
            output: output,
            status: this.tracker.getStatus(),
            tokenId: token ? token.id : null,
        });
    };
    /**
     * @private
     * @param {?} token
     * @param {?=} input
     * @param {?=} output
     * @return {?}
     */
    WorkQueueManager.prototype.emitWorkStarted = /**
     * @private
     * @param {?} token
     * @param {?=} input
     * @param {?=} output
     * @return {?}
     */
    function (token, input, output) {
        this.emitQueueChange(token, WorkQueueStatusEventType.UnitOfWorkStarted, input, output);
    };
    /**
     * @private
     * @param {?} token
     * @param {?=} input
     * @param {?=} output
     * @return {?}
     */
    WorkQueueManager.prototype.emitWorkComplete = /**
     * @private
     * @param {?} token
     * @param {?=} input
     * @param {?=} output
     * @return {?}
     */
    function (token, input, output) {
        this.emitQueueChange(token, WorkQueueStatusEventType.UnitOfWorkComplete, input, output);
    };
    /**
     * @private
     * @param {?} token
     * @return {?}
     */
    WorkQueueManager.prototype.onWorkerCompleted = /**
     * @private
     * @param {?} token
     * @return {?}
     */
    function (token) {
        if (token.isComplete) {
            return;
        }
        /** @type {?} */
        var index = this.workerTokens.indexOf(token);
        token.complete();
        if (index !== -1) {
            this.workerTokens.splice(index, 1);
        }
        this.emitQueueChange(token, WorkQueueStatusEventType.QueueWorkerComplete);
        if (this.workerTokens.length === 0) {
            this.emitQueueChange(token, WorkQueueStatusEventType.QueueComplete);
            this.tracker.complete();
        }
    };
    /**
     * @private
     * @param {?} token
     * @param {?} next
     * @return {?}
     */
    WorkQueueManager.prototype.checkIfWorkerComplete = /**
     * @private
     * @param {?} token
     * @param {?} next
     * @return {?}
     */
    function (token, next) {
        if (isNotValue(next)) {
            this.onWorkerCompleted(token);
        }
    };
    /**
     * @private
     * @param {?} token
     * @return {?}
     */
    WorkQueueManager.prototype.getNextAndDoWork = /**
     * @private
     * @param {?} token
     * @return {?}
     */
    function (token) {
        var _this = this;
        if (token.isCanceled) {
            this.log.debug("Canceling worker due to canceled toke: " + token.id);
            this.onWorkerCompleted(token);
        }
        this.log.trace('Retrieving next queue item to start processing');
        /** @type {?} */
        var processingData = { input: null, output: null };
        this.getNext()
            .pipe(tap((/**
         * @param {?} input
         * @return {?}
         */
        function (input) { return processingData.input = input; })), tap((/**
         * @param {?} input
         * @return {?}
         */
        function (input) { return _this.checkIfWorkerComplete(token, input); })), takeWhile((/**
         * @param {?} input
         * @return {?}
         */
        function (input) { return isValue(input) && !token.isCanceled; })), tap((/**
         * @param {?} input
         * @return {?}
         */
        function (input) { return _this.emitWorkStarted(token, input); })), mergeMap((/**
         * @param {?} input
         * @return {?}
         */
        function (input) { return _this.onBeforeWorkStarted(input); })), mergeMap((/**
         * @param {?} input
         * @return {?}
         */
        function (input) { return _this.doWork(input); })), tap((/**
         * @param {?} output
         * @return {?}
         */
        function (output) { return processingData.output = output; })), map((/**
         * @return {?}
         */
        function () { return processingData; })), mergeMap((/**
         * @param {?} data
         * @return {?}
         */
        function (data) { return _this.onWorkComplete(data); })))
            .subscribe((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            _this.log.trace('Completed work for item');
            token.totalComplete++;
            _this.emitWorkComplete(token, data.input, data.output);
            _this.getNextAndDoWork(token);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            _this.log.error("Failed to process item. {error}", error);
            token.totalFailed++;
            _this.onWorkFailed(processingData, error)
                .toPromise()
                .then((/**
             * @return {?}
             */
            function () { return _this.getNextAndDoWork(token); }));
        }));
    };
    return WorkQueueManager;
}());
/**
 * Provides the core queueing workflow for basic unit of work queues.
 * High Priority Todos:
 * * Implement worker cancelation into the worker token - RG.
 *
 * Low Priority Todos:
 * * Add queue prioritization - a queue priority flag to pull those items first from the queue - RG.
 * * Change overriding of methods to use metho attributes instead. Example: \@OnWorkComplete.
 * @abstract
 * @template TInput, TOutput
 */
export { WorkQueueManager };
if (false) {
    /**
     * @type {?}
     * @private
     */
    WorkQueueManager.prototype.queueChangeObserver;
    /**
     * @type {?}
     * @protected
     */
    WorkQueueManager.prototype.workerTokens;
    /**
     * @type {?}
     * @protected
     */
    WorkQueueManager.prototype.tracker;
    /** @type {?} */
    WorkQueueManager.prototype.queueChange;
    /** @type {?} */
    WorkQueueManager.prototype.queueStarted;
    /** @type {?} */
    WorkQueueManager.prototype.queueComplete;
    /** @type {?} */
    WorkQueueManager.prototype.options;
    /**
     * @type {?}
     * @protected
     */
    WorkQueueManager.prototype.log;
    /**
     * Implementation method to do the actual unit of work.
     * @abstract
     * @protected
     * @param {?} item The input paramater needed to process the unit of work and return an output result.
     * @return {?}
     */
    WorkQueueManager.prototype.doWork = function (item) { };
    /**
     * Implementation method to retrieve the next value in the queue. Note, there are no further checks
     * to verify duplicate items are not processed - it is the responsibility of the implementer of this
     * base class to never return the same item from this method. Typically the item in the queue is either
     * dequeued or marked as "processing" to prevent this potential issue.
     * @abstract
     * @protected
     * @return {?}
     */
    WorkQueueManager.prototype.getNext = function () { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29yay1xdWV1ZS1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRzcy9zZGsvIiwic291cmNlcyI6WyJsaWIvcXVldWluZy93b3JrLXF1ZXVlLW1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxPQUFPLEVBQWMsT0FBTyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDcEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUl2RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUV4RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUMxRSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUlyRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDL0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLDBDQUEwQyxDQUFDOztBQUd0RSxNQUFNLEtBQU8sMEJBQTBCLEdBQUc7SUFDeEMsZ0JBQWdCLEVBQUUsSUFBSTtJQUN0QixXQUFXLEVBQUUsQ0FBQztDQUNmOzs7Ozs7Ozs7Ozs7QUFZRDs7Ozs7Ozs7Ozs7O0lBbUJFLDBCQUFzQixHQUFXLEVBQUUsT0FBNEI7UUFBL0QsaUJBZ0JDO1FBaEJxQixRQUFHLEdBQUgsR0FBRyxDQUFRO1FBaEJkLGlCQUFZLEdBQXVCLEVBQUUsQ0FBQztRQUN0QyxZQUFPLEdBQTJCLElBQUksc0JBQXNCLEVBQUUsQ0FBQztRQUt6RSxZQUFPLEdBQXVCLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLDBCQUEwQixDQUFDLENBQUM7UUFXbkYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUN6QyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUVuRCxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQy9DLE1BQU07Ozs7UUFBQyxVQUFBLE1BQU0sSUFBSSxPQUFBLE1BQU0sQ0FBQyxLQUFLLEtBQUssd0JBQXdCLENBQUMsWUFBWSxFQUF0RCxDQUFzRCxFQUFDLENBQ3pFLENBQUM7UUFFRixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQ2hELE1BQU07Ozs7UUFBQyxVQUFBLE1BQU0sSUFBSSxPQUFBLE1BQU0sQ0FBQyxLQUFLLEtBQUssd0JBQXdCLENBQUMsYUFBYSxFQUF2RCxDQUF1RCxFQUFDLENBQzFFLENBQUM7UUFFRixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEVBQUU7WUFDakMsVUFBVTs7O1lBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxTQUFTLEVBQUUsRUFBaEIsQ0FBZ0IsRUFBQyxDQUFDO1NBQ3BDO0lBQ0gsQ0FBQztJQXhCRCxzQkFBSSx1Q0FBUzs7OztRQUFiO1lBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQztRQUNoQyxDQUFDOzs7T0FBQTtJQUVELHNCQUFJLG9DQUFNOzs7O1FBQVY7WUFDRSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDbEMsQ0FBQzs7O09BQUE7SUFvQkQ7OztPQUdHOzs7Ozs7SUFDSCxxQ0FBVTs7Ozs7SUFBVixVQUFXLE9BQTJCO1FBQ3BDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNyQyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7OztPQUlHOzs7Ozs7O0lBQ0gsb0NBQVM7Ozs7OztJQUFUO1FBQUEsaUJBNkJDOzs7O1lBMUJPLGFBQWEsR0FBRyxHQUFHOzs7UUFBQyxjQUFNLE9BQUEsQ0FBQyxLQUFJLENBQUMsU0FBUyxFQUFmLENBQWUsR0FDN0MsSUFBSSxDQUFDLHNCQUFzQixFQUFFO2FBQzFCLElBQUksQ0FDSCxHQUFHOzs7O1FBQUMsVUFBQyxVQUFrQixJQUFLLE9BQUEsS0FBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLEVBQXJDLENBQXFDLEVBQUMsQ0FDbkUsQ0FDSjtRQUVELElBQUksQ0FBQyxPQUFPLEVBQUU7YUFDWCxJQUFJLENBQ0gsUUFBUTs7O1FBQUMsY0FBTSxPQUFBLGFBQWEsRUFBYixDQUFhLEVBQUMsQ0FDOUI7YUFDQSxTQUFTOzs7UUFBQzs7Z0JBQ0gsY0FBYyxHQUFHLEtBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxHQUFHLEtBQUksQ0FBQyxZQUFZLENBQUMsTUFBTTtZQUUxRSxJQUFJLGNBQWMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3RCLEtBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLHdCQUF3QixDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQ25FO1lBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGNBQWMsRUFBRSxDQUFDLEVBQUUsRUFBRTs7b0JBQ2pDLEtBQUssR0FBRyxJQUFJLGdCQUFnQixFQUFFLENBQUMsS0FBSyxFQUFFO2dCQUM1QyxLQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDOUIsS0FBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzlCLEtBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLHdCQUF3QixDQUFDLGtCQUFrQixDQUFDLENBQUM7Z0JBQ3pFLEtBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUM5QjtRQUNILENBQUMsRUFBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOztPQUVHOzs7OztJQUNILG1DQUFROzs7O0lBQVI7UUFDRSxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU87Ozs7UUFBQyxVQUFBLEtBQUssSUFBSSxPQUFBLEtBQUssQ0FBQyxNQUFNLEVBQUUsRUFBZCxDQUFjLEVBQUMsQ0FBQztJQUNyRCxDQUFDO0lBZ0JEOzs7OztPQUtHOzs7Ozs7Ozs7SUFDTyxrQ0FBTzs7Ozs7Ozs7SUFBakI7UUFDRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNsQixDQUFDOzs7Ozs7SUFFUyw4Q0FBbUI7Ozs7O0lBQTdCLFVBQThCLEtBQWE7UUFDekMsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkIsQ0FBQzs7Ozs7O0lBRVMseUNBQWM7Ozs7O0lBQXhCLFVBQXlCLElBQW1DO1FBQzFELE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2xCLENBQUM7Ozs7Ozs7SUFFUyx1Q0FBWTs7Ozs7O0lBQXRCLFVBQXVCLElBQW1DLEVBQUUsS0FBVTtRQUNwRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDekIsQ0FBQzs7Ozs7SUFFUyxpREFBc0I7Ozs7SUFBaEM7UUFDRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hCLENBQUM7Ozs7Ozs7OztJQUVTLDBDQUFlOzs7Ozs7OztJQUF6QixVQUEwQixLQUF1QixFQUFFLEtBQStCLEVBQUUsS0FBYyxFQUFFLE1BQWdCO1FBQ2xILElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUM7WUFDNUIsS0FBSyxPQUFBO1lBQ0wsS0FBSyxPQUFBO1lBQ0wsTUFBTSxRQUFBO1lBQ04sTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFO1lBQ2hDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUk7U0FDakMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7Ozs7Ozs7SUFFTywwQ0FBZTs7Ozs7OztJQUF2QixVQUF3QixLQUF1QixFQUFFLEtBQWMsRUFBRSxNQUFnQjtRQUMvRSxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssRUFBRSx3QkFBd0IsQ0FBQyxpQkFBaUIsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDekYsQ0FBQzs7Ozs7Ozs7SUFFTywyQ0FBZ0I7Ozs7Ozs7SUFBeEIsVUFBeUIsS0FBdUIsRUFBRSxLQUFjLEVBQUUsTUFBZ0I7UUFDaEYsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsd0JBQXdCLENBQUMsa0JBQWtCLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzFGLENBQUM7Ozs7OztJQUVPLDRDQUFpQjs7Ozs7SUFBekIsVUFBMEIsS0FBdUI7UUFDL0MsSUFBSSxLQUFLLENBQUMsVUFBVSxFQUFFO1lBQ3BCLE9BQU87U0FDUjs7WUFFSyxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO1FBQzlDLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUVqQixJQUFJLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBRTtZQUNoQixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDcEM7UUFFRCxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssRUFBRSx3QkFBd0IsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQzFFLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ2xDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLHdCQUF3QixDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3BFLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7U0FDekI7SUFDSCxDQUFDOzs7Ozs7O0lBRU8sZ0RBQXFCOzs7Ozs7SUFBN0IsVUFBOEIsS0FBdUIsRUFBRSxJQUFZO1FBQ2pFLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMvQjtJQUNILENBQUM7Ozs7OztJQUVPLDJDQUFnQjs7Ozs7SUFBeEIsVUFBeUIsS0FBdUI7UUFBaEQsaUJBZ0NDO1FBL0JDLElBQUksS0FBSyxDQUFDLFVBQVUsRUFBRTtZQUNwQixJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyw0Q0FBMEMsS0FBSyxDQUFDLEVBQUksQ0FBQyxDQUFDO1lBQ3JFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMvQjtRQUVELElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7O1lBQzNELGNBQWMsR0FBa0MsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7UUFDbkYsSUFBSSxDQUFDLE9BQU8sRUFBRTthQUNYLElBQUksQ0FDSCxHQUFHOzs7O1FBQUMsVUFBQyxLQUFhLElBQUssT0FBQSxjQUFjLENBQUMsS0FBSyxHQUFHLEtBQUssRUFBNUIsQ0FBNEIsRUFBQyxFQUNwRCxHQUFHOzs7O1FBQUMsVUFBQyxLQUFhLElBQUssT0FBQSxLQUFJLENBQUMscUJBQXFCLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUF4QyxDQUF3QyxFQUFDLEVBQ2hFLFNBQVM7Ozs7UUFBQyxVQUFDLEtBQWEsSUFBSyxPQUFBLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQW5DLENBQW1DLEVBQUMsRUFDakUsR0FBRzs7OztRQUFDLFVBQUMsS0FBYSxJQUFLLE9BQUEsS0FBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQWxDLENBQWtDLEVBQUMsRUFDMUQsUUFBUTs7OztRQUFDLFVBQUMsS0FBYSxJQUFLLE9BQUEsS0FBSSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxFQUEvQixDQUErQixFQUFDLEVBQzVELFFBQVE7Ozs7UUFBQyxVQUFDLEtBQWEsSUFBSyxPQUFBLEtBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQWxCLENBQWtCLEVBQUMsRUFDL0MsR0FBRzs7OztRQUFDLFVBQUMsTUFBZSxJQUFLLE9BQUEsY0FBYyxDQUFDLE1BQU0sR0FBRyxNQUFNLEVBQTlCLENBQThCLEVBQUMsRUFDeEQsR0FBRzs7O1FBQUMsY0FBTSxPQUFBLGNBQWMsRUFBZCxDQUFjLEVBQUMsRUFDekIsUUFBUTs7OztRQUFDLFVBQUMsSUFBbUMsSUFBSyxPQUFBLEtBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQXpCLENBQXlCLEVBQUMsQ0FDL0U7YUFDRSxTQUFTOzs7O1FBQUMsVUFBQyxJQUFtQztZQUM3QyxLQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1lBQzFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUN0QixLQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3RELEtBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMvQixDQUFDOzs7O1FBQUUsVUFBQyxLQUFLO1lBQ1AsS0FBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsaUNBQWlDLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDekQsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ3BCLEtBQUksQ0FBQyxZQUFZLENBQUMsY0FBYyxFQUFFLEtBQUssQ0FBQztpQkFDckMsU0FBUyxFQUFFO2lCQUNYLElBQUk7OztZQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLEVBQTVCLENBQTRCLEVBQUMsQ0FBQztRQUM5QyxDQUFDLEVBQUMsQ0FBQztJQUNQLENBQUM7SUFDSCx1QkFBQztBQUFELENBQUMsQUE3TUQsSUE2TUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTVNQywrQ0FBNEU7Ozs7O0lBRTVFLHdDQUF5RDs7Ozs7SUFDekQsbUNBQWtGOztJQUVsRix1Q0FBd0U7O0lBQ3hFLHdDQUF5RTs7SUFDekUseUNBQTBFOztJQUMxRSxtQ0FBcUY7Ozs7O0lBVXpFLCtCQUFxQjs7Ozs7Ozs7SUEwRWpDLHdEQUE2RDs7Ozs7Ozs7OztJQVE3RCxxREFBaUQiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAzcmQgUGFydHkuXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBvZiwgaWlmIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlV2hpbGUsIHRhcCwgZmlsdGVyLCBtZXJnZU1hcCwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vLyBUU1MuXG5pbXBvcnQgeyBXb3JrZXJRdWV1ZU9wdGlvbnMgfSBmcm9tICcuL3dvcmtlci1xdWV1ZS1vcHRpb25zJztcbmltcG9ydCB7IFF1ZXVlV29ya2VyVG9rZW4gfSBmcm9tICcuL3F1ZXVlLXdvcmtlci10b2tlbic7XG5pbXBvcnQgeyBXb3JrUXVldWVTdGF0dXNFdmVudCB9IGZyb20gJy4vd29yay1xdWV1ZS1zdGF0dXMtZXZlbnQnO1xuaW1wb3J0IHsgV29ya1F1ZXVlU3RhdHVzRXZlbnRUeXBlIH0gZnJvbSAnLi93b3JrLXF1ZXVlLXN0YXR1cy1ldmVudC10eXBlJztcbmltcG9ydCB7IFdvcmtRdWV1ZVN0YXR1c1RyYWNrZXIgfSBmcm9tICcuL3dvcmstcXVldWUtc3RhdHVzLXRyYWNrZXInO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vY29yZS9sb2dnaW5nL2xvZ2dlci5zZXJ2aWNlJztcbmltcG9ydCB7IFdvcmtRdWV1ZVN0YXR1cyB9IGZyb20gJy4vd29yay1xdWV1ZS1zdGF0dXMnO1xuaW1wb3J0IHsgUXVldWVQYXlsb2FkIH0gZnJvbSAnLi9xdWV1ZS1wYXlsb2FkJztcbmltcG9ydCB7IGlzVmFsdWUgfSBmcm9tICcuLi9jb3JlL3R5cGUtY2hlY2svaXMtdmFsdWUuZnVuY3Rpb24nO1xuaW1wb3J0IHsgaXNOb3RWYWx1ZSB9IGZyb20gJy4uL2NvcmUvdHlwZS1jaGVjay9pcy1ub3QtdmFsdWUuZnVuY3Rpb24nO1xuXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1dPUktfUVVFVUVfT1BUSU9OUyA9IHtcbiAgYXV0b1N0YXJ0V29ya2VyczogdHJ1ZSxcbiAgd29ya2VyQ291bnQ6IDEsXG59O1xuXG5cbi8qKlxuICogUHJvdmlkZXMgdGhlIGNvcmUgcXVldWVpbmcgd29ya2Zsb3cgZm9yIGJhc2ljIHVuaXQgb2Ygd29yayBxdWV1ZXMuXG4gKiBIaWdoIFByaW9yaXR5IFRvZG9zOlxuICogKiBJbXBsZW1lbnQgd29ya2VyIGNhbmNlbGF0aW9uIGludG8gdGhlIHdvcmtlciB0b2tlbiAtIFJHLlxuICpcbiAqIExvdyBQcmlvcml0eSBUb2RvczpcbiAqICogQWRkIHF1ZXVlIHByaW9yaXRpemF0aW9uIC0gYSBxdWV1ZSBwcmlvcml0eSBmbGFnIHRvIHB1bGwgdGhvc2UgaXRlbXMgZmlyc3QgZnJvbSB0aGUgcXVldWUgLSBSRy5cbiAqICogQ2hhbmdlIG92ZXJyaWRpbmcgb2YgbWV0aG9kcyB0byB1c2UgbWV0aG8gYXR0cmlidXRlcyBpbnN0ZWFkLiBFeGFtcGxlOiBAT25Xb3JrQ29tcGxldGUuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBXb3JrUXVldWVNYW5hZ2VyPFRJbnB1dCwgVE91dHB1dD4ge1xuICBwcml2YXRlIHF1ZXVlQ2hhbmdlT2JzZXJ2ZXI6IFN1YmplY3Q8V29ya1F1ZXVlU3RhdHVzRXZlbnQ8VElucHV0LCBUT3V0cHV0Pj47XG5cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHdvcmtlclRva2VuczogUXVldWVXb3JrZXJUb2tlbltdID0gW107XG4gIHByb3RlY3RlZCByZWFkb25seSB0cmFja2VyOiBXb3JrUXVldWVTdGF0dXNUcmFja2VyID0gbmV3IFdvcmtRdWV1ZVN0YXR1c1RyYWNrZXIoKTtcblxuICByZWFkb25seSBxdWV1ZUNoYW5nZTogT2JzZXJ2YWJsZTxXb3JrUXVldWVTdGF0dXNFdmVudDxUSW5wdXQsIFRPdXRwdXQ+PjtcbiAgcmVhZG9ubHkgcXVldWVTdGFydGVkOiBPYnNlcnZhYmxlPFdvcmtRdWV1ZVN0YXR1c0V2ZW50PFRJbnB1dCwgVE91dHB1dD4+O1xuICByZWFkb25seSBxdWV1ZUNvbXBsZXRlOiBPYnNlcnZhYmxlPFdvcmtRdWV1ZVN0YXR1c0V2ZW50PFRJbnB1dCwgVE91dHB1dD4+O1xuICByZWFkb25seSBvcHRpb25zOiBXb3JrZXJRdWV1ZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1dPUktfUVVFVUVfT1BUSU9OUyk7XG5cbiAgZ2V0IGlzV29ya2luZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy50cmFja2VyLmlzV29ya2luZztcbiAgfVxuXG4gIGdldCBzdGF0dXMoKTogV29ya1F1ZXVlU3RhdHVzIHtcbiAgICByZXR1cm4gdGhpcy50cmFja2VyLmdldFN0YXR1cygpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGxvZzogTG9nZ2VyLCBvcHRpb25zPzogV29ya2VyUXVldWVPcHRpb25zKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMucXVldWVDaGFuZ2VPYnNlcnZlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgdGhpcy5xdWV1ZUNoYW5nZSA9IHRoaXMucXVldWVDaGFuZ2VPYnNlcnZlci5waXBlKCk7XG5cbiAgICB0aGlzLnF1ZXVlU3RhcnRlZCA9IHRoaXMucXVldWVDaGFuZ2VPYnNlcnZlci5waXBlKFxuICAgICAgZmlsdGVyKGNoYW5nZSA9PiBjaGFuZ2UuZXZlbnQgPT09IFdvcmtRdWV1ZVN0YXR1c0V2ZW50VHlwZS5RdWV1ZVN0YXJ0ZWQpXG4gICAgKTtcblxuICAgIHRoaXMucXVldWVDb21wbGV0ZSA9IHRoaXMucXVldWVDaGFuZ2VPYnNlcnZlci5waXBlKFxuICAgICAgZmlsdGVyKGNoYW5nZSA9PiBjaGFuZ2UuZXZlbnQgPT09IFdvcmtRdWV1ZVN0YXR1c0V2ZW50VHlwZS5RdWV1ZUNvbXBsZXRlKVxuICAgICk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9TdGFydFdvcmtlcnMpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydFdvcmsoKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBkZWZhdWx0IG9wdGlvbnMuXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgKi9cbiAgc2V0T3B0aW9ucyhvcHRpb25zOiBXb3JrZXJRdWV1ZU9wdGlvbnMpOiBXb3JrUXVldWVNYW5hZ2VyPFRJbnB1dCwgVE91dHB1dD4ge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBLaWNrcyBvZmYgdGhlIHF1ZXVlIHdvcmtmbG93IHdpdGggdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygd29ya2Vycy4gSWZcbiAgICogdGhlIG1heGltdW0gbnVtYmVyIG9mIHdvcmtlcnMgYXJlIGN1cnJlbnRseSBydW5uaW5nLCBubyBhZGRpdGlvbmFsIHdvcmtlcnNcbiAgICogd2lsbCBiZSBjcmVhdGVkIChvbmx5IHRoZSBkZWx0YSBvZiBhbGxvd2VkIGFuZCBydW5uaW5nIHdpbGwgYmUgc3RhcnRlZCkuXG4gICAqL1xuICBzdGFydFdvcmsoKTogdm9pZCB7XG4gICAgLy8gV2UgZG9udCcgd2FudCB0byBjaGFuZ2UgdGhlIHF1ZXVlIHNpemUgaWYgdGhlIHF1ZXVlIGlzIGFscmVhZHkgd29ya2luZ1xuICAgIC8vIGJlY2F1c2UgaXQgd2lsbCBtZXNzIHVwIHRoZSBzdGF0aXN0aWNzIChwZXJjZW50IGNvcG1sZXRlLCBldGMpLlxuICAgIGNvbnN0IHN0YXJ0ZXJTb3VyY2UgPSBpaWYoKCkgPT4gIXRoaXMuaXNXb3JraW5nLFxuICAgICAgdGhpcy5nZXRSZW1haW5pbmdRdWV1ZUNvdW50KClcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgdGFwKChxdWV1ZUNvdW50OiBudW1iZXIpID0+IHRoaXMudHJhY2tlci5zZXRRdWV1ZVNpemUocXVldWVDb3VudCkpXG4gICAgICAgIClcbiAgICApO1xuXG4gICAgdGhpcy5vblJlYWR5KClcbiAgICAgIC5waXBlKFxuICAgICAgICBtZXJnZU1hcCgoKSA9PiBzdGFydGVyU291cmNlKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdvcmtlcnNUb1N0YXJ0ID0gdGhpcy5vcHRpb25zLndvcmtlckNvdW50IC0gdGhpcy53b3JrZXJUb2tlbnMubGVuZ3RoO1xuXG4gICAgICAgIGlmICh3b3JrZXJzVG9TdGFydCA+IDApIHtcbiAgICAgICAgICB0aGlzLmVtaXRRdWV1ZUNoYW5nZShudWxsLCBXb3JrUXVldWVTdGF0dXNFdmVudFR5cGUuUXVldWVTdGFydGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29ya2Vyc1RvU3RhcnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHRva2VuID0gbmV3IFF1ZXVlV29ya2VyVG9rZW4oKS5zdGFydCgpO1xuICAgICAgICAgIHRoaXMudHJhY2tlci5hZGRXb3JrZXIodG9rZW4pO1xuICAgICAgICAgIHRoaXMud29ya2VyVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIHRoaXMuZW1pdFF1ZXVlQ2hhbmdlKHRva2VuLCBXb3JrUXVldWVTdGF0dXNFdmVudFR5cGUuUXVldWVXb3JrZXJTdGFydGVkKTtcbiAgICAgICAgICB0aGlzLmdldE5leHRBbmREb1dvcmsodG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBhbGwgd29ya2VycyBmcm9tIHByb2Nlc3NpbmcgdGhlIHF1ZXVlLlxuICAgKi9cbiAgc3RvcFdvcmsoKTogdm9pZCB7XG4gICAgdGhpcy53b3JrZXJUb2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB0b2tlbi5jYW5jZWwoKSk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gbWV0aG9kIHRvIGRvIHRoZSBhY3R1YWwgdW5pdCBvZiB3b3JrLlxuICAgKiBAcGFyYW0gaXRlbSBUaGUgaW5wdXQgcGFyYW1hdGVyIG5lZWRlZCB0byBwcm9jZXNzIHRoZSB1bml0IG9mIHdvcmsgYW5kIHJldHVybiBhbiBvdXRwdXQgcmVzdWx0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGRvV29yayhpdGVtOiBUSW5wdXQpOiBPYnNlcnZhYmxlPFRPdXRwdXQ+O1xuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBtZXRob2QgdG8gcmV0cmlldmUgdGhlIG5leHQgdmFsdWUgaW4gdGhlIHF1ZXVlLiBOb3RlLCB0aGVyZSBhcmUgbm8gZnVydGhlciBjaGVja3NcbiAgICogdG8gdmVyaWZ5IGR1cGxpY2F0ZSBpdGVtcyBhcmUgbm90IHByb2Nlc3NlZCAtIGl0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgaW1wbGVtZW50ZXIgb2YgdGhpc1xuICAgKiBiYXNlIGNsYXNzIHRvIG5ldmVyIHJldHVybiB0aGUgc2FtZSBpdGVtIGZyb20gdGhpcyBtZXRob2QuIFR5cGljYWxseSB0aGUgaXRlbSBpbiB0aGUgcXVldWUgaXMgZWl0aGVyXG4gICAqIGRlcXVldWVkIG9yIG1hcmtlZCBhcyBcInByb2Nlc3NpbmdcIiB0byBwcmV2ZW50IHRoaXMgcG90ZW50aWFsIGlzc3VlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldE5leHQoKTogT2JzZXJ2YWJsZTxUSW5wdXQ+O1xuXG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBkZXRlcm1pbmVzIHRoYXQgdGhlIHdvcmtlcnMgYXJlIHJlYWR5IHRvIGJlIHN0YXJ0ZWQuIE5vdGUsIGluIHRoaXMgaW1wbGVtZW50YXRpb24gaXRcbiAgICogbWFrZXMgdXNlIG9mIGFuIGVtcHR5IHByb21pc2UuIFRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBpcyB0byBwcm92aWRlIGEgaG9vayBmb3Igb3RoZXIgaW1wbGVtZW50ZXJzXG4gICAqIHRvIHNldHVwL2luaXRpYWxpemUgdGhlIHF1ZXVlIGJlZm9yZSBzdGFydGluZyB0aGUgd29ya2Vycy4gQWRkaXRpb25hbHksIHRoaXMgcHJhY3RpY2VzIHByb3ZpZGVzIGFcbiAgICogd2F5IHRvIHJ1biB0aGUgd29ya2VycyBhc3luY2hyb25vdXNseS5cbiAgICovXG4gIHByb3RlY3RlZCBvblJlYWR5KCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIG9mKG51bGwpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQmVmb3JlV29ya1N0YXJ0ZWQoaW5wdXQ6IFRJbnB1dCk6IE9ic2VydmFibGU8VElucHV0PiB7XG4gICAgcmV0dXJuIG9mKGlucHV0KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbldvcmtDb21wbGV0ZShkYXRhOiBRdWV1ZVBheWxvYWQ8VElucHV0LCBUT3V0cHV0Pik6IE9ic2VydmFibGU8UXVldWVQYXlsb2FkPFRJbnB1dCwgVE91dHB1dD4+IHtcbiAgICByZXR1cm4gb2YoZGF0YSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25Xb3JrRmFpbGVkKGRhdGE6IFF1ZXVlUGF5bG9hZDxUSW5wdXQsIFRPdXRwdXQ+LCBlcnJvcjogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gb2YoZGF0YSwgZXJyb3IpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldFJlbWFpbmluZ1F1ZXVlQ291bnQoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICByZXR1cm4gb2YoLTEpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGVtaXRRdWV1ZUNoYW5nZSh0b2tlbjogUXVldWVXb3JrZXJUb2tlbiwgZXZlbnQ6IFdvcmtRdWV1ZVN0YXR1c0V2ZW50VHlwZSwgaW5wdXQ/OiBUSW5wdXQsIG91dHB1dD86IFRPdXRwdXQpOiB2b2lkIHtcbiAgICB0aGlzLnF1ZXVlQ2hhbmdlT2JzZXJ2ZXIubmV4dCh7XG4gICAgICBldmVudCxcbiAgICAgIGlucHV0LFxuICAgICAgb3V0cHV0LFxuICAgICAgc3RhdHVzOiB0aGlzLnRyYWNrZXIuZ2V0U3RhdHVzKCksXG4gICAgICB0b2tlbklkOiB0b2tlbiA/IHRva2VuLmlkIDogbnVsbCxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdFdvcmtTdGFydGVkKHRva2VuOiBRdWV1ZVdvcmtlclRva2VuLCBpbnB1dD86IFRJbnB1dCwgb3V0cHV0PzogVE91dHB1dCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdFF1ZXVlQ2hhbmdlKHRva2VuLCBXb3JrUXVldWVTdGF0dXNFdmVudFR5cGUuVW5pdE9mV29ya1N0YXJ0ZWQsIGlucHV0LCBvdXRwdXQpO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0V29ya0NvbXBsZXRlKHRva2VuOiBRdWV1ZVdvcmtlclRva2VuLCBpbnB1dD86IFRJbnB1dCwgb3V0cHV0PzogVE91dHB1dCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdFF1ZXVlQ2hhbmdlKHRva2VuLCBXb3JrUXVldWVTdGF0dXNFdmVudFR5cGUuVW5pdE9mV29ya0NvbXBsZXRlLCBpbnB1dCwgb3V0cHV0KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Xb3JrZXJDb21wbGV0ZWQodG9rZW46IFF1ZXVlV29ya2VyVG9rZW4pIHtcbiAgICBpZiAodG9rZW4uaXNDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy53b3JrZXJUb2tlbnMuaW5kZXhPZih0b2tlbik7XG4gICAgdG9rZW4uY29tcGxldGUoKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMud29ya2VyVG9rZW5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0UXVldWVDaGFuZ2UodG9rZW4sIFdvcmtRdWV1ZVN0YXR1c0V2ZW50VHlwZS5RdWV1ZVdvcmtlckNvbXBsZXRlKTtcbiAgICBpZiAodGhpcy53b3JrZXJUb2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmVtaXRRdWV1ZUNoYW5nZSh0b2tlbiwgV29ya1F1ZXVlU3RhdHVzRXZlbnRUeXBlLlF1ZXVlQ29tcGxldGUpO1xuICAgICAgdGhpcy50cmFja2VyLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0lmV29ya2VyQ29tcGxldGUodG9rZW46IFF1ZXVlV29ya2VyVG9rZW4sIG5leHQ6IFRJbnB1dCkge1xuICAgIGlmIChpc05vdFZhbHVlKG5leHQpKSB7XG4gICAgICB0aGlzLm9uV29ya2VyQ29tcGxldGVkKHRva2VuKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldE5leHRBbmREb1dvcmsodG9rZW46IFF1ZXVlV29ya2VyVG9rZW4pOiB2b2lkIHtcbiAgICBpZiAodG9rZW4uaXNDYW5jZWxlZCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoYENhbmNlbGluZyB3b3JrZXIgZHVlIHRvIGNhbmNlbGVkIHRva2U6ICR7dG9rZW4uaWR9YCk7XG4gICAgICB0aGlzLm9uV29ya2VyQ29tcGxldGVkKHRva2VuKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZy50cmFjZSgnUmV0cmlldmluZyBuZXh0IHF1ZXVlIGl0ZW0gdG8gc3RhcnQgcHJvY2Vzc2luZycpO1xuICAgIGNvbnN0IHByb2Nlc3NpbmdEYXRhOiBRdWV1ZVBheWxvYWQ8VElucHV0LCBUT3V0cHV0PiA9IHsgaW5wdXQ6IG51bGwsIG91dHB1dDogbnVsbCB9O1xuICAgIHRoaXMuZ2V0TmV4dCgpXG4gICAgICAucGlwZShcbiAgICAgICAgdGFwKChpbnB1dDogVElucHV0KSA9PiBwcm9jZXNzaW5nRGF0YS5pbnB1dCA9IGlucHV0KSxcbiAgICAgICAgdGFwKChpbnB1dDogVElucHV0KSA9PiB0aGlzLmNoZWNrSWZXb3JrZXJDb21wbGV0ZSh0b2tlbiwgaW5wdXQpKSxcbiAgICAgICAgdGFrZVdoaWxlKChpbnB1dDogVElucHV0KSA9PiBpc1ZhbHVlKGlucHV0KSAmJiAhdG9rZW4uaXNDYW5jZWxlZCksXG4gICAgICAgIHRhcCgoaW5wdXQ6IFRJbnB1dCkgPT4gdGhpcy5lbWl0V29ya1N0YXJ0ZWQodG9rZW4sIGlucHV0KSksXG4gICAgICAgIG1lcmdlTWFwKChpbnB1dDogVElucHV0KSA9PiB0aGlzLm9uQmVmb3JlV29ya1N0YXJ0ZWQoaW5wdXQpKSxcbiAgICAgICAgbWVyZ2VNYXAoKGlucHV0OiBUSW5wdXQpID0+IHRoaXMuZG9Xb3JrKGlucHV0KSksXG4gICAgICAgIHRhcCgob3V0cHV0OiBUT3V0cHV0KSA9PiBwcm9jZXNzaW5nRGF0YS5vdXRwdXQgPSBvdXRwdXQpLFxuICAgICAgICBtYXAoKCkgPT4gcHJvY2Vzc2luZ0RhdGEpLFxuICAgICAgICBtZXJnZU1hcCgoZGF0YTogUXVldWVQYXlsb2FkPFRJbnB1dCwgVE91dHB1dD4pID0+IHRoaXMub25Xb3JrQ29tcGxldGUoZGF0YSkpLFxuICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKGRhdGE6IFF1ZXVlUGF5bG9hZDxUSW5wdXQsIFRPdXRwdXQ+KSA9PiB7XG4gICAgICAgIHRoaXMubG9nLnRyYWNlKCdDb21wbGV0ZWQgd29yayBmb3IgaXRlbScpO1xuICAgICAgICB0b2tlbi50b3RhbENvbXBsZXRlKys7XG4gICAgICAgIHRoaXMuZW1pdFdvcmtDb21wbGV0ZSh0b2tlbiwgZGF0YS5pbnB1dCwgZGF0YS5vdXRwdXQpO1xuICAgICAgICB0aGlzLmdldE5leHRBbmREb1dvcmsodG9rZW4pO1xuICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyBpdGVtLiB7ZXJyb3J9YCwgZXJyb3IpO1xuICAgICAgICB0b2tlbi50b3RhbEZhaWxlZCsrO1xuICAgICAgICB0aGlzLm9uV29ya0ZhaWxlZChwcm9jZXNzaW5nRGF0YSwgZXJyb3IpXG4gICAgICAgICAgLnRvUHJvbWlzZSgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5nZXROZXh0QW5kRG9Xb3JrKHRva2VuKSk7XG4gICAgICB9KTtcbiAgfVxufVxuIl19