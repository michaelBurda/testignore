/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
// Angular.
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { DataSourceConfig } from '../data-source-config';
import { toFormDataString } from '../../http/to-form-data-string.function';
import { AttachmentType } from './attachment-type';
import { base64toBlob } from '../../core/media/base64-to-blob.function';
import { ATTACHMENT_FILE_FORM_KEY, ATTACHMENT_DATA_FORM_KEY } from './attachments.constants';
import { BaseResourceService } from '../../core/resource/base-resource.service';
import { isString } from '../../core/type-check/is-string.function';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "../data-source-config";
var AttachmentService = /** @class */ (function (_super) {
    tslib_1.__extends(AttachmentService, _super);
    function AttachmentService(http, dsConfig) {
        var _this = _super.call(this, http, {
            url: dsConfig.serviceUrl,
            queryEndpoint: dsConfig.attachmentsEndpoint,
            getEndpoint: dsConfig.attachmentsEndpoint,
            updateEndpoint: dsConfig.attachmentsEndpoint,
            deleteEndpoint: dsConfig.attachmentsEndpoint,
            createEndpoint: dsConfig.attachmentsEndpoint,
        }) || this;
        _this.http = http;
        return _this;
    }
    /**
     * @param {?} attachment
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    AttachmentService.prototype.create = /**
     * @param {?} attachment
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    function (attachment, routeTokens, params) {
        /** @type {?} */
        var url = this.getUrl(this.config.createEndpoint, routeTokens);
        /** @type {?} */
        var formData = new FormData();
        /** @type {?} */
        var fileData;
        if (attachment.type === AttachmentType.Image && isString(attachment.data)) {
            fileData = base64toBlob((/** @type {?} */ (attachment.data)));
        }
        else if (attachment.type === AttachmentType.Text) {
            fileData = new Blob([attachment.data]);
        }
        else {
            fileData = (/** @type {?} */ (attachment.data));
        }
        delete attachment.data;
        formData.append(ATTACHMENT_FILE_FORM_KEY, fileData);
        formData.append(ATTACHMENT_DATA_FORM_KEY, toFormDataString(attachment));
        return this.http.post(url, formData, { params: params, reportProgress: true });
    };
    /**
     * @param {?} attachmentId
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    AttachmentService.prototype.download = /**
     * @param {?} attachmentId
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    function (attachmentId, routeTokens, params) {
        // TODO: Complete - RG.
        // const url = this.getUrl(this.config.getEndpoint, Object.assign({ action: 'download' }, routeTokens));
        throw new Error('Not implemented yet');
    };
    AttachmentService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    AttachmentService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: DataSourceConfig }
    ]; };
    /** @nocollapse */ AttachmentService.ngInjectableDef = i0.defineInjectable({ factory: function AttachmentService_Factory() { return new AttachmentService(i0.inject(i1.HttpClient), i0.inject(i2.DataSourceConfig)); }, token: AttachmentService, providedIn: "root" });
    return AttachmentService;
}(BaseResourceService));
export { AttachmentService };
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AttachmentService.prototype.http;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXR0YWNobWVudC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRzcy9zZGsvIiwic291cmNlcyI6WyJsaWIvZGF0YS1zb3VyY2UvYXR0YWNobWVudHMvYXR0YWNobWVudC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBYyxNQUFNLHNCQUFzQixDQUFDO0FBTzlELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3pELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBQzNFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNuRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMENBQTBDLENBQUM7QUFDeEUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLHdCQUF3QixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDN0YsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sMkNBQTJDLENBQUM7QUFDaEYsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDBDQUEwQyxDQUFDOzs7O0FBR3BFO0lBR3VDLDZDQUErQjtJQUNwRSwyQkFBc0IsSUFBZ0IsRUFBRSxRQUEwQjtRQUFsRSxZQUNFLGtCQUFNLElBQUksRUFBRTtZQUNWLEdBQUcsRUFBRSxRQUFRLENBQUMsVUFBVTtZQUN4QixhQUFhLEVBQUUsUUFBUSxDQUFDLG1CQUFtQjtZQUMzQyxXQUFXLEVBQUUsUUFBUSxDQUFDLG1CQUFtQjtZQUN6QyxjQUFjLEVBQUUsUUFBUSxDQUFDLG1CQUFtQjtZQUM1QyxjQUFjLEVBQUUsUUFBUSxDQUFDLG1CQUFtQjtZQUM1QyxjQUFjLEVBQUUsUUFBUSxDQUFDLG1CQUFtQjtTQUM3QyxDQUFDLFNBQ0g7UUFUcUIsVUFBSSxHQUFKLElBQUksQ0FBWTs7SUFTdEMsQ0FBQzs7Ozs7OztJQUVELGtDQUFNOzs7Ozs7SUFBTixVQUFPLFVBQXNCLEVBQUUsV0FBaUIsRUFBRSxNQUFtQjs7WUFDN0QsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsV0FBVyxDQUFDOztZQUMxRCxRQUFRLEdBQWEsSUFBSSxRQUFRLEVBQUU7O1lBQ3JDLFFBQXVCO1FBRTNCLElBQUksVUFBVSxDQUFDLElBQUksS0FBSyxjQUFjLENBQUMsS0FBSyxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDekUsUUFBUSxHQUFHLFlBQVksQ0FBQyxtQkFBQSxVQUFVLENBQUMsSUFBSSxFQUFVLENBQUMsQ0FBQztTQUNwRDthQUFNLElBQUksVUFBVSxDQUFDLElBQUksS0FBSyxjQUFjLENBQUMsSUFBSSxFQUFFO1lBQ2xELFFBQVEsR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ3hDO2FBQU07WUFDTCxRQUFRLEdBQUcsbUJBQUEsVUFBVSxDQUFDLElBQUksRUFBUSxDQUFDO1NBQ3BDO1FBRUQsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDO1FBQ3ZCLFFBQVEsQ0FBQyxNQUFNLENBQUMsd0JBQXdCLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDcEQsUUFBUSxDQUFDLE1BQU0sQ0FBQyx3QkFBd0IsRUFBRSxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBRXhFLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQWEsR0FBRyxFQUFFLFFBQVEsRUFBRSxFQUFFLE1BQU0sUUFBQSxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3JGLENBQUM7Ozs7Ozs7SUFFRCxvQ0FBUTs7Ozs7O0lBQVIsVUFBUyxZQUFvQixFQUFFLFdBQWlCLEVBQUUsTUFBbUI7UUFDbkUsdUJBQXVCO1FBQ3ZCLHdHQUF3RztRQUN4RyxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDekMsQ0FBQzs7Z0JBdkNGLFVBQVUsU0FBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkI7Ozs7Z0JBbEJRLFVBQVU7Z0JBT1YsZ0JBQWdCOzs7NEJBVHpCO0NBMERDLEFBeENELENBR3VDLG1CQUFtQixHQXFDekQ7U0FyQ1ksaUJBQWlCOzs7Ozs7SUFDaEIsaUNBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQW5ndWxhci5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEh0dHBDbGllbnQsIEh0dHBQYXJhbXMgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5cbi8vIDNyZCBQYXJ0eS5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcblxuLy8gVFNTLlxuaW1wb3J0IHsgQXR0YWNobWVudCB9IGZyb20gJy4vYXR0YWNobWVudCc7XG5pbXBvcnQgeyBEYXRhU291cmNlQ29uZmlnIH0gZnJvbSAnLi4vZGF0YS1zb3VyY2UtY29uZmlnJztcbmltcG9ydCB7IHRvRm9ybURhdGFTdHJpbmcgfSBmcm9tICcuLi8uLi9odHRwL3RvLWZvcm0tZGF0YS1zdHJpbmcuZnVuY3Rpb24nO1xuaW1wb3J0IHsgQXR0YWNobWVudFR5cGUgfSBmcm9tICcuL2F0dGFjaG1lbnQtdHlwZSc7XG5pbXBvcnQgeyBiYXNlNjR0b0Jsb2IgfSBmcm9tICcuLi8uLi9jb3JlL21lZGlhL2Jhc2U2NC10by1ibG9iLmZ1bmN0aW9uJztcbmltcG9ydCB7IEFUVEFDSE1FTlRfRklMRV9GT1JNX0tFWSwgQVRUQUNITUVOVF9EQVRBX0ZPUk1fS0VZIH0gZnJvbSAnLi9hdHRhY2htZW50cy5jb25zdGFudHMnO1xuaW1wb3J0IHsgQmFzZVJlc291cmNlU2VydmljZSB9IGZyb20gJy4uLy4uL2NvcmUvcmVzb3VyY2UvYmFzZS1yZXNvdXJjZS5zZXJ2aWNlJztcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi4vLi4vY29yZS90eXBlLWNoZWNrL2lzLXN0cmluZy5mdW5jdGlvbic7XG5cblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgQXR0YWNobWVudFNlcnZpY2UgZXh0ZW5kcyBCYXNlUmVzb3VyY2VTZXJ2aWNlPEF0dGFjaG1lbnQ+IHtcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGh0dHA6IEh0dHBDbGllbnQsIGRzQ29uZmlnOiBEYXRhU291cmNlQ29uZmlnKSB7XG4gICAgc3VwZXIoaHR0cCwge1xuICAgICAgdXJsOiBkc0NvbmZpZy5zZXJ2aWNlVXJsLFxuICAgICAgcXVlcnlFbmRwb2ludDogZHNDb25maWcuYXR0YWNobWVudHNFbmRwb2ludCxcbiAgICAgIGdldEVuZHBvaW50OiBkc0NvbmZpZy5hdHRhY2htZW50c0VuZHBvaW50LFxuICAgICAgdXBkYXRlRW5kcG9pbnQ6IGRzQ29uZmlnLmF0dGFjaG1lbnRzRW5kcG9pbnQsXG4gICAgICBkZWxldGVFbmRwb2ludDogZHNDb25maWcuYXR0YWNobWVudHNFbmRwb2ludCxcbiAgICAgIGNyZWF0ZUVuZHBvaW50OiBkc0NvbmZpZy5hdHRhY2htZW50c0VuZHBvaW50LFxuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlKGF0dGFjaG1lbnQ6IEF0dGFjaG1lbnQsIHJvdXRlVG9rZW5zPzogYW55LCBwYXJhbXM/OiBIdHRwUGFyYW1zKTogT2JzZXJ2YWJsZTxBdHRhY2htZW50PiB7XG4gICAgY29uc3QgdXJsID0gdGhpcy5nZXRVcmwodGhpcy5jb25maWcuY3JlYXRlRW5kcG9pbnQsIHJvdXRlVG9rZW5zKTtcbiAgICBjb25zdCBmb3JtRGF0YTogRm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBsZXQgZmlsZURhdGE6IHN0cmluZyB8IEJsb2I7XG5cbiAgICBpZiAoYXR0YWNobWVudC50eXBlID09PSBBdHRhY2htZW50VHlwZS5JbWFnZSAmJiBpc1N0cmluZyhhdHRhY2htZW50LmRhdGEpKSB7XG4gICAgICBmaWxlRGF0YSA9IGJhc2U2NHRvQmxvYihhdHRhY2htZW50LmRhdGEgYXMgc3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKGF0dGFjaG1lbnQudHlwZSA9PT0gQXR0YWNobWVudFR5cGUuVGV4dCkge1xuICAgICAgZmlsZURhdGEgPSBuZXcgQmxvYihbYXR0YWNobWVudC5kYXRhXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGVEYXRhID0gYXR0YWNobWVudC5kYXRhIGFzIEJsb2I7XG4gICAgfVxuXG4gICAgZGVsZXRlIGF0dGFjaG1lbnQuZGF0YTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoQVRUQUNITUVOVF9GSUxFX0ZPUk1fS0VZLCBmaWxlRGF0YSk7XG4gICAgZm9ybURhdGEuYXBwZW5kKEFUVEFDSE1FTlRfREFUQV9GT1JNX0tFWSwgdG9Gb3JtRGF0YVN0cmluZyhhdHRhY2htZW50KSk7XG5cbiAgICByZXR1cm4gdGhpcy5odHRwLnBvc3Q8QXR0YWNobWVudD4odXJsLCBmb3JtRGF0YSwgeyBwYXJhbXMsIHJlcG9ydFByb2dyZXNzOiB0cnVlIH0pO1xuICB9XG5cbiAgZG93bmxvYWQoYXR0YWNobWVudElkOiBzdHJpbmcsIHJvdXRlVG9rZW5zPzogYW55LCBwYXJhbXM/OiBIdHRwUGFyYW1zKSB7XG4gICAgLy8gVE9ETzogQ29tcGxldGUgLSBSRy5cbiAgICAvLyBjb25zdCB1cmwgPSB0aGlzLmdldFVybCh0aGlzLmNvbmZpZy5nZXRFbmRwb2ludCwgT2JqZWN0LmFzc2lnbih7IGFjdGlvbjogJ2Rvd25sb2FkJyB9LCByb3V0ZVRva2VucykpO1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkIHlldCcpO1xuICB9XG59XG4iXX0=