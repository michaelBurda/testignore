/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { toMultiPartPaths } from './to-multi-part-paths.function';
import { addRange } from '../../core/array/add-range.function';
import { getMeasureFromPoint } from '../point/get-measure-from-point.function';
/**
 * @param {?} line
 * @param {?} measure
 * @return {?}
 */
export function getPoint(line, measure) {
    /** @type {?} */
    var pointComparisionDetails = [];
    /** @type {?} */
    var paths = toMultiPartPaths(line);
    paths.forEach((/**
     * @param {?} coordinates
     * @return {?}
     */
    function (coordinates) {
        /** @type {?} */
        var details = comparePathWithMeasure(coordinates, measure);
        addRange(pointComparisionDetails, details);
    }));
    /** @type {?} */
    var minPoint = pointComparisionDetails.reduce((/**
     * @param {?} accumulator
     * @param {?} value
     * @return {?}
     */
    function (accumulator, value) { return minPointCloserToMeasure(accumulator, value, measure); }));
    /** @type {?} */
    var maxPoint = pointComparisionDetails.reduce((/**
     * @param {?} accumulator
     * @param {?} value
     * @return {?}
     */
    function (accumulator, value) { return maxPointCloserToMeasure(accumulator, value, measure); }));
    /** @type {?} */
    var measureDeltaPercent = calculateMeasureDelta(minPoint.pointMeasure, maxPoint.pointMeasure, measure);
    /** @type {?} */
    var x = interpolateX(minPoint.pointCoordinate, maxPoint.pointCoordinate, measureDeltaPercent);
    /** @type {?} */
    var y = interpolateY(minPoint.pointCoordinate, maxPoint.pointCoordinate, measureDeltaPercent);
    return [x, y, 0, measure];
}
/**
 * @param {?} __0
 * @param {?} __1
 * @param {?} delta
 * @return {?}
 */
function interpolateX(_a, _b, delta) {
    var _c = tslib_1.__read(_a, 1), minX = _c[0];
    var _d = tslib_1.__read(_b, 1), maxX = _d[0];
    return minX + delta * (maxX - minX);
}
/**
 * @param {?} __0
 * @param {?} __1
 * @param {?} delta
 * @return {?}
 */
function interpolateY(_a, _b, delta) {
    var _c = tslib_1.__read(_a, 2), minY = _c[1];
    var _d = tslib_1.__read(_b, 2), maxY = _d[1];
    return minY + delta * (maxY - minY);
}
/**
 * @param {?} minMeasure
 * @param {?} maxMeasure
 * @param {?} measure
 * @return {?}
 */
function calculateMeasureDelta(minMeasure, maxMeasure, measure) {
    if (maxMeasure === minMeasure) {
        return 0;
    }
    return (measure - minMeasure) / (maxMeasure - minMeasure);
}
/**
 * @param {?} coordinates
 * @param {?} measureToCompare
 * @return {?}
 */
function comparePathWithMeasure(coordinates, measureToCompare) {
    /** @type {?} */
    var pointComparisionDetailsFromPath = coordinates
        .map((/**
     * @param {?} coordinate
     * @param {?} index
     * @return {?}
     */
    function (coordinate, index) { return compareCoordinateWithMeasure(coordinate, measureToCompare, index); }));
    return pointComparisionDetailsFromPath;
}
/**
 * @param {?} coordinate
 * @param {?} measureToCompare
 * @param {?} index
 * @return {?}
 */
function compareCoordinateWithMeasure(coordinate, measureToCompare, index) {
    /** @type {?} */
    var measureFromCoordinate = getMeasureFromPoint(coordinate);
    /** @type {?} */
    var pointDetails = {
        pointCoordinate: coordinate,
        distance: Math.abs(measureFromCoordinate - measureToCompare),
        pointMeasure: measureFromCoordinate,
        index: index
    };
    return pointDetails;
}
/**
 * @param {?} accumulator
 * @param {?} value
 * @param {?} measureToCompare
 * @return {?}
 */
function minPointCloserToMeasure(accumulator, value, measureToCompare) {
    /** @type {?} */
    var isPointCloserToMeasure = value.distance <= accumulator.distance;
    /** @type {?} */
    var isPointLessThanMeasure = value.pointMeasure <= measureToCompare;
    return isPointCloserToMeasure && isPointLessThanMeasure
        ? value
        : accumulator;
}
/**
 * @param {?} point1
 * @param {?} point2
 * @param {?} measureToCompare
 * @return {?}
 */
function maxPointCloserToMeasure(point1, point2, measureToCompare) {
    /** @type {?} */
    var isPointCloserToMeasure = point1.distance <= point2.distance;
    /** @type {?} */
    var isPointGreaterThanMeasure = point1.pointMeasure >= measureToCompare;
    return isPointCloserToMeasure && isPointGreaterThanMeasure
        ? point1
        : point2;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0LXBvaW50LmZ1bmN0aW9uLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRzcy9zZGsvIiwic291cmNlcyI6WyJsaWIvZ2VvbWV0cnkvbGluZS9nZXQtcG9pbnQuZnVuY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUVsRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFFL0QsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sMENBQTBDLENBQUM7Ozs7OztBQUcvRSxNQUFNLFVBQVUsUUFBUSxDQUFDLElBQWtCLEVBQUUsT0FBZTs7UUFDcEQsdUJBQXVCLEdBQTZCLEVBQUU7O1FBQ3RELEtBQUssR0FBaUIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDO0lBRWxELEtBQUssQ0FBQyxPQUFPOzs7O0lBQUMsVUFBQyxXQUF1Qjs7WUFDOUIsT0FBTyxHQUFHLHNCQUFzQixDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUM7UUFDNUQsUUFBUSxDQUFDLHVCQUF1QixFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzdDLENBQUMsRUFBQyxDQUFDOztRQUVHLFFBQVEsR0FBRyx1QkFBdUIsQ0FBQyxNQUFNOzs7OztJQUFDLFVBQUMsV0FBVyxFQUFFLEtBQUssSUFBSyxPQUFBLHVCQUF1QixDQUFDLFdBQVcsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLEVBQXBELENBQW9ELEVBQUM7O1FBQ3ZILFFBQVEsR0FBRyx1QkFBdUIsQ0FBQyxNQUFNOzs7OztJQUFDLFVBQUMsV0FBVyxFQUFFLEtBQUssSUFBSyxPQUFBLHVCQUF1QixDQUFDLFdBQVcsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLEVBQXBELENBQW9ELEVBQUM7O1FBQ3ZILG1CQUFtQixHQUFHLHFCQUFxQixDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUM7O1FB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dWx0aS1wYXJ0LXBhdGhzLmZ1bmN0aW9uJztcbmltcG9ydCB7IExpbmVHZW9tZXRyeSB9IGZyb20gJy4vbGluZS1nZW9tZXRyeSc7XG5pbXBvcnQgeyBhZGRSYW5nZSB9IGZyb20gJy4uLy4uL2NvcmUvYXJyYXkvYWRkLXJhbmdlLmZ1bmN0aW9uJztcbmltcG9ydCB7IFBvaW50Q29tcGFyaXNvbkRldGFpbHMgfSBmcm9tICcuLi9wb2ludC9wb2ludC1jb21wYXJpc29uLWRldGFpbHMnO1xuaW1wb3J0IHsgZ2V0TWVhc3VyZUZyb21Qb2ludCB9IGZyb20gJy4uL3BvaW50L2dldC1tZWFzdXJlLWZyb20tcG9pbnQuZnVuY3Rpb24nO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2ludChsaW5lOiBMaW5lR2VvbWV0cnksIG1lYXN1cmU6IG51bWJlcik6IG51bWJlcltdIHtcbiAgY29uc3QgcG9pbnRDb21wYXJpc2lvbkRldGFpbHM6IFBvaW50Q29tcGFyaXNvbkRldGFpbHNbXSA9IFtdO1xuICBjb25zdCBwYXRoczogbnVtYmVyW11bXVtdID0gdG9NdWx0aVBhcnRQYXRocyhsaW5lKTtcblxuICBwYXRocy5mb3JFYWNoKChjb29yZGluYXRlczogbnVtYmVyW11bXSkgPT4ge1xuICAgIGNvbnN0IGRldGFpbHMgPSBjb21wYXJlUGF0aFdpdGhNZWFzdXJlKGNvb3JkaW5hdGVzLCBtZWFzdXJlKTtcbiAgICBhZGRSYW5nZShwb2ludENvbXBhcmlzaW9uRGV0YWlscywgZGV0YWlscyk7XG4gIH0pO1xuXG4gIGNvbnN0IG1pblBvaW50ID0gcG9pbnRDb21wYXJpc2lvbkRldGFpbHMucmVkdWNlKChhY2N1bXVsYXRvciwgdmFsdWUpID0+IG1pblBvaW50Q2xvc2VyVG9NZWFzdXJlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgbWVhc3VyZSkpO1xuICBjb25zdCBtYXhQb2ludCA9IHBvaW50Q29tcGFyaXNpb25EZXRhaWxzLnJlZHVjZSgoYWNjdW11bGF0b3IsIHZhbHVlKSA9PiBtYXhQb2ludENsb3NlclRvTWVhc3VyZShhY2N1bXVsYXRvciwgdmFsdWUsIG1lYXN1cmUpKTtcbiAgY29uc3QgbWVhc3VyZURlbHRhUGVyY2VudCA9IGNhbGN1bGF0ZU1lYXN1cmVEZWx0YShtaW5Qb2ludC5wb2ludE1lYXN1cmUsIG1heFBvaW50LnBvaW50TWVhc3VyZSwgbWVhc3VyZSk7XG4gIGNvbnN0IHggPSBpbnRlcnBvbGF0ZVgobWluUG9pbnQucG9pbnRDb29yZGluYXRlLCBtYXhQb2ludC5wb2ludENvb3JkaW5hdGUsIG1lYXN1cmVEZWx0YVBlcmNlbnQpO1xuICBjb25zdCB5ID0gaW50ZXJwb2xhdGVZKG1pblBvaW50LnBvaW50Q29vcmRpbmF0ZSwgbWF4UG9pbnQucG9pbnRDb29yZGluYXRlLCBtZWFzdXJlRGVsdGFQZXJjZW50KTtcblxuICByZXR1cm4gW3gsIHksIDAsIG1lYXN1cmVdO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVgoW21pblhdOiBudW1iZXJbXSwgW21heFhdOiBudW1iZXJbXSwgZGVsdGE6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBtaW5YICsgZGVsdGEgKiAobWF4WCAtIG1pblgpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVkoWywgbWluWV06IG51bWJlcltdLCBbLCBtYXhZXTogbnVtYmVyW10sIGRlbHRhOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gbWluWSArIGRlbHRhICogKG1heFkgLSBtaW5ZKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTWVhc3VyZURlbHRhKG1pbk1lYXN1cmU6IG51bWJlciwgbWF4TWVhc3VyZTogbnVtYmVyLCBtZWFzdXJlOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAobWF4TWVhc3VyZSA9PT0gbWluTWVhc3VyZSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIChtZWFzdXJlIC0gbWluTWVhc3VyZSkgLyAobWF4TWVhc3VyZSAtIG1pbk1lYXN1cmUpO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlUGF0aFdpdGhNZWFzdXJlKGNvb3JkaW5hdGVzOiBudW1iZXJbXVtdLCBtZWFzdXJlVG9Db21wYXJlOiBudW1iZXIpOiBQb2ludENvbXBhcmlzb25EZXRhaWxzW10ge1xuICBjb25zdCBwb2ludENvbXBhcmlzaW9uRGV0YWlsc0Zyb21QYXRoOiBQb2ludENvbXBhcmlzb25EZXRhaWxzW10gPSBjb29yZGluYXRlc1xuICAgIC5tYXAoXG4gICAgICAoY29vcmRpbmF0ZTogbnVtYmVyW10sIGluZGV4OiBudW1iZXIpID0+IGNvbXBhcmVDb29yZGluYXRlV2l0aE1lYXN1cmUoY29vcmRpbmF0ZSwgbWVhc3VyZVRvQ29tcGFyZSwgaW5kZXgpXG4gICAgKTtcblxuICByZXR1cm4gcG9pbnRDb21wYXJpc2lvbkRldGFpbHNGcm9tUGF0aDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUNvb3JkaW5hdGVXaXRoTWVhc3VyZShjb29yZGluYXRlOiBudW1iZXJbXSwgbWVhc3VyZVRvQ29tcGFyZTogbnVtYmVyLCBpbmRleDogbnVtYmVyKTogUG9pbnRDb21wYXJpc29uRGV0YWlscyB7XG4gIGNvbnN0IG1lYXN1cmVGcm9tQ29vcmRpbmF0ZSA9IGdldE1lYXN1cmVGcm9tUG9pbnQoY29vcmRpbmF0ZSk7XG4gIGNvbnN0IHBvaW50RGV0YWlsczogUG9pbnRDb21wYXJpc29uRGV0YWlscyA9IHtcbiAgICBwb2ludENvb3JkaW5hdGU6IGNvb3JkaW5hdGUsXG4gICAgZGlzdGFuY2U6IE1hdGguYWJzKG1lYXN1cmVGcm9tQ29vcmRpbmF0ZSAtIG1lYXN1cmVUb0NvbXBhcmUpLFxuICAgIHBvaW50TWVhc3VyZTogbWVhc3VyZUZyb21Db29yZGluYXRlLFxuICAgIGluZGV4XG4gIH07XG5cbiAgcmV0dXJuIHBvaW50RGV0YWlscztcbn1cblxuZnVuY3Rpb24gbWluUG9pbnRDbG9zZXJUb01lYXN1cmUoXG4gIGFjY3VtdWxhdG9yOiBQb2ludENvbXBhcmlzb25EZXRhaWxzLFxuICB2YWx1ZTogUG9pbnRDb21wYXJpc29uRGV0YWlscyxcbiAgbWVhc3VyZVRvQ29tcGFyZTogbnVtYmVyXG4pOiBQb2ludENvbXBhcmlzb25EZXRhaWxzIHtcbiAgY29uc3QgaXNQb2ludENsb3NlclRvTWVhc3VyZSA9IHZhbHVlLmRpc3RhbmNlIDw9IGFjY3VtdWxhdG9yLmRpc3RhbmNlO1xuICBjb25zdCBpc1BvaW50TGVzc1RoYW5NZWFzdXJlID0gdmFsdWUucG9pbnRNZWFzdXJlIDw9IG1lYXN1cmVUb0NvbXBhcmU7XG5cbiAgcmV0dXJuIGlzUG9pbnRDbG9zZXJUb01lYXN1cmUgJiYgaXNQb2ludExlc3NUaGFuTWVhc3VyZVxuICAgID8gdmFsdWVcbiAgICA6IGFjY3VtdWxhdG9yO1xufVxuXG5mdW5jdGlvbiBtYXhQb2ludENsb3NlclRvTWVhc3VyZShcbiAgcG9pbnQxOiBQb2ludENvbXBhcmlzb25EZXRhaWxzLFxuICBwb2ludDI6IFBvaW50Q29tcGFyaXNvbkRldGFpbHMsXG4gIG1lYXN1cmVUb0NvbXBhcmU6IG51bWJlclxuKTogUG9pbnRDb21wYXJpc29uRGV0YWlscyB7XG4gIGNvbnN0IGlzUG9pbnRDbG9zZXJUb01lYXN1cmUgPSBwb2ludDEuZGlzdGFuY2UgPD0gcG9pbnQyLmRpc3RhbmNlO1xuICBjb25zdCBpc1BvaW50R3JlYXRlclRoYW5NZWFzdXJlID0gcG9pbnQxLnBvaW50TWVhc3VyZSA+PSBtZWFzdXJlVG9Db21wYXJlO1xuXG4gIHJldHVybiBpc1BvaW50Q2xvc2VyVG9NZWFzdXJlICYmIGlzUG9pbnRHcmVhdGVyVGhhbk1lYXN1cmVcbiAgICA/IHBvaW50MVxuICAgIDogcG9pbnQyO1xufVxuIl19