/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { toMultiPartPaths } from './to-multi-part-paths.function';
import { getDistanceBetweenPoints, getMetersBetweenLatLng } from '../point/get-distance-between-points.function';
import { toSinglePartPointArray } from '../point/to-single-part-point.function';
import { getDistanceToLine } from './get-distance-to-line.function';
import { addRange } from '../../core/array/add-range.function';
/**
 * @record
 */
export function LineVerticeeSummary() { }
if (false) {
    /** @type {?} */
    LineVerticeeSummary.prototype.nearestPoint;
    /** @type {?} */
    LineVerticeeSummary.prototype.furthestPoint;
    /** @type {?} */
    LineVerticeeSummary.prototype.minPoint;
    /** @type {?} */
    LineVerticeeSummary.prototype.maxPoint;
    /** @type {?} */
    LineVerticeeSummary.prototype.nextPoint;
    /** @type {?} */
    LineVerticeeSummary.prototype.previousPoint;
}
/**
 * @param {?} line
 * @param {?} point
 * @param {?=} isPointDegrees
 * @return {?}
 */
export function getVerticeeInfos(line, point, isPointDegrees) {
    if (isPointDegrees === void 0) { isPointDegrees = true; }
    /** @type {?} */
    var pointComparisonDetails = [];
    /** @type {?} */
    var paths = toMultiPartPaths(line);
    paths.forEach((/**
     * @param {?} coordinates
     * @return {?}
     */
    function (coordinates) {
        /** @type {?} */
        var details = comparePathWithPoint(coordinates, point, isPointDegrees);
        addRange(pointComparisonDetails, details);
    }));
    /** @type {?} */
    var nearestPoint;
    /** @type {?} */
    var furthestPoint;
    /** @type {?} */
    var minPoint;
    /** @type {?} */
    var maxPoint;
    pointComparisonDetails.forEach((/**
     * @param {?} pointCandidate
     * @return {?}
     */
    function (pointCandidate) {
        if (!nearestPoint || pointCandidate.distance < nearestPoint.distance) {
            nearestPoint = pointCandidate;
        }
        if (!furthestPoint || pointCandidate.distance > furthestPoint.distance) {
            furthestPoint = pointCandidate;
        }
        if (!minPoint || pointCandidate.pointMeasure < minPoint.pointMeasure) {
            minPoint = pointCandidate;
        }
        if (!maxPoint || pointCandidate.pointMeasure > maxPoint.pointMeasure) {
            maxPoint = pointCandidate;
        }
    }));
    // const nearestPoint = pointComparisionDetails
    //   .reduce((accumulator, value) => accumulator.distance > value.distance ? value : accumulator);
    /** @type {?} */
    var pointBefore = pointComparisonDetails[nearestPoint.index - 1];
    /** @type {?} */
    var pointAfter = pointComparisonDetails[nearestPoint.index + 1];
    /** @type {?} */
    var nextPoint = pointAfter;
    /** @type {?} */
    var previousPoint = pointBefore;
    // NOTE: this logic handles the rare case where the distance of the test point matches both the next
    // and previous verticee.
    // 0-----4--------------------------100
    //          5
    if (pointBefore && pointAfter) {
        /** @type {?} */
        var beforDistance = getDistanceToLine(point, nearestPoint.pointCoordinate, pointBefore.pointCoordinate);
        /** @type {?} */
        var afterDistance = getDistanceToLine(point, nearestPoint.pointCoordinate, pointAfter.pointCoordinate);
        if (beforDistance < afterDistance) {
            nextPoint = pointBefore;
            previousPoint = pointComparisonDetails[nextPoint.index - 2];
        }
    }
    return {
        nearestPoint: nearestPoint,
        furthestPoint: furthestPoint,
        nextPoint: nextPoint,
        previousPoint: previousPoint,
        minPoint: minPoint,
        maxPoint: maxPoint
    };
}
/**
 * @param {?} line
 * @param {?} point
 * @param {?=} isPointDegrees
 * @return {?}
 */
export function getClosestVerticees(line, point, isPointDegrees) {
    if (isPointDegrees === void 0) { isPointDegrees = true; }
    /** @type {?} */
    var info = getVerticeeInfos(line, point, isPointDegrees);
    return [
        info.nearestPoint ? info.nearestPoint.pointCoordinate : null,
        info.nextPoint ? info.nextPoint.pointCoordinate : null
    ];
}
/**
 * @param {?} line
 * @param {?} point
 * @param {?=} isPointDegrees
 * @return {?}
 */
export function getClosestVerticee(line, point, isPointDegrees) {
    if (isPointDegrees === void 0) { isPointDegrees = true; }
    var _a = tslib_1.__read(getClosestVerticees(line, point, isPointDegrees), 1), firstClosest = _a[0];
    return firstClosest;
}
/**
 * @param {?} coordinates
 * @param {?} pointToCompare
 * @param {?} isPointDegrees
 * @return {?}
 */
function comparePathWithPoint(coordinates, pointToCompare, isPointDegrees) {
    /** @type {?} */
    var pointComparisionDetailsFromPath = coordinates
        .map((/**
     * @param {?} coordinate
     * @param {?} index
     * @return {?}
     */
    function (coordinate, index) { return compareCoordinateWithPoint(coordinate, pointToCompare, isPointDegrees, index); }));
    return pointComparisionDetailsFromPath;
}
/**
 * @param {?} coordinate
 * @param {?} pointToCompare
 * @return {?}
 */
function getDegreeDistance(coordinate, pointToCompare) {
    /** @type {?} */
    var coordinate2 = toSinglePartPointArray(pointToCompare);
    return getMetersBetweenLatLng(coordinate[1], coordinate[0], coordinate2[1], coordinate2[0]);
}
/**
 * @param {?} coordinate
 * @param {?} pointToCompare
 * @param {?} isPointDegrees
 * @param {?} index
 * @return {?}
 */
function compareCoordinateWithPoint(coordinate, pointToCompare, isPointDegrees, index) {
    /** @type {?} */
    var distance = isPointDegrees
        ? getDegreeDistance(coordinate, pointToCompare)
        : getDistanceBetweenPoints(coordinate, pointToCompare);
    /** @type {?} */
    var pointDetails = {
        pointCoordinate: coordinate,
        distance: distance,
        index: index
    };
    return pointDetails;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0LW5lYXJlc3QtcG9pbnQtYnktZ2VvbWV0cnkuZnVuY3Rpb24uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdHNzL3Nkay8iLCJzb3VyY2VzIjpbImxpYi9nZW9tZXRyeS9saW5lL2dldC1uZWFyZXN0LXBvaW50LWJ5LWdlb21ldHJ5LmZ1bmN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFHbEUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLHNCQUFzQixFQUFFLE1BQU0sK0NBQStDLENBQUM7QUFDakgsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFDaEYsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDcEUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLHFDQUFxQyxDQUFDOzs7O0FBRy9ELHlDQU9DOzs7SUFOQywyQ0FBcUM7O0lBQ3JDLDRDQUFzQzs7SUFDdEMsdUNBQWlDOztJQUNqQyx1Q0FBaUM7O0lBQ2pDLHdDQUFrQzs7SUFDbEMsNENBQXNDOzs7Ozs7OztBQUl4QyxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsSUFBa0IsRUFBRSxLQUFrQixFQUFFLGNBQThCO0lBQTlCLCtCQUFBLEVBQUEscUJBQThCOztRQUMvRixzQkFBc0IsR0FBNkIsRUFBRTs7UUFDckQsS0FBSyxHQUFpQixnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7SUFFbEQsS0FBSyxDQUFDLE9BQU87Ozs7SUFBQyxVQUFDLFdBQXVCOztZQUM5QixPQUFPLEdBQUcsb0JBQW9CLENBQUMsV0FBVyxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUM7UUFDeEUsUUFBUSxDQUFDLHNCQUFzQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzVDLENBQUMsRUFBQyxDQUFDOztRQUVDLFlBQW9DOztRQUNwQyxhQUFxQzs7UUFDckMsUUFBZ0M7O1FBQ2hDLFFBQWdDO0lBRXBD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QStCLENBQUM7QUFDekMsQ0FBQzs7Ozs7O0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxVQUFvQixFQUFFLGNBQTJCOztRQUNwRSxXQUFXLEdBQWEsc0JBQXNCLENBQUMsY0FBYyxDQUFDO0lBRXBFLE9BQU8sc0JBQXNCLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUYsQ0FBQzs7Ozs7Ozs7QUFFRCxTQUFTLDBCQUEwQixDQUNqQyxVQUFvQixFQUNwQixjQUEyQixFQUMzQixjQUF1QixFQUN2QixLQUFhOztRQUVQLFFBQVEsR0FBRyxjQUFjO1FBQzdCLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLEVBQUUsY0FBYyxDQUFDO1FBQy9DLENBQUMsQ0FBQyx3QkFBd0IsQ0FBQyxVQUFVLEVBQUUsY0FBYyxDQUFDOztRQUVsRCxZQUFZLEdBQTJCO1FBQzNDLGVBQWUsRUFBRSxVQUFVO1FBQzNCLFFBQVEsVUFBQTtRQUNSLEtBQUssT0FBQTtLQUNOO0lBRUQsT0FBTyxZQUFZLENBQUM7QUFDdEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpbmVHZW9tZXRyeSB9IGZyb20gJy4vbGluZS1nZW9tZXRyeSc7XG5pbXBvcnQgeyB0b011bHRpUGFydFBhdGhzIH0gZnJvbSAnLi90by1tdWx0aS1wYXJ0LXBhdGhzLmZ1bmN0aW9uJztcbmltcG9ydCB7IFBvaW50Q29tcGFyaXNvbkRldGFpbHMgfSBmcm9tICcuLi9wb2ludC9wb2ludC1jb21wYXJpc29uLWRldGFpbHMnO1xuaW1wb3J0IHsgU2luZ2xlUG9pbnQgfSBmcm9tICcuLi9wb2ludC9zaW5nbGUtcG9pbnQnO1xuaW1wb3J0IHsgZ2V0RGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBnZXRNZXRlcnNCZXR3ZWVuTGF0TG5nIH0gZnJvbSAnLi4vcG9pbnQvZ2V0LWRpc3RhbmNlLWJldHdlZW4tcG9pbnRzLmZ1bmN0aW9uJztcbmltcG9ydCB7IHRvU2luZ2xlUGFydFBvaW50QXJyYXkgfSBmcm9tICcuLi9wb2ludC90by1zaW5nbGUtcGFydC1wb2ludC5mdW5jdGlvbic7XG5pbXBvcnQgeyBnZXREaXN0YW5jZVRvTGluZSB9IGZyb20gJy4vZ2V0LWRpc3RhbmNlLXRvLWxpbmUuZnVuY3Rpb24nO1xuaW1wb3J0IHsgYWRkUmFuZ2UgfSBmcm9tICcuLi8uLi9jb3JlL2FycmF5L2FkZC1yYW5nZS5mdW5jdGlvbic7XG5cblxuZXhwb3J0IGludGVyZmFjZSBMaW5lVmVydGljZWVTdW1tYXJ5IHtcbiAgbmVhcmVzdFBvaW50OiBQb2ludENvbXBhcmlzb25EZXRhaWxzO1xuICBmdXJ0aGVzdFBvaW50OiBQb2ludENvbXBhcmlzb25EZXRhaWxzO1xuICBtaW5Qb2ludDogUG9pbnRDb21wYXJpc29uRGV0YWlscztcbiAgbWF4UG9pbnQ6IFBvaW50Q29tcGFyaXNvbkRldGFpbHM7XG4gIG5leHRQb2ludDogUG9pbnRDb21wYXJpc29uRGV0YWlscztcbiAgcHJldmlvdXNQb2ludDogUG9pbnRDb21wYXJpc29uRGV0YWlscztcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVydGljZWVJbmZvcyhsaW5lOiBMaW5lR2VvbWV0cnksIHBvaW50OiBTaW5nbGVQb2ludCwgaXNQb2ludERlZ3JlZXM6IGJvb2xlYW4gPSB0cnVlKTogTGluZVZlcnRpY2VlU3VtbWFyeSB7XG4gIGNvbnN0IHBvaW50Q29tcGFyaXNvbkRldGFpbHM6IFBvaW50Q29tcGFyaXNvbkRldGFpbHNbXSA9IFtdO1xuICBjb25zdCBwYXRoczogbnVtYmVyW11bXVtdID0gdG9NdWx0aVBhcnRQYXRocyhsaW5lKTtcblxuICBwYXRocy5mb3JFYWNoKChjb29yZGluYXRlczogbnVtYmVyW11bXSkgPT4ge1xuICAgIGNvbnN0IGRldGFpbHMgPSBjb21wYXJlUGF0aFdpdGhQb2ludChjb29yZGluYXRlcywgcG9pbnQsIGlzUG9pbnREZWdyZWVzKTtcbiAgICBhZGRSYW5nZShwb2ludENvbXBhcmlzb25EZXRhaWxzLCBkZXRhaWxzKTtcbiAgfSk7XG5cbiAgbGV0IG5lYXJlc3RQb2ludDogUG9pbnRDb21wYXJpc29uRGV0YWlscztcbiAgbGV0IGZ1cnRoZXN0UG9pbnQ6IFBvaW50Q29tcGFyaXNvbkRldGFpbHM7XG4gIGxldCBtaW5Qb2ludDogUG9pbnRDb21wYXJpc29uRGV0YWlscztcbiAgbGV0IG1heFBvaW50OiBQb2ludENvbXBhcmlzb25EZXRhaWxzO1xuXG4gIHBvaW50Q29tcGFyaXNvbkRldGFpbHMuZm9yRWFjaChwb2ludENhbmRpZGF0ZSA9PiB7XG4gICAgaWYgKCFuZWFyZXN0UG9pbnQgfHwgcG9pbnRDYW5kaWRhdGUuZGlzdGFuY2UgPCBuZWFyZXN0UG9pbnQuZGlzdGFuY2UpIHtcbiAgICAgIG5lYXJlc3RQb2ludCA9IHBvaW50Q2FuZGlkYXRlO1xuICAgIH1cblxuICAgIGlmICghZnVydGhlc3RQb2ludCB8fCBwb2ludENhbmRpZGF0ZS5kaXN0YW5jZSA+IGZ1cnRoZXN0UG9pbnQuZGlzdGFuY2UpIHtcbiAgICAgIGZ1cnRoZXN0UG9pbnQgPSBwb2ludENhbmRpZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAoIW1pblBvaW50IHx8IHBvaW50Q2FuZGlkYXRlLnBvaW50TWVhc3VyZSA8IG1pblBvaW50LnBvaW50TWVhc3VyZSkge1xuICAgICAgbWluUG9pbnQgPSBwb2ludENhbmRpZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAoIW1heFBvaW50IHx8IHBvaW50Q2FuZGlkYXRlLnBvaW50TWVhc3VyZSA+IG1heFBvaW50LnBvaW50TWVhc3VyZSkge1xuICAgICAgbWF4UG9pbnQgPSBwb2ludENhbmRpZGF0ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNvbnN0IG5lYXJlc3RQb2ludCA9IHBvaW50Q29tcGFyaXNpb25EZXRhaWxzXG4gIC8vICAgLnJlZHVjZSgoYWNjdW11bGF0b3IsIHZhbHVlKSA9PiBhY2N1bXVsYXRvci5kaXN0YW5jZSA+IHZhbHVlLmRpc3RhbmNlID8gdmFsdWUgOiBhY2N1bXVsYXRvcik7XG5cbiAgY29uc3QgcG9pbnRCZWZvcmUgPSBwb2ludENvbXBhcmlzb25EZXRhaWxzW25lYXJlc3RQb2ludC5pbmRleCAtIDFdO1xuICBjb25zdCBwb2ludEFmdGVyID0gcG9pbnRDb21wYXJpc29uRGV0YWlsc1tuZWFyZXN0UG9pbnQuaW5kZXggKyAxXTtcbiAgbGV0IG5leHRQb2ludCA9IHBvaW50QWZ0ZXI7XG4gIGxldCBwcmV2aW91c1BvaW50ID0gcG9pbnRCZWZvcmU7XG5cbiAgLy8gTk9URTogdGhpcyBsb2dpYyBoYW5kbGVzIHRoZSByYXJlIGNhc2Ugd2hlcmUgdGhlIGRpc3RhbmNlIG9mIHRoZSB0ZXN0IHBvaW50IG1hdGNoZXMgYm90aCB0aGUgbmV4dFxuICAvLyBhbmQgcHJldmlvdXMgdmVydGljZWUuXG4gIC8vIDAtLS0tLTQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLTEwMFxuICAvLyAgICAgICAgICA1XG4gIGlmIChwb2ludEJlZm9yZSAmJiBwb2ludEFmdGVyKSB7XG4gICAgY29uc3QgYmVmb3JEaXN0YW5jZSA9IGdldERpc3RhbmNlVG9MaW5lKHBvaW50LCBuZWFyZXN0UG9pbnQucG9pbnRDb29yZGluYXRlLCBwb2ludEJlZm9yZS5wb2ludENvb3JkaW5hdGUpO1xuICAgIGNvbnN0IGFmdGVyRGlzdGFuY2UgPSBnZXREaXN0YW5jZVRvTGluZShwb2ludCwgbmVhcmVzdFBvaW50LnBvaW50Q29vcmRpbmF0ZSwgcG9pbnRBZnRlci5wb2ludENvb3JkaW5hdGUpO1xuXG4gICAgaWYgKGJlZm9yRGlzdGFuY2UgPCBhZnRlckRpc3RhbmNlKSB7XG4gICAgICBuZXh0UG9pbnQgPSBwb2ludEJlZm9yZTtcbiAgICAgIHByZXZpb3VzUG9pbnQgPSBwb2ludENvbXBhcmlzb25EZXRhaWxzW25leHRQb2ludC5pbmRleCAtIDJdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmVhcmVzdFBvaW50LFxuICAgIGZ1cnRoZXN0UG9pbnQsXG4gICAgbmV4dFBvaW50LFxuICAgIHByZXZpb3VzUG9pbnQsXG4gICAgbWluUG9pbnQsXG4gICAgbWF4UG9pbnRcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENsb3Nlc3RWZXJ0aWNlZXMoXG4gIGxpbmU6IExpbmVHZW9tZXRyeSxcbiAgcG9pbnQ6IFNpbmdsZVBvaW50LFxuICBpc1BvaW50RGVncmVlczogYm9vbGVhbiA9IHRydWVcbik6IFtTaW5nbGVQb2ludCB8IG51bGwsIFNpbmdsZVBvaW50IHwgbnVsbF0ge1xuICBjb25zdCBpbmZvID0gZ2V0VmVydGljZWVJbmZvcyhsaW5lLCBwb2ludCwgaXNQb2ludERlZ3JlZXMpO1xuXG4gIHJldHVybiBbXG4gICAgaW5mby5uZWFyZXN0UG9pbnQgPyBpbmZvLm5lYXJlc3RQb2ludC5wb2ludENvb3JkaW5hdGUgOiBudWxsLFxuICAgIGluZm8ubmV4dFBvaW50ID8gaW5mby5uZXh0UG9pbnQucG9pbnRDb29yZGluYXRlIDogbnVsbFxuICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xvc2VzdFZlcnRpY2VlKGxpbmU6IExpbmVHZW9tZXRyeSwgcG9pbnQ6IFNpbmdsZVBvaW50LCBpc1BvaW50RGVncmVlczogYm9vbGVhbiA9IHRydWUpOiBTaW5nbGVQb2ludCB7XG4gIGNvbnN0IFtmaXJzdENsb3Nlc3RdID0gZ2V0Q2xvc2VzdFZlcnRpY2VlcyhsaW5lLCBwb2ludCwgaXNQb2ludERlZ3JlZXMpO1xuICByZXR1cm4gZmlyc3RDbG9zZXN0O1xufVxuXG5mdW5jdGlvbiBjb21wYXJlUGF0aFdpdGhQb2ludChjb29yZGluYXRlczogbnVtYmVyW11bXSwgcG9pbnRUb0NvbXBhcmU6IFNpbmdsZVBvaW50LCBpc1BvaW50RGVncmVlczogYm9vbGVhbik6IFBvaW50Q29tcGFyaXNvbkRldGFpbHNbXSB7XG4gIGNvbnN0IHBvaW50Q29tcGFyaXNpb25EZXRhaWxzRnJvbVBhdGg6IFBvaW50Q29tcGFyaXNvbkRldGFpbHNbXSA9IGNvb3JkaW5hdGVzXG4gICAgLm1hcChcbiAgICAgIChjb29yZGluYXRlOiBudW1iZXJbXSwgaW5kZXg6IG51bWJlcikgPT4gY29tcGFyZUNvb3JkaW5hdGVXaXRoUG9pbnQoY29vcmRpbmF0ZSwgcG9pbnRUb0NvbXBhcmUsIGlzUG9pbnREZWdyZWVzLCBpbmRleClcbiAgICApO1xuXG4gIHJldHVybiBwb2ludENvbXBhcmlzaW9uRGV0YWlsc0Zyb21QYXRoO1xufVxuXG5mdW5jdGlvbiBnZXREZWdyZWVEaXN0YW5jZShjb29yZGluYXRlOiBudW1iZXJbXSwgcG9pbnRUb0NvbXBhcmU6IFNpbmdsZVBvaW50KTogbnVtYmVyIHtcbiAgY29uc3QgY29vcmRpbmF0ZTI6IG51bWJlcltdID0gdG9TaW5nbGVQYXJ0UG9pbnRBcnJheShwb2ludFRvQ29tcGFyZSk7XG5cbiAgcmV0dXJuIGdldE1ldGVyc0JldHdlZW5MYXRMbmcoY29vcmRpbmF0ZVsxXSwgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZTJbMV0sIGNvb3JkaW5hdGUyWzBdKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUNvb3JkaW5hdGVXaXRoUG9pbnQoXG4gIGNvb3JkaW5hdGU6IG51bWJlcltdLFxuICBwb2ludFRvQ29tcGFyZTogU2luZ2xlUG9pbnQsXG4gIGlzUG9pbnREZWdyZWVzOiBib29sZWFuLFxuICBpbmRleDogbnVtYmVyXG4pOiBQb2ludENvbXBhcmlzb25EZXRhaWxzIHtcbiAgY29uc3QgZGlzdGFuY2UgPSBpc1BvaW50RGVncmVlc1xuICAgID8gZ2V0RGVncmVlRGlzdGFuY2UoY29vcmRpbmF0ZSwgcG9pbnRUb0NvbXBhcmUpXG4gICAgOiBnZXREaXN0YW5jZUJldHdlZW5Qb2ludHMoY29vcmRpbmF0ZSwgcG9pbnRUb0NvbXBhcmUpO1xuXG4gIGNvbnN0IHBvaW50RGV0YWlsczogUG9pbnRDb21wYXJpc29uRGV0YWlscyA9IHtcbiAgICBwb2ludENvb3JkaW5hdGU6IGNvb3JkaW5hdGUsXG4gICAgZGlzdGFuY2UsXG4gICAgaW5kZXhcbiAgfTtcblxuICByZXR1cm4gcG9pbnREZXRhaWxzO1xufVxuIl19