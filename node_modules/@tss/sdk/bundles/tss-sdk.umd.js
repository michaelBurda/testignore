(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/platform-browser'), require('@angular/router'), require('@angular/forms'), require('@turf/helpers'), require('@turf/nearest-point-on-line'), require('@turf/line-split'), require('@turf/length'), require('util'), require('@turf/destination'), require('@turf/bearing'), require('@turf/distance'), require('@angular/common'), require('rxjs'), require('rxjs/operators'), require('@angular/common/http'), require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('@tss/sdk', ['exports', '@angular/platform-browser', '@angular/router', '@angular/forms', '@turf/helpers', '@turf/nearest-point-on-line', '@turf/line-split', '@turf/length', 'util', '@turf/destination', '@turf/bearing', '@turf/distance', '@angular/common', 'rxjs', 'rxjs/operators', '@angular/common/http', '@angular/core'], factory) :
    (factory((global.tss = global.tss || {}, global.tss.sdk = {}),global.ng.platformBrowser,global.ng.router,global.ng.forms,global.helpers,global.nearestPointOnLine,global.lineSplit,global.length,global.util,global.destination,global.bearing,global.distance,global.ng.common,global.rxjs,global.rxjs.operators,global.ng.common.http,global.ng.core));
}(this, (function (exports,platformBrowser,i1,forms,helpers,nearestPointOnLine,lineSplit,length,util,destination,bearing,distance,common,rxjs,operators,i1$1,i0) { 'use strict';

    nearestPointOnLine = nearestPointOnLine && nearestPointOnLine.hasOwnProperty('default') ? nearestPointOnLine['default'] : nearestPointOnLine;
    lineSplit = lineSplit && lineSplit.hasOwnProperty('default') ? lineSplit['default'] : lineSplit;
    length = length && length.hasOwnProperty('default') ? length['default'] : length;
    destination = destination && destination.hasOwnProperty('default') ? destination['default'] : destination;
    bearing = bearing && bearing.hasOwnProperty('default') ? bearing['default'] : bearing;
    distance = distance && distance.hasOwnProperty('default') ? distance['default'] : distance;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ResourceConfig = /** @class */ (function () {
        function ResourceConfig() {
        }
        Object.defineProperty(ResourceConfig.prototype, "hasServiceUrl", {
            get: /**
             * @return {?}
             */ function () {
                return Boolean(this.serviceUrl);
            },
            enumerable: true,
            configurable: true
        });
        return ResourceConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var LogLevel = {
        Trace: 0,
        Debug: 1,
        Info: 2,
        Warn: 3,
        Error: 4,
        Fatal: 5,
    };
    LogLevel[LogLevel.Trace] = 'Trace';
    LogLevel[LogLevel.Debug] = 'Debug';
    LogLevel[LogLevel.Info] = 'Info';
    LogLevel[LogLevel.Warn] = 'Warn';
    LogLevel[LogLevel.Error] = 'Error';
    LogLevel[LogLevel.Fatal] = 'Fatal';
    /**
     * @param {?} type
     * @return {?}
     */
    function typeToLevel(type) {
        if (type === 'trace') {
            return LogLevel.Trace;
        }
        else if (type === 'debug') {
            return LogLevel.Debug;
        }
        else if (type === 'info') {
            return LogLevel.Info;
        }
        else if (type === 'warn') {
            return LogLevel.Warn;
        }
        else if (type === 'error') {
            return LogLevel.Error;
        }
        else if (type === 'fatal') {
            return LogLevel.Fatal;
        }
        else {
            throw new Error("Unknown log type: '" + type + "'");
        }
    }
    /**
     * @param {?} level
     * @return {?}
     */
    function levelToType(level) {
        if (level === LogLevel.Trace) {
            return 'trace';
        }
        else if (level === LogLevel.Debug) {
            return 'debug';
        }
        else if (level === LogLevel.Info) {
            return 'info';
        }
        else if (level === LogLevel.Warn) {
            return 'warn';
        }
        else if (level === LogLevel.Error) {
            return 'error';
        }
        else if (level === LogLevel.Fatal) {
            return 'fatal';
        }
        else {
            throw new Error("Unknown log level: '" + level + "'");
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var MeasurementUnit = {
        Imperial: 'imperial',
        Metric: 'metric',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A simple settings/config class for storing key/value pairs with persistence.
     */
    var CoreConfig = /** @class */ (function () {
        function CoreConfig() {
            this.autoConfig = true;
            this.logEnabled = true;
            this.logLevel = LogLevel.Info;
            this.defaultNotifyInfoMsg = 'Info';
            this.defaultNotifyWarnMsg = 'Warning';
            this.defaultNotifyErrorMsg = 'Error';
            this.defaultNotifySuccessMsg = 'Success';
            this.defaultNotifyWaitMsg = 'Wait';
            this.measurementUnit = MeasurementUnit.Imperial;
        }
        CoreConfig.moduleConfigs = [{ className: 'CoreConfig', injectorToken: CoreConfig }];
        CoreConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ CoreConfig.ngInjectableDef = i0.defineInjectable({ factory: function CoreConfig_Factory() { return new CoreConfig(); }, token: CoreConfig, providedIn: "root" });
        return CoreConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @param {?} expectedType
     * @return {?}
     */
    function isType(val, expectedType) {
        return typeof val === expectedType;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isString(val) {
        return isType(val, 'string');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} config
     * @return {?}
     */
    function AutoConfig(config) {
        return ( /**
         * @param {?} constructor
         * @return {?}
         */function (constructor) {
            /** @type {?} */
            var autoConf = isString(config)
                ? { className: ( /** @type {?} */(config)), injectorToken: constructor }
                : ( /** @type {?} */(config));
            CoreConfig.moduleConfigs.push(autoConf);
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_APP_ID = 'all';
    /** @type {?} */
    var DEFAULT_PROFILE_ID = 'default';
    /**
     * Application related configuration options. These settings are used to
     * drive all general "global" application related behaviour. The settings can be
     * overridden directly in the code, application module, or from the TDS server.
     */
    var AppConfig = /** @class */ (function (_super) {
        __extends(AppConfig, _super);
        function AppConfig() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.appId = DEFAULT_APP_ID;
            _this.queryProfile = true;
            _this.profileId = null;
            _this.profile = null;
            _this.defaultProfileId = DEFAULT_PROFILE_ID;
            _this.allowQueryParamInjections = true;
            _this.continueOnAppBootstrapError = false;
            _this.appSettingsEndpoint = 'api/apps/{appId}/settings/{id}';
            _this.appProfileEndpoint = 'api/apps/{appId}/profiles/{id}';
            _this.pingEndpoint = 'api/ping';
            _this.statusEndpoint = 'api/status';
            return _this;
        }
        AppConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ AppConfig.ngInjectableDef = i0.defineInjectable({ factory: function AppConfig_Factory() { return new AppConfig(); }, token: AppConfig, providedIn: "root" });
        /**
         * Application related configuration options. These settings are used to
         * drive all general "global" application related behaviour. The settings can be
         * overridden directly in the code, application module, or from the TDS server.
         */
        AppConfig = __decorate([
            AutoConfig('AppConfig')
        ], AppConfig);
        return AppConfig;
    }(ResourceConfig));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // Port from: https://github.com/jfromaniello/url-join
    // TODO: Refactor this to be cleaner - RG.
    /**
     * @param {...?} parts
     * @return {?}
     */
    function join() {
        var parts = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parts[_i] = arguments[_i];
        }
        /** @type {?} */
        var resultArray = [];
        /** @type {?} */
        var str;
        if (Array.isArray(parts[0])) {
            parts = parts[0];
        }
        parts[0] = parts[0] || '';
        // If the first part is a plain protocol, we combine it with the next part.
        if (parts[0].match(/^[^/:]+:\/*$/) && parts.length > 1) {
            /** @type {?} */
            var first = parts.shift();
            parts[0] = first + parts[0];
        }
        // There must be two or three slashes in the file protocol, two slashes in anything else.
        if (parts[0].match(/^file:\/\/\//)) {
            parts[0] = parts[0].replace(/^([^/:]+):\/*/, '$1:///');
        }
        else {
            parts[0] = parts[0].replace(/^([^/:]+):\/*/, '$1://');
        }
        for (var i = 0; i < parts.length; i++) {
            /** @type {?} */
            var component = parts[i];
            if (typeof component !== 'string') {
                throw new TypeError('Url must be a string. Received ' + component);
            }
            if (component === '') {
                continue;
            }
            if (i > 0) {
                // Removing the starting slashes for each component but the first.
                component = component.replace(/^[\/]+/, '');
            }
            if (i < parts.length - 1) {
                // Removing the ending slashes for each component but the last.
                component = component.replace(/[\/]+$/, '');
            }
            else {
                // For the last component we will combine multiple slashes to a single one.
                component = component.replace(/[\/]+$/, '/');
            }
            resultArray.push(component);
        }
        str = resultArray.join('/');
        // Each input component is now separated by a single slash except the possible first plain protocol part.
        // Remove trailing slash before parameters or hash.
        str = str.replace(/\/(\?|&|#[^!])/g, '$1');
        // Replace ? in parameters with &.
        /** @type {?} */
        var urlParts = str.split('?');
        str = urlParts.shift() + (urlParts.length > 0 ? '?' : '') + urlParts.join('&');
        return str;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var TOKEN_EXPRESSION = new RegExp('{(.*?)}', 'gi');
    /** @type {?} */
    var FULL_TOKEN_EXPRESSION = new RegExp('{{(.*?)}}', 'gi');
    /** @type {?} */
    var WILDCARD_EXPRESSION_VALUE = '(.*)';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} template
     * @param {?=} replaceValue
     * @return {?}
     */
    function replaceTokens(template, replaceValue) {
        if (replaceValue === void 0) {
            replaceValue = '';
        }
        return (template || '')
            .replace(FULL_TOKEN_EXPRESSION, replaceValue)
            .replace(TOKEN_EXPRESSION, replaceValue);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} template
     * @param {?} tokenKey
     * @param {?} tokenValue
     * @return {?}
     */
    function replaceToken(template, tokenKey, tokenValue) {
        return (template || '')
            .replace(new RegExp("{{" + tokenKey + "}}", 'gi'), tokenValue)
            .replace(new RegExp("{" + tokenKey + "}", 'gi'), tokenValue);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // TODO: Expand this to have the full functionality of:
    // https://github.com/davidchambers/string-format
    // -RG.
    /**
     * @param {?} template
     * @param {?} tokens
     * @param {?=} removeEmptyTokens
     * @return {?}
     */
    function format(template, tokens, removeEmptyTokens) {
        if (removeEmptyTokens === void 0) {
            removeEmptyTokens = false;
        }
        Object.keys(tokens || {})
            .forEach(( /**
     * @param {?} key
     * @return {?}
     */function (key) { return template = replaceToken(template, key, tokens[key]); }));
        if (removeEmptyTokens) {
            template = replaceTokens(template);
        }
        return template;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Cleans a URL:
     *  - Removes double-slashes
     * @param {?} url
     * @return {?}
     */
    function clean(url) {
        return isString(url)
            ? url.replace(/([^:]\/)\/+/g, '$1')
            : url;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NO_URL_ERROR_MSG = 'No URL configured for resource service.';
    /** @type {?} */
    var UNSUPPORTED_GET_EXCEPTION_MSG = "The 'Get' method is unsupported for this resource";
    /** @type {?} */
    var UNSUPPORTED_CREATE_EXCEPTION_MSG = "The 'Create' method is unsupported for this resource";
    /** @type {?} */
    var EMPTY_PARAM_VALUE = '';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     * @template T
     */
    var /**
     * @abstract
     * @template T
     */ BaseEmptyResourceService = /** @class */ (function () {
        function BaseEmptyResourceService(http, paramsOrUrl) {
            this.http = http;
            this.config = {
                url: null,
                idFieldName: 'id',
                cleanUrl: true,
            };
            if (isString(paramsOrUrl)) {
                this.config.url = ( /** @type {?} */(paramsOrUrl));
            }
            else {
                Object.assign(this.config, paramsOrUrl);
            }
            if (!this.config.url) {
                throw NO_URL_ERROR_MSG;
            }
        }
        /**
         * @protected
         * @param {?} entity
         * @param {?} endpoint
         * @param {?} tokens
         * @return {?}
         */
        BaseEmptyResourceService.prototype.getUrlWithEntity = /**
         * @protected
         * @param {?} entity
         * @param {?} endpoint
         * @param {?} tokens
         * @return {?}
         */
            function (entity, endpoint, tokens) {
                return this.getUrlWithId(entity ? entity[this.config.idFieldName] : null, endpoint, tokens);
            };
        /**
         * @protected
         * @param {?} id
         * @param {?} endpoint
         * @param {?} tokens
         * @return {?}
         */
        BaseEmptyResourceService.prototype.getUrlWithId = /**
         * @protected
         * @param {?} id
         * @param {?} endpoint
         * @param {?} tokens
         * @return {?}
         */
            function (id, endpoint, tokens) {
                /** @type {?} */
                var inferredRouteTokens = {};
                inferredRouteTokens[this.config.idFieldName] = id;
                return this.getUrl(endpoint, Object.assign(inferredRouteTokens, tokens));
            };
        /**
         * @protected
         * @param {?} endpoint
         * @param {?} tokens
         * @return {?}
         */
        BaseEmptyResourceService.prototype.getUrl = /**
         * @protected
         * @param {?} endpoint
         * @param {?} tokens
         * @return {?}
         */
            function (endpoint, tokens) {
                /** @type {?} */
                var url = endpoint
                    ? join(this.config.url, endpoint)
                    : this.config.url;
                return this.replaceTokens(url, tokens);
            };
        /**
         * @protected
         * @param {?} url
         * @param {?} tokens
         * @return {?}
         */
        BaseEmptyResourceService.prototype.replaceTokens = /**
         * @protected
         * @param {?} url
         * @param {?} tokens
         * @return {?}
         */
            function (url, tokens) {
                tokens = tokens || {};
                if (this.config.defaultRouteTokens) {
                    tokens = Object.assign({}, this.config.defaultRouteTokens, tokens);
                }
                url = format(url, tokens, true);
                if (this.config.cleanUrl) {
                    url = clean(url);
                }
                return url;
            };
        return BaseEmptyResourceService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ApiService = /** @class */ (function (_super) {
        __extends(ApiService, _super);
        function ApiService(http, appConfig) {
            var _this = _super.call(this, http, appConfig.serviceUrl) || this;
            _this.appConfig = appConfig;
            return _this;
        }
        /**
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        ApiService.prototype.ping = /**
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (routeTokens, params) {
                /** @type {?} */
                var url = this.getUrl(this.appConfig.pingEndpoint, routeTokens);
                return this.http.get(url, { params: params });
            };
        /**
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        ApiService.prototype.status = /**
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (routeTokens, params) {
                /** @type {?} */
                var url = this.getUrl(this.appConfig.pingEndpoint, routeTokens);
                return this.http.get(url, { params: params });
            };
        ApiService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        ApiService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: AppConfig }
            ];
        };
        /** @nocollapse */ ApiService.ngInjectableDef = i0.defineInjectable({ factory: function ApiService_Factory() { return new ApiService(i0.inject(i1$1.HttpClient), i0.inject(AppConfig)); }, token: ApiService, providedIn: "root" });
        return ApiService;
    }(BaseEmptyResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Console logger.
     */
    var Logger = /** @class */ (function () {
        function Logger(config) {
            this.config = config;
            this.logs = [];
        }
        Object.defineProperty(Logger.prototype, "level", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.logLevel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Logger.prototype, "enabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.logEnabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Logger.prototype, "isTrace", {
            get: /**
             * @return {?}
             */ function () {
                return this.level >= LogLevel.Trace;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Logger.prototype, "isDebug", {
            get: /**
             * @return {?}
             */ function () {
                return this.level >= LogLevel.Debug;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Logger.prototype, "isWarn", {
            get: /**
             * @return {?}
             */ function () {
                return this.level >= LogLevel.Warn;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Logger.prototype, "isError", {
            get: /**
             * @return {?}
             */ function () {
                return this.level >= LogLevel.Error;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Logger.prototype, "isFatal", {
            get: /**
             * @return {?}
             */ function () {
                return this.level >= LogLevel.Fatal;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Logger.prototype, "traceCount", {
            get: /**
             * @return {?}
             */ function () {
                return this.count('trace');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Logger.prototype, "debugCount", {
            get: /**
             * @return {?}
             */ function () {
                return this.count('debug');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Logger.prototype, "warnCount", {
            get: /**
             * @return {?}
             */ function () {
                return this.count('warn');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Logger.prototype, "errorCount", {
            get: /**
             * @return {?}
             */ function () {
                return this.count('error');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Logger.prototype, "fatalCount", {
            get: /**
             * @return {?}
             */ function () {
                return this.count('fatal');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} logType
         * @return {?}
         */
        Logger.prototype.count = /**
         * @param {?} logType
         * @return {?}
         */
            function (logType) {
                return this.logsByType(logType).length;
            };
        /**
         * @param {?} logType
         * @return {?}
         */
        Logger.prototype.logsByType = /**
         * @param {?} logType
         * @return {?}
         */
            function (logType) {
                return this.logsByLevel(typeToLevel(logType));
            };
        /**
         * @param {?} logLevel
         * @return {?}
         */
        Logger.prototype.logsByLevel = /**
         * @param {?} logLevel
         * @return {?}
         */
            function (logLevel) {
                return this.logs.filter(( /**
                 * @param {?} l
                 * @return {?}
                 */function (l) { return l.level === logLevel; }));
            };
        /**
         * @param {?} log
         * @return {?}
         */
        Logger.prototype.logEntry = /**
         * @param {?} log
         * @return {?}
         */
            function (log) {
                if (this.config.logEnabled && log.level >= this.config.logLevel) {
                    this.logs.push(log);
                    if (this.isDebug) {
                        console.log(LogLevel[log.level] + ": " + log.msg + " " + (log.error || ''));
                    }
                }
                return log;
            };
        /**
         * @param {?} msg
         * @param {?} level
         * @param {?=} error
         * @return {?}
         */
        Logger.prototype.log = /**
         * @param {?} msg
         * @param {?} level
         * @param {?=} error
         * @return {?}
         */
            function (msg, level, error) {
                if (error === void 0) {
                    error = null;
                }
                return this.logEntry({
                    msg: format(msg, { error: error }),
                    level: level,
                    error: error,
                    created: new Date()
                });
            };
        /**
         * @param {?} msg
         * @return {?}
         */
        Logger.prototype.trace = /**
         * @param {?} msg
         * @return {?}
         */
            function (msg) {
                return this.log(msg, LogLevel.Trace);
            };
        /**
         * @param {?} msg
         * @return {?}
         */
        Logger.prototype.debug = /**
         * @param {?} msg
         * @return {?}
         */
            function (msg) {
                return this.log(msg, LogLevel.Debug);
            };
        /**
         * @param {?} msg
         * @return {?}
         */
        Logger.prototype.info = /**
         * @param {?} msg
         * @return {?}
         */
            function (msg) {
                return this.log(msg, LogLevel.Info);
            };
        /**
         * @param {?} msg
         * @param {?=} error
         * @return {?}
         */
        Logger.prototype.warn = /**
         * @param {?} msg
         * @param {?=} error
         * @return {?}
         */
            function (msg, error) {
                if (error === void 0) {
                    error = null;
                }
                return this.log(msg, LogLevel.Warn, error);
            };
        /**
         * @param {?} msg
         * @param {?=} error
         * @return {?}
         */
        Logger.prototype.error = /**
         * @param {?} msg
         * @param {?=} error
         * @return {?}
         */
            function (msg, error) {
                if (error === void 0) {
                    error = null;
                }
                return this.log(msg, LogLevel.Error, error);
            };
        /**
         * @param {?} msg
         * @param {?=} error
         * @return {?}
         */
        Logger.prototype.fatal = /**
         * @param {?} msg
         * @param {?=} error
         * @return {?}
         */
            function (msg, error) {
                if (error === void 0) {
                    error = null;
                }
                return this.log(msg, LogLevel.Fatal, error);
            };
        /**
         * @return {?}
         */
        Logger.prototype.clear = /**
         * @return {?}
         */
            function () {
                this.logs.length = 0;
            };
        Logger.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        Logger.ctorParameters = function () {
            return [
                { type: CoreConfig }
            ];
        };
        /** @nocollapse */ Logger.ngInjectableDef = i0.defineInjectable({ factory: function Logger_Factory() { return new Logger(i0.inject(CoreConfig)); }, token: Logger, providedIn: "root" });
        return Logger;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @return {?}
     */
    function getByteSize(value) {
        value = value || '';
        // Matches only the 10.. bytes that are non-initial characters in a multi-byte sequence.
        /** @type {?} */
        var match = encodeURIComponent(value).match(/%[89ABab]/g);
        return value.length + (match ? match.length : 0);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var STORAGE_FORMAT_UNITS = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    /** @type {?} */
    var NO_BYTES_FORMATTED = '0 KB';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isDefined(val) {
        return !isType(val, 'undefined');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isValue(val) {
        return isDefined(val) && val !== null && val !== '';
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} numberOfBytes
     * @param {?=} decimalPlaces
     * @param {?=} lowerCaseUnits
     * @return {?}
     */
    function formatByteSize(numberOfBytes, decimalPlaces, lowerCaseUnits) {
        if (lowerCaseUnits === void 0) {
            lowerCaseUnits = false;
        }
        /** @type {?} */
        var len = 0;
        if (!numberOfBytes) {
            return NO_BYTES_FORMATTED;
        }
        while (numberOfBytes >= 1024 && ++len) {
            numberOfBytes = numberOfBytes / 1024;
        }
        if (!isValue(decimalPlaces)) {
            decimalPlaces = numberOfBytes >= 10 || len < 1 ? 0 : 1;
        }
        /** @type {?} */
        var fixedNum = numberOfBytes.toFixed(decimalPlaces);
        /** @type {?} */
        var unit = lowerCaseUnits
            ? STORAGE_FORMAT_UNITS[len].toLowerCase()
            : STORAGE_FORMAT_UNITS[len];
        return fixedNum + " " + unit;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var BaseStorage = /** @class */ (function () {
        function BaseStorage() {
            this.keyPrefix = '';
            this.keySuffix = '';
        }
        /**
         * @param {?} key
         * @return {?}
         */
        BaseStorage.prototype.has = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return Boolean(this.get(key));
            };
        /**
         * Returns the number of bytes for this storage key.
         */
        /**
         * Returns the number of bytes for this storage key.
         * @param {?} key
         * @return {?}
         */
        BaseStorage.prototype.size = /**
         * Returns the number of bytes for this storage key.
         * @param {?} key
         * @return {?}
         */
            function (key) {
                /** @type {?} */
                var value = this.get(key);
                return getByteSize(value) + getByteSize(key);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        BaseStorage.prototype.sizeFormatted = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return formatByteSize(this.size(key));
            };
        /**
         * @param {?} key
         * @return {?}
         */
        BaseStorage.prototype.getObject = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                /** @type {?} */
                var value = this.get(key);
                return value ? JSON.parse(value) : null;
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        BaseStorage.prototype.setObject = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                this.set(key, JSON.stringify(value));
            };
        /**
         * @protected
         * @param {?} key
         * @return {?}
         */
        BaseStorage.prototype.formatKey = /**
         * @protected
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return "" + this.keyPrefix + key + this.keySuffix;
            };
        BaseStorage.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ BaseStorage.ngInjectableDef = i0.defineInjectable({ factory: function BaseStorage_Factory() { return new BaseStorage(); }, token: BaseStorage, providedIn: "root" });
        return BaseStorage;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PersistentStorage = /** @class */ (function (_super) {
        __extends(PersistentStorage, _super);
        function PersistentStorage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(PersistentStorage.prototype, "length", {
            get: /**
             * @return {?}
             */ function () {
                return localStorage.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} key
         * @return {?}
         */
        PersistentStorage.prototype.get = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return localStorage.getItem(this.formatKey(key));
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        PersistentStorage.prototype.set = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                localStorage.setItem(this.formatKey(key), value);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        PersistentStorage.prototype.remove = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                localStorage.removeItem(this.formatKey(key));
            };
        /**
         * @return {?}
         */
        PersistentStorage.prototype.clear = /**
         * @return {?}
         */
            function () {
                localStorage.clear();
            };
        PersistentStorage.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */ PersistentStorage.ngInjectableDef = i0.defineInjectable({ factory: function PersistentStorage_Factory() { return new PersistentStorage(); }, token: PersistentStorage, providedIn: "root" });
        return PersistentStorage;
    }(BaseStorage));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function hasWindow() {
        return typeof window !== 'undefined';
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function getFullUrl() {
        return hasWindow() ? location.href : '';
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?=} search
     * @return {?}
     */
    function getQueryParams(search) {
        /** @type {?} */
        var hashes;
        search = search || getFullUrl();
        if (!search) {
            return {};
        }
        hashes = search.slice(search.indexOf('?') + 1).split('&');
        if (!hashes || !hashes.length || !hashes[0] || hashes.length === 1 && !String(hashes[0]).includes('=')) {
            return {};
        }
        return hashes.reduce(( /**
         * @param {?} params
         * @param {?} hash
         * @return {?}
         */function (params, hash) {
            var _a;
            var _b = __read(hash.split('='), 2), key = _b[0], val = _b[1];
            return Object.assign(params, (_a = {}, _a[key] = decodeURIComponent(val), _a));
        }), {});
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} list
     * @return {?}
     */
    function getLastItem(list) {
        return list[list.length - 1];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} url
     * @return {?}
     */
    function getPostHashRoutePaths(url) {
        /** @type {?} */
        var parts = clean(url).split('#');
        /** @type {?} */
        var hashPart = parts.length > 1
            ? getLastItem(parts)
            : null;
        return hashPart && hashPart !== '/'
            ? hashPart
                .split('/')
                .filter(( /**
         * @param {?} part
         * @return {?}
         */function (part) { return Boolean(part) && !part.includes('='); }))
            : [];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} url
     * @return {?}
     */
    function getFirstHashRoutePath(url) {
        var _a = __read(getPostHashRoutePaths(url), 1), postHashParts = _a[0];
        return postHashParts || null;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isDate(val) {
        return val instanceof Date;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isNotValue(val) {
        return !isValue(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function canNotBeNumber(val) {
        return isNaN(Number(val));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function canBeNumber(val) {
        return !canNotBeNumber(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @return {?}
     */
    function toPrimitiveType(value) {
        if (isNotValue(value)) {
            return value;
        }
        else if (value === 'true' || value === 'false') {
            return Boolean(value);
        }
        else if (canBeNumber(value)) {
            return Number(value);
        }
        else {
            return value;
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @return {?}
     */
    function lowerCaseFirst(value) {
        return String(value).charAt(0).toLowerCase() + value.slice(1);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // TODO: Refactor this method and give it proper names.
    // This was a copy/paste from online - RG.
    /**
     * @param {?} target
     * @param {?} key
     * @param {?} val
     * @return {?}
     */
    function setValue(target, key, val) {
        if (!target) {
            return;
        }
        /** @type {?} */
        var ka = key.split(/\./);
        if (ka.length < 2) {
            target[ka[0]] = val;
        }
        else {
            if (!target[ka[0]]) {
                target[ka[0]] = {};
            }
            target = target[ka.shift()];
            setValue(target, ka.join('.'), val);
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Security related configuration options. These settings are used to drive all
     * security related behaviour throughout the application. The settings can be
     * overridden directly in the code, application module, or from the TDS server.
     */
    var SecurityConfig = /** @class */ (function (_super) {
        __extends(SecurityConfig, _super);
        function SecurityConfig() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.rolesEnabled = true;
            _this.storeToken = true;
            _this.autoSignIn = true;
            _this.authorizationType = 'Bearer';
            _this.tokenEndpoint = 'token';
            _this.signOutEndpoint = 'api/account/signout';
            _this.userInfoEndpoint = 'api/account/userinfo';
            _this.usersEndpoint = 'api/users/{id}';
            _this.rolesEndpoint = 'api/roles/{id}';
            _this.privilegesEndpoint = 'api/privileges/{id}';
            _this.userRolesEndpoint = 'api/users/{userId}/roles/{roleName}';
            _this.rolesPrivilegesEndpoint = 'api/roles/{roleId}/privileges/{privilegeId}';
            _this.tokenStorageKey = '__tss_token';
            _this.tokenInvalidationDateLookup = '__tss_token_invalidate_date';
            _this.tdsTokenInclusionExpression = '/api/';
            _this.withCredentialsInclusionExpression = '(.*?)';
            _this.setWithCredentials = false;
            _this.accessToken = null;
            _this.defaultUserName = null;
            _this.defaultPassword = null;
            _this.roleSplitterExp = '[,|]+';
            _this.tokenBody = ( /**
             * @param {?} userName
             * @param {?} password
             * @return {?}
             */function (userName, password) { return "grant_type=password&username=" + userName + "&password=" + password; });
            return _this;
        }
        SecurityConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ SecurityConfig.ngInjectableDef = i0.defineInjectable({ factory: function SecurityConfig_Factory() { return new SecurityConfig(); }, token: SecurityConfig, providedIn: "root" });
        /**
         * Security related configuration options. These settings are used to drive all
         * security related behaviour throughout the application. The settings can be
         * overridden directly in the code, application module, or from the TDS server.
         */
        SecurityConfig = __decorate([
            AutoConfig('SecurityConfig')
        ], SecurityConfig);
        return SecurityConfig;
    }(ResourceConfig));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isArray(val) {
        return Array.isArray(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isNumber(val) {
        return isType(val, 'number');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RoleManagerService = /** @class */ (function () {
        function RoleManagerService(config) {
            this.config = config;
            this.roles = new Set();
            this.roleSplitterExpr = new RegExp(this.config.roleSplitterExp);
        }
        Object.defineProperty(RoleManagerService.prototype, "enabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.rolesEnabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoleManagerService.prototype, "roleCount", {
            get: /**
             * @return {?}
             */ function () {
                return this.roles.size;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        RoleManagerService.prototype.getRoles = /**
         * @return {?}
         */
            function () {
                return Array.from(this.roles);
            };
        /**
         * @param {?} roles
         * @return {?}
         */
        RoleManagerService.prototype.setRoles = /**
         * @param {?} roles
         * @return {?}
         */
            function (roles) {
                this.clearRoles();
                this.addRoles(roles);
            };
        /**
         * @param {?} roles
         * @return {?}
         */
        RoleManagerService.prototype.addRoles = /**
         * @param {?} roles
         * @return {?}
         */
            function (roles) {
                if (isString(roles) && (( /** @type {?} */(roles))).includes(',')) {
                    roles = this.toArray((( /** @type {?} */(roles))));
                }
                if (isArray(roles)) {
                    (( /** @type {?} */(roles))).forEach(this.addRole, this);
                }
                else {
                    this.addRole(( /** @type {?} */(roles)));
                }
            };
        /**
         * @param {?} role
         * @return {?}
         */
        RoleManagerService.prototype.addRole = /**
         * @param {?} role
         * @return {?}
         */
            function (role) {
                this.roles.add(String(role).trim());
            };
        /**
         * @return {?}
         */
        RoleManagerService.prototype.clearRoles = /**
         * @return {?}
         */
            function () {
                this.roles.clear();
            };
        /**
         * @param {?} role
         * @return {?}
         */
        RoleManagerService.prototype.hasRole = /**
         * @param {?} role
         * @return {?}
         */
            function (role) {
                if (!this.enabled) {
                    return true;
                }
                if (!isValue(role)) {
                    return false;
                }
                return this.hasRoles(String(role));
            };
        /**
         * @param {?} roles
         * @return {?}
         */
        RoleManagerService.prototype.hasRoles = /**
         * @param {?} roles
         * @return {?}
         */
            function (roles) {
                /** @type {?} */
                var splitRoles;
                if (!this.enabled) {
                    return true;
                }
                if (!isValue(roles)) {
                    return false;
                }
                splitRoles = this.toArray(roles);
                return String(roles).includes(',')
                    ? this.hasAllRoles(splitRoles)
                    : this.hasAnyRoles(splitRoles);
            };
        /**
         * @param {?} roles
         * @return {?}
         */
        RoleManagerService.prototype.hasAllRoles = /**
         * @param {?} roles
         * @return {?}
         */
            function (roles) {
                if (!this.enabled) {
                    return true;
                }
                if (!isValue(roles)) {
                    return false;
                }
                /** @type {?} */
                var roleList = this.toStringArray(roles);
                return roleList.every(this.forRealHasRole.bind(this));
            };
        /**
         * @param {?} roles
         * @return {?}
         */
        RoleManagerService.prototype.hasAnyRoles = /**
         * @param {?} roles
         * @return {?}
         */
            function (roles) {
                if (!this.enabled) {
                    return true;
                }
                if (!isValue(roles)) {
                    return false;
                }
                /** @type {?} */
                var roleList = this.toStringArray(roles);
                return roleList.some(this.forRealHasRole.bind(this));
            };
        /**
         * @private
         * @param {?} role
         * @return {?}
         */
        RoleManagerService.prototype.forRealHasRole = /**
         * @private
         * @param {?} role
         * @return {?}
         */
            function (role) {
                return this.roles.has(String(role).trim());
            };
        /**
         * @private
         * @param {?} roles
         * @return {?}
         */
        RoleManagerService.prototype.toStringArray = /**
         * @private
         * @param {?} roles
         * @return {?}
         */
            function (roles) {
                /** @type {?} */
                var rolesList = [];
                if (isString(roles)) {
                    rolesList = this.toArray(( /** @type {?} */(roles)));
                }
                else if (isNumber(roles)) {
                    rolesList.push(String(roles));
                }
                else {
                    rolesList = ( /** @type {?} */(roles));
                }
                return rolesList;
            };
        /**
         * @private
         * @param {?} roles
         * @return {?}
         */
        RoleManagerService.prototype.toArray = /**
         * @private
         * @param {?} roles
         * @return {?}
         */
            function (roles) {
                return String(roles).split(this.roleSplitterExpr);
            };
        RoleManagerService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        RoleManagerService.ctorParameters = function () {
            return [
                { type: SecurityConfig }
            ];
        };
        /** @nocollapse */ RoleManagerService.ngInjectableDef = i0.defineInjectable({ factory: function RoleManagerService_Factory() { return new RoleManagerService(i0.inject(SecurityConfig)); }, token: RoleManagerService, providedIn: "root" });
        return RoleManagerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var SignInState = {
        SignedIn: 0,
        SignedOut: 1,
        SignInFailed: 2,
        SignOutFailed: 3,
    };
    SignInState[SignInState.SignedIn] = 'SignedIn';
    SignInState[SignInState.SignedOut] = 'SignedOut';
    SignInState[SignInState.SignInFailed] = 'SignInFailed';
    SignInState[SignInState.SignOutFailed] = 'SignOutFailed';
    var AuthService = /** @class */ (function () {
        function AuthService(http, roleMgr, config, storage, log) {
            this.http = http;
            this.roleMgr = roleMgr;
            this.config = config;
            this.storage = storage;
            this.log = log;
            this.stateChangeSubject = new rxjs.Subject();
            this.rememberMe = config.storeToken;
            this.stateChange = this.stateChangeSubject.asObservable();
            if (config.autoSignIn && !this.isAuthenticated) {
                this.loadStoredToken();
            }
        }
        /**
         * @param {?} userName
         * @param {?} password
         * @param {?=} rememberMe
         * @return {?}
         */
        AuthService.prototype.signIn = /**
         * @param {?} userName
         * @param {?} password
         * @param {?=} rememberMe
         * @return {?}
         */
            function (userName, password, rememberMe) {
                if (rememberMe === void 0) {
                    rememberMe = this.rememberMe;
                }
                /** @type {?} */
                var observable = this.http.post(this.config.serviceUrl + "/" + this.config.tokenEndpoint, this.config.tokenBody(userName, password))
                    .pipe(operators.publishReplay(1));
                this.rememberMe = rememberMe;
                observable.subscribe(this.onSignedIn.bind(this), this.onSignInFailed.bind(this));
                return observable;
            };
        /**
         * @return {?}
         */
        AuthService.prototype.signOut = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var signOutUrl = this.config.serviceUrl + "/" + this.config.signOutEndpoint;
                if (this.isFederatedAccount) {
                    this.log.info("Signing out. Authentication Type: STS. Forwarded to: " + signOutUrl);
                    this.onSignedOut();
                    if (typeof location !== 'undefined') {
                        location.href = signOutUrl;
                    }
                }
                else {
                    // The only reason this "Account" method is abstracted here is because there is additional stuff that
                    // has to happen when you sign out - like removing the user information cache, etc.
                    /** @type {?} */
                    var obserable = this.http.get(signOutUrl)
                        .pipe(operators.publishReplay(1));
                    obserable
                        .subscribe(this.onSignedOut.bind(this), this.onSignedOutFailed.bind(this));
                    return obserable;
                }
            };
        /**
         * @return {?}
         */
        AuthService.prototype.getUserInfo = /**
         * @return {?}
         */
            function () {
                return this.http.get(this.config.serviceUrl + "/" + this.config.userInfoEndpoint);
            };
        /**
         * @return {?}
         */
        AuthService.prototype.getToken = /**
         * @return {?}
         */
            function () {
                return this.isAuthenticated
                    ? this.account.access_token || null
                    : null;
            };
        /**
         * @return {?}
         */
        AuthService.prototype.loadStoredToken = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var token = this.getLocalToken();
                /** @type {?} */
                var loaded = false;
                if (token && token['.expires']) {
                    /** @type {?} */
                    var expiresDate = token['.expires'];
                    if (expiresDate > new Date()) {
                        this.onSignedIn(token, true);
                        loaded = true;
                    }
                }
                return loaded;
            };
        /**
         * @param {?} account
         * @param {?=} skipLocalStorage
         * @return {?}
         */
        AuthService.prototype.onSignedIn = /**
         * @param {?} account
         * @param {?=} skipLocalStorage
         * @return {?}
         */
            function (account, skipLocalStorage) {
                if (skipLocalStorage === void 0) {
                    skipLocalStorage = false;
                }
                this.account = account;
                this.isAuthenticated = true;
                this.isDomainAccount = (account.foundContextType || '').toLowerCase() === 'domain';
                this.isFederatedAccount = (account.authenticationType || '').toLowerCase() === 'federation';
                // Note, we are exposing the access token through the security config because the token intercepter
                // can not use this auth service - it will result in a cyclic dpendency injection error.
                // See Angular issue: https://github.com/angular/angular/issues/18224
                // TODO: Deprecate "accessToken" property on "SecurityConfig" once this is resolved - RG.
                this.config.accessToken = account.access_token;
                this.roleMgr.setRoles(account.privileges || account.roles);
                if (!skipLocalStorage && this.rememberMe) {
                    account.lastSignIn = new Date();
                    this.setLocalToken(account);
                }
                this.log.debug('User signed in succesfully');
                this.stateChangeSubject.next(SignInState.SignedIn);
            };
        /**
         * @return {?}
         */
        AuthService.prototype.onSignedOut = /**
         * @return {?}
         */
            function () {
                // We set the "authenticated" flag state to false so that anyone watching this can see the new state and
                // get rid of the account information that was cached, because it is no longer applicable.
                this.isAuthenticated = false;
                this.isDomainAccount = false;
                this.isFederatedAccount = false;
                this.account = null;
                this.roleMgr.clearRoles();
                this.setLocalToken(null);
                this.log.debug('User signed out succesfully');
                this.stateChangeSubject.next(SignInState.SignedOut);
            };
        /**
         * @private
         * @param {?} err
         * @return {?}
         */
        AuthService.prototype.onSignInFailed = /**
         * @private
         * @param {?} err
         * @return {?}
         */
            function (err) {
                this.log.error('Failed to sign in', err);
                this.stateChangeSubject.next(SignInState.SignInFailed);
            };
        /**
         * @private
         * @param {?} err
         * @return {?}
         */
        AuthService.prototype.onSignedOutFailed = /**
         * @private
         * @param {?} err
         * @return {?}
         */
            function (err) {
                this.log.error('Failed to sign out', err);
                this.stateChangeSubject.next(SignInState.SignOutFailed);
            };
        /**
         * @private
         * @return {?}
         */
        AuthService.prototype.getLocalToken = /**
         * @private
         * @return {?}
         */
            function () {
                try {
                    /** @type {?} */
                    var token = this.storage.getObject(this.config.tokenStorageKey);
                    if (token && token.lastSignIn && isString(token.lastSignIn)) {
                        token.lastSignIn = new Date(token.lastSignIn);
                    }
                    if (token && token['.expires'] && isString(token['.expires'])) {
                        token['.expires'] = new Date(Date.parse(token['.expires']));
                    }
                    return token;
                }
                finally {
                    // We don't need to do anything bbecause this is not critical path.
                }
            };
        /**
         * @private
         * @param {?} token
         * @return {?}
         */
        AuthService.prototype.setLocalToken = /**
         * @private
         * @param {?} token
         * @return {?}
         */
            function (token) {
                try {
                    if (token) {
                        this.storage.setObject(this.config.tokenStorageKey, token);
                    }
                    else {
                        this.storage.remove(this.config.tokenStorageKey);
                    }
                }
                finally {
                    // We don't need to do anything as this is not a core workflow.
                }
            };
        AuthService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        AuthService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: RoleManagerService },
                { type: SecurityConfig },
                { type: PersistentStorage },
                { type: Logger }
            ];
        };
        /** @nocollapse */ AuthService.ngInjectableDef = i0.defineInjectable({ factory: function AuthService_Factory() { return new AuthService(i0.inject(i1$1.HttpClient), i0.inject(RoleManagerService), i0.inject(SecurityConfig), i0.inject(PersistentStorage), i0.inject(Logger)); }, token: AuthService, providedIn: "root" });
        return AuthService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     * @template T
     */
    var /**
     * @abstract
     * @template T
     */ BaseResourceService = /** @class */ (function (_super) {
        __extends(BaseResourceService, _super);
        function BaseResourceService(http, paramsOrUrl) {
            var _this = _super.call(this, http, paramsOrUrl) || this;
            _this.http = http;
            return _this;
        }
        /**
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        BaseResourceService.prototype.query = /**
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (routeTokens, params) {
                /** @type {?} */
                var url = this.getUrl(this.config.queryEndpoint, routeTokens);
                return this.http.get(url, { params: params });
            };
        /**
         * @param {?} id
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        BaseResourceService.prototype.get = /**
         * @param {?} id
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (id, routeTokens, params) {
                /** @type {?} */
                var url = this.getUrlWithId(id, this.config.getEndpoint, routeTokens);
                return this.http.get(url, { params: params });
            };
        /**
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        BaseResourceService.prototype.create = /**
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (entity, routeTokens, params) {
                /** @type {?} */
                var url = this.getUrl(this.config.createEndpoint, routeTokens);
                return this.http.post(url, entity, { params: params });
            };
        /**
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        BaseResourceService.prototype.update = /**
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (entity, routeTokens, params) {
                /** @type {?} */
                var url = this.getUrlWithEntity(entity, this.config.updateEndpoint, routeTokens);
                return this.http.put(url, entity, { params: params });
            };
        /**
         * @param {?} id
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        BaseResourceService.prototype.delete = /**
         * @param {?} id
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (id, routeTokens, params) {
                /** @type {?} */
                var url = this.getUrlWithId(id, this.config.deleteEndpoint, routeTokens);
                return this.http.delete(url, { params: params });
            };
        return BaseResourceService;
    }(BaseEmptyResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AppProfileService = /** @class */ (function (_super) {
        __extends(AppProfileService, _super);
        function AppProfileService(http, config) {
            var _this = _super.call(this, http, {
                url: join(config.serviceUrl, config.appProfileEndpoint),
                defaultRouteTokens: {
                    appId: config.appId
                }
            }) || this;
            _this.http = http;
            return _this;
        }
        AppProfileService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        AppProfileService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: AppConfig }
            ];
        };
        /** @nocollapse */ AppProfileService.ngInjectableDef = i0.defineInjectable({ factory: function AppProfileService_Factory() { return new AppProfileService(i0.inject(i1$1.HttpClient), i0.inject(AppConfig)); }, token: AppProfileService, providedIn: "root" });
        return AppProfileService;
    }(BaseResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Application initialization service that is responsible for bootstrapping
     * the application.
     */
    var AppInitializerService = /** @class */ (function () {
        function AppInitializerService(router, auth, appProfiles, log, config, storage, securityConfig, roleMgr, injector) {
            var _this = this;
            this.router = router;
            this.auth = auth;
            this.appProfiles = appProfiles;
            this.log = log;
            this.config = config;
            this.storage = storage;
            this.securityConfig = securityConfig;
            this.roleMgr = roleMgr;
            this.injector = injector;
            this.ready = false;
            this.loading = false;
            this.moduleConfigInstances = new Map();
            this.queryParameters = getQueryParams();
            this.onReady = new Promise(( /**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */function (resolve, reject) {
                _this.resolveFn = resolve;
                _this.rejectFn = reject;
            }));
        }
        /**
         * Initializes/bootstraps a standard TSS application.
         */
        /**
         * Initializes/bootstraps a standard TSS application.
         * @return {?}
         */
        AppInitializerService.prototype.initialize = /**
         * Initializes/bootstraps a standard TSS application.
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var appId = this.config.appId;
                var _a = __read(this.router.url.split('/'), 1), firstRoutePath = _a[0];
                /** @type {?} */
                var profileId = this.queryParameters.profileId
                    || firstRoutePath
                    || getFirstHashRoutePath(getFullUrl())
                    || this.config.defaultProfileId;
                // We override module configurations here because the user may be trying to debug the session. The
                // override has to happen again at the end of the process to override any settings that may have
                // been set through the app initialization process.
                this.overrideModuleConfigurationsFromQueryParams();
                this.log.debug("Initializing application with profile ID: " + profileId);
                // We need to try and read any stored security token before we make
                // a request to get profile info, so that the request is authenticated.
                this.auth.loadStoredToken();
                this.populateModuleConfigInstances();
                if (!this.config.queryProfile || !this.config.hasServiceUrl) {
                    this.config.profile = {
                        name: '',
                        appId: appId,
                        id: profileId,
                    };
                    this.log.debug(this.config.hasServiceUrl
                        ? "Profile query skipped due to configuration option"
                        : "No service URL configured, can't retrieve profile details - skipping profile retrieval");
                    this.overrideModuleConfigurationsFromQueryParams();
                    this.ready = true;
                    this.resolveFn(this.config.profile);
                }
                else {
                    this.loading = true;
                    // We need to try and read any stored security token before we make
                    // a request to get profile info, so that the request is authenticated.
                    this.queryProfile(profileId)
                        .then(( /**
                 * @param {?} profile
                 * @return {?}
                 */function (profile) { return _this.resolveFn(profile); }))
                        .catch(( /**
                 * @param {?} err
                 * @return {?}
                 */function (err) {
                        if (_this.config.continueOnAppBootstrapError) {
                            _this.resolveFn(_this.config.profile);
                        }
                        else {
                            _this.rejectFn(err);
                        }
                    }));
                }
            };
        /**
         * @private
         * @param {?} profileId
         * @return {?}
         */
        AppInitializerService.prototype.queryProfile = /**
         * @private
         * @param {?} profileId
         * @return {?}
         */
            function (profileId) {
                var _this = this;
                return new Promise(( /**
                 * @param {?} resolve
                 * @param {?} reject
                 * @return {?}
                 */function (resolve, reject) {
                    _this.appProfiles.get(profileId)
                        .subscribe(( /**
                 * @param {?} profile
                 * @return {?}
                 */function (profile) {
                        if (!profile) {
                            return reject("No profile found with ID '" + profileId + "'");
                        }
                        _this.config.profileId = profile.id;
                        _this.config.profile = profile;
                        _this.checkTokenInvalidationDate();
                        _this.applyModuleConfigurations();
                        _this.overrideModuleConfigurationsFromQueryParams();
                        _this.retrieveUserAccount()
                            .then(( /**
                     * @return {?}
                     */function () {
                            _this.configureRoleManager();
                            _this.ready = true;
                            _this.loading = false;
                            resolve(profile);
                        }))
                            .catch(( /**
                     * @param {?} err
                     * @return {?}
                     */function (err) {
                            _this.loading = false;
                            reject(err);
                        }));
                    }), ( /**
                     * @param {?} err
                     * @return {?}
                     */function (err) {
                        _this.loading = false;
                        _this.log.error("Failed to retrieve application profile with app ID '" + _this.config.appId + "' and ID '" + profileId + "'");
                        reject(err);
                    }));
                }));
            };
        /**
         * Gets the date of the cached "invalidation" date.
         * The invalidation date is used to let the server force users to re-authenticate.
         */
        /**
         * Gets the date of the cached "invalidation" date.
         * The invalidation date is used to let the server force users to re-authenticate.
         * @private
         * @return {?}
         */
        AppInitializerService.prototype.getCachedTokenInvalidationDate = /**
         * Gets the date of the cached "invalidation" date.
         * The invalidation date is used to let the server force users to re-authenticate.
         * @private
         * @return {?}
         */
            function () {
                return new Date(this.storage.get(this.securityConfig.tokenInvalidationDateLookup));
            };
        /**
         * Caches the "invalidation" date.
         * The invalidation date is used to let the server force users to re-authenticate.
         */
        /**
         * Caches the "invalidation" date.
         * The invalidation date is used to let the server force users to re-authenticate.
         * @private
         * @param {?=} setDate
         * @return {?}
         */
        AppInitializerService.prototype.setCachedTokenExpireDate = /**
         * Caches the "invalidation" date.
         * The invalidation date is used to let the server force users to re-authenticate.
         * @private
         * @param {?=} setDate
         * @return {?}
         */
            function (setDate) {
                this.log.debug("Setting cached token invalidation date: " + setDate);
                if (setDate) {
                    this.log.debug("Setting token invalidation date to: " + setDate);
                    this.storage.set(this.securityConfig.tokenInvalidationDateLookup, setDate);
                }
                else {
                    this.storage.remove(this.securityConfig.tokenInvalidationDateLookup);
                }
            };
        /**
         * Compares the cached token validation data with the invalidation date from the server.
         * If the invalidation date from the server is new than the cached date, then the user
         * must be forcibly signed out.
         */
        /**
         * Compares the cached token validation data with the invalidation date from the server.
         * If the invalidation date from the server is new than the cached date, then the user
         * must be forcibly signed out.
         * @private
         * @return {?}
         */
        AppInitializerService.prototype.checkTokenInvalidationDate = /**
         * Compares the cached token validation data with the invalidation date from the server.
         * If the invalidation date from the server is new than the cached date, then the user
         * must be forcibly signed out.
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var tokenExpireDate;
                /** @type {?} */
                var siteInfo = this.config.profile && this.config.profile.app && this.config.profile.app.siteInfo
                    ? this.config.profile.app.siteInfo
                    : null;
                if (siteInfo && siteInfo[AppInitializerService.tokenExpireDateKey]) {
                    /** @type {?} */
                    var lastTokenInvalidateDate = this.getCachedTokenInvalidationDate();
                    tokenExpireDate = new Date(siteInfo[AppInitializerService.tokenExpireDateKey]);
                    // Note, we are setting milliseconds to 0 because we don't care about that level of accuracy.
                    // Also, the "setMilliseconds" method returns the "timestamp" so we can just compare those two results.
                    /** @type {?} */
                    var lastTokenValidationDatesMatch = isDate(lastTokenInvalidateDate) && isDate(tokenExpireDate)
                        ? lastTokenInvalidateDate.setMilliseconds(0) === tokenExpireDate.setMilliseconds(0)
                        : lastTokenInvalidateDate === tokenExpireDate;
                    if (this.auth.account && this.auth.account.lastSignIn < tokenExpireDate && !lastTokenValidationDatesMatch) {
                        this.log.info('Signing out user due to token invalidation date from security configuration');
                        this.auth.onSignedOut();
                    }
                    else if (this.auth.account) {
                        this.log.debug('User has been authenticated after the token invalidation date');
                    }
                    if (tokenExpireDate) {
                        this.setCachedTokenExpireDate(tokenExpireDate);
                    }
                }
            };
        /**
         * Retrieves the user account if the user is already signed in, logs the user out if
         * the token is expired, or refreshes the user account information - depending on
         * the configured authentication provider.
         */
        /**
         * Retrieves the user account if the user is already signed in, logs the user out if
         * the token is expired, or refreshes the user account information - depending on
         * the configured authentication provider.
         * @private
         * @return {?}
         */
        AppInitializerService.prototype.retrieveUserAccount = /**
         * Retrieves the user account if the user is already signed in, logs the user out if
         * the token is expired, or refreshes the user account information - depending on
         * the configured authentication provider.
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                return new Promise(( /**
                 * @param {?} resolve
                 * @param {?} reject
                 * @return {?}
                 */function (resolve, reject) {
                    try {
                        /** @type {?} */
                        var queryingInfo = false;
                        /** @type {?} */
                        var app_1 = _this.config.profile && _this.config.profile.app
                            ? _this.config.profile.app : null;
                        // If the local auth status says that no one is logged in, but the service is recognizing that someone is
                        // logged in, then this means that authentication is happening through windows via Active Directory or some
                        // other means. We need to get the user info so we can set the app "state" as "logged in".
                        if (app_1 && app_1.security && !_this.auth.isAuthenticated && app_1.security.isAuthenticated) {
                            _this.log.debug('Retrieving additional user info do to authentication state');
                            queryingInfo = true;
                            _this.auth.getUserInfo().subscribe(( /**
                             * @param {?} info
                             * @return {?}
                             */function (info) {
                                /** @type {?} */
                                var expiresDate = new Date();
                                expiresDate.setDate(expiresDate.getDate() + app_1.security.accessTokenExpireDays);
                                _this.auth.onSignedIn(Object.assign({ '.expires': expiresDate }, info));
                                resolve(info);
                            }), ( /**
                             * @param {?} err
                             * @return {?}
                             */function (err) {
                                reject(err);
                            }));
                        }
                        else if (_this.auth.isAuthenticated && app_1.security && !app_1.security.isAuthenticated) {
                            _this.log.debug("Signing out user do to out of sync authentication state");
                            // Sign out/clear the auth cache because the server says they don't know who this is, but
                            // the client side code thinks it knows who it is.
                            _this.auth.onSignedOut();
                        }
                        if (!queryingInfo) {
                            _this.log.debug("No request made for additional user account info");
                            resolve(_this.auth.account);
                        }
                    }
                    catch (e) {
                        _this.log.error('Failed to do pre-verification of user on app load. {0}', e);
                        reject(e);
                    }
                }));
            };
        /**
         * Set module configuration properties based on overrides from an object.
         * This object can come from multiple places - such as the server or query params.
         * See: the "applyModuleConfigurations" and "overrideModuleConfigurations" methods.
         */
        /**
         * Set module configuration properties based on overrides from an object.
         * This object can come from multiple places - such as the server or query params.
         * See: the "applyModuleConfigurations" and "overrideModuleConfigurations" methods.
         * @private
         * @param {?} sourceMapping
         * @return {?}
         */
        AppInitializerService.prototype.applyModuleConfigurationsFromObject = /**
         * Set module configuration properties based on overrides from an object.
         * This object can come from multiple places - such as the server or query params.
         * See: the "applyModuleConfigurations" and "overrideModuleConfigurations" methods.
         * @private
         * @param {?} sourceMapping
         * @return {?}
         */
            function (sourceMapping) {
                var _this = this;
                sourceMapping = sourceMapping || {};
                this.moduleConfigInstances
                    .forEach(( /**
             * @param {?} config
             * @return {?}
             */function (config) {
                    /** @type {?} */
                    var moduleConfigName = config.config.className;
                    /** @type {?} */
                    var configInstance = config.instance;
                    Object.keys(sourceMapping)
                        .forEach(( /**
                 * @param {?} key
                 * @return {?}
                 */function (key) {
                        /** @type {?} */
                        var value = toPrimitiveType(sourceMapping[key]);
                        /** @type {?} */
                        var modulePrefix = lowerCaseFirst(moduleConfigName + '.');
                        /** @type {?} */
                        var rootKey = key.replace(modulePrefix, '');
                        if (isValue(value) && key.toLowerCase().startsWith(modulePrefix.toLowerCase())) {
                            // A config object has properties in our siteInfo object.
                            _this.log.debug("Setting " + moduleConfigName + " property '" + rootKey + "' to " + value);
                            setValue(configInstance, rootKey, value);
                        }
                    }));
                }));
            };
        /**
         * Set module configuration properties based on overrides from the server.
         * This functionality lets us dynamically override client side configuration
         * through the use of "App Settings" from the server.
         */
        /**
         * Set module configuration properties based on overrides from the server.
         * This functionality lets us dynamically override client side configuration
         * through the use of "App Settings" from the server.
         * @private
         * @return {?}
         */
        AppInitializerService.prototype.applyModuleConfigurations = /**
         * Set module configuration properties based on overrides from the server.
         * This functionality lets us dynamically override client side configuration
         * through the use of "App Settings" from the server.
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var profile = this.config.profile;
                if (!profile || !profile.app || !profile.app.siteInfo) {
                    return;
                }
                this.applyModuleConfigurationsFromObject(profile.app.siteInfo);
            };
        /**
         * Set module configuration properties based on overrides from the URL query parameters.
         * This functionality lets us dynamically override client side and server side configurations
         * by passing explicit settings through query parameters. A good use case for this is to pass
         * "coreConfig.logLevel=1" as a query parameter in production to debug an issue in a production
         * environment.
         */
        /**
         * Set module configuration properties based on overrides from the URL query parameters.
         * This functionality lets us dynamically override client side and server side configurations
         * by passing explicit settings through query parameters. A good use case for this is to pass
         * "coreConfig.logLevel=1" as a query parameter in production to debug an issue in a production
         * environment.
         * @private
         * @return {?}
         */
        AppInitializerService.prototype.overrideModuleConfigurationsFromQueryParams = /**
         * Set module configuration properties based on overrides from the URL query parameters.
         * This functionality lets us dynamically override client side and server side configurations
         * by passing explicit settings through query parameters. A good use case for this is to pass
         * "coreConfig.logLevel=1" as a query parameter in production to debug an issue in a production
         * environment.
         * @private
         * @return {?}
         */
            function () {
                if (this.config.allowQueryParamInjections) {
                    this.applyModuleConfigurationsFromObject(this.queryParameters);
                }
            };
        /**
         * Instantiates instances of each configured module configuration object. Properties of
         * these module config instances will later be set based on server-side overides.
         */
        /**
         * Instantiates instances of each configured module configuration object. Properties of
         * these module config instances will later be set based on server-side overides.
         * @private
         * @return {?}
         */
        AppInitializerService.prototype.populateModuleConfigInstances = /**
         * Instantiates instances of each configured module configuration object. Properties of
         * these module config instances will later be set based on server-side overides.
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                CoreConfig.moduleConfigs
                    .forEach(( /**
             * @param {?} moduleAutoConfig
             * @return {?}
             */function (moduleAutoConfig) {
                    try {
                        // Reason: https://github.com/angular/angular/issues/22063
                        // tslint:disable-next-line
                        /** @type {?} */
                        var configInstance = _this.injector.get(moduleAutoConfig.injectorToken);
                        _this.moduleConfigInstances.set(moduleAutoConfig.injectorToken, {
                            instance: configInstance,
                            config: moduleAutoConfig
                        });
                        _this.log.debug("Created module configuration instance for: " + moduleAutoConfig.className);
                        if ('serviceUrl' in configInstance || 'hasServiceUrl' in configInstance) {
                            configInstance.serviceUrl = _this.config.serviceUrl;
                        }
                    }
                    catch (err) {
                        _this.log.error("Failed to get module config: " + moduleAutoConfig.className, err);
                    }
                }));
            };
        /**
         * Updates security options based on information retrieved form the application profile.
         * For example, security may be enabled or disabled, guest roles will be set, etc.
         */
        /**
         * Updates security options based on information retrieved form the application profile.
         * For example, security may be enabled or disabled, guest roles will be set, etc.
         * @private
         * @return {?}
         */
        AppInitializerService.prototype.configureRoleManager = /**
         * Updates security options based on information retrieved form the application profile.
         * For example, security may be enabled or disabled, guest roles will be set, etc.
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var security = this.config.profile && this.config.profile.app && this.config.profile.app.security
                    ? this.config.profile.app.security : null;
                if (!security) {
                    return;
                }
                // We want to explicitly
                if (security.hasOwnProperty('enabled')) {
                    this.securityConfig.rolesEnabled = !!security.enabled;
                }
                if (!this.roleMgr.enabled) {
                    this.log.warn('Security is disabled');
                }
                security.guestPrivileges = security.guestPrivileges || [];
                this.roleMgr.addRoles(security.guestPrivileges);
                this.log.info("Configured default roles (guest roles) - total of " + security.guestPrivileges.length);
                this.log.info("User has a total of " + this.roleMgr.roleCount + " roles assigned to them");
            };
        AppInitializerService.tokenExpireDateKey = 'token-expire-date';
        AppInitializerService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        AppInitializerService.ctorParameters = function () {
            return [
                { type: i1.Router },
                { type: AuthService },
                { type: AppProfileService },
                { type: Logger },
                { type: AppConfig },
                { type: PersistentStorage },
                { type: SecurityConfig },
                { type: RoleManagerService },
                { type: i0.Injector }
            ];
        };
        /** @nocollapse */ AppInitializerService.ngInjectableDef = i0.defineInjectable({ factory: function AppInitializerService_Factory() { return new AppInitializerService(i0.inject(i1.Router), i0.inject(AuthService), i0.inject(AppProfileService), i0.inject(Logger), i0.inject(AppConfig), i0.inject(PersistentStorage), i0.inject(SecurityConfig), i0.inject(RoleManagerService), i0.inject(i0.INJECTOR)); }, token: AppInitializerService, providedIn: "root" });
        return AppInitializerService;
    }());
    /**
     * Application initialization factory that provides a hook into
     * the Angular bootstrapping process.
     * @param {?} injector
     * @return {?}
     */
    function AppInitializerFactory(injector) {
        return ( /**
         * @return {?}
         */function () {
            /** @type {?} */
            var initializer = injector.get(AppInitializerService);
            initializer.initialize();
            return initializer.onReady;
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ALL_APPS_QUERY_ID = 'all';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var KeysPipe = /** @class */ (function () {
        function KeysPipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        KeysPipe.prototype.transform = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var keys = [];
                Object.keys(value)
                    .forEach(( /**
             * @param {?} key
             * @return {?}
             */function (key) { return keys.push({ key: key, value: value[key] }); }));
                return keys;
            };
        KeysPipe.decorators = [
            { type: i0.Pipe, args: [{ name: 'keys' },] }
        ];
        return KeysPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FileSizePipe = /** @class */ (function () {
        function FileSizePipe() {
        }
        /**
         * @param {?=} bytes
         * @return {?}
         */
        FileSizePipe.prototype.transform = /**
         * @param {?=} bytes
         * @return {?}
         */
            function (bytes) {
                if (bytes === void 0) {
                    bytes = 0;
                }
                return formatByteSize(bytes);
            };
        FileSizePipe.decorators = [
            { type: i0.Pipe, args: [{ name: 'fileSize' },] }
        ];
        return FileSizePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var STANDARDIZED_QUERY_DATE_FORMAT = "timestamp '{date}'";
    /** @type {?} */
    var ORACLE_DATE_FORMAT = "TO_DATE('{date}','YYYY-MM-DD HH24:MI:SS')";
    /** @type {?} */
    var DEFAULT_DATE_FORMAT = 'yyyy-MM-dd HH:mm:ss';
    /** @type {?} */
    var HOURS_PER_DAY = 24;
    /** @type {?} */
    var MINUTES_PER_HOUR = 60;
    /** @type {?} */
    var SECONDS_PER_MINUTE = 60;
    /** @type {?} */
    var MILLISECONDS_PER_SECOND = 1000;
    /** @type {?} */
    var MILLISECONDS_PER_MINUTE = 60000;
    /** @type {?} */
    var MILLISECONDS_PER_HOUR = 3600000;
    /** @type {?} */
    var MILLISECONDS_PER_DAY = 86400000;
    /** @type {?} */
    var READABLE_TIME_SUFFIX_MAP = {
        ms: 'ms',
        msDecimalPlaces: 0,
        sec: 'sec',
        secDecimalPlaces: 0,
        min: 'min',
        minDecimalPlaces: 2,
        hr: 'hr',
        hrDecimalPlaces: 2,
        days: 'days',
        daysDecimalPlaces: 2,
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @param {?} unitOfTime
     * @return {?}
     */
    function toMilliseconds(value, unitOfTime) {
        /** @type {?} */
        var conversionFactor;
        if (unitOfTime === 'milliseconds') {
            conversionFactor = 1;
        }
        else if (unitOfTime === 'seconds') {
            conversionFactor = MILLISECONDS_PER_SECOND;
        }
        else if (unitOfTime === 'minutes') {
            conversionFactor = MILLISECONDS_PER_MINUTE;
        }
        else if (unitOfTime === 'hours') {
            conversionFactor = MILLISECONDS_PER_HOUR;
        }
        else if (unitOfTime === 'days') {
            conversionFactor = MILLISECONDS_PER_DAY;
        }
        else {
            throw new Error("Unsuported unit of time supplied: '" + unitOfTime + "'");
        }
        return (value || 0) * conversionFactor;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} milliseconds
     * @return {?}
     */
    function millisecondsToSeconds(milliseconds) {
        return milliseconds / MILLISECONDS_PER_SECOND;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} milliseconds
     * @return {?}
     */
    function millisecondsToMinutes(milliseconds) {
        return milliseconds / MILLISECONDS_PER_MINUTE;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} milliseconds
     * @return {?}
     */
    function millisecondsToHours(milliseconds) {
        return milliseconds / MILLISECONDS_PER_HOUR;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} milliseconds
     * @return {?}
     */
    function millisecondsToDays(milliseconds) {
        return milliseconds / MILLISECONDS_PER_DAY;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} milliseconds
     * @param {?=} suffixMap
     * @return {?}
     */
    function toReadableTime(milliseconds, suffixMap) {
        if (suffixMap === void 0) {
            suffixMap = {};
        }
        // TODO: Get rid of magic numbers below - RG.
        /** @type {?} */
        var formatAsMilliseconds = milliseconds < MILLISECONDS_PER_SECOND;
        /** @type {?} */
        var formatAsSeconds = milliseconds < (MILLISECONDS_PER_MINUTE - 1);
        /** @type {?} */
        var formatAsMinutes = milliseconds < (MILLISECONDS_PER_HOUR - 299);
        /** @type {?} */
        var formatAsHours = milliseconds < (MILLISECONDS_PER_DAY - 18000);
        /** @type {?} */
        var value = milliseconds;
        /** @type {?} */
        var unit;
        /** @type {?} */
        var decimalPlaces;
        suffixMap = suffixMap
            ? Object.assign({}, READABLE_TIME_SUFFIX_MAP, suffixMap)
            : READABLE_TIME_SUFFIX_MAP;
        // We assume the milliseconds was passed in.
        if (formatAsMilliseconds) {
            // The time should be shown in milliseconds.
            unit = suffixMap.ms;
            value = milliseconds;
            decimalPlaces = suffixMap.msDecimalPlaces;
        }
        else if (formatAsSeconds) {
            // The time should be shown in seconds.
            /** @type {?} */
            var seconds = millisecondsToSeconds(milliseconds);
            unit = suffixMap.sec;
            value = seconds;
            decimalPlaces = suffixMap.secDecimalPlaces;
        }
        else if (formatAsMinutes) {
            // The time should be shown in in minutes.
            /** @type {?} */
            var minutes = millisecondsToMinutes(milliseconds);
            unit = suffixMap.min;
            value = minutes;
            decimalPlaces = suffixMap.minDecimalPlaces;
        }
        else if (formatAsHours) {
            // The time should be shown in hours.
            /** @type {?} */
            var hours = millisecondsToHours(milliseconds);
            unit = suffixMap.hr;
            value = hours;
            decimalPlaces = suffixMap.hrDecimalPlaces;
        }
        else {
            // The time should be shown in days.
            /** @type {?} */
            var days = millisecondsToDays(milliseconds);
            unit = suffixMap.days;
            value = days;
            decimalPlaces = suffixMap.daysDecimalPlaces;
        }
        /** @type {?} */
        var numberWithStrippedZeros = Number(value.toFixed(decimalPlaces));
        return numberWithStrippedZeros + " " + unit;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ReadableTimePipe = /** @class */ (function () {
        function ReadableTimePipe() {
        }
        /**
         * @param {?} time
         * @param {?=} unit
         * @return {?}
         */
        ReadableTimePipe.prototype.transform = /**
         * @param {?} time
         * @param {?=} unit
         * @return {?}
         */
            function (time, unit) {
                if (unit === void 0) {
                    unit = 'milliseconds';
                }
                /** @type {?} */
                var millis = toMilliseconds(time, unit);
                return toReadableTime(millis);
            };
        ReadableTimePipe.decorators = [
            { type: i0.Pipe, args: [{ name: 'readableTime' },] }
        ];
        return ReadableTimePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SafeUrlPipe = /** @class */ (function () {
        function SafeUrlPipe(sanitizer) {
            this.sanitizer = sanitizer;
        }
        /**
         * @param {?} url
         * @return {?}
         */
        SafeUrlPipe.prototype.transform = /**
         * @param {?} url
         * @return {?}
         */
            function (url) {
                return this.sanitizer.bypassSecurityTrustResourceUrl(url);
            };
        SafeUrlPipe.decorators = [
            { type: i0.Pipe, args: [{ name: 'safeUrl' },] }
        ];
        /** @nocollapse */
        SafeUrlPipe.ctorParameters = function () {
            return [
                { type: platformBrowser.DomSanitizer }
            ];
        };
        return SafeUrlPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssCoreModule = /** @class */ (function () {
        function TssCoreModule() {
        }
        TssCoreModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [],
                        declarations: [
                            FileSizePipe,
                            KeysPipe,
                            ReadableTimePipe,
                            SafeUrlPipe,
                        ],
                        exports: [
                            FileSizePipe,
                            KeysPipe,
                            ReadableTimePipe,
                            SafeUrlPipe
                        ],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssCoreModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssGeometryModule = /** @class */ (function () {
        function TssGeometryModule() {
        }
        TssGeometryModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            TssCoreModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssGeometryModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssDataSourceModule = /** @class */ (function () {
        function TssDataSourceModule() {
        }
        TssDataSourceModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            TssCoreModule,
                            i1$1.HttpClientModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssDataSourceModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssEsriModule = /** @class */ (function () {
        function TssEsriModule() {
        }
        TssEsriModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            TssCoreModule,
                            TssDataSourceModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssEsriModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var LAYER_RENDER_TYPES = [
        { alias: 'Single Value', renderType: 'simple', description: 'Displays a single symbology, regardless of values' },
        { alias: 'Unique Value', renderType: 'uniqueValue', description: 'Displays different symbologies based on a unique value' },
        { alias: 'Class Break', renderType: 'classBreaks', description: 'Displays different symbologies based on a classification of values' },
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LayerRendererTypePipe = /** @class */ (function () {
        function LayerRendererTypePipe() {
        }
        /**
         * @param {?} input
         * @return {?}
         */
        LayerRendererTypePipe.prototype.transform = /**
         * @param {?} input
         * @return {?}
         */
            function (input) {
                /** @type {?} */
                var renderType = isString(input)
                    ? ( /** @type {?} */(input))
                    : (( /** @type {?} */(input))).type;
                /** @type {?} */
                var definition = LAYER_RENDER_TYPES
                    .find(( /**
             * @param {?} t
             * @return {?}
             */function (t) { return t.renderType === renderType; }));
                return definition.alias;
            };
        LayerRendererTypePipe.decorators = [
            { type: i0.Pipe, args: [{ name: 'layerRendererType' },] }
        ];
        return LayerRendererTypePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssMapsModule = /** @class */ (function () {
        function TssMapsModule() {
        }
        TssMapsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            TssCoreModule,
                        ],
                        declarations: [
                            LayerRendererTypePipe
                        ],
                        exports: [
                            LayerRendererTypePipe
                        ],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssMapsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssLrsModule = /** @class */ (function () {
        function TssLrsModule() {
        }
        TssLrsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            TssCoreModule,
                            TssDataSourceModule,
                            i1$1.HttpClientModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssLrsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TokenInterceptor = /** @class */ (function () {
        function TokenInterceptor(config) {
            this.config = config;
        }
        /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
        TokenInterceptor.prototype.intercept = /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
            function (request, next) {
                /** @type {?} */
                var withCredsExpr = new RegExp(this.config.withCredentialsInclusionExpression);
                if (this.config.accessToken && new RegExp(this.config.tdsTokenInclusionExpression).test(request.url)) {
                    request = request.clone({
                        withCredentials: this.config.setWithCredentials && withCredsExpr.test(request.url),
                        setHeaders: {
                            Authorization: this.config.authorizationType + " " + this.config.accessToken
                        }
                    });
                }
                else if (this.config.setWithCredentials && withCredsExpr.test(request.url)) {
                    request = request.clone({
                        withCredentials: true
                    });
                }
                return next.handle(request);
            };
        TokenInterceptor.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        TokenInterceptor.ctorParameters = function () {
            return [
                { type: SecurityConfig }
            ];
        };
        /** @nocollapse */ TokenInterceptor.ngInjectableDef = i0.defineInjectable({ factory: function TokenInterceptor_Factory() { return new TokenInterceptor(i0.inject(SecurityConfig)); }, token: TokenInterceptor, providedIn: "root" });
        return TokenInterceptor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var HasRolesDirective = /** @class */ (function () {
        function HasRolesDirective(templateRef, viewContainer, roleMgr, log) {
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.roleMgr = roleMgr;
            this.log = log;
        }
        Object.defineProperty(HasRolesDirective.prototype, "hasRoles", {
            set: /**
             * @param {?} roles
             * @return {?}
             */ function (roles) {
                if (this.roleMgr.hasRoles(roles)) {
                    // If condition is true add template to DOM
                    this.viewContainer.createEmbeddedView(this.templateRef);
                    this.log.trace("Granted access: " + roles);
                }
                else {
                    // Else remove template from DOM
                    this.viewContainer.clear();
                    this.log.trace("Denied access: " + roles);
                }
            },
            enumerable: true,
            configurable: true
        });
        HasRolesDirective.decorators = [
            { type: i0.Directive, args: [{
                        // TODO: remove this once this is moved to it's own package - RG.
                        // tslint:disable-next-line
                        selector: '[hasRoles]'
                    },] }
        ];
        /** @nocollapse */
        HasRolesDirective.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef },
                { type: RoleManagerService },
                { type: Logger }
            ];
        };
        HasRolesDirective.propDecorators = {
            hasRoles: [{ type: i0.Input }]
        };
        return HasRolesDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssSecurityModule = /** @class */ (function () {
        function TssSecurityModule() {
        }
        TssSecurityModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            i1$1.HttpClientModule,
                            forms.FormsModule,
                            TssCoreModule
                        ],
                        declarations: [
                            HasRolesDirective,
                        ],
                        exports: [
                            HasRolesDirective,
                        ],
                        providers: [
                            {
                                provide: i1$1.HTTP_INTERCEPTORS,
                                useClass: TokenInterceptor,
                                multi: true
                            }
                        ],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssSecurityModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PreventDefaultLinkDirective = /** @class */ (function () {
        function PreventDefaultLinkDirective() {
        }
        /**
         * @param {?} event
         * @return {?}
         */
        PreventDefaultLinkDirective.prototype.preventDefault = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.href.length) {
                    event.preventDefault();
                }
            };
        PreventDefaultLinkDirective.decorators = [
            { type: i0.Directive, args: [{
                        // TODO: remove this once this is moved to it's own package - RG.
                        // tslint:disable-next-line
                        selector: '[href]'
                    },] }
        ];
        PreventDefaultLinkDirective.propDecorators = {
            href: [{ type: i0.Input }],
            preventDefault: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
        };
        return PreventDefaultLinkDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssPolyfillModule = /** @class */ (function () {
        function TssPolyfillModule() {
        }
        TssPolyfillModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [],
                        declarations: [
                            PreventDefaultLinkDirective,
                        ],
                        exports: [
                            PreventDefaultLinkDirective,
                        ],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssPolyfillModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Queue module provides data queueing and core unit of work queue functionality.
     */
    var TssQueueModule = /** @class */ (function () {
        function TssQueueModule() {
        }
        TssQueueModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssQueueModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isFunction(val) {
        return isType(val, 'function');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} route
     * @param {?} routeExpression
     * @return {?}
     */
    function isRouteMatch(route, routeExpression) {
        /** @type {?} */
        var exp;
        if (isFunction(routeExpression)) {
            return Boolean((( /** @type {?} */(routeExpression)))(route));
        }
        if (isString(routeExpression)) {
            // NOTE: We are replacing the friendly route matching with real regex.
            /** @type {?} */
            var wildcardExp = new RegExp('[*]', 'gi');
            /** @type {?} */
            var routeAsString = ( /** @type {?} */(routeExpression));
            /** @type {?} */
            var resolvedRoute = replaceTokens(routeAsString, '*')
                .replace(wildcardExp, '.*');
            exp = new RegExp(resolvedRoute, 'i');
        }
        else {
            exp = ( /** @type {?} */(routeExpression));
        }
        return exp.test(route);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing global data caching settings.
     */
    var HttpConfig = /** @class */ (function () {
        function HttpConfig() {
            this.paramInjectionsEnabled = true;
            this.paramInjectionDefitions = [];
        }
        Object.defineProperty(HttpConfig.prototype, "hasInjections", {
            get: /**
             * @return {?}
             */ function () {
                return Boolean(this.paramInjectionDefitions.length);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} route
         * @param {?} paramName
         * @param {?} paramValue
         * @return {?}
         */
        HttpConfig.prototype.addOrUpdateParameterInjection = /**
         * @param {?} route
         * @param {?} paramName
         * @param {?} paramValue
         * @return {?}
         */
            function (route, paramName, paramValue) {
                /** @type {?} */
                var definition = {
                    route: route,
                    paramName: paramName,
                    paramValue: paramValue
                };
                /** @type {?} */
                var existingDefinition = this.paramInjectionDefitions.find(( /**
                 * @param {?} def
                 * @return {?}
                 */function (def) { return def.route === route && def.paramName === paramName; }));
                if (existingDefinition) {
                    Object.assign(existingDefinition, definition);
                    return existingDefinition;
                }
                else {
                    this.paramInjectionDefitions.push(definition);
                    return definition;
                }
            };
        /**
         * @param {?} route
         * @param {?} paramName
         * @param {?} paramValue
         * @return {?}
         */
        HttpConfig.prototype.addParameterInjection = /**
         * @param {?} route
         * @param {?} paramName
         * @param {?} paramValue
         * @return {?}
         */
            function (route, paramName, paramValue) {
                /** @type {?} */
                var definition = {
                    route: route,
                    paramName: paramName,
                    paramValue: paramValue
                };
                this.paramInjectionDefitions.push(definition);
                return definition;
            };
        /**
         * @param {?} route
         * @return {?}
         */
        HttpConfig.prototype.getInjectionDefinitions = /**
         * @param {?} route
         * @return {?}
         */
            function (route) {
                return this.paramInjectionDefitions.filter(( /**
                 * @param {?} def
                 * @return {?}
                 */function (def) { return isRouteMatch(route, def.route); }));
            };
        /**
         * @param {?} route
         * @return {?}
         */
        HttpConfig.prototype.getFirstInjectionDefinition = /**
         * @param {?} route
         * @return {?}
         */
            function (route) {
                return this.paramInjectionDefitions.find(( /**
                 * @param {?} def
                 * @return {?}
                 */function (def) { return isRouteMatch(route, def.route); }));
            };
        HttpConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ HttpConfig.ngInjectableDef = i0.defineInjectable({ factory: function HttpConfig_Factory() { return new HttpConfig(); }, token: HttpConfig, providedIn: "root" });
        /**
         * Configuration class for storing global data caching settings.
         */
        HttpConfig = __decorate([
            AutoConfig('HttpConfig')
        ], HttpConfig);
        return HttpConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var HttpParamInterceptor = /** @class */ (function () {
        function HttpParamInterceptor(config, log) {
            this.config = config;
            this.log = log;
        }
        /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
        HttpParamInterceptor.prototype.intercept = /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
            function (request, next) {
                /** @type {?} */
                var httpParamInjections = this.config.paramInjectionsEnabled
                    ? this.config.getInjectionDefinitions(request.urlWithParams)
                    : [];
                if (httpParamInjections.length) {
                    request = this.generateRequestWithParams(request, httpParamInjections);
                }
                return next.handle(request);
            };
        /**
         * @param {?} request
         * @param {?} httpParamInjections
         * @return {?}
         */
        HttpParamInterceptor.prototype.generateRequestWithParams = /**
         * @param {?} request
         * @param {?} httpParamInjections
         * @return {?}
         */
            function (request, httpParamInjections) {
                var _this = this;
                /** @type {?} */
                var params = request.params;
                httpParamInjections
                    .forEach(( /**
             * @param {?} paramInjection
             * @return {?}
             */function (paramInjection) {
                    _this.log.debug("Injecting URL '" + request.url + "' with parameter value (name: '" + paramInjection.paramName + "')");
                    params = params.set(paramInjection.paramName, paramInjection.paramValue);
                }));
                return request.clone({ params: params });
            };
        HttpParamInterceptor.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        HttpParamInterceptor.ctorParameters = function () {
            return [
                { type: HttpConfig },
                { type: Logger }
            ];
        };
        /** @nocollapse */ HttpParamInterceptor.ngInjectableDef = i0.defineInjectable({ factory: function HttpParamInterceptor_Factory() { return new HttpParamInterceptor(i0.inject(HttpConfig), i0.inject(Logger)); }, token: HttpParamInterceptor, providedIn: "root" });
        return HttpParamInterceptor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssHttpModule = /** @class */ (function () {
        function TssHttpModule() {
        }
        TssHttpModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            i1$1.HttpClientModule,
                            TssCoreModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [
                            {
                                provide: i1$1.HTTP_INTERCEPTORS,
                                useClass: HttpParamInterceptor,
                                multi: true
                            }
                        ],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssHttpModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ɵ0 = AppInitializerFactory;
    var TssAppModule = /** @class */ (function () {
        function TssAppModule() {
        }
        TssAppModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            i1$1.HttpClientModule,
                            i1.RouterModule,
                            TssCoreModule,
                            TssPolyfillModule,
                            TssHttpModule,
                            TssDataSourceModule,
                            TssQueueModule,
                            TssSecurityModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [
                            AppProfileService,
                            ApiService,
                            AppInitializerService,
                            {
                                provide: i0.APP_INITIALIZER,
                                useFactory: ɵ0,
                                multi: true,
                                deps: [i0.Injector]
                            }
                        ],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssAppModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssAppSpatialModule = /** @class */ (function () {
        function TssAppSpatialModule() {
        }
        TssAppSpatialModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            TssAppModule,
                            TssEsriModule,
                            TssGeometryModule,
                            TssMapsModule,
                            TssLrsModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssAppSpatialModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ALL_APP_SETTINGS_QUERY_ID = 'all';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AppSettingService = /** @class */ (function (_super) {
        __extends(AppSettingService, _super);
        function AppSettingService(http, config) {
            var _this = _super.call(this, http, {
                url: join(config.serviceUrl, config.appSettingsEndpoint),
                defaultRouteTokens: {
                    appId: config.appId
                }
            }) || this;
            _this.http = http;
            return _this;
        }
        /**
         * Retrieves a list of application settings.
         */
        /**
         * Retrieves a list of application settings.
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        AppSettingService.prototype.queryAllApps = /**
         * Retrieves a list of application settings.
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (routeTokens, params) {
                routeTokens = routeTokens || {};
                routeTokens.appId = ALL_APP_SETTINGS_QUERY_ID;
                return _super.prototype.query.call(this, routeTokens, params);
            };
        AppSettingService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        AppSettingService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: AppConfig }
            ];
        };
        /** @nocollapse */ AppSettingService.ngInjectableDef = i0.defineInjectable({ factory: function AppSettingService_Factory() { return new AppSettingService(i0.inject(i1$1.HttpClient), i0.inject(AppConfig)); }, token: AppSettingService, providedIn: "root" });
        return AppSettingService;
    }(BaseResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var CachePersistence = {
        Persistent: 'persistent',
        InMemory: 'in-memory',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var CacheStrategy = {
        NetworkFirst: 'network-first',
        CacheFirst: 'cache-first',
        Fastest: 'fastest',
        CacheOnly: 'cache-only',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing global data caching settings.
     */
    var CacheConfig = /** @class */ (function () {
        function CacheConfig() {
            /**
             * Determines whether caching should be used or not. When disabled, all
             * caching-related functionality is ignored (not used).
             */
            this.cacheEnabled = false;
            /**
             * List of configurations that describe what to cache and how to cache it.
             * The main parts of this configuration include the "route" (how to match what
             * to cache) and the "strategy" (whether to look for content in the cache first
             * or try to make the HTTP request first).
             */
            this.cacheDefitions = [];
            /**
             * When set, this strategy will trump all strategies defined in the "Cache Defintions".
             * WARNING: This is a global setting and can have adverse affects when used improperly.
             * The main use case for this setting is to allow for the global cache strategy of
             * 'cacheOnly', which will allow an application to force an "offline" state (forcing
             * requests to pull from cache only).
             */
            this.forcedGlobalCacheStrategy = null;
        }
        CacheConfig_1 = CacheConfig;
        /**
         * @param {?} config
         * @return {?}
         */
        CacheConfig.create = /**
         * @param {?} config
         * @return {?}
         */
            function (config) {
                return Object.assign(new CacheConfig_1(), config);
            };
        /**
         * @param {...?} defs
         * @return {?}
         */
        CacheConfig.enable = /**
         * @param {...?} defs
         * @return {?}
         */
            function () {
                var defs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    defs[_i] = arguments[_i];
                }
                return CacheConfig_1.create({
                    cacheEnabled: true,
                    cacheDefitions: defs,
                });
            };
        /**
         * @param {?} route
         * @return {?}
         */
        CacheConfig.prototype.getCacheDefinition = /**
         * @param {?} route
         * @return {?}
         */
            function (route) {
                return this.cacheDefitions.find(( /**
                 * @param {?} def
                 * @return {?}
                 */function (def) { return isRouteMatch(route, def.route); }));
            };
        var CacheConfig_1;
        CacheConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ CacheConfig.ngInjectableDef = i0.defineInjectable({ factory: function CacheConfig_Factory() { return new CacheConfig(); }, token: CacheConfig, providedIn: "root" });
        /**
         * Configuration class for storing global data caching settings.
         */
        CacheConfig = CacheConfig_1 = __decorate([
            AutoConfig('CacheConfig')
        ], CacheConfig);
        return CacheConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CACHE_ONLY_NO_DATA_EXC_MSG = 'No cache available';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CACHE_STORAGE_KEY_PREFIX = 'http-cache:';
    /**
     * Configuration class for storing global data caching settings.
     */
    var PersistentCacheStorage = /** @class */ (function (_super) {
        __extends(PersistentCacheStorage, _super);
        function PersistentCacheStorage() {
            var _this = _super.call(this) || this;
            _this.keyPrefix = CACHE_STORAGE_KEY_PREFIX;
            return _this;
        }
        PersistentCacheStorage.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        PersistentCacheStorage.ctorParameters = function () { return []; };
        /** @nocollapse */ PersistentCacheStorage.ngInjectableDef = i0.defineInjectable({ factory: function PersistentCacheStorage_Factory() { return new PersistentCacheStorage(); }, token: PersistentCacheStorage, providedIn: "root" });
        return PersistentCacheStorage;
    }(PersistentStorage));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Cache Service is an observables based in-memory cache implementation
     * Keeps track of in-flight observables and sets a default expiry for cached values
     */
    var CacheService = /** @class */ (function () {
        function CacheService(cache) {
            this.cache = cache;
        }
        /**
         * @param {?} key
         * @return {?}
         */
        CacheService.prototype.get = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                /** @type {?} */
                var cacheItem = this.cache.getObject(key);
                /** @type {?} */
                var now = new Date();
                /** @type {?} */
                var cacheData;
                if (cacheItem && cacheItem.expires && cacheItem.expires.getTime() < now.getTime()) {
                    this.cache.remove(key);
                }
                else if (cacheItem) {
                    // NOTE: We can't just pull the serialized data, because
                    // we need an actual instance of the HttpResponse class.
                    cacheData = Object.assign(new i1$1.HttpResponse(), cacheItem.value);
                }
                else {
                    cacheData = null;
                }
                return cacheData;
            };
        /**
         * @param {?} key
         * @param {?} value
         * @param {?=} timeToLive
         * @return {?}
         */
        CacheService.prototype.set = /**
         * @param {?} key
         * @param {?} value
         * @param {?=} timeToLive
         * @return {?}
         */
            function (key, value, timeToLive) {
                if (timeToLive === void 0) {
                    timeToLive = null;
                }
                /** @type {?} */
                var expires = timeToLive ? this.getExpireDate(timeToLive) : null;
                /** @type {?} */
                var cacheData = { expires: expires, value: value };
                this.cache.setObject(key, cacheData);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        CacheService.prototype.has = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return this.cache.has(key);
            };
        /**
         * @private
         * @param {?=} timeToLive
         * @return {?}
         */
        CacheService.prototype.getExpireDate = /**
         * @private
         * @param {?=} timeToLive
         * @return {?}
         */
            function (timeToLive) {
                if (timeToLive === void 0) {
                    timeToLive = null;
                }
                /** @type {?} */
                var expires = new Date();
                expires.setSeconds(expires.getSeconds() + timeToLive);
                return expires;
            };
        CacheService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        CacheService.ctorParameters = function () {
            return [
                { type: PersistentCacheStorage }
            ];
        };
        /** @nocollapse */ CacheService.ngInjectableDef = i0.defineInjectable({ factory: function CacheService_Factory() { return new CacheService(i0.inject(PersistentCacheStorage)); }, token: CacheService, providedIn: "root" });
        return CacheService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} template
     * @return {?}
     */
    function hasTokens(template) {
        return TOKEN_EXPRESSION.test(template);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} template
     * @return {?}
     */
    function standardizeTokens(template) {
        return (template || '').replace(/{{/gi, '{').replace(/}}/gi, '}');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @return {?}
     */
    function stripTokenBraces(value) {
        return (value || '')
            .replace(new RegExp('{', 'gi'), '')
            .replace(new RegExp('}', 'gi'), '');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} template
     * @param {?} resolvedPath
     * @return {?}
     */
    function extractTokenValuesFromTemplate(template, resolvedPath) {
        /** @type {?} */
        var tokens = {};
        template = standardizeTokens(template);
        /** @type {?} */
        var wildcardTemplate = replaceTokens(template, WILDCARD_EXPRESSION_VALUE);
        /** @type {?} */
        var parts = new RegExp(wildcardTemplate).exec(resolvedPath);
        if (parts && parts.length) {
            /** @type {?} */
            var tokensList_1 = template.match(TOKEN_EXPRESSION);
            // Get rid of the full match.
            parts.shift();
            parts.forEach(( /**
             * @param {?} templateValue
             * @param {?} index
             * @return {?}
             */function (templateValue, index) {
                if (tokensList_1[index]) {
                    /** @type {?} */
                    var key = stripTokenBraces(tokensList_1[index]);
                    tokens[key] = (templateValue || '').replace(new RegExp('/', 'gi'), '');
                }
            }));
        }
        return tokens;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} strategy
     * @return {?}
     */
    function shouldCheckCacheFirst(strategy) {
        return strategy === CacheStrategy.CacheFirst
            || strategy === CacheStrategy.Fastest
            || strategy === CacheStrategy.CacheOnly;
    }
    /**
     * @param {?} definition
     * @param {?} requestUrl
     * @return {?}
     */
    function getCacheKey(definition, requestUrl) {
        /** @type {?} */
        var cacheKey = definition.cacheId || requestUrl;
        if (hasTokens(cacheKey) && isString(definition.route)) {
            /** @type {?} */
            var tokenValues = extractTokenValuesFromTemplate(( /** @type {?} */(definition.route)), requestUrl);
            cacheKey = format(cacheKey, tokenValues, true);
        }
        return cacheKey;
    }
    var CacheInterceptor = /** @class */ (function () {
        function CacheInterceptor(config, cache, log) {
            this.config = config;
            this.cache = cache;
            this.log = log;
        }
        /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
        CacheInterceptor.prototype.intercept = /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
            function (request, next) {
                /** @type {?} */
                var allowCaching = request.method === 'GET' && this.config.cacheEnabled;
                /** @type {?} */
                var matchingCacheDefinition;
                // TODO: Handle request method type.
                // TDOO: Handle global use cache only.
                if (allowCaching) {
                    matchingCacheDefinition = this.config.getCacheDefinition(request.urlWithParams);
                    /** @type {?} */
                    var strategy = matchingCacheDefinition
                        ? this.config.forcedGlobalCacheStrategy || matchingCacheDefinition.strategy
                        : null;
                    if (matchingCacheDefinition && shouldCheckCacheFirst(strategy)) {
                        /** @type {?} */
                        var cacheKey = getCacheKey(matchingCacheDefinition, request.url);
                        /** @type {?} */
                        var isCacheOnly = strategy === CacheStrategy.CacheOnly;
                        /** @type {?} */
                        var cachedResponse = this.cache.get(cacheKey);
                        if (cachedResponse) {
                            this.log.debug("Resolving HTTP request from cache: '" + request.url + "'");
                            return rxjs.of(cachedResponse);
                        }
                        else if (isCacheOnly) {
                            return rxjs.throwError(new Error(CACHE_ONLY_NO_DATA_EXC_MSG));
                        }
                    }
                }
                this.log.trace("Making HTTP request: '" + request.url + "'");
                /** @type {?} */
                var continuedResponse = next.handle(request);
                // If a matched cache definition is found, then we need to handle caching when the request when it is complete.
                if (allowCaching && matchingCacheDefinition) {
                    continuedResponse = this.cacheResponse(continuedResponse, request, matchingCacheDefinition);
                }
                return continuedResponse;
            };
        /**
         * @private
         * @param {?} source
         * @param {?} request
         * @param {?} cacheDefinition
         * @return {?}
         */
        CacheInterceptor.prototype.cacheResponse = /**
         * @private
         * @param {?} source
         * @param {?} request
         * @param {?} cacheDefinition
         * @return {?}
         */
            function (source, request, cacheDefinition) {
                var _this = this;
                /** @type {?} */
                var cacheKey = getCacheKey(cacheDefinition, request.url);
                return source.pipe(operators.tap(( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                    if (cacheDefinition && event instanceof i1$1.HttpResponse) {
                        _this.log.debug("Caching HTTP request: '" + request.url + "'");
                        _this.cache.set(cacheKey, event, cacheDefinition.expires);
                    }
                })), operators.catchError(( /**
                 * @param {?} error
                 * @return {?}
                 */function (error) {
                    /** @type {?} */
                    var cachedData = _this.cache.get(cacheKey);
                    if (cachedData) {
                        _this.log.debug("Failed to resolve cacheable HTTP request from URL '" + request.url + "', fallingback to cache");
                        return rxjs.of(cachedData);
                    }
                    else {
                        _this.log.debug("Failed to resolve cacheable HTTP request from URL '" + request.url + "' and no cached data available");
                        throw error;
                    }
                })));
            };
        CacheInterceptor.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        CacheInterceptor.ctorParameters = function () {
            return [
                { type: CacheConfig },
                { type: CacheService },
                { type: Logger }
            ];
        };
        /** @nocollapse */ CacheInterceptor.ngInjectableDef = i0.defineInjectable({ factory: function CacheInterceptor_Factory() { return new CacheInterceptor(i0.inject(CacheConfig), i0.inject(CacheService), i0.inject(Logger)); }, token: CacheInterceptor, providedIn: "root" });
        return CacheInterceptor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssCacheModule = /** @class */ (function () {
        function TssCacheModule() {
        }
        TssCacheModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            i1$1.HttpClientModule,
                            TssCoreModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [
                            CacheConfig,
                            PersistentCacheStorage,
                            CacheService,
                            {
                                provide: i1$1.HTTP_INTERCEPTORS,
                                useClass: CacheInterceptor,
                                multi: true
                            }
                        ],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssCacheModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} list
     * @param {...?} itemsToAdd
     * @return {?}
     */
    function addIfNotExist(list) {
        var itemsToAdd = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            itemsToAdd[_i - 1] = arguments[_i];
        }
        itemsToAdd.forEach(( /**
         * @param {?} item
         * @return {?}
         */function (item) {
            if (list.indexOf(item) === -1) {
                list.push(item);
            }
        }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} list
     * @param {?} itemsToAdd
     * @return {?}
     */
    function addRangeToBeginning(list, itemsToAdd) {
        list.unshift.apply(list, __spread(itemsToAdd));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} list
     * @param {?} itemsToAdd
     * @return {?}
     */
    function addRange(list, itemsToAdd) {
        list.push.apply(list, __spread(itemsToAdd));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} list
     * @return {?}
     */
    function removeDuplicates(list) {
        return list
            .filter(( /**
     * @param {?} element
     * @param {?} position
     * @param {?} filteredList
     * @return {?}
     */function (element, position, filteredList) {
            return filteredList.indexOf(element) === position;
        }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} list
     * @param {...?} itemsToDelete
     * @return {?}
     */
    function removeItem(list) {
        var itemsToDelete = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            itemsToDelete[_i - 1] = arguments[_i];
        }
        itemsToDelete.forEach(( /**
         * @param {?} itemToDelete
         * @return {?}
         */function (itemToDelete) {
            /** @type {?} */
            var index = list.indexOf(itemToDelete);
            /** @type {?} */
            var numberOfItemsToRemove = 1;
            if (index > -1) {
                list.splice(index, numberOfItemsToRemove);
            }
        }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} list
     * @param {?} predicate
     * @return {?}
     */
    function removeWhere(list, predicate) {
        /** @type {?} */
        var itemsToRemove = list.filter(( /**
         * @param {?} t
         * @return {?}
         */function (t) { return predicate(t); }));
        removeItem.apply(void 0, __spread([list], itemsToRemove));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} objectToClone
     * @return {?}
     */
    function clone(objectToClone) {
        return JSON.parse(JSON.stringify(objectToClone));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} hex
     * @return {?}
     */
    function hexToRgb(hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        /** @type {?} */
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        /** @type {?} */
        var result = null;
        hex = hex.replace(shorthandRegex, ( /**
         * @param {?} _
         * @param {?} red
         * @param {?} green
         * @param {?} blue
         * @return {?}
         */function (_, red, green, blue) {
            return red + red + green + green + blue + blue;
        }));
        /** @type {?} */
        var matchResult = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (matchResult) {
            /** @type {?} */
            var red = parseInt(matchResult[1], 16);
            /** @type {?} */
            var blue = parseInt(matchResult[2], 16);
            /** @type {?} */
            var green = parseInt(matchResult[3], 16);
            result = [red, blue, green];
        }
        return result;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} colorTest
     * @return {?}
     */
    function isHexColor(colorTest) {
        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(colorTest);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} rgb
     * @return {?}
     */
    function rgbToHex(rgb) {
        /** @type {?} */
        var red = rgb[0];
        /** @type {?} */
        var green = rgb[1];
        /** @type {?} */
        var blue = rgb[2];
        // tslint:disable-next-line
        return "#" + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} transparency
     * @return {?}
     */
    function transparencyToOpacity(transparency) {
        return 1 - (transparency * 0.01);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Given a cookie key `name`, returns the value of
     * the cookie or `null`, if the key is not found.
     * @param {?} name
     * @return {?}
     */
    function getCookie(name) {
        /** @type {?} */
        var nameMatchLength = name.length + 1;
        return document.cookie
            .split(';')
            .map(( /**
     * @param {?} c
     * @return {?}
     */function (c) { return c.trim(); }))
            .filter(( /**
     * @param {?} cookie
     * @return {?}
     */function (cookie) {
            return cookie.substring(0, nameMatchLength) === name + "=";
        }))
            .map(( /**
     * @param {?} cookie
     * @return {?}
     */function (cookie) {
            return decodeURIComponent(cookie.substring(nameMatchLength));
        }))[0] || null;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} milliseconds
     * @param {?=} date
     * @return {?}
     */
    function addMilliseconds(milliseconds, date) {
        date = date || new Date();
        /** @type {?} */
        var time = date.getTime();
        /** @type {?} */
        var newTime = time + milliseconds;
        date.setTime(newTime);
        return date;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} minutes
     * @param {?=} date
     * @return {?}
     */
    function addMinutes(minutes, date) {
        return addMilliseconds(minutes * MILLISECONDS_PER_MINUTE, date);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} days
     * @param {?=} date
     * @return {?}
     */
    function addDays(days, date) {
        return addMinutes(days * HOURS_PER_DAY, date);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} hours
     * @param {?=} date
     * @return {?}
     */
    function addHours(hours, date) {
        return addMinutes(hours * MINUTES_PER_HOUR, date);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} seconds
     * @param {?=} date
     * @return {?}
     */
    function addSeconds(seconds, date) {
        return addMilliseconds(seconds * MILLISECONDS_PER_SECOND, date);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} date
     * @return {?}
     */
    function toUtcDate(date) {
        return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} date
     * @param {?=} dateFormat
     * @return {?}
     */
    function formatDate(date, dateFormat) {
        if (dateFormat === void 0) {
            dateFormat = DEFAULT_DATE_FORMAT;
        }
        /** @type {?} */
        var dateTransformer = new common.DatePipe('en-US');
        if (dateFormat === STANDARDIZED_QUERY_DATE_FORMAT || dateFormat === ORACLE_DATE_FORMAT) {
            return format(dateFormat, {
                date: dateTransformer.transform(date, DEFAULT_DATE_FORMAT)
            });
        }
        /** @type {?} */
        var formattedDate = dateTransformer.transform(date, dateFormat);
        return "" + formattedDate;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} date
     * @return {?}
     */
    function toStandardizedQueryDateFormat(date) {
        // Attribute query expects UTC time, so convert from local time.
        // The date formatter uses local time, so create a new Date object
        // whose local time is set to UTC time from the input date.
        date = toUtcDate(date);
        return formatDate(date, STANDARDIZED_QUERY_DATE_FORMAT);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} date
     * @return {?}
     */
    function toUtcEpochDate(date) {
        return toUtcDate(date).getTime();
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} date
     * @param {?=} dateFormat
     * @return {?}
     */
    function formatDateForQuery(date, dateFormat) {
        if (dateFormat === void 0) {
            dateFormat = DEFAULT_DATE_FORMAT;
        }
        /** @type {?} */
        var quoteDate = true;
        if (dateFormat === STANDARDIZED_QUERY_DATE_FORMAT || dateFormat === ORACLE_DATE_FORMAT) {
            quoteDate = false;
        }
        /** @type {?} */
        var formattedDate = formatDate(date, dateFormat);
        return quoteDate ? "'" + formattedDate + "'" : "" + formattedDate;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var SqlDateFormat = {
        Standardized: 0,
        Literal: 1,
        Oracle: 2,
    };
    SqlDateFormat[SqlDateFormat.Standardized] = 'Standardized';
    SqlDateFormat[SqlDateFormat.Literal] = 'Literal';
    SqlDateFormat[SqlDateFormat.Oracle] = 'Oracle';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function getCurrentDateAsUtc() {
        return toUtcDate(new Date());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function getCurrentDateEpochAsUtc() {
        return toUtcDate(new Date()).getTime();
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} start
     * @param {?=} end
     * @return {?}
     */
    function getElapsedMilliseconds(start, end) {
        end = end || new Date();
        return Math.abs(start.getTime() - end.getTime());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} start
     * @param {?=} end
     * @return {?}
     */
    function getElapsedSeconds(start, end) {
        return getElapsedMilliseconds(start, end) / 1000;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} seconds
     * @param {?=} suffixMap
     * @return {?}
     */
    function secondsToReadableTime(seconds, suffixMap) {
        if (suffixMap === void 0) {
            suffixMap = {};
        }
        return toReadableTime(seconds * MILLISECONDS_PER_SECOND, suffixMap);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} date
     * @return {?}
     */
    function setDateToBeginningOfDay(date) {
        date.setHours(0, 0, 0, 0);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} date
     * @return {?}
     */
    function setDateToEndOfDay(date) {
        date.setHours(23, 59, 59);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} days
     * @param {?=} date
     * @return {?}
     */
    function subtractDays(days, date) {
        return addDays(days * -1, date);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} minutes
     * @param {?=} date
     * @return {?}
     */
    function subtractMinutes(minutes, date) {
        return addMinutes(minutes * -1, date);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} minutes
     * @param {?=} date
     * @return {?}
     */
    function subtractSeconds(minutes, date) {
        return addSeconds(minutes * -1, date);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} hours
     * @param {?=} date
     * @return {?}
     */
    function subtractHours(hours, date) {
        return addHours(hours * -1, date);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} milliseconds
     * @param {?=} date
     * @return {?}
     */
    function subtractMilliseconds(milliseconds, date) {
        return addMilliseconds(milliseconds * -1, date);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function hasLocalStorage() {
        return hasWindow() && Boolean(window.localStorage);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OnlineOfflineService = /** @class */ (function () {
        function OnlineOfflineService() {
            var _this = this;
            this.internalConnectionChanged = new rxjs.Subject();
            this.connectionChanged = this.internalConnectionChanged.asObservable();
            window.addEventListener('online', ( /**
             * @return {?}
             */function () { return _this.updateOnlineStatus(); }));
            window.addEventListener('offline', ( /**
             * @return {?}
             */function () { return _this.updateOnlineStatus(); }));
        }
        Object.defineProperty(OnlineOfflineService.prototype, "isOnline", {
            get: /**
             * @return {?}
             */ function () {
                return !!window.navigator.onLine;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        OnlineOfflineService.prototype.updateOnlineStatus = /**
         * @private
         * @return {?}
         */
            function () {
                this.internalConnectionChanged.next(window.navigator.onLine);
            };
        OnlineOfflineService.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        OnlineOfflineService.ctorParameters = function () { return []; };
        /** @nocollapse */ OnlineOfflineService.ngInjectableDef = i0.defineInjectable({ factory: function OnlineOfflineService_Factory() { return new OnlineOfflineService(); }, token: OnlineOfflineService, providedIn: "root" });
        return OnlineOfflineService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_POINT_EQUALITY_PRECISION = 7;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns true if the two arguments are equal within the given precision.
     * @param {?} number1
     * @param {?} number2
     * @param {?=} precision
     * @return {?}
     */
    function almostEqual(number1, number2, precision) {
        if (precision === void 0) {
            precision = DEFAULT_POINT_EQUALITY_PRECISION;
        }
        /** @type {?} */
        var tolerance = 0.5 * Math.pow(10, -precision);
        return Math.abs(number1 - number2) < tolerance;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} x1
     * @param {?} y1
     * @param {?} x2
     * @param {?} y2
     * @param {?=} precision
     * @return {?}
     */
    function pointsAlmostEqual(x1, y1, x2, y2, precision) {
        if (precision === void 0) {
            precision = DEFAULT_POINT_EQUALITY_PRECISION;
        }
        return almostEqual(x1, x2, precision) && almostEqual(y1, y2, precision);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_ERROR_MSG = 'An error occurred';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} errorOrMsg
     * @param {?=} error
     * @return {?}
     */
    function errorMsg(errorOrMsg, error) {
        /** @type {?} */
        var exceptionDetails;
        errorOrMsg = errorOrMsg || DEFAULT_ERROR_MSG;
        if (isString(errorOrMsg)) {
            exceptionDetails = error ? errorMsg(error) : '';
            return format(errorOrMsg, { error: exceptionDetails });
        }
        return errorMsg(errorOrMsg.innerException
            || errorOrMsg.InnerException
            || errorOrMsg.exceptionMessage
            || errorOrMsg.ExceptionMessage
            || errorOrMsg.message
            || errorOrMsg.Message
            || errorOrMsg.msg
            || errorOrMsg.Msg
            || errorOrMsg.error_description
            || errorOrMsg.error
            || errorOrMsg.Error
            || errorOrMsg.data
            || errorOrMsg.Data
            || errorOrMsg.exception
            || errorOrMsg.Exception);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @param {?=} digits
     * @param {?=} locale
     * @return {?}
     */
    function formatNumber(value, digits, locale) {
        return new common.DecimalPipe('en-US').transform(value, digits, locale);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var FIRST_LETTER_SEPERATED_BY_SPACE_MATCH_REGEX = /^[a-z]|\s[a-z]/gm;
    /** @type {?} */
    var PASCAL_CASE_FIRST_LETTER_MATCH_REGEX = /(?=[A-Z])/;
    /** @type {?} */
    var LEADING_AND_TRAILING_UNDERSCORE_MATCH_REGEX = /^[\s_]+|[\s_]+$/gm;
    /** @type {?} */
    var LEADING_AND_TRAILING_HYPHEN_MATCH_REGEX = /^[\s-]+|[\s-]+$/gm;
    /** @type {?} */
    var UNDERSCORE_MATCH_REGEX = /[_\s]+/gm;
    /** @type {?} */
    var HYPHEN_MATCH_REGEX = /[-\s]+/gm;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} text
     * @return {?}
     */
    function upperCaseEachWord(text) {
        return (text || '')
            .replace(FIRST_LETTER_SEPERATED_BY_SPACE_MATCH_REGEX, ( /**
     * @param {?} match
     * @return {?}
     */function (match) {
            return match.toUpperCase();
        }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @return {?}
     */
    function upperCaseFirstLetter(value) {
        return String(value).charAt(0).toUpperCase() + value.slice(1);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} text
     * @param {?=} upperCaseAllWords
     * @return {?}
     */
    function humanize(text, upperCaseAllWords) {
        if (upperCaseAllWords === void 0) {
            upperCaseAllWords = true;
        }
        /** @type {?} */
        var result = (text || '')
            .split(PASCAL_CASE_FIRST_LETTER_MATCH_REGEX)
            .join(' ')
            .replace(LEADING_AND_TRAILING_UNDERSCORE_MATCH_REGEX, '')
            .replace(LEADING_AND_TRAILING_HYPHEN_MATCH_REGEX, '')
            .replace(UNDERSCORE_MATCH_REGEX, ' ')
            .replace(HYPHEN_MATCH_REGEX, ' ')
            .toLowerCase();
        return upperCaseAllWords
            ? upperCaseEachWord(result)
            : upperCaseFirstLetter(result);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @param {?=} trimCharacter
     * @return {?}
     */
    function trimEnd(value, trimCharacter) {
        if (trimCharacter === void 0) {
            trimCharacter = ' ';
        }
        if (value.endsWith(trimCharacter)) {
            value = value.substr(0, value.length - 1);
        }
        return value;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @param {?=} trimCharacter
     * @return {?}
     */
    function trimStart(value, trimCharacter) {
        if (trimCharacter === void 0) {
            trimCharacter = ' ';
        }
        if (value.startsWith(trimCharacter)) {
            value = value.substr(1);
        }
        return value;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @param {?=} trimCharacter
     * @return {?}
     */
    function trim(value, trimCharacter) {
        if (trimCharacter === void 0) {
            trimCharacter = ' ';
        }
        value = trimStart(value, trimCharacter);
        value = trimEnd(value, trimCharacter);
        return value;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template Key, Value
     * @param {?} list
     * @param {?} keyGetter
     * @return {?}
     */
    function groupBy(list, keyGetter) {
        /** @type {?} */
        var map = new Map();
        list.forEach(( /**
         * @param {?} item
         * @return {?}
         */function (item) {
            /** @type {?} */
            var key = keyGetter(item);
            /** @type {?} */
            var collection = map.get(key);
            if (!collection) {
                map.set(key, [item]);
            }
            else {
                collection.push(item);
            }
        }));
        return map;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var BASE_64_METADATA_REGEX = /data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/;
    /** @type {?} */
    var JSON_MIME_TYPE = 'application/json';
    // Text files.
    /** @type {?} */
    var TEXT_MIME_TYPE = 'text/plain';
    /** @type {?} */
    var TEXT_FILE_EXTENSION = '.txt';
    // Audio.
    /** @type {?} */
    var AUDIO_WEBM_MIME_TYPE = 'audio/webm';
    /** @type {?} */
    var AUDIO_MP3_MIME_TYPE = 'audio/mpeg-3';
    /** @type {?} */
    var AUDIO_MP3_FILE_EXTENSION = '.mp3';
    // Video.
    /** @type {?} */
    var VIDEO_WEBM_MIME_TYPE = 'video/webm;codecs=h264';
    /** @type {?} */
    var VIDEO_MP4_MIME_TYPE = 'video/mp4';
    /** @type {?} */
    var VIDEO_MP4_FILE_EXTENSION = '.mp4';
    // Images.
    /** @type {?} */
    var IMAGE_PNG_FILE_EXTENSION = '.png';
    /** @type {?} */
    var IMAGE_PNG_MIME_TYPE = 'image/png';
    /** @type {?} */
    var IMAGE_JPEG_FILE_EXTENSION = '.jpeg';
    /** @type {?} */
    var IMAGE_JPEG_MIME_TYPE = 'image/jpeg';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} encoded
     * @return {?}
     */
    function base64MimeType(encoded) {
        /** @type {?} */
        var result = null;
        /** @type {?} */
        var mime = encoded.match(BASE_64_METADATA_REGEX);
        if (mime && mime.length) {
            result = mime[1];
        }
        return result;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} base64
     * @return {?}
     */
    function stripBase64Metadata(base64) {
        /** @type {?} */
        var result = base64.split(',');
        return getLastItem(result).trim();
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} base64Data
     * @return {?}
     */
    function base64toByteArray(base64Data) {
        /** @type {?} */
        var sliceSize = 1024;
        /** @type {?} */
        var strippedBase64Data = stripBase64Metadata(base64Data);
        /** @type {?} */
        var byteCharacters = atob(strippedBase64Data);
        /** @type {?} */
        var bytesLength = byteCharacters.length;
        /** @type {?} */
        var slicesCount = Math.ceil(bytesLength / sliceSize);
        /** @type {?} */
        var byteArrays = new Array(slicesCount);
        /** @type {?} */
        var sliceIndex;
        for (sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
            /** @type {?} */
            var begin = sliceIndex * sliceSize;
            /** @type {?} */
            var end = Math.min(begin + sliceSize, bytesLength);
            /** @type {?} */
            var bytes = new Array(end - begin);
            /** @type {?} */
            var offset = void 0;
            /** @type {?} */
            var i = void 0;
            for (offset = begin, i = 0; offset < end; ++i, ++offset) {
                bytes[i] = byteCharacters[offset].charCodeAt(0);
            }
            byteArrays[sliceIndex] = new Uint8Array(bytes);
        }
        return byteArrays;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} base64Data
     * @param {?=} contentType
     * @return {?}
     */
    function base64toBlob(base64Data, contentType) {
        if (contentType === void 0) {
            contentType = null;
        }
        contentType = contentType || base64MimeType(base64Data);
        return new Blob(base64toByteArray(base64Data), { type: contentType });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isObject(val) {
        return isType(val, 'object') && !Array.isArray(val) && isValue(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Deep merge two objects.
     * @param {?} target
     * @param {?} source
     * @param {?=} options
     * @return {?}
     */
    function mergeDeep(target, source, options) {
        if (options === void 0) {
            options = {};
        }
        if (isObject(target) && isObject(source)) {
            Object.keys(source).forEach(( /**
             * @param {?} key
             * @return {?}
             */function (key) {
                var _a;
                /** @type {?} */
                var value = source[key];
                if (isObject(value)) {
                    if (!target[key]) {
                        target[key] = {};
                    }
                    mergeDeep(target[key], value, options);
                }
                else {
                    /** @type {?} */
                    var doCopy = true;
                    if (options.ignoreArrays && Array.isArray(value)
                        || isFunction(value) && !options.copyFunctions) {
                        doCopy = false;
                    }
                    if (doCopy) {
                        Object.assign(target, (_a = {}, _a[key] = value, _a));
                    }
                }
            }));
        }
        return target;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} target
     * @param {?} source
     * @param {?=} options
     * @return {?}
     */
    function mergeDeepArray(target, source, options) {
        if (!target || !source) {
            return;
        }
        options = Object.assign({}, {
            identifier: 'id',
            addMissing: true,
            beforeMerge: ( /**
             * @return {?}
             */function () { return undefined; }),
            afterMerge: ( /**
             * @return {?}
             */function () { return undefined; }),
        }, options);
        target.forEach(( /**
         * @param {?} targetItem
         * @return {?}
         */function (targetItem) {
            /** @type {?} */
            var targetId = targetItem[options.identifier];
            /** @type {?} */
            var match = source.find(( /**
             * @param {?} s
             * @return {?}
             */function (s) { return targetId && s[options.identifier] === targetId; }));
            if (match) {
                /** @type {?} */
                var continueWithMerge = options.beforeMerge(targetItem, match);
                if (continueWithMerge !== false) {
                    mergeDeep(targetItem, match);
                }
                options.afterMerge(targetItem, match);
            }
        }));
        if (options.addMissing) {
            source
                .filter(( /**
         * @param {?} src
         * @return {?}
         */function (src) {
                return !target.find(( /**
                 * @param {?} x
                 * @return {?}
                 */function (x) { return src[options.identifier] && src[options.identifier] === x[options.identifier]; }));
            }))
                .forEach(( /**
         * @param {?} missing
         * @return {?}
         */function (missing) { return target.push(missing); }));
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     * @template T
     */
    var /**
     * @abstract
     * @template T
     */ BaseNotificationTracker = /** @class */ (function () {
        function BaseNotificationTracker(notify, log, config) {
            if (config === void 0) {
                config = { logErrors: true };
            }
            this.notify = notify;
            this.log = log;
            this.config = config;
            this.eventWatchers = [];
        }
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        BaseNotificationTracker.prototype.wait = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                this.waitResponse = this.notify.wait(message, title, config);
                // This method needs implemented in each implementation.
                this.emit('wait');
                return this;
            };
        /**
         * @param {?} predicate
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        BaseNotificationTracker.prototype.waitIf = /**
         * @param {?} predicate
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (predicate, message, title, config) {
                /** @type {?} */
                var doWait = isFunction(predicate)
                    ? (( /** @type {?} */(predicate)))()
                    : Boolean(predicate);
                return doWait ? this.wait(message, title, config) : this;
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        BaseNotificationTracker.prototype.success = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                this.config.showSuccess = true;
                this.config.successMsg = message;
                this.config.successTitle = title;
                this.config.successConfiguration = config;
                this.emit('success');
                return this;
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        BaseNotificationTracker.prototype.error = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                this.config.showError = true;
                this.config.errorMsg = message;
                this.config.errorTitle = title;
                this.config.errorConfiguration = config;
                this.emit('error');
                return this;
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        BaseNotificationTracker.prototype.warn = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                this.config.showWarn = true;
                this.config.warnMsg = message;
                this.config.warnTitle = title;
                this.config.warnConfiguration = config;
                this.emit('warn');
                return this;
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        BaseNotificationTracker.prototype.info = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                this.config.showInfo = true;
                this.config.infoMsg = message;
                this.config.infoTitle = title;
                this.config.infoConfiguration = config;
                this.emit('info');
                return this;
            };
        /**
         * @param {?} onDone
         * @return {?}
         */
        BaseNotificationTracker.prototype.finally = /**
         * @param {?} onDone
         * @return {?}
         */
            function (onDone) {
                this.onDone = onDone;
                this.emit('finally');
                return this;
            };
        /**
         * @param {?} eventType
         * @param {?} callback
         * @return {?}
         */
        BaseNotificationTracker.prototype.on = /**
         * @param {?} eventType
         * @param {?} callback
         * @return {?}
         */
            function (eventType, callback) {
                this.eventWatchers.push({ eventType: eventType, callback: callback });
            };
        /**
         * @protected
         * @param {?} eventType
         * @param {?=} event
         * @return {?}
         */
        BaseNotificationTracker.prototype.emit = /**
         * @protected
         * @param {?} eventType
         * @param {?=} event
         * @return {?}
         */
            function (eventType, event) {
                this.eventWatchers
                    .filter(( /**
             * @param {?} watcher
             * @return {?}
             */function (watcher) { return watcher.eventType === eventType; }))
                    .forEach(( /**
             * @param {?} watcher
             * @return {?}
             */function (watcher) { return watcher.callback(event); }));
            };
        /**
         * @protected
         * @param {?=} response
         * @return {?}
         */
        BaseNotificationTracker.prototype.done = /**
         * @protected
         * @param {?=} response
         * @return {?}
         */
            function (response) {
                if (this.waitResponse) {
                    this.notify.clear(this.waitResponse.notifyId, this.waitResponse.containerId);
                }
                if (this.onDone) {
                    this.onDone(response);
                }
            };
        /**
         * @protected
         * @param {?} response
         * @return {?}
         */
        BaseNotificationTracker.prototype.onSuccess = /**
         * @protected
         * @param {?} response
         * @return {?}
         */
            function (response) {
                if (this.config.showSuccess) {
                    this.notify.success(this.config.successMsg, this.config.successTitle, this.config.successConfiguration);
                }
                if (this.config.showInfo) {
                    this.notify.info(this.config.infoMsg, this.config.infoTitle, this.config.infoConfiguration);
                }
                this.done(response);
            };
        /**
         * @protected
         * @param {?} error
         * @return {?}
         */
        BaseNotificationTracker.prototype.onFail = /**
         * @protected
         * @param {?} error
         * @return {?}
         */
            function (error) {
                /** @type {?} */
                var responseError = (error.error || error) || error;
                /** @type {?} */
                var msg = errorMsg(this.config.errorMsg, responseError);
                if (this.log && this.config.logErrors) {
                    this.log.error(msg);
                }
                if (this.config.showError) {
                    this.notify.error(msg, this.config.errorTitle, responseError, this.config.errorConfiguration);
                }
                if (this.config.showWarn) {
                    this.notify.warn(msg, this.config.infoTitle, this.config.warnConfiguration);
                }
                this.done();
            };
        return BaseNotificationTracker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ NotificationPromiseTracker = /** @class */ (function (_super) {
        __extends(NotificationPromiseTracker, _super);
        function NotificationPromiseTracker(source, notify, log, config) {
            if (config === void 0) {
                config = {};
            }
            var _this = _super.call(this, notify, log, config) || this;
            _this.source = source;
            return _this;
        }
        /**
         * @param {?} message
         * @param {?=} title
         * @return {?}
         */
        NotificationPromiseTracker.prototype.wait = /**
         * @param {?} message
         * @param {?=} title
         * @return {?}
         */
            function (message, title) {
                var _this = this;
                _super.prototype.wait.call(this, message, title);
                this.source = this.source
                    .then(( /**
             * @param {?} result
             * @return {?}
             */function (result) {
                    _this.onSuccess(result);
                    return result;
                }))
                    .catch(( /**
             * @param {?} error
             * @return {?}
             */function (error) {
                    _this.onFail(error);
                    throw error;
                }));
                return this;
            };
        /**
         * @param {?} predicate
         * @param {?} message
         * @param {?=} title
         * @return {?}
         */
        NotificationPromiseTracker.prototype.waitIf = /**
         * @param {?} predicate
         * @param {?} message
         * @param {?=} title
         * @return {?}
         */
            function (predicate, message, title) {
                return ( /** @type {?} */(_super.prototype.waitIf.call(this, predicate, message, title)));
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @return {?}
         */
        NotificationPromiseTracker.prototype.success = /**
         * @param {?} message
         * @param {?=} title
         * @return {?}
         */
            function (message, title) {
                return ( /** @type {?} */(_super.prototype.success.call(this, message, title)));
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @return {?}
         */
        NotificationPromiseTracker.prototype.error = /**
         * @param {?} message
         * @param {?=} title
         * @return {?}
         */
            function (message, title) {
                return ( /** @type {?} */(_super.prototype.error.call(this, message, title)));
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @return {?}
         */
        NotificationPromiseTracker.prototype.warn = /**
         * @param {?} message
         * @param {?=} title
         * @return {?}
         */
            function (message, title) {
                return ( /** @type {?} */(_super.prototype.warn.call(this, message, title)));
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @return {?}
         */
        NotificationPromiseTracker.prototype.info = /**
         * @param {?} message
         * @param {?=} title
         * @return {?}
         */
            function (message, title) {
                return ( /** @type {?} */(_super.prototype.info.call(this, message, title)));
            };
        /**
         * @param {?} onDone
         * @return {?}
         */
        NotificationPromiseTracker.prototype.finally = /**
         * @param {?} onDone
         * @return {?}
         */
            function (onDone) {
                return ( /** @type {?} */(_super.prototype.finally.call(this, onDone)));
            };
        /**
         * @param {?=} onfulfilled
         * @return {?}
         */
        NotificationPromiseTracker.prototype.then = /**
         * @param {?=} onfulfilled
         * @return {?}
         */
            function (onfulfilled) {
                return this.source.then(onfulfilled);
            };
        /**
         * @param {?=} onrejected
         * @return {?}
         */
        NotificationPromiseTracker.prototype.catch = /**
         * @param {?=} onrejected
         * @return {?}
         */
            function (onrejected) {
                return this.source.catch(onrejected);
            };
        return NotificationPromiseTracker;
    }(BaseNotificationTracker));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ NotificationSubscriptionTracker = /** @class */ (function (_super) {
        __extends(NotificationSubscriptionTracker, _super);
        function NotificationSubscriptionTracker(source, notify, log, config) {
            if (config === void 0) {
                config = {};
            }
            var _this = _super.call(this, notify, log, config) || this;
            _this.source = source;
            // We need to do a timeout here so that the chained events coming in after this method will be fired
            // before this subscription is added - this is necessary for any synchronous/immediate observables.
            _this.source = _this.source.pipe(operators.tap(( /**
             * @param {?} x
             * @return {?}
             */function (x) {
                setTimeout(( /**
                 * @return {?}
                 */function () { return _this.onSuccess(x); }));
            }), ( /**
             * @param {?} error
             * @return {?}
             */function (error) {
                setTimeout(( /**
                 * @return {?}
                 */function () { return _this.onFail(error); }));
            })));
            if (_this.config.useSingletonSubscriptionEmission) {
                _this.source = _this.source.pipe(operators.publishReplay());
            }
            return _this;
        }
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        NotificationSubscriptionTracker.prototype.wait = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                return ( /** @type {?} */(_super.prototype.wait.call(this, message, title, config)));
            };
        /**
         * @param {?} predicate
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        NotificationSubscriptionTracker.prototype.waitIf = /**
         * @param {?} predicate
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (predicate, message, title, config) {
                return ( /** @type {?} */(_super.prototype.waitIf.call(this, predicate, message, title, config)));
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        NotificationSubscriptionTracker.prototype.success = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                return ( /** @type {?} */(_super.prototype.success.call(this, message, title, config)));
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        NotificationSubscriptionTracker.prototype.error = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                return ( /** @type {?} */(_super.prototype.error.call(this, message, title, config)));
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        NotificationSubscriptionTracker.prototype.warn = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                return ( /** @type {?} */(_super.prototype.warn.call(this, message, title, config)));
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        NotificationSubscriptionTracker.prototype.info = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                return ( /** @type {?} */(_super.prototype.info.call(this, message, title, config)));
            };
        /**
         * @param {?} onDone
         * @return {?}
         */
        NotificationSubscriptionTracker.prototype.finally = /**
         * @param {?} onDone
         * @return {?}
         */
            function (onDone) {
                return ( /** @type {?} */(_super.prototype.finally.call(this, onDone)));
            };
        /**
         * @param {?=} next
         * @param {?=} error
         * @param {?=} complete
         * @return {?}
         */
        NotificationSubscriptionTracker.prototype.subscribe = /**
         * @param {?=} next
         * @param {?=} error
         * @param {?=} complete
         * @return {?}
         */
            function (next, error, complete) {
                return this.source.subscribe(next, error, complete);
            };
        return NotificationSubscriptionTracker;
    }(BaseNotificationTracker));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var NotifyType = {
        Wait: 0,
        Success: 1,
        Info: 2,
        Warn: 3,
        Error: 4,
    };
    NotifyType[NotifyType.Wait] = 'Wait';
    NotifyType[NotifyType.Success] = 'Success';
    NotifyType[NotifyType.Info] = 'Info';
    NotifyType[NotifyType.Warn] = 'Warn';
    NotifyType[NotifyType.Error] = 'Error';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Notification service.
     */
    var NotifyService = /** @class */ (function () {
        function NotifyService(config, log) {
            this.config = config;
            this.log = log;
        }
        /**
         * @param {?} type
         * @param {?} message
         * @param {?} title
         * @param {?=} config
         * @return {?}
         */
        NotifyService.prototype.notify = /**
         * @param {?} type
         * @param {?} message
         * @param {?} title
         * @param {?=} config
         * @return {?}
         */
            function (type, message, title, config) {
                // Add actual notification implementation here.
                return {};
            };
        /**
         * @param {?=} notifyId
         * @param {?=} containerId
         * @return {?}
         */
        NotifyService.prototype.clear = /**
         * @param {?=} notifyId
         * @param {?=} containerId
         * @return {?}
         */
            function (notifyId, containerId) {
            };
        /**
         * @template T
         * @param {?} source
         * @return {?}
         */
        NotifyService.prototype.with = /**
         * @template T
         * @param {?} source
         * @return {?}
         */
            function (source) {
                return new NotificationSubscriptionTracker(source, this, this.log);
            };
        /**
         * @template T
         * @param {?} source
         * @return {?}
         */
        NotifyService.prototype.promise = /**
         * @template T
         * @param {?} source
         * @return {?}
         */
            function (source) {
                return new NotificationPromiseTracker(source, this, this.log);
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        NotifyService.prototype.wait = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                if (title === void 0) {
                    title = this.config.defaultNotifyWaitMsg;
                }
                return this.notify(NotifyType.Wait, message, title, config);
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        NotifyService.prototype.success = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                if (title === void 0) {
                    title = this.config.defaultNotifySuccessMsg;
                }
                return this.notify(NotifyType.Success, message, title, config);
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} error
         * @param {?=} config
         * @return {?}
         */
        NotifyService.prototype.error = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} error
         * @param {?=} config
         * @return {?}
         */
            function (message, title, error, config) {
                if (title === void 0) {
                    title = this.config.defaultNotifyErrorMsg;
                }
                if (error === void 0) {
                    error = null;
                }
                return this.notify(NotifyType.Error, format(message, { error: error }), title, config);
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} error
         * @param {?=} config
         * @return {?}
         */
        NotifyService.prototype.warn = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} error
         * @param {?=} config
         * @return {?}
         */
            function (message, title, error, config) {
                if (title === void 0) {
                    title = this.config.defaultNotifyWarnMsg;
                }
                if (error === void 0) {
                    error = null;
                }
                return this.notify(NotifyType.Warn, format(message, { error: error }), title, config);
            };
        /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
        NotifyService.prototype.info = /**
         * @param {?} message
         * @param {?=} title
         * @param {?=} config
         * @return {?}
         */
            function (message, title, config) {
                if (title === void 0) {
                    title = this.config.defaultNotifyInfoMsg;
                }
                return this.notify(NotifyType.Info, message, title, config);
            };
        NotifyService.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        NotifyService.ctorParameters = function () {
            return [
                { type: CoreConfig },
                { type: Logger }
            ];
        };
        /** @nocollapse */ NotifyService.ngInjectableDef = i0.defineInjectable({ factory: function NotifyService_Factory() { return new NotifyService(i0.inject(CoreConfig), i0.inject(Logger)); }, token: NotifyService, providedIn: "root" });
        return NotifyService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Assigns values from one object to another, but only for values that are valid (not null, undefined, or empty string).
     * Restriction properties can be passed in to specificy explicitly which properties to assign (if valid).
     * @template T
     * @param {?} targetItem
     * @param {?} sourceItem
     * @param {...?} restrictionProperties
     * @return {?}
     */
    function assignValidValues(targetItem, sourceItem) {
        var restrictionProperties = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            restrictionProperties[_i - 2] = arguments[_i];
        }
        if (restrictionProperties.length === 0) {
            restrictionProperties = Object.keys(sourceItem);
        }
        restrictionProperties
            .filter(( /**
     * @param {?} property
     * @return {?}
     */function (property) { return isValue(sourceItem[property]); }))
            .forEach(( /**
     * @param {?} property
     * @return {?}
     */function (property) { return targetItem[property] = sourceItem[property]; }));
        return targetItem;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // TODO: Refactor this method and give it proper names.
    // This was a copy/paste from online - RG.
    /**
     * @param {?} obj
     * @param {?} path
     * @return {?}
     */
    function getValue(obj, path) {
        /** @type {?} */
        var arr = path.split('.');
        while (arr.length && obj) {
            obj = obj[arr.shift()];
        }
        return obj;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns a random integer between min (inclusive) and max (inclusive)
     * Using Math.round() will give you a non-uniform distribution!
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    function getRandomInteger(min, max) {
        if (min === void 0) {
            min = 0;
        }
        if (max === void 0) {
            max = 1000;
        }
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns a random number between min (inclusive) and max (exclusive)
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    function getRandomNumber(min, max) {
        if (min === void 0) {
            min = 0;
        }
        if (max === void 0) {
            max = 10;
        }
        return Math.random() * (max - min) + min;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} numberToRound
     * @param {?=} decimalPlaces
     * @return {?}
     */
    function round(numberToRound, decimalPlaces) {
        if (decimalPlaces === void 0) {
            decimalPlaces = 3;
        }
        return isNumber(numberToRound)
            ? Number(numberToRound.toFixed(decimalPlaces))
            : numberToRound;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} list
     * @return {?}
     */
    function sortByOrder(list) {
        /** @type {?} */
        var compareResult = -1;
        list
            .sort(( /**
     * @param {?} compare1
     * @param {?} compare2
     * @return {?}
     */function (compare1, compare2) {
            if (!isNumber(compare2.order) || compare1.order < compare2.order) {
                compareResult = -1;
            }
            else if (!isNumber(compare1.order) || compare1.order > compare2.order) {
                compareResult = 1;
            }
            else if (compare1.order === compare2.order) {
                compareResult = 0;
            }
            return compareResult;
        }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} list
     * @return {?}
     */
    function sortAndReorder(list) {
        sortByOrder(list);
        list
            .forEach(( /**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */function (item, index) { return item.order = index + 1; }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var SortDirection = {
        Ascending: 0,
        Descending: 1,
    };
    SortDirection[SortDirection.Ascending] = 'Ascending';
    SortDirection[SortDirection.Descending] = 'Descending';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} list
     * @param {...?} sortProperties
     * @return {?}
     */
    function sortAscending(list) {
        var sortProperties = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sortProperties[_i - 1] = arguments[_i];
        }
        return sort.apply(void 0, __spread([list, SortDirection.Ascending], sortProperties));
    }
    /**
     * @template T
     * @param {?} list
     * @param {...?} sortProperties
     * @return {?}
     */
    function sortDescending(list) {
        var sortProperties = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sortProperties[_i - 1] = arguments[_i];
        }
        return sort.apply(void 0, __spread([list, SortDirection.Descending], sortProperties));
    }
    /**
     * @template T
     * @param {?} list
     * @param {?=} direction
     * @param {...?} sortProperties
     * @return {?}
     */
    function sort(list, direction) {
        if (direction === void 0) {
            direction = SortDirection.Ascending;
        }
        var sortProperties = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            sortProperties[_i - 2] = arguments[_i];
        }
        list.sort(( /**
         * @param {?} item1
         * @param {?} item2
         * @return {?}
         */function (item1, item2) {
            /** @type {?} */
            var sortResponse = 0;
            if (sortProperties && sortProperties.length) {
                sortProperties.forEach(( /**
                 * @param {?} property
                 * @return {?}
                 */function (property) {
                    if (sortResponse === 0) {
                        /** @type {?} */
                        var value1 = getPropertyValue(item1, property);
                        /** @type {?} */
                        var value2 = getPropertyValue(item2, property);
                        sortResponse = getSortResultForString(value1, value2, direction);
                    }
                }));
            }
            else {
                sortResponse = getSortResultForString(item1, item2, direction);
            }
            return sortResponse;
        }));
        return list;
    }
    /**
     * @template T
     * @param {?} item
     * @param {?} property
     * @return {?}
     */
    function getPropertyValue(item, property) {
        return isFunction(property)
            ? (( /** @type {?} */(property)))(item)
            : item[( /** @type {?} */(property))];
    }
    /**
     * @param {?} value1
     * @param {?} value2
     * @param {?} direction
     * @return {?}
     */
    function getSortResultForString(value1, value2, direction) {
        return direction === SortDirection.Ascending
            ? getSortResultForStringAscending(value1, value2)
            : getSortResultForStringDescending(value1, value2);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    function ensureValue(value) {
        return value === null || value === undefined ? '' : value;
    }
    /**
     * @param {?} value1
     * @param {?} value2
     * @return {?}
     */
    function getSortResultForStringAscending(value1, value2) {
        value1 = ensureValue(value1);
        value2 = ensureValue(value2);
        /** @type {?} */
        var compare1 = isString(value1) ? value1.toUpperCase() : value1;
        /** @type {?} */
        var compare2 = isString(value2) ? value2.toUpperCase() : value2;
        /** @type {?} */
        var compareResult = 0;
        if (compare1 < compare2) {
            compareResult = -1;
        }
        else if (compare1 > compare2) {
            compareResult = 1;
        }
        // NOTE: 0 = equals, 1 = greater, -1 less than.
        return compareResult;
    }
    /**
     * @param {?} value1
     * @param {?} value2
     * @return {?}
     */
    function getSortResultForStringDescending(value1, value2) {
        /** @type {?} */
        var compare1 = isString(value1) ? value1.toUpperCase() : value1;
        /** @type {?} */
        var compare2 = isString(value2) ? value2.toUpperCase() : value2;
        /** @type {?} */
        var compareResult = 0;
        if (compare1 > compare2) {
            compareResult = -1;
        }
        else if (compare1 < compare2) {
            compareResult = 1;
        }
        // NOTE: 0 = equals, 1 = greater, -1 less than.
        return compareResult;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} list
     * @return {?}
     */
    function average(list) {
        list = list.filter(( /**
         * @param {?} value
         * @return {?}
         */function (value) { return isNumber(value); }));
        /** @type {?} */
        var total = list.reduce(( /**
         * @param {?} current
         * @param {?} accumulating
         * @return {?}
         */function (current, accumulating) { return current + accumulating; }), 0);
        return total / list.length;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} x1
     * @param {?} y1
     * @param {?} x2
     * @param {?} y2
     * @param {?} testX
     * @param {?} testY
     * @return {?}
     */
    function calculateCrossProduct(x1, y1, x2, y2, testX, testY) {
        return (testX - x1) * (y2 - y1) - (testY - y1) * (x2 - x1);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} partialValue
     * @param {?} totalValue
     * @return {?}
     */
    function calculatePercentComplete(partialValue, totalValue) {
        return (100 * partialValue) / totalValue;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} totalProcessed
     * @param {?} ellapsedSeconds
     * @param {?} remainingCount
     * @return {?}
     */
    function calculateRemainingSeconds(totalProcessed, ellapsedSeconds, remainingCount) {
        /** @type {?} */
        var estimatedSecondsRemaining = -1;
        if (totalProcessed > 0) {
            estimatedSecondsRemaining = ellapsedSeconds / totalProcessed * remainingCount;
        }
        return estimatedSecondsRemaining;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} testNumber
     * @param {?} rangeStart
     * @param {?} rangeEnd
     * @return {?}
     */
    function isNumberBetweenOrEqual(testNumber, rangeStart, rangeEnd) {
        /** @type {?} */
        var minRange = Math.min(rangeStart, rangeEnd);
        /** @type {?} */
        var maxRange = Math.max(rangeStart, rangeEnd);
        return testNumber >= minRange && testNumber <= maxRange;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} testNumber
     * @param {?} rangeStart
     * @param {?} rangeEnd
     * @return {?}
     */
    function isNumberBetween(testNumber, rangeStart, rangeEnd) {
        /** @type {?} */
        var minRange = Math.min(rangeStart, rangeEnd);
        /** @type {?} */
        var maxRange = Math.max(rangeStart, rangeEnd);
        return testNumber > minRange && testNumber < maxRange;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} list
     * @param {?} predicate
     * @return {?}
     */
    function sum(list, predicate) {
        return list
            .reduce(( /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */function (a, b) {
            /** @type {?} */
            var value = predicate(b);
            value = isNumber(value) ? value : 0;
            return a + value;
        }), 0);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var StatsTracker = /** @class */ (function () {
        function StatsTracker() {
            var progressables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                progressables[_i] = arguments[_i];
            }
            this.progressables = progressables || [];
        }
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} progressable
         * @return {THIS}
         */
        StatsTracker.prototype.add = /**
         * @template THIS
         * @this {THIS}
         * @param {?} progressable
         * @return {THIS}
         */
            function (progressable) {
                ( /** @type {?} */(this)).progressables.push(progressable);
                return ( /** @type {?} */(this));
            };
        /**
         * @return {?}
         */
        StatsTracker.prototype.getPercentComplete = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var totalPercentComplete = sum(this.progressables, ( /**
                 * @param {?} p
                 * @return {?}
                 */function (p) { return p.percentComplete; }));
                /** @type {?} */
                var overallComplete = totalPercentComplete / this.progressables.length;
                return Math.round(overallComplete);
            };
        return StatsTracker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} list
     * @param {?} property
     * @return {?}
     */
    function sumProperty(list, property) {
        return sum(list, ( /**
         * @param {?} value
         * @return {?}
         */function (value) { return value[property]; }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} list
     * @return {?}
     */
    function sumValues(list) {
        return sum(list, ( /**
         * @param {?} value
         * @return {?}
         */function (value) { return value; }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var InMemoryStorage = /** @class */ (function (_super) {
        __extends(InMemoryStorage, _super);
        function InMemoryStorage() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.cache = new Map();
            return _this;
        }
        Object.defineProperty(InMemoryStorage.prototype, "length", {
            get: /**
             * @return {?}
             */ function () {
                return this.cache.size;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} key
         * @return {?}
         */
        InMemoryStorage.prototype.get = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return this.cache.get(this.formatKey(key));
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        InMemoryStorage.prototype.set = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                this.cache.set(this.formatKey(key), value);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        InMemoryStorage.prototype.remove = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                this.cache.delete(this.formatKey(key));
            };
        /**
         * @return {?}
         */
        InMemoryStorage.prototype.clear = /**
         * @return {?}
         */
            function () {
                this.cache.clear();
            };
        InMemoryStorage.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */ InMemoryStorage.ngInjectableDef = i0.defineInjectable({ factory: function InMemoryStorage_Factory() { return new InMemoryStorage(); }, token: InMemoryStorage, providedIn: "root" });
        return InMemoryStorage;
    }(BaseStorage));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} template
     * @return {?}
     */
    function extractTokens(template) {
        template = standardizeTokens(template);
        return template.match(new RegExp(TOKEN_EXPRESSION));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} template
     * @return {?}
     */
    function extractTokenExpressions(template) {
        return extractTokens(template)
            .map(( /**
     * @param {?} tokenDefinition
     * @return {?}
     */function (tokenDefinition) { return stripTokenBraces(tokenDefinition); }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isBoolean(val) {
        return isType(val, 'boolean');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isNotArray(val) {
        return !isArray(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isNotBoolean(val) {
        return !isBoolean(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isNotDate(val) {
        return !isDate(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isNotDefined(val) {
        return !isDefined(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isNotFunction(val) {
        return !isFunction(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isNotNumber(val) {
        return !isNumber(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isNotObject(val) {
        return !isObject(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isPrimitive(val) {
        return isNotFunction(val) && this.isNotObject(val) && isNotArray(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isNotPrimitive(val) {
        return !isPrimitive(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @return {?}
     */
    function isNotString(val) {
        return !isString(val);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} val
     * @param {?} expectedType
     * @return {?}
     */
    function isNotType(val, expectedType) {
        return !isType(val, expectedType);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var AreaUnit = {
        Acres: 'acres',
        Hectares: 'hectares',
        SquareFeet: 'square-feet',
        SquareMeters: 'square-meters',
        SquareMiles: 'square-miles',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} fromUnit
     * @param {?} toUnit
     * @return {?}
     */
    function convertAreaUnits(fromUnit, toUnit) {
        throw new Error("'convertAreaUnits' is not implemented yet");
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var LengthUnit = {
        Foot: 'foot',
        Degree: 'degree',
        Radian: 'radian',
        Mile: 'mile',
        Meter: 'meter',
        Kilometer: 'kilometer',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function getMeterConversionFactors() {
        /** @type {?} */
        var factors = {};
        factors[LengthUnit.Foot] = 0.3048;
        factors[LengthUnit.Kilometer] = 1000;
        factors[LengthUnit.Meter] = 1;
        factors[LengthUnit.Mile] = 1609.34;
        return factors;
    }
    /** @type {?} */
    var LENGTH_UNIT_METER_CONVERSION_FACTOR = getMeterConversionFactors();

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @param {?} fromUnit
     * @return {?}
     */
    function toMeters(value, fromUnit) {
        /** @type {?} */
        var conversionFactor = LENGTH_UNIT_METER_CONVERSION_FACTOR[fromUnit];
        if (isNotNumber(conversionFactor)) {
            throw new Error("Can not convert unsupported unit: '" + fromUnit + "'");
        }
        return value * conversionFactor;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @param {?} toUnit
     * @return {?}
     */
    function fromMeters(value, toUnit) {
        /** @type {?} */
        var conversionFactor = LENGTH_UNIT_METER_CONVERSION_FACTOR[toUnit];
        if (!isNumber(conversionFactor)) {
            throw new Error("Can not convert unsupported unit: '" + toUnit + "'");
        }
        return value / conversionFactor;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} fromValue
     * @param {?} fromUnit
     * @param {?} toUnit
     * @return {?}
     */
    function convertLengthUnits(fromValue, fromUnit, toUnit) {
        /** @type {?} */
        var fromValueInMeters = toMeters(fromValue, fromUnit);
        return fromMeters(fromValueInMeters, toUnit);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} metersPerSecond
     * @return {?}
     */
    function metersPerSecondToKilometersPerHour(metersPerSecond) {
        return metersPerSecond * 3.6;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} metersPerSecond
     * @return {?}
     */
    function metersPerSecondToMilesPerHour(metersPerSecond) {
        return metersPerSecond * 2.237;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} url
     * @return {?}
     */
    function ensureProtocol(url) {
        if (hasWindow() && String(url).startsWith('//')) {
            url = "" + window.location.protocol + url;
        }
        return url;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} url
     * @return {?}
     */
    function getBaseUrl(url) {
        var _a;
        var _b = __read(clean(url).split('#'), 1), someUrl = _b[0];
        _a = __read(someUrl.split('?'), 1), someUrl = _a[0];
        return someUrl;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} tokens
     * @param {...?} parts
     * @return {?}
     */
    function joinAndFomat(tokens) {
        var parts = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            parts[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var url = join.apply(void 0, __spread(parts));
        return format(url, tokens);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} queryParameters
     * @return {?}
     */
    function parametersToString(queryParameters) {
        return Object
            .keys(queryParameters)
            .filter(( /**
     * @param {?} key
     * @return {?}
     */function (key) { return isValue(queryParameters[key]); }))
            .map(( /**
     * @param {?} key
     * @return {?}
     */function (key) {
            /** @type {?} */
            var value = isObject(queryParameters[key])
                ? JSON.stringify(queryParameters[key])
                : queryParameters[key];
            return key + "=" + value;
        }))
            .join('&');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EMPTY_PARAMS_REGEX = /(&?\w+=((?=$)|(?=&)))/g;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} url
     * @return {?}
     */
    function removeEmptyParams(url) {
        return url.replace(EMPTY_PARAMS_REGEX, '');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} url
     * @return {?}
     */
    function stripTrailingSlash(url) {
        return trimEnd(url, '/');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Provides a syntax that ensures the correct use of Disposable objects.
     * @template T
     * @param {?} resource
     * @param {?} func
     * @return {?}
     */
    function using(resource, func) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, , 2, 4]);
                        return [4 /*yield*/, func(resource)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, resource.dispose()];
                    case 3:
                        _a.sent();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var INVALID_GUID_ERROR_MSG = 'Invalid GUID value provided';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} replaceValue
     * @return {?}
     */
    function uuidValueReplacer(replaceValue) {
        // tslint:disable-next-line
        /** @type {?} */
        var randomValue = Math.random() * 16 | 0;
        // tslint:disable-next-line
        /** @type {?} */
        var value = replaceValue === 'x' ? randomValue : (randomValue & 0x3 | 0x8);
        return value.toString(16);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function uuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
            .replace(new RegExp('[xy]', 'g'), uuidValueReplacer);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a Global Unique Identifier (GUID). GUID creation ported from:
     * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
     */
    var Guid = /** @class */ (function () {
        function Guid(value) {
            this.value = value || Guid.empty;
            if (!Guid.isValid(value)) {
                throw new Error(INVALID_GUID_ERROR_MSG);
            }
        }
        Object.defineProperty(Guid.prototype, "isEmpty", {
            get: /**
             * @return {?}
             */ function () {
                return this.value === Guid.empty;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        Guid.newGuid = /**
         * @return {?}
         */
            function () {
                return new Guid(uuid());
            };
        /**
         * @param {?} str
         * @return {?}
         */
        Guid.isValid = /**
         * @param {?} str
         * @return {?}
         */
            function (str) {
                /** @type {?} */
                var validRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
                return validRegex.test(str);
            };
        /**
         * @param {?} guid
         * @return {?}
         */
        Guid.prototype.equals = /**
         * @param {?} guid
         * @return {?}
         */
            function (guid) {
                return guid.toString() === this.toString();
            };
        /**
         * @return {?}
         */
        Guid.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this.value;
            };
        /**
         * @return {?}
         */
        Guid.prototype.toJSON = /**
         * @return {?}
         */
            function () {
                return this.value;
            };
        Guid.empty = '00000000-0000-0000-0000-000000000000';
        return Guid;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ValidationResult = /** @class */ (function () {
        function ValidationResult() {
            this.violaters = [];
        }
        Object.defineProperty(ValidationResult.prototype, "failed", {
            get: /**
             * @return {?}
             */ function () {
                return this.ran && !this.passed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValidationResult.prototype, "skipped", {
            get: /**
             * @return {?}
             */ function () {
                return this.validationSkipped;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.validationSkipped = value;
                this.ran = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} inner
         * @return {?}
         */
        ValidationResult.prototype.add = /**
         * @param {?} inner
         * @return {?}
         */
            function (inner) {
                if (inner.failed) {
                    this.passed = false;
                }
                if (inner.warned) {
                    this.warned = true;
                }
                return this;
            };
        return ValidationResult;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var BASE_ID = 1;
    /**
     * @template T
     */
    var /**
     * @template T
     */ ValidationCheck = /** @class */ (function () {
        function ValidationCheck(description, passCheck) {
            this.subChecks = [];
            this.description = description;
            this.passCheck = passCheck;
            this.id = BASE_ID++;
        }
        /**
         * @param {?} id
         * @return {?}
         */
        ValidationCheck.prototype.hasId = /**
         * @param {?} id
         * @return {?}
         */
            function (id) {
                this.id = id;
                return this;
            };
        /**
         * @param {?} description
         * @return {?}
         */
        ValidationCheck.prototype.message = /**
         * @param {?} description
         * @return {?}
         */
            function (description) {
                this.description = description;
                return this;
            };
        /**
         * @param {?=} passCheck
         * @return {?}
         */
        ValidationCheck.prototype.pass = /**
         * @param {?=} passCheck
         * @return {?}
         */
            function (passCheck) {
                this.passCheck = passCheck;
                return this;
            };
        /**
         * @param {?=} failCheck
         * @return {?}
         */
        ValidationCheck.prototype.fail = /**
         * @param {?=} failCheck
         * @return {?}
         */
            function (failCheck) {
                this.failCheck = failCheck;
                return this;
            };
        /**
         * @param {?=} warnCheck
         * @return {?}
         */
        ValidationCheck.prototype.warn = /**
         * @param {?=} warnCheck
         * @return {?}
         */
            function (warnCheck) {
                this.warnCheck = warnCheck;
                return this;
            };
        /**
         * @param {?=} onlyIfCheck
         * @return {?}
         */
        ValidationCheck.prototype.onlyIf = /**
         * @param {?=} onlyIfCheck
         * @return {?}
         */
            function (onlyIfCheck) {
                this.onlyIfCheck = onlyIfCheck;
                return this;
            };
        /**
         * @param {...?} innerChecks
         * @return {?}
         */
        ValidationCheck.prototype.add = /**
         * @param {...?} innerChecks
         * @return {?}
         */
            function () {
                var _this = this;
                var innerChecks = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    innerChecks[_i] = arguments[_i];
                }
                innerChecks.forEach(( /**
                 * @param {?} inner
                 * @return {?}
                 */function (inner) { return _this.subChecks.push(inner); }));
                return this;
            };
        /**
         * @param {?} target
         * @return {?}
         */
        ValidationCheck.prototype.check = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                /** @type {?} */
                var result = new ValidationResult();
                if (this.onlyIfCheck && !this.onlyIfCheck(target)) {
                    result.skipped = true;
                    return result;
                }
                if (this.passCheck) {
                    result.passed = this.passCheck(target);
                }
                if (this.failCheck) {
                    result.passed = !this.failCheck(target);
                }
                if (this.warnCheck) {
                    result.warned = !this.warnCheck(target);
                }
                if (this.subChecks) {
                    this.subChecks.forEach(( /**
                     * @param {?} c
                     * @return {?}
                     */function (c) {
                        /** @type {?} */
                        var innerResult = c.check(target);
                        result.add(innerResult);
                    }));
                }
                return result;
            };
        return ValidationCheck;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing csv-related settings.
     */
    var CsvConfig = /** @class */ (function () {
        function CsvConfig() {
        }
        CsvConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ CsvConfig.ngInjectableDef = i0.defineInjectable({ factory: function CsvConfig_Factory() { return new CsvConfig(); }, token: CsvConfig, providedIn: "root" });
        /**
         * Configuration class for storing csv-related settings.
         */
        CsvConfig = __decorate([
            AutoConfig('CsvConfig')
        ], CsvConfig);
        return CsvConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CSV_NEW_LINE = '\r';
    /** @type {?} */
    var CSV_SEPARATOR = ',';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssCsvModule = /** @class */ (function () {
        function TssCsvModule() {
        }
        TssCsvModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            TssCoreModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssCsvModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} data
     * @param {...?} properties
     * @return {?}
     */
    function toCsv(data) {
        var properties = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            properties[_i - 1] = arguments[_i];
        }
        var _a = __read(data, 1), firstItem = _a[0];
        /** @type {?} */
        var csv = '';
        if (firstItem) {
            // NOTE: We need to clone the object here because we can't trust on Object.keys working
            // on every object type. For example, a true "coordinate", object.keys doesn't work - RG.
            properties = properties && properties.length
                ? properties
                : Object.keys(clone(firstItem));
            /** @type {?} */
            var header = "" + properties.join(CSV_SEPARATOR);
            /** @type {?} */
            var csvLines = data.map(( /**
             * @param {?} point
             * @return {?}
             */function (point) {
                /** @type {?} */
                var fields = properties.map(( /**
                 * @param {?} property
                 * @return {?}
                 */function (property) {
                    /** @type {?} */
                    var value = point[property];
                    /** @type {?} */
                    var hasPropertyValue = isDefined(value);
                    return hasPropertyValue ? value : '';
                }));
                return fields.join(CSV_SEPARATOR);
            }));
            csv = "" + header + CSV_NEW_LINE + csvLines.join(CSV_NEW_LINE);
        }
        return csv;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} geometry
     * @return {?}
     */
    function isLine(geometry) {
        return Boolean(geometry
            && geometry.type
            && String(geometry.type)
                .toLowerCase()
                .includes('linestring'));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @return {?}
     */
    function isMultiPartLine(line) {
        return Boolean(line
            && line.length
            && isArray(line[0])
            && isArray(line[0][0]));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @return {?}
     */
    function toMultiPartPaths(line) {
        if (isArray(line)) {
            /** @type {?} */
            var lineAsArray = (( /** @type {?} */(line)));
            return isMultiPartLine(lineAsArray)
                ? lineAsArray
                : [lineAsArray];
        }
        else {
            /** @type {?} */
            var lineGeometry = ( /** @type {?} */(line));
            return lineGeometry.type === 'LineString'
                ? [lineGeometry.coordinates]
                : lineGeometry.coordinates;
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @return {?}
     */
    function flattenLine(line) {
        /** @type {?} */
        var flattenedPoints = [];
        /** @type {?} */
        var multipParts = toMultiPartPaths(line);
        multipParts.forEach(( /**
         * @param {?} part
         * @return {?}
         */function (part) {
            part.forEach(( /**
             * @param {?} position
             * @return {?}
             */function (position) {
                flattenedPoints.push(position);
            }));
        }));
        return flattenedPoints;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} geometry
     * @return {?}
     */
    function isPoint(geometry) {
        return geometry && geometry.type
            ? geometry.type === 'Point' || geometry.type === 'MultiPoint'
            : false;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} point
     * @return {?}
     */
    function isMultiPartPoint(point) {
        /** @type {?} */
        var coordinates = isArray(point)
            ? (( /** @type {?} */(point)))
            : (( /** @type {?} */(point))).coordinates;
        return Boolean(coordinates
            && coordinates.length
            && isArray(coordinates[0]));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} point
     * @return {?}
     */
    function toMultiPartPoint(point) {
        /** @type {?} */
        var coordinates = isArray(point)
            ? (( /** @type {?} */(point)))
            : (( /** @type {?} */(point))).coordinates;
        return isMultiPartPoint(coordinates)
            ? ( /** @type {?} */(coordinates))
            : [( /** @type {?} */(coordinates))];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} geometry
     * @return {?}
     */
    function isPolygon(geometry) {
        return geometry && geometry.type
            ? geometry.type === 'Polygon' || geometry.type === 'MultiPolygon'
            : false;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} geometry
     * @param {...?} verticeeOrdinalNames
     * @return {?}
     */
    function geometryToCsv(geometry) {
        var verticeeOrdinalNames = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            verticeeOrdinalNames[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var pointInfos = [];
        /** @type {?} */
        var verticees = [];
        if (isLine(geometry)) {
            verticees = flattenLine(( /** @type {?} */(geometry)));
        }
        else if (isPoint(geometry)) {
            verticees = toMultiPartPoint(( /** @type {?} */(geometry)));
        }
        else if (isPolygon(geometry)) {
            /** @type {?} */
            var polygon = ( /** @type {?} */(geometry));
            verticees = flattenLine(polygon.coordinates);
        }
        else {
            throw new Error('Unknown or unsupported geometry type provided');
        }
        verticees.map(( /**
         * @param {?} verticee
         * @return {?}
         */function (verticee) {
            /** @type {?} */
            var info = {};
            pointInfos.push(info);
            if (!verticeeOrdinalNames || !verticeeOrdinalNames.length) {
                verticeeOrdinalNames = ['x', 'y'];
                if (verticee.length > 2) {
                    verticeeOrdinalNames.push('z');
                }
                if (verticee.length > 3) {
                    verticeeOrdinalNames.push('m');
                }
            }
            verticeeOrdinalNames.forEach(( /**
             * @param {?} name
             * @param {?} index
             * @return {?}
             */function (name, index) {
                info[name] = verticee[index];
            }));
        }));
        return toCsv(pointInfos);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var APPLY_EDITS_SEED_POD_FILE_EXTENSION = '.tssedits';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing global ESRI-related settings.
     */
    var DataSourceConfig = /** @class */ (function (_super) {
        __extends(DataSourceConfig, _super);
        function DataSourceConfig() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.dataSourcesEndpoint = 'api/data/sources/{id}';
            _this.tablesEndpoint = 'api/data/sources/{id}/tables';
            _this.columnsEndpoint = 'api/data/sources/{id}/tables/{table}/columns/{column}/{action}';
            _this.tableActionEndpoint = 'api/data/sources/{id}/tables/{table}/{action}/{subaction}';
            _this.editDataEndpoint = 'api/data/sources/{id}/tables/{table}/edit';
            _this.applyEditsEndpoint = 'api/data/sources/{id}/applyedits';
            _this.attachmentsEndpoint = 'api/attachments/{id}/{action}';
            _this.skipColumnQuotes = false;
            return _this;
        }
        DataSourceConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ DataSourceConfig.ngInjectableDef = i0.defineInjectable({ factory: function DataSourceConfig_Factory() { return new DataSourceConfig(); }, token: DataSourceConfig, providedIn: "root" });
        /**
         * Configuration class for storing global ESRI-related settings.
         */
        DataSourceConfig = __decorate([
            AutoConfig('DataSourceConfig')
        ], DataSourceConfig);
        return DataSourceConfig;
    }(ResourceConfig));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DataSourceEditService = /** @class */ (function (_super) {
        __extends(DataSourceEditService, _super);
        function DataSourceEditService(http, dsConfig) {
            var _this = _super.call(this, http, {
                url: dsConfig.serviceUrl
            }) || this;
            _this.http = http;
            _this.dsConfig = dsConfig;
            return _this;
        }
        /**
         * @param {?} data
         * @param {?=} params
         * @return {?}
         */
        DataSourceEditService.prototype.applyEdits = /**
         * @param {?} data
         * @param {?=} params
         * @return {?}
         */
            function (data, params) {
                if (!data) {
                    throw new Error('Missing or invalid apply edits seed data provided');
                }
                else if (!data.dataSourceId) {
                    throw new Error("Missing 'dataSourceId' from the apply edits seed data");
                }
                /** @type {?} */
                var url = this.getUrlWithId(data.dataSourceId, this.dsConfig.applyEditsEndpoint, {});
                return this.http.post(url, data, { params: params });
            };
        /**
         * @param {?} dataSourceId
         * @param {?} table
         * @param {?} feature
         * @param {?=} version
         * @param {?=} params
         * @return {?}
         */
        DataSourceEditService.prototype.createRecord = /**
         * @param {?} dataSourceId
         * @param {?} table
         * @param {?} feature
         * @param {?=} version
         * @param {?=} params
         * @return {?}
         */
            function (dataSourceId, table, feature, version, params) {
                /** @type {?} */
                var url = this.getUrlWithId(dataSourceId, this.dsConfig.editDataEndpoint, { table: table });
                params = (params || new i1$1.HttpParams())
                    .set('version', version || EMPTY_PARAM_VALUE);
                return this.http.post(url, feature, { params: params });
            };
        DataSourceEditService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        DataSourceEditService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: DataSourceConfig }
            ];
        };
        /** @nocollapse */ DataSourceEditService.ngInjectableDef = i0.defineInjectable({ factory: function DataSourceEditService_Factory() { return new DataSourceEditService(i0.inject(i1$1.HttpClient), i0.inject(DataSourceConfig)); }, token: DataSourceEditService, providedIn: "root" });
        return DataSourceEditService;
    }(BaseEmptyResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var AttachmentType = {
        Video: 'video',
        Image: 'image',
        Audio: 'audio',
        Text: 'text',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} value
     * @param {?=} encodeData
     * @return {?}
     */
    function toFormDataString(value, encodeData) {
        if (encodeData === void 0) {
            encodeData = true;
        }
        /** @type {?} */
        var stringValue;
        if (isNotValue(value)) {
            stringValue = '';
        }
        else if (isObject(value) || isArray(value)) {
            stringValue = JSON.stringify(value);
        }
        else {
            stringValue = value.toString();
        }
        return isValue(stringValue) && encodeData ?
            encodeURIComponent(stringValue)
            : stringValue;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ATTACHMENT_FILE_FORM_KEY = 'file';
    /** @type {?} */
    var ATTACHMENT_DATA_FORM_KEY = 'attachment';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AttachmentService = /** @class */ (function (_super) {
        __extends(AttachmentService, _super);
        function AttachmentService(http, dsConfig) {
            var _this = _super.call(this, http, {
                url: dsConfig.serviceUrl,
                queryEndpoint: dsConfig.attachmentsEndpoint,
                getEndpoint: dsConfig.attachmentsEndpoint,
                updateEndpoint: dsConfig.attachmentsEndpoint,
                deleteEndpoint: dsConfig.attachmentsEndpoint,
                createEndpoint: dsConfig.attachmentsEndpoint,
            }) || this;
            _this.http = http;
            return _this;
        }
        /**
         * @param {?} attachment
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        AttachmentService.prototype.create = /**
         * @param {?} attachment
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (attachment, routeTokens, params) {
                /** @type {?} */
                var url = this.getUrl(this.config.createEndpoint, routeTokens);
                /** @type {?} */
                var formData = new FormData();
                /** @type {?} */
                var fileData;
                if (attachment.type === AttachmentType.Image && isString(attachment.data)) {
                    fileData = base64toBlob(( /** @type {?} */(attachment.data)));
                }
                else if (attachment.type === AttachmentType.Text) {
                    fileData = new Blob([attachment.data]);
                }
                else {
                    fileData = ( /** @type {?} */(attachment.data));
                }
                delete attachment.data;
                formData.append(ATTACHMENT_FILE_FORM_KEY, fileData);
                formData.append(ATTACHMENT_DATA_FORM_KEY, toFormDataString(attachment));
                return this.http.post(url, formData, { params: params, reportProgress: true });
            };
        /**
         * @param {?} attachmentId
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        AttachmentService.prototype.download = /**
         * @param {?} attachmentId
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (attachmentId, routeTokens, params) {
                // TODO: Complete - RG.
                // const url = this.getUrl(this.config.getEndpoint, Object.assign({ action: 'download' }, routeTokens));
                throw new Error('Not implemented yet');
            };
        AttachmentService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        AttachmentService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: DataSourceConfig }
            ];
        };
        /** @nocollapse */ AttachmentService.ngInjectableDef = i0.defineInjectable({ factory: function AttachmentService_Factory() { return new AttachmentService(i0.inject(i1$1.HttpClient), i0.inject(DataSourceConfig)); }, token: AttachmentService, providedIn: "root" });
        return AttachmentService;
    }(BaseResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var DataSourceProviderType = {
        SqlServer: 'System.Data.SqlClient',
        SqlLite: 'System.Data.SQLite',
        SqlCompactEdition: 'System.Data.SqlServerCe.4.0',
        Oracle: 'Oracle.ManagedDataAccess.Client',
        OracleDevArt: 'Devart.Data.Oracle',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SELECT_ALL_WHERE_CLAUSE = '1=1';
    /** @type {?} */
    var DATA_SOURCE_PROVIDERS = [
        { alias: 'SQL Server', provider: DataSourceProviderType.SqlServer, canUseEF: true, schedulingCompatible: true },
        { alias: 'SQLite', provider: DataSourceProviderType.SqlLite, canUseEF: false, schedulingCompatible: true },
        {
            alias: 'SQL Server Compact Edition',
            provider: DataSourceProviderType.SqlCompactEdition,
            canUseEF: true,
            schedulingCompatible: false
        },
        { alias: 'Oracle', provider: DataSourceProviderType.Oracle, canUseEF: false, schedulingCompatible: false },
        { alias: 'Oracle', provider: DataSourceProviderType.OracleDevArt, canUseEF: true, efOnly: true, schedulingCompatible: false }
    ];
    /** @type {?} */
    var DATA_SOURCE_EXAMPLES = [
        {
            name: 'SQL Server Connection',
            providerName: DataSourceProviderType.SqlServer,
            connectionString: 'data source=YOUR_HOST, 1433;initial catalog=YOUR_DB;persist security info=True;'
                + 'user id=YOUR_USER;password=YOUR_PASSWORD;MultipleActiveResultSets=true;'
        },
        {
            name: 'SQL Server Compact (SQL CE) Connection',
            providerName: DataSourceProviderType.SqlCompactEdition,
            connectionString: 'Data Source=|DataDirectory|\\YOUR_DB_NAME.sdf;Max Database Size=4091'
        },
        {
            name: 'SQLite',
            providerName: DataSourceProviderType.SqlLite,
            connectionString: 'Data Source=|DataDirectory|\\YOUR_DB_NAME.sqlite;Version=3'
        },
        {
            name: 'Oracle Connection (without TNS names entry)',
            providerName: DataSourceProviderType.Oracle,
            connectionString: 'Data Source=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)'
                + '(HOST=YOUR_HOST)(PORT=1522)))(CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=YOUR_SERVICE)));'
                + 'User Id=YOUR_USER;Password=YOUR_PASSWORD;'
        },
        {
            name: 'Oracle Connection (with TNS names entry)',
            providerName: DataSourceProviderType.Oracle,
            connectionString: 'Data Source=YOUR_SOURCE;User Id=YOUR_USER;Password=YOUR_PASSWORD;'
        },
        {
            name: 'Oracle Connection (without TNS names entry)',
            providerName: DataSourceProviderType.OracleDevArt,
            connectionString: 'Data Source=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)'
                + '(HOST=YOUR_HOST)(PORT=1522)))(CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=YOUR_SERVICE)));'
                + 'User Id=YOUR_USER;Password=YOUR_PASSWORD;'
        },
        {
            name: 'Oracle Connection (with TNS names entry)',
            providerName: DataSourceProviderType.OracleDevArt,
            connectionString: 'Data Source=YOUR_SOURCE;User Id=YOUR_USER;Password=YOUR_PASSWORD;'
        }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DataSourceService = /** @class */ (function (_super) {
        __extends(DataSourceService, _super);
        function DataSourceService(http, dsConfig) {
            var _this = _super.call(this, http, {
                url: dsConfig.serviceUrl,
                queryEndpoint: dsConfig.dataSourcesEndpoint,
                getEndpoint: dsConfig.dataSourcesEndpoint,
                updateEndpoint: dsConfig.dataSourcesEndpoint,
                deleteEndpoint: dsConfig.dataSourcesEndpoint,
                createEndpoint: dsConfig.dataSourcesEndpoint,
            }) || this;
            _this.http = http;
            _this.dsConfig = dsConfig;
            return _this;
        }
        /**
         * @param {?} entity
         * @param {?} useEntityFramework
         * @param {?=} params
         * @return {?}
         */
        DataSourceService.prototype.testConnection = /**
         * @param {?} entity
         * @param {?} useEntityFramework
         * @param {?=} params
         * @return {?}
         */
            function (entity, useEntityFramework, params) {
                throw new Error('Not implemented yet');
            };
        /**
         * @param {?} id
         * @param {?=} params
         * @return {?}
         */
        DataSourceService.prototype.testExistingConnection = /**
         * @param {?} id
         * @param {?=} params
         * @return {?}
         */
            function (id, params) {
                throw new Error('Not implemented yet');
            };
        // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables'
        // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables'
        /**
         * @param {?} dataSourceId
         * @param {?=} params
         * @return {?}
         */
        DataSourceService.prototype.getTables =
            // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables'
            /**
             * @param {?} dataSourceId
             * @param {?=} params
             * @return {?}
             */
            function (dataSourceId, params) {
                /** @type {?} */
                var url = this.getUrlWithId(dataSourceId, this.dsConfig.tablesEndpoint, {});
                return this.http.get(url, { params: params });
            };
        // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables/details'
        // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables/details'
        /**
         * @param {?} dataSourceId
         * @param {?=} params
         * @return {?}
         */
        DataSourceService.prototype.getTableDetails =
            // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables/details'
            /**
             * @param {?} dataSourceId
             * @param {?=} params
             * @return {?}
             */
            function (dataSourceId, params) {
                /** @type {?} */
                var url = this.getUrlWithId(dataSourceId, this.dsConfig.tableActionEndpoint, {
                    action: 'details'
                });
                return this.http.get(url, { params: params });
            };
        // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables/:table/columns/:column/:action',
        // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables/:table/columns/:column/:action',
        /**
         * @param {?} dataSourceId
         * @param {?} table
         * @param {?=} params
         * @return {?}
         */
        DataSourceService.prototype.getColumns =
            // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables/:table/columns/:column/:action',
            /**
             * @param {?} dataSourceId
             * @param {?} table
             * @param {?=} params
             * @return {?}
             */
            function (dataSourceId, table, params) {
                /** @type {?} */
                var url = this.getUrlWithId(dataSourceId, this.dsConfig.columnsEndpoint, { table: table });
                return this.http.get(url, { params: params });
            };
        // api/data/sources/test_1051_sql/tables/RH.DIVIDED_ROADS/columns/SurveyDirection/values?unique=false
        // api/data/sources/test_1051_sql/tables/RH.DIVIDED_ROADS/columns/SurveyDirection/values?unique=false
        /**
         * @template T
         * @param {?} dataSourceId
         * @param {?} table
         * @param {?} column
         * @param {?=} unique
         * @param {?=} params
         * @return {?}
         */
        DataSourceService.prototype.getColumnValues =
            // api/data/sources/test_1051_sql/tables/RH.DIVIDED_ROADS/columns/SurveyDirection/values?unique=false
            /**
             * @template T
             * @param {?} dataSourceId
             * @param {?} table
             * @param {?} column
             * @param {?=} unique
             * @param {?=} params
             * @return {?}
             */
            function (dataSourceId, table, column, unique, params) {
                if (unique === void 0) {
                    unique = false;
                }
                /** @type {?} */
                var url = this.getUrlWithId(dataSourceId, this.dsConfig.columnsEndpoint, {
                    table: table,
                    column: column,
                    action: 'values'
                });
                params = (params || new i1$1.HttpParams()).set('unique', String(unique));
                return this.http.get(url, { params: params });
            };
        // api/data/sources/test_1051_sql/tables/RH.DIVIDED_ROADS/columns/SurveyDirection/values?unique=true
        // api/data/sources/test_1051_sql/tables/RH.DIVIDED_ROADS/columns/SurveyDirection/values?unique=true
        /**
         * @template T
         * @param {?} dataSourceId
         * @param {?} table
         * @param {?} column
         * @param {?=} params
         * @return {?}
         */
        DataSourceService.prototype.getUniqueColumnValues =
            // api/data/sources/test_1051_sql/tables/RH.DIVIDED_ROADS/columns/SurveyDirection/values?unique=true
            /**
             * @template T
             * @param {?} dataSourceId
             * @param {?} table
             * @param {?} column
             * @param {?=} params
             * @return {?}
             */
            function (dataSourceId, table, column, params) {
                return this.getColumnValues(dataSourceId, table, column, true, params);
            };
        // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables/:count'
        // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables/:count'
        /**
         * @param {?} dataSourceId
         * @param {?} table
         * @param {?=} whereClause
         * @param {?=} version
         * @param {?=} params
         * @return {?}
         */
        DataSourceService.prototype.getRecordCount =
            // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables/:count'
            /**
             * @param {?} dataSourceId
             * @param {?} table
             * @param {?=} whereClause
             * @param {?=} version
             * @param {?=} params
             * @return {?}
             */
            function (dataSourceId, table, whereClause, version, params) {
                if (whereClause === void 0) {
                    whereClause = SELECT_ALL_WHERE_CLAUSE;
                }
                /** @type {?} */
                var url = this.getUrlWithId(dataSourceId, this.dsConfig.tableActionEndpoint, {
                    table: table,
                    action: 'count'
                });
                params = (params || new i1$1.HttpParams())
                    .set('where', whereClause)
                    .set('version', version || EMPTY_PARAM_VALUE);
                return this.http.get(url, { params: params });
            };
        // api/data/sources/test_1051_sql/tables/RH.DIVIDED_ROADS/query/details?page=1&pageSize=25&where=1%3D1
        // api/data/sources/test_1051_sql/tables/RH.DIVIDED_ROADS/query/details?page=1&pageSize=25&where=1%3D1
        /**
         * @param {?} dataSourceId
         * @param {?} table
         * @param {?} whereClause
         * @param {?=} version
         * @param {?=} page
         * @param {?=} pageSize
         * @param {?=} includeGeometry
         * @param {?=} shapeField
         * @param {?=} params
         * @return {?}
         */
        DataSourceService.prototype.queryData =
            // api/data/sources/test_1051_sql/tables/RH.DIVIDED_ROADS/query/details?page=1&pageSize=25&where=1%3D1
            /**
             * @param {?} dataSourceId
             * @param {?} table
             * @param {?} whereClause
             * @param {?=} version
             * @param {?=} page
             * @param {?=} pageSize
             * @param {?=} includeGeometry
             * @param {?=} shapeField
             * @param {?=} params
             * @return {?}
             */
            function (dataSourceId, table, whereClause, version, page, pageSize, includeGeometry, shapeField, params) {
                return this.querySpatialData(dataSourceId, table, whereClause, version, page, pageSize, includeGeometry, shapeField, 'json', params);
            };
        /**
         * @param {?} dataSourceId
         * @param {?} table
         * @param {?} whereClause
         * @param {?=} version
         * @param {?=} page
         * @param {?=} pageSize
         * @param {?=} includeGeometry
         * @param {?=} shapeField
         * @param {?=} params
         * @return {?}
         */
        DataSourceService.prototype.queryGeoJsonData = /**
         * @param {?} dataSourceId
         * @param {?} table
         * @param {?} whereClause
         * @param {?=} version
         * @param {?=} page
         * @param {?=} pageSize
         * @param {?=} includeGeometry
         * @param {?=} shapeField
         * @param {?=} params
         * @return {?}
         */
            function (dataSourceId, table, whereClause, version, page, pageSize, includeGeometry, shapeField, params) {
                return this.querySpatialData(dataSourceId, table, whereClause, version, page, pageSize, includeGeometry, shapeField, 'geojson', params);
            };
        /**
         * @template T
         * @param {?} dataSourceId
         * @param {?} table
         * @param {?} whereClause
         * @param {?=} version
         * @param {?=} page
         * @param {?=} pageSize
         * @param {?=} includeGeometry
         * @param {?=} shapeField
         * @param {?=} format
         * @param {?=} params
         * @return {?}
         */
        DataSourceService.prototype.querySpatialData = /**
         * @template T
         * @param {?} dataSourceId
         * @param {?} table
         * @param {?} whereClause
         * @param {?=} version
         * @param {?=} page
         * @param {?=} pageSize
         * @param {?=} includeGeometry
         * @param {?=} shapeField
         * @param {?=} format
         * @param {?=} params
         * @return {?}
         */
            function (dataSourceId, table, whereClause, version, page, pageSize, includeGeometry, shapeField, format, params) {
                /** @type {?} */
                var url = this.getUrlWithId(dataSourceId, this.dsConfig.tableActionEndpoint, {
                    table: table,
                    action: 'query/details'
                });
                params = (params || new i1$1.HttpParams())
                    .set('where', whereClause || EMPTY_PARAM_VALUE)
                    .set('version', version || EMPTY_PARAM_VALUE)
                    .set('page', isValue(page) ? String(page) : EMPTY_PARAM_VALUE)
                    .set('pageSize', isValue(pageSize) ? String(pageSize) : EMPTY_PARAM_VALUE)
                    .set('includeGeometry', isValue(includeGeometry) ? String(includeGeometry) : EMPTY_PARAM_VALUE)
                    .set('shapeField', shapeField || EMPTY_PARAM_VALUE)
                    .set('format', format || EMPTY_PARAM_VALUE);
                return this.http.get(url, { params: params });
            };
        DataSourceService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        DataSourceService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: DataSourceConfig }
            ];
        };
        /** @nocollapse */ DataSourceService.ngInjectableDef = i0.defineInjectable({ factory: function DataSourceService_Factory() { return new DataSourceService(i0.inject(i1$1.HttpClient), i0.inject(DataSourceConfig)); }, token: DataSourceService, providedIn: "root" });
        return DataSourceService;
    }(BaseResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} tableName
     * @return {?}
     */
    function stripTableName(tableName) {
        return (tableName || '').split('.').slice(-1)[0];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} dataSource
     * @return {?}
     */
    function getDataSourceId(dataSource) {
        /** @type {?} */
        var dataSourceId;
        if (isString(dataSource)) {
            dataSourceId = ( /** @type {?} */(dataSource));
        }
        else {
            /** @type {?} */
            var src = ( /** @type {?} */(dataSource));
            if (src) {
                dataSourceId = src.id;
            }
        }
        return dataSourceId;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} providerType
     * @return {?}
     */
    function isOracleProvider(providerType) {
        return providerType === DataSourceProviderType.Oracle || providerType === DataSourceProviderType.OracleDevArt;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} providerType
     * @return {?}
     */
    function getDateFormatForProvider(providerType) {
        if (!providerType) {
            return STANDARDIZED_QUERY_DATE_FORMAT;
        }
        else if (isOracleProvider(providerType)) {
            return ORACLE_DATE_FORMAT;
        }
        else {
            return DEFAULT_DATE_FORMAT;
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} providerType
     * @return {?}
     */
    function isEnterpriseProvider(providerType) {
        return providerType === DataSourceProviderType.SqlServer
            || providerType === DataSourceProviderType.Oracle
            || providerType === DataSourceProviderType.OracleDevArt;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SEED_POD_FILE_EXTENSION = '.tss';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var FIELD_TYPE_OID = 'id';
    /** @type {?} */
    var FIELD_TYPE_OID_STRING = 'id-string';
    /** @type {?} */
    var FIELD_TYPE_STRING = 'string';
    /** @type {?} */
    var FIELD_TYPE_NUMBER = 'number';
    /** @type {?} */
    var FIELD_TYPE_XML = 'xml';
    /** @type {?} */
    var FIELD_TYPE_BLOB = 'blob';
    /** @type {?} */
    var FIELD_TYPE_DATE = 'date';
    /** @type {?} */
    var FIELD_TYPE_DOUBLE = 'double';
    /** @type {?} */
    var FIELD_TYPE_GUID = 'guid';
    /** @type {?} */
    var FIELD_TYPE_GEOMETRY = 'geometry';
    /** @type {?} */
    var FIELD_TYPE_GLOBALID = 'globalId';
    /** @type {?} */
    var FIELD_TYPE_INTEGER = 'integer';
    /** @type {?} */
    var FIELD_TYPE_RASTER = 'raster';
    /** @type {?} */
    var FIELD_TYPE_SINGLE = 'single';
    /** @type {?} */
    var FIELD_TYPE_SMALL_INTEGER = 'int';
    /** @type {?} */
    var ESRI_FIELD_TYPE_OID = 'esriFieldTypeOID';
    /** @type {?} */
    var ESRI_FIELD_TYPE_STRING = 'esriFieldTypeString';
    /** @type {?} */
    var ESRI_FIELD_TYPE_NUMBER = 'esriFieldTypeNumber';
    /** @type {?} */
    var ESRI_FIELD_TYPE_XML = 'esriFieldTypeXML';
    /** @type {?} */
    var ESRI_FIELD_TYPE_BLOB = 'esriFieldTypeBlob';
    /** @type {?} */
    var ESRI_FIELD_TYPE_DATE = 'esriFieldTypeDate';
    /** @type {?} */
    var ESRI_FIELD_TYPE_DOUBLE = 'esriFieldTypeDouble';
    /** @type {?} */
    var ESRI_FIELD_TYPE_GUID = 'esriFieldTypeGUID';
    /** @type {?} */
    var ESRI_FIELD_TYPE_GEOMETRY = 'esriFieldTypeGeometry';
    /** @type {?} */
    var ESRI_FIELD_TYPE_GLOBALID = 'esriFieldTypeGlobalID';
    /** @type {?} */
    var ESRI_FIELD_TYPE_INTEGER = 'esriFieldTypeInteger';
    /** @type {?} */
    var ESRI_FIELD_TYPE_RASTER = 'esriFieldTypeRaster';
    /** @type {?} */
    var ESRI_FIELD_TYPE_SINGLE = 'esriFieldTypeSingle';
    /** @type {?} */
    var ESRI_FIELD_TYPE_SMALL_INTEGER = 'esriFieldTypeSmallInteger';
    /** @type {?} */
    var FIELD_METADATA = [
        { alias: 'ID', isNumeric: true, types: [FIELD_TYPE_OID, ESRI_FIELD_TYPE_OID] },
        { alias: 'ID', isNumeric: false, types: [FIELD_TYPE_OID_STRING] },
        { alias: 'string', isNumeric: false, types: [FIELD_TYPE_STRING, ESRI_FIELD_TYPE_STRING] },
        { alias: 'number', isNumeric: true, types: [FIELD_TYPE_NUMBER, ESRI_FIELD_TYPE_NUMBER] },
        { alias: 'double', isNumeric: true, types: [FIELD_TYPE_DOUBLE, ESRI_FIELD_TYPE_DOUBLE] },
        { alias: 'int', isNumeric: true, types: [FIELD_TYPE_INTEGER, ESRI_FIELD_TYPE_INTEGER, ESRI_FIELD_TYPE_SMALL_INTEGER] },
        { alias: 'date', isNumeric: false, types: [FIELD_TYPE_DATE, ESRI_FIELD_TYPE_DATE] },
        { alias: 'geometry', isNumeric: false, types: [FIELD_TYPE_GEOMETRY, ESRI_FIELD_TYPE_GEOMETRY] },
        { alias: 'xml', isNumeric: false, types: [FIELD_TYPE_XML, ESRI_FIELD_TYPE_XML] },
        { alias: 'blob', isNumeric: false, types: [FIELD_TYPE_BLOB, ESRI_FIELD_TYPE_BLOB] },
        { alias: 'guid', isNumeric: false, types: [FIELD_TYPE_GUID, ESRI_FIELD_TYPE_GUID] },
        { alias: 'globalId', isNumeric: false, types: [FIELD_TYPE_GLOBALID, ESRI_FIELD_TYPE_GLOBALID] },
        { alias: 'integer', isNumeric: true, types: [FIELD_TYPE_INTEGER, ESRI_FIELD_TYPE_INTEGER] },
        { alias: 'raster', isNumeric: false, types: [FIELD_TYPE_RASTER, ESRI_FIELD_TYPE_RASTER] },
        { alias: 'single', isNumeric: false, types: [FIELD_TYPE_SINGLE, ESRI_FIELD_TYPE_SINGLE] },
    ];
    /**
     * @param {?} fieldType
     * @return {?}
     */
    function isFieldGeometryType(fieldType) {
        return fieldType === 'esriFieldTypeGeometry' || fieldType === 'geometry';
    }
    /**
     * @param {?} fieldType
     * @return {?}
     */
    function isObjectIdType(fieldType) {
        return fieldType === 'esriFieldTypeOID' || fieldType === 'id';
    }
    /**
     * @param {?} fields
     * @return {?}
     */
    function getGeometryField(fields) {
        return (fields || []).find(( /**
         * @param {?} f
         * @return {?}
         */function (f) { return isFieldGeometryType(f.type); }));
    }
    /**
     * @param {?} fields
     * @return {?}
     */
    function getGeometryFieldName(fields) {
        /** @type {?} */
        var field = getGeometryField(fields);
        return field ? field.name : null;
    }
    /**
     * @param {?} fields
     * @return {?}
     */
    function getIdField(fields) {
        return (fields || []).find(( /**
         * @param {?} f
         * @return {?}
         */function (f) { return isObjectIdType(f.type); }));
    }
    /**
     * @param {?} fields
     * @return {?}
     */
    function getIdFieldFieldName(fields) {
        /** @type {?} */
        var field = getIdField(fields);
        return field ? field.name : null;
    }
    /**
     * @param {?} fieldNameOrExpression
     * @return {?}
     */
    function isFieldExpression(fieldNameOrExpression) {
        return hasTokens(fieldNameOrExpression);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    function toFieldType(field) {
        return isString(field)
            ? ( /** @type {?} */(field))
            : (( /** @type {?} */(field))).type;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    function toFieldName(field) {
        return isString(field) ? ( /** @type {?} */(field)) : (( /** @type {?} */(field))).name;
    }
    /**
     * @param {?} fieldName
     * @param {?} fields
     * @return {?}
     */
    function getField(fieldName, fields) {
        return fields.find(( /**
         * @param {?} f
         * @return {?}
         */function (f) { return f.name === fieldName; })) || null;
    }
    /**
     * @param {?} fieldName
     * @param {?} fields
     * @return {?}
     */
    function getFieldAlias(fieldName, fields) {
        /** @type {?} */
        var fieldAlias = null;
        /** @type {?} */
        var field = getField(fieldName, fields);
        if (field && field.alias) {
            fieldAlias = field.alias;
        }
        return fieldAlias;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    function isFieldNumeric(field) {
        /** @type {?} */
        var fieldType = toFieldType(field);
        /** @type {?} */
        var match = FIELD_METADATA
            .filter(( /**
     * @param {?} f
     * @return {?}
     */function (f) { return f.isNumeric; }))
            .find(( /**
     * @param {?} f
     * @return {?}
     */function (f) { return f.types.indexOf(fieldType) > -1; }));
        return Boolean(match);
    }
    /**
     * @param {?} field
     * @param {?} value
     * @return {?}
     */
    function isFieldValueNumeric(field, value) {
        /** @type {?} */
        var fieldType = toFieldType(field);
        if (isObjectIdType(fieldType) && canNotBeNumber(value)) {
            return false;
        }
        return isFieldNumeric(field);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var FIELD_QUOTE = '"';
    /** @enum {string} */
    var CriteriaOperator = {
        Equals: '=',
        DoesNotEqual: '<>',
        // In = 'IN',
        // OneOf, NotOneOf, Between, NotBetween, Contains...
        GreaterThan: '>',
        LessThan: '<',
        GreaterOrEqualTo: '>=',
        LessThanOrEqualTo: '<=',
    };
    /** @enum {string} */
    var TargetOperator = {
        Is: 'IS',
        Not: 'NOT',
        In: 'IN',
        Like: 'LIKE',
        Between: 'BETWEEN',
    };
    /** @enum {string} */
    var ValueOperator = {
        Wildcard: '%',
        Null: 'NULL',
    };
    /** @enum {string} */
    var GroupingOperator = {
        OpenParenthesis: '(',
        ClosedParenthesis: ')',
        Parenthesis: '()',
    };
    /** @enum {string} */
    var CombiningOperator = {
        And: 'AND',
        Or: 'OR',
    };
    /** @type {?} */
    var DefaultWhereClauseBuilderOptions = {
        quoteFields: true
    };
    var WhereClauseBuilder = /** @class */ (function () {
        function WhereClauseBuilder(options) {
            this.statements = [];
            this.options = Object.assign({}, DefaultWhereClauseBuilderOptions, options);
        }
        Object.defineProperty(WhereClauseBuilder.prototype, "criteriaCount", {
            get: /**
             * @return {?}
             */ function () {
                return this.statements.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} statement
         * @return {THIS}
         */
        WhereClauseBuilder.prototype.add = /**
         * @template THIS
         * @this {THIS}
         * @param {?} statement
         * @return {THIS}
         */
            function (statement) {
                ( /** @type {?} */(this)).statements.push(statement);
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} value
         * @return {THIS}
         */
        WhereClauseBuilder.prototype.whereEqual = /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} value
         * @return {THIS}
         */
            function (field, value) {
                return value === null
                    ? ( /** @type {?} */(this)).whereIsNull(field.name)
                    : ( /** @type {?} */(this)).where(field.name, CriteriaOperator.Equals, value, isFieldValueNumeric(field, value));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} value
         * @return {THIS}
         */
        WhereClauseBuilder.prototype.whereLike = /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} value
         * @return {THIS}
         */
            function (field, value) {
                return ( /** @type {?} */(this)).add(( /** @type {?} */(this)).formatField(field) + " " + TargetOperator.Like + " '%" + value + "%'");
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} value
         * @return {THIS}
         */
        WhereClauseBuilder.prototype.whereStartsWith = /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} value
         * @return {THIS}
         */
            function (field, value) {
                return ( /** @type {?} */(this)).add(( /** @type {?} */(this)).formatField(field) + " " + TargetOperator.Like + " '" + value + "%'");
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} value
         * @return {THIS}
         */
        WhereClauseBuilder.prototype.whereEndsWith = /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} value
         * @return {THIS}
         */
            function (field, value) {
                return ( /** @type {?} */(this)).add(( /** @type {?} */(this)).formatField(field) + " " + TargetOperator.Like + " '%" + value + "'");
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} value
         * @return {THIS}
         */
        WhereClauseBuilder.prototype.whereNotEqual = /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} value
         * @return {THIS}
         */
            function (field, value) {
                return value === null
                    ? ( /** @type {?} */(this)).whereIsNotNull(field.name)
                    : ( /** @type {?} */(this)).where(field.name, CriteriaOperator.DoesNotEqual, value, isFieldValueNumeric(field, value));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @return {THIS}
         */
        WhereClauseBuilder.prototype.whereIsNull = /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @return {THIS}
         */
            function (field) {
                return ( /** @type {?} */(this)).add(( /** @type {?} */(this)).formatField(field) + " " + TargetOperator.Is + " " + ValueOperator.Null);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @return {THIS}
         */
        WhereClauseBuilder.prototype.whereIsNotNull = /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @return {THIS}
         */
            function (field) {
                return ( /** @type {?} */(this)).add(( /** @type {?} */(this)).formatField(field) + " " + TargetOperator.Is + " " + TargetOperator.Not + " " + ValueOperator.Null);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} operator
         * @param {?} value
         * @param {?=} isNumeric
         * @return {THIS}
         */
        WhereClauseBuilder.prototype.where = /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} operator
         * @param {?} value
         * @param {?=} isNumeric
         * @return {THIS}
         */
            function (field, operator, value, isNumeric) {
                if (isNumeric === void 0) {
                    isNumeric = false;
                }
                value = isNumeric ? value : "'" + value + "'";
                ( /** @type {?} */(this)).add("" + ( /** @type {?} */(this)).formatField(field) + operator + value);
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} value
         * @return {THIS}
         */
        WhereClauseBuilder.prototype.whereNumeric = /**
         * @template THIS
         * @this {THIS}
         * @param {?} field
         * @param {?} value
         * @return {THIS}
         */
            function (field, value) {
                ( /** @type {?} */(this)).where(field, value, true);
                return ( /** @type {?} */(this));
            };
        /**
         * @return {?}
         */
        WhereClauseBuilder.prototype.toWhereClause = /**
         * @return {?}
         */
            function () {
                return this.statements.join(" " + CombiningOperator.And + " ");
            };
        /**
         * @return {?}
         */
        WhereClauseBuilder.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this.toWhereClause();
            };
        /**
         * @return {?}
         */
        WhereClauseBuilder.prototype.clear = /**
         * @return {?}
         */
            function () {
                this.statements.length = 0;
            };
        /**
         * @protected
         * @param {?} field
         * @return {?}
         */
        WhereClauseBuilder.prototype.formatField = /**
         * @protected
         * @param {?} field
         * @return {?}
         */
            function (field) {
                field = field || '';
                /** @type {?} */
                var addQuotes = this.options.quoteFields;
                if (addQuotes) {
                    if (!field.startsWith(FIELD_QUOTE)) {
                        field = "" + FIELD_QUOTE + field;
                    }
                    if (!field.endsWith(FIELD_QUOTE)) {
                        field = "" + field + FIELD_QUOTE;
                    }
                }
                else {
                    /** @type {?} */
                    var quoteRegex = new RegExp(FIELD_QUOTE, 'i');
                    return field.replace(quoteRegex, '');
                }
                return field;
            };
        return WhereClauseBuilder;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NO_TEMPORAL_LAYER_SUPPLIED_ERROR_MSG = 'No LRS temporal layers supplied';
    /** @type {?} */
    var NO_REFERENCE_LAYER_SUPPLIED_ERROR_MSG = 'No LRS reference layer supplied';
    /** @type {?} */
    var LRS_DATE_WHERE_CLAUSE_TEMPLATE = '(({fromDateFieldName} IS NULL OR {fromDateFieldName} <= {dateEndOfDay})'
        + ' AND ({toDateFieldName} IS NULL OR {toDateFieldName} > {date}))';
    /** @type {?} */
    var LRS_POINT_EVENT_WHERE_CLAUSE_TEMPLATE = "({fromMeasureFieldName} between {fromMeasure} and {toMeasure})";
    /** @type {?} */
    var LRS_LINEAR_EVENT_WHERE_CLAUSE_TEMPLATE = "(({fromMeasureFieldName} between {fromMeasure} AND {toMeasure})"
        + " OR ({toMeasureFieldName} between {fromMeasure} AND {toMeasure}) OR ({fromMeasureFieldName} < {fromMeasure}"
        + " AND {toMeasureFieldName} > {toMeasure})) AND NOT (({fromMeasureFieldName} < {fromMeasure}"
        + " AND {toMeasureFieldName} <= {fromMeasure}) OR ({toMeasureFieldName} > {toMeasure} AND {fromMeasureFieldName} >= {toMeasure}))";
    /**
     * @param {?} fromDateFieldName
     * @param {?} toDateFieldName
     * @param {?=} dbType
     * @param {?=} viewDate
     * @return {?}
     */
    function getLrsViewDateWhereStatement(fromDateFieldName, toDateFieldName, dbType, viewDate) {
        viewDate = toUtcDate(viewDate || new Date());
        setDateToBeginningOfDay(viewDate);
        // TODO: Look into whether we need to actually use end of day or not
        // Currently we are just setting it to same as 'date' - RG.
        /** @type {?} */
        var dateFormat = getDateFormatForProvider(dbType);
        return format(LRS_DATE_WHERE_CLAUSE_TEMPLATE, {
            fromDateFieldName: fromDateFieldName,
            toDateFieldName: toDateFieldName,
            date: formatDateForQuery(viewDate, dateFormat),
            dateEndOfDay: formatDateForQuery(viewDate, dateFormat),
        });
    }
    var LrsWhereClauseBuilder = /** @class */ (function (_super) {
        __extends(LrsWhereClauseBuilder, _super);
        function LrsWhereClauseBuilder(options) {
            return _super.call(this, options) || this;
        }
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} sourceData
         * @return {THIS}
         */
        LrsWhereClauseBuilder.prototype.withDataSource = /**
         * @template THIS
         * @this {THIS}
         * @param {?} sourceData
         * @return {THIS}
         */
            function (sourceData) {
                return ( /** @type {?} */(this)).withDataProvider(sourceData.providerName);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} sourceDbType
         * @return {THIS}
         */
        LrsWhereClauseBuilder.prototype.withDataProvider = /**
         * @template THIS
         * @this {THIS}
         * @param {?} sourceDbType
         * @return {THIS}
         */
            function (sourceDbType) {
                ( /** @type {?} */(this)).sourceDbType = sourceDbType;
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} eventLayer
         * @return {THIS}
         */
        LrsWhereClauseBuilder.prototype.withEventLayer = /**
         * @template THIS
         * @this {THIS}
         * @param {?} eventLayer
         * @return {THIS}
         */
            function (eventLayer) {
                return ( /** @type {?} */(this)).withTemporalLayer(eventLayer)
                    .withReferenceLayer(eventLayer);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} referenceLayer
         * @return {THIS}
         */
        LrsWhereClauseBuilder.prototype.withReferenceLayer = /**
         * @template THIS
         * @this {THIS}
         * @param {?} referenceLayer
         * @return {THIS}
         */
            function (referenceLayer) {
                ( /** @type {?} */(this)).referenceLayer = referenceLayer;
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} networkLayer
         * @return {THIS}
         */
        LrsWhereClauseBuilder.prototype.withNetworkLayer = /**
         * @template THIS
         * @this {THIS}
         * @param {?} networkLayer
         * @return {THIS}
         */
            function (networkLayer) {
                return ( /** @type {?} */(this)).withTemporalLayer(networkLayer);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} temporalLayer
         * @return {THIS}
         */
        LrsWhereClauseBuilder.prototype.withTemporalLayer = /**
         * @template THIS
         * @this {THIS}
         * @param {?} temporalLayer
         * @return {THIS}
         */
            function (temporalLayer) {
                ( /** @type {?} */(this)).temporalLayer = temporalLayer;
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} routeId
         * @param {?=} routeIdFieldName
         * @return {THIS}
         */
        LrsWhereClauseBuilder.prototype.withRouteId = /**
         * @template THIS
         * @this {THIS}
         * @param {?} routeId
         * @param {?=} routeIdFieldName
         * @return {THIS}
         */
            function (routeId, routeIdFieldName) {
                return ( /** @type {?} */(this)).where(routeIdFieldName || ( /** @type {?} */(this)).referenceLayer.routeIdFieldName, CriteriaOperator.Equals, routeId);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?=} viewDate
         * @param {?=} fromDateFieldName
         * @param {?=} toDateFieldName
         * @return {THIS}
         */
        LrsWhereClauseBuilder.prototype.withViewDate = /**
         * @template THIS
         * @this {THIS}
         * @param {?=} viewDate
         * @param {?=} fromDateFieldName
         * @param {?=} toDateFieldName
         * @return {THIS}
         */
            function (viewDate, fromDateFieldName, toDateFieldName) {
                if (( /** @type {?} */(this)).temporalLayer) {
                    fromDateFieldName = fromDateFieldName || ( /** @type {?} */(this)).temporalLayer.fromDateFieldName;
                    toDateFieldName = toDateFieldName || ( /** @type {?} */(this)).temporalLayer.toDateFieldName;
                }
                /** @type {?} */
                var hasDateFieldInfo = Boolean(( /** @type {?} */(this)).temporalLayer || fromDateFieldName && toDateFieldName);
                if (!hasDateFieldInfo) {
                    throw new Error(NO_TEMPORAL_LAYER_SUPPLIED_ERROR_MSG);
                }
                if (fromDateFieldName && toDateFieldName) {
                    /** @type {?} */
                    var dateClause = getLrsViewDateWhereStatement(( /** @type {?} */(this)).formatField(fromDateFieldName), ( /** @type {?} */(this)).formatField(toDateFieldName), ( /** @type {?} */(this)).sourceDbType, viewDate);
                    ( /** @type {?} */(this)).add(dateClause);
                }
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} fromMeasure
         * @param {?} toMeasure
         * @param {?=} fromMeasureFieldName
         * @param {?=} toMeasureFieldName
         * @return {THIS}
         */
        LrsWhereClauseBuilder.prototype.betweenMeasures = /**
         * @template THIS
         * @this {THIS}
         * @param {?} fromMeasure
         * @param {?} toMeasure
         * @param {?=} fromMeasureFieldName
         * @param {?=} toMeasureFieldName
         * @return {THIS}
         */
            function (fromMeasure, toMeasure, fromMeasureFieldName, toMeasureFieldName) {
                if (( /** @type {?} */(this)).referenceLayer) {
                    fromMeasureFieldName = fromMeasureFieldName || ( /** @type {?} */(this)).referenceLayer.fromMeasureFieldName;
                    toMeasureFieldName = toMeasureFieldName || ( /** @type {?} */(this)).referenceLayer.toMeasureFieldName;
                }
                /** @type {?} */
                var hasMeasureFieldInfo = Boolean(( /** @type {?} */(this)).referenceLayer || fromMeasureFieldName);
                if (!hasMeasureFieldInfo) {
                    throw new Error(NO_REFERENCE_LAYER_SUPPLIED_ERROR_MSG);
                }
                /** @type {?} */
                var whereTemplate = toMeasureFieldName
                    ? LRS_LINEAR_EVENT_WHERE_CLAUSE_TEMPLATE
                    : LRS_POINT_EVENT_WHERE_CLAUSE_TEMPLATE;
                /** @type {?} */
                var measureClause = format(whereTemplate, {
                    fromMeasureFieldName: ( /** @type {?} */(this)).formatField(fromMeasureFieldName),
                    toMeasureFieldName: ( /** @type {?} */(this)).formatField(toMeasureFieldName),
                    fromMeasure: fromMeasure,
                    toMeasure: toMeasure,
                });
                return ( /** @type {?} */(this)).add(measureClause);
            };
        return LrsWhereClauseBuilder;
    }(WhereClauseBuilder));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ BaseEsriService = /** @class */ (function () {
        function BaseEsriService(http, config, dataConfig, log) {
            this.http = http;
            this.config = config;
            this.dataConfig = dataConfig;
            this.log = log;
        }
        /**
         * @protected
         * @param {?} payload
         * @return {?}
         */
        BaseEsriService.prototype.shouldUsePostMethod = /**
         * @protected
         * @param {?} payload
         * @return {?}
         */
            function (payload) {
                return this.config.arcgisQueryMethodStrategy === 'force-post'
                    || JSON.stringify(payload || '').length > this.config.arcgisMaxWhereLengthGetThreshold;
            };
        /**
         * @protected
         * @template T
         * @param {?} response
         * @param {?} url
         * @return {?}
         */
        BaseEsriService.prototype.handleEsriResponseError = /**
         * @protected
         * @template T
         * @param {?} response
         * @param {?} url
         * @return {?}
         */
            function (response, url) {
                /** @type {?} */
                var error = ( /** @type {?} */(response));
                if (error && error.error) {
                    /** @type {?} */
                    var returnError = new Error("Failed to query map service: " + error.error.message);
                    this.log.error("Failed to execute map service request: " + url, returnError);
                    throw returnError;
                }
            };
        /**
         * @protected
         * @return {?}
         */
        BaseEsriService.prototype.getWhereBuilder = /**
         * @protected
         * @return {?}
         */
            function () {
                return new LrsWhereClauseBuilder({ quoteFields: !this.dataConfig.skipColumnQuotes });
            };
        return BaseEsriService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing global ESRI-related settings.
     */
    var EsriConfig = /** @class */ (function () {
        function EsriConfig() {
            this.arcgis = {};
            this.arcgisQueryMethodStrategy = 'prefer-get';
            this.arcgisMaxWhereLengthGetThreshold = 3500;
        }
        Object.defineProperty(EsriConfig.prototype, "hasGeometryUrl", {
            get: /**
             * @return {?}
             */ function () {
                return Boolean(this.arcgis && this.arcgis.geometryUrl);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EsriConfig.prototype, "arcGisGeometryUrl", {
            get: /**
             * @return {?}
             */ function () {
                return this.hasGeometryUrl ? this.arcgis.geometryUrl : null;
            },
            enumerable: true,
            configurable: true
        });
        EsriConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ EsriConfig.ngInjectableDef = i0.defineInjectable({ factory: function EsriConfig_Factory() { return new EsriConfig(); }, token: EsriConfig, providedIn: "root" });
        /**
         * Configuration class for storing global ESRI-related settings.
         */
        EsriConfig = __decorate([
            AutoConfig('EsriConfig')
        ], EsriConfig);
        return EsriConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SORTED_BY_MEASURE_PROPERTY_FLAG = '$$$sorted';
    /** @type {?} */
    var EARTH_RADIUS_IN_KILOMETERS = 6371;
    /** @type {?} */
    var EARTH_RADIUS_IN_METERS = 6371008.8;
    /** @type {?} */
    var WGS_84_SRID = 4326;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} point
     * @return {?}
     */
    function toSinglePartPointArray(point) {
        return isArray(point)
            ? (( /** @type {?} */(point)))
            : (( /** @type {?} */(point))).coordinates;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} firstPoint
     * @param {?} secondPoint
     * @return {?}
     */
    function getSortResultForPoints(firstPoint, secondPoint) {
        /** @type {?} */
        var first = toSinglePartPointArray(firstPoint);
        /** @type {?} */
        var second = toSinglePartPointArray(secondPoint);
        /** @type {?} */
        var firstCoordinateMeasure = getLastItem(first);
        /** @type {?} */
        var secondCoordinateMeasure = getLastItem(second);
        return firstCoordinateMeasure - secondCoordinateMeasure;
    }
    /**
     * @param {?} points
     * @param {?=} cacheSort
     * @return {?}
     */
    function sortPointsByMeasure(points, cacheSort) {
        if (cacheSort === void 0) {
            cacheSort = false;
        }
        if (points[SORTED_BY_MEASURE_PROPERTY_FLAG]) {
            return;
        }
        /** @type {?} */
        var coordinates = toMultiPartPoint(points);
        /** @type {?} */
        var coordinatesHaveMeasureValue = Boolean(coordinates.length
            && coordinates[0].length > 2);
        if (coordinatesHaveMeasureValue) {
            coordinates.sort(getSortResultForPoints);
            if (cacheSort) {
                points[SORTED_BY_MEASURE_PROPERTY_FLAG] = true;
            }
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @return {?}
     */
    function singleLineToCoordinates(line) {
        return isArray(line)
            ? ( /** @type {?} */(line))
            : (( /** @type {?} */(line))).coordinates;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @return {?}
     */
    function multiLineToCoordinates(line) {
        return isArray(line)
            ? ( /** @type {?} */(line))
            : (( /** @type {?} */(line))).coordinates;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @return {?}
     */
    function hasMeasureValues(line) {
        /** @type {?} */
        var paths = toMultiPartPaths(line);
        return multiLineHasMeasureValues(paths);
    }
    /**
     * @param {?} line
     * @return {?}
     */
    function singleLineHasMeasureValues(line) {
        /** @type {?} */
        var coordinates = singleLineToCoordinates(line);
        return Boolean(coordinates
            && coordinates.length
            && coordinates[0].length > 2);
    }
    /**
     * @param {?} line
     * @return {?}
     */
    function multiLineHasMeasureValues(line) {
        /** @type {?} */
        var coordinates = multiLineToCoordinates(line);
        return Boolean(coordinates.length
            && singleLineHasMeasureValues(coordinates[0]));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @return {?}
     */
    function sortLineByMeasure(line) {
        if (line[SORTED_BY_MEASURE_PROPERTY_FLAG]) {
            // There's no need to waste time sorting this geometry if it's already been done.
            return;
        }
        /** @type {?} */
        var paths = toMultiPartPaths(line);
        if (!multiLineHasMeasureValues(paths)) {
            // We can not continue sorting if the coordinates do not have measure values in them.
            return;
        }
        // We need to sort all of the inner coordinates first, and then the outer paths
        // because we don't know the min/max of the inner coordinates until this is done.
        paths.forEach(( /**
         * @param {?} coordinates
         * @return {?}
         */function (coordinates) { return sortPointsByMeasure(coordinates); }));
        paths.sort(( /**
         * @param {?} firstCoordinate
         * @param {?} secondCoordinate
         * @return {?}
         */function (firstCoordinate, secondCoordinate) {
            /** @type {?} */
            var firstCoordinateFirstPoint = firstCoordinate[0];
            /** @type {?} */
            var secondCoordinateFirstPoint = secondCoordinate[0];
            return getSortResultForPoints(firstCoordinateFirstPoint, secondCoordinateFirstPoint);
        }));
        line[SORTED_BY_MEASURE_PROPERTY_FLAG] = true;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} point
     * @return {?}
     */
    function getMeasureFromPoint(point) {
        /** @type {?} */
        var coordinate = toSinglePartPointArray(point);
        /** @type {?} */
        var hasMeasureValues = Boolean(coordinate
            && coordinate.length
            && coordinate.length > 2);
        return hasMeasureValues
            ? getLastItem(coordinate)
            : null;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @return {?}
     */
    function getMeasureExtentFromLine(line) {
        /** @type {?} */
        var paths = toMultiPartPaths(line);
        /** @type {?} */
        var min;
        /** @type {?} */
        var max;
        if (paths.length) {
            sortLineByMeasure(line);
            /** @type {?} */
            var firstPath = paths[0];
            /** @type {?} */
            var lastPath = getLastItem(paths);
            /** @type {?} */
            var firstCoordinate = firstPath[0];
            /** @type {?} */
            var lastCoordinate = getLastItem(lastPath);
            min = getMeasureFromPoint(firstCoordinate);
            max = getMeasureFromPoint(lastCoordinate);
        }
        return {
            min: min,
            max: max
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} point
     * @return {?}
     */
    function getMeasureExtentFromPoint(point) {
        /** @type {?} */
        var points = toMultiPartPoint(point);
        /** @type {?} */
        var firstPoint = points[0];
        /** @type {?} */
        var lastPoint = getLastItem(points);
        /** @type {?} */
        var min;
        /** @type {?} */
        var max;
        sortPointsByMeasure(points);
        min = getMeasureFromPoint(firstPoint);
        max = getMeasureFromPoint(lastPoint);
        return { min: min, max: max };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} geometry
     * @return {?}
     */
    function getMeasureExtent(geometry) {
        /** @type {?} */
        var extent;
        if (isLine(geometry)) {
            /** @type {?} */
            var lineGeometry = ( /** @type {?} */(geometry));
            extent = getMeasureExtentFromLine(lineGeometry);
        }
        else {
            /** @type {?} */
            var point = ( /** @type {?} */(geometry));
            extent = getMeasureExtentFromPoint(point);
        }
        return extent;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} field
     * @param {?} value
     * @return {?}
     */
    function getCodedValue(field, value) {
        return field.domain
            ? field.domain.codedValues.find(( /**
             * @param {?} codedValue
             * @return {?}
             */function (codedValue) { return codedValue.code === value; }))
            : undefined;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} field
     * @param {?} value
     * @return {?}
     */
    function getCodedValueName(field, value) {
        /** @type {?} */
        var codedValue = getCodedValue(field, value);
        return codedValue
            ? codedValue.name
            : undefined;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} field
     * @param {?} value
     * @return {?}
     */
    function getCodedValueNameOrDefault(field, value) {
        /** @type {?} */
        var name = getCodedValueName(field, value);
        return isValue(name)
            ? name
            : String(value);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DYNAMIC_DATA_REGEX = new RegExp('^layer_(\\d+)_field_(\\w+|\\*):?(\\w+)?', 'i');
    /**
     * @param {?} expression
     * @return {?}
     */
    function isDynamicDataExpression(expression) {
        return DYNAMIC_DATA_REGEX.test(expression);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ALL_FIELD_CRITERIA = '*';
    /**
     * @template T
     * @param {?} layerId
     * @param {?=} field
     * @param {...?} features
     * @return {?}
     */
    function extractFeatureDataByLayer(layerId, field) {
        if (field === void 0) {
            field = '*';
        }
        var features = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            features[_i - 2] = arguments[_i];
        }
        return extractFeatureData.apply(void 0, __spread([field], features.filter(( /**
         * @param {?} feature
         * @return {?}
         */function (feature) { return feature.layerId === layerId; }))));
    }
    /**
     * @template T
     * @param {?=} field
     * @param {...?} features
     * @return {?}
     */
    function extractFeatureData(field) {
        if (field === void 0) {
            field = ALL_FIELD_CRITERIA;
        }
        var features = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            features[_i - 1] = arguments[_i];
        }
        return features.map(( /**
         * @param {?} feature
         * @return {?}
         */function (feature) {
            return field === ALL_FIELD_CRITERIA
                ? feature.properties
                : feature.properties[field];
        }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} dataValues
     * @return {?}
     */
    function dataValuesToNumbers(dataValues) {
        return dataValues
            .filter(( /**
     * @param {?} value
     * @return {?}
     */function (value) { return util.isNumber(value); }))
            .map(( /**
     * @param {?} value
     * @return {?}
     */function (value) { return Number(value); }));
    }
    /**
     * @param {?} expression
     * @param {...?} features
     * @return {?}
     */
    function evaluateSingleDynamicDataExpression(expression) {
        var features = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            features[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var parsedValue = expression.match(DYNAMIC_DATA_REGEX);
        /** @type {?} */
        var expressionValue;
        if (parsedValue && parsedValue.length > 2) {
            /** @type {?} */
            var layerId = Number(parsedValue[1]);
            /** @type {?} */
            var field = parsedValue[2];
            /** @type {?} */
            var subsetKeyword = ( /** @type {?} */((parsedValue[3] || 'first').toLocaleLowerCase()));
            /** @type {?} */
            var dataValues = extractFeatureDataByLayer.apply(void 0, __spread([layerId, field], features));
            if (subsetKeyword === 'first') {
                expressionValue = dataValues[0];
            }
            else if (subsetKeyword === 'last') {
                expressionValue = dataValues[dataValues.length - 1];
            }
            else if (subsetKeyword === 'sum' || subsetKeyword === 'add') {
                /** @type {?} */
                var numberValues = dataValuesToNumbers(dataValues);
                expressionValue = sumValues(numberValues);
            }
            else if (subsetKeyword === 'avg' || subsetKeyword === 'average') {
                /** @type {?} */
                var numberValues = dataValuesToNumbers(dataValues);
                expressionValue = average(numberValues);
            }
            else if (subsetKeyword === 'concat') {
                expressionValue = dataValues.join(', ');
            }
            else if (subsetKeyword === 'min') {
                /** @type {?} */
                var numberValues = dataValuesToNumbers(dataValues);
                expressionValue = Math.min.apply(Math, __spread(numberValues));
            }
            else if (subsetKeyword === 'max') {
                /** @type {?} */
                var numberValues = dataValuesToNumbers(dataValues);
                expressionValue = Math.max.apply(Math, __spread(numberValues));
            }
            else {
                throw new Error("Unsupported dynamic data expression subset keyword '" + subsetKeyword + "'");
            }
            return isObject(expressionValue)
                ? JSON.stringify(expressionValue)
                : String(expressionValue);
        }
    }
    /**
     * @param {?} expression
     * @param {...?} features
     * @return {?}
     */
    function evaluateDynamicDataExpression(expression) {
        var features = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            features[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var tokenExpressions = extractTokenExpressions(expression);
        /** @type {?} */
        var evaluationResult = expression;
        tokenExpressions
            .filter(( /**
     * @param {?} tokenExpression
     * @return {?}
     */function (tokenExpression) { return isDynamicDataExpression(tokenExpression); }))
            .forEach(( /**
     * @param {?} tokenExpression
     * @return {?}
     */function (tokenExpression) {
            /** @type {?} */
            var value = evaluateSingleDynamicDataExpression.apply(void 0, __spread([tokenExpression], features));
            evaluationResult = replaceToken(evaluationResult, tokenExpression, value);
        }));
        return evaluationResult;
    }
    /**
     * @param {?} expression
     * @param {...?} features
     * @return {?}
     */
    function evaluteFeatureDataExpression(expression) {
        var features = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            features[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var evaluationResult = evaluateDynamicDataExpression.apply(void 0, __spread([expression], features));
        /** @type {?} */
        var firstFeatureProperties = features && features.length
            ? features[0].properties
            : {};
        /** @type {?} */
        var replaceTokens = Object.assign({}, firstFeatureProperties, {
            RecordCount: features.length,
        });
        return format(evaluationResult, replaceTokens);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MapFeature = /** @class */ (function () {
        function MapFeature(feature, layer, spatialReferenceId) {
            if (spatialReferenceId === void 0) {
                spatialReferenceId = WGS_84_SRID;
            }
            this.id = feature.id;
            this.properties = feature.properties;
            this.type = feature.type;
            this.bbox = feature.bbox;
            this.layer = layer;
            this.spatialReferenceId = spatialReferenceId;
            /** @type {?} */
            var idFieldName = this.getIdFieldName();
            this.id = this.id || this.getValue(idFieldName);
            this.displayValue = this.getValue(layer.displayField);
            this.setGeometry(feature.geometry);
        }
        Object.defineProperty(MapFeature.prototype, "layerId", {
            get: /**
             * @return {?}
             */ function () {
                return this.layer ? this.layer.id : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapFeature.prototype, "hasZ", {
            get: /**
             * @return {?}
             */ function () {
                return this.layer.hasZ;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapFeature.prototype, "hasM", {
            get: /**
             * @return {?}
             */ function () {
                return this.layer.hasM;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MapFeature.prototype.getIdFieldName = /**
         * @return {?}
         */
            function () {
                return getIdFieldFieldName(this.layer.fields);
            };
        /**
         * @param {?} fieldNameOrExpression
         * @return {?}
         */
        MapFeature.prototype.getValue = /**
         * @param {?} fieldNameOrExpression
         * @return {?}
         */
            function (fieldNameOrExpression) {
                return isFieldExpression(fieldNameOrExpression)
                    ? evaluteFeatureDataExpression(fieldNameOrExpression, this)
                    : this.properties && this.properties[fieldNameOrExpression];
            };
        /**
         * @param {?} fieldName
         * @return {?}
         */
        MapFeature.prototype.getCodedValueNameOrDefault = /**
         * @param {?} fieldName
         * @return {?}
         */
            function (fieldName) {
                /** @type {?} */
                var value = this.getValue(fieldName);
                /** @type {?} */
                var field = this.layer.getField(fieldName);
                return getCodedValueNameOrDefault(field, value);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} fieldName
         * @param {?} value
         * @return {THIS}
         */
        MapFeature.prototype.setValue = /**
         * @template THIS
         * @this {THIS}
         * @param {?} fieldName
         * @param {?} value
         * @return {THIS}
         */
            function (fieldName, value) {
                ( /** @type {?} */(this)).properties[fieldName] = value;
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} id
         * @return {THIS}
         */
        MapFeature.prototype.setId = /**
         * @template THIS
         * @this {THIS}
         * @param {?} id
         * @return {THIS}
         */
            function (id) {
                ( /** @type {?} */(this)).id = id;
                ( /** @type {?} */(this)).setValue(getIdFieldFieldName(( /** @type {?} */(this)).layer.fields), id);
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} geometry
         * @return {THIS}
         */
        MapFeature.prototype.setGeometry = /**
         * @template THIS
         * @this {THIS}
         * @param {?} geometry
         * @return {THIS}
         */
            function (geometry) {
                ( /** @type {?} */(this)).geometry = geometry;
                return ( /** @type {?} */(this)).setGeometryTypeProperties();
            };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        MapFeature.prototype.setMeasureFromGeometry = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
            function () {
                if (( /** @type {?} */(this)).geometry) {
                    /** @type {?} */
                    var extent = getMeasureExtent(( /** @type {?} */(this)).geometry);
                    ( /** @type {?} */(this)).fromMeasure = extent.min;
                    ( /** @type {?} */(this)).toMeasure = extent.max;
                }
                return ( /** @type {?} */(this));
            };
        /**
         * @return {?}
         */
        MapFeature.prototype.isSpatialReferenceWgs84 = /**
         * @return {?}
         */
            function () {
                return this.spatialReferenceId === WGS_84_SRID;
            };
        /**
         * @return {?}
         */
        MapFeature.prototype.clone = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var copyFeature = clone(this.toFeature());
                return new MapFeature(copyFeature, this.layer);
            };
        /**
         * @return {?}
         */
        MapFeature.prototype.toFeature = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var feature = {
                    type: 'Feature',
                    geometry: this.geometry,
                    properties: this.properties,
                    id: this.id,
                    bbox: this.bbox,
                };
                return feature;
            };
        /**
         * @return {?}
         */
        MapFeature.prototype.toGeoJson = /**
         * @return {?}
         */
            function () {
                return this.toFeature();
            };
        /**
         * @protected
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        MapFeature.prototype.setGeometryTypeProperties = /**
         * @protected
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
            function () {
                ( /** @type {?} */(this)).isLinear = isLine(( /** @type {?} */(this)).geometry);
                ( /** @type {?} */(this)).isPoint = isPoint(( /** @type {?} */(this)).geometry);
                ( /** @type {?} */(this)).isPolygon = isPolygon(( /** @type {?} */(this)).geometry);
                return ( /** @type {?} */(this));
            };
        return MapFeature;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LrsFeature = /** @class */ (function (_super) {
        __extends(LrsFeature, _super);
        function LrsFeature(feature, layer, spatialReferenceId) {
            if (spatialReferenceId === void 0) {
                spatialReferenceId = WGS_84_SRID;
            }
            var _this = _super.call(this, feature, layer, spatialReferenceId) || this;
            if (_this.geometry && _this.isGeometryTypeInvalid()) {
                throw new Error("Unsupported geometry type of " + _this.geometry.type + " detected.");
            }
            return _this;
        }
        Object.defineProperty(LrsFeature.prototype, "layerId", {
            get: /**
             * @return {?}
             */ function () {
                return this.layer ? this.layer.id : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LrsFeature.prototype, "fromDate", {
            get: /**
             * @return {?}
             */ function () {
                return this.getValue(this.layer.fromDateFieldName);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LrsFeature.prototype, "toDate", {
            get: /**
             * @return {?}
             */ function () {
                return this.getValue(this.layer.toDateFieldName);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LrsFeature.prototype, "isRetired", {
            get: /**
             * @return {?}
             */ function () {
                return Boolean(this.toDate);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LrsFeature.prototype, "isActive", {
            get: /**
             * @return {?}
             */ function () {
                return !this.isRetired;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} date
         * @return {THIS}
         */
        LrsFeature.prototype.setFromDate = /**
         * @template THIS
         * @this {THIS}
         * @param {?} date
         * @return {THIS}
         */
            function (date) {
                return ( /** @type {?} */(this)).setValue(( /** @type {?} */(this)).layer.fromDateFieldName, date);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} date
         * @return {THIS}
         */
        LrsFeature.prototype.setToDate = /**
         * @template THIS
         * @this {THIS}
         * @param {?} date
         * @return {THIS}
         */
            function (date) {
                return ( /** @type {?} */(this)).setValue(( /** @type {?} */(this)).layer.toDateFieldName, date);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        LrsFeature.prototype.retire = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
            function () {
                if (( /** @type {?} */(this)).layer.toDateFieldName) {
                    ( /** @type {?} */(this)).setValue(( /** @type {?} */(this)).layer.toDateFieldName, new Date());
                }
                return ( /** @type {?} */(this));
            };
        /**
         * @return {?}
         */
        LrsFeature.prototype.clone = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var copyFeature = clone(this.toFeature());
                return new LrsFeature(copyFeature, this.layer);
            };
        /**
         * @protected
         * @return {?}
         */
        LrsFeature.prototype.isGeometryTypeValid = /**
         * @protected
         * @return {?}
         */
            function () {
                return isLine(this.geometry) || isPoint(this.geometry);
            };
        /**
         * @private
         * @return {?}
         */
        LrsFeature.prototype.isGeometryTypeInvalid = /**
         * @private
         * @return {?}
         */
            function () {
                return !this.isGeometryTypeValid();
            };
        return LrsFeature;
    }(MapFeature));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var EventFeature = /** @class */ (function (_super) {
        __extends(EventFeature, _super);
        function EventFeature(feature, layer, spatialReferenceId) {
            if (spatialReferenceId === void 0) {
                spatialReferenceId = WGS_84_SRID;
            }
            var _this = _super.call(this, feature, layer, spatialReferenceId) || this;
            _this.routeId = _this.getValue(layer.routeIdFieldName);
            _this.fromMeasure = _this.getValue(layer.fromMeasureFieldName);
            _this.toMeasure = _this.getValue(layer.toMeasureFieldName);
            return _this;
        }
        /**
         * @param {?} layer
         * @param {?=} properties
         * @param {?=} geometry
         * @return {?}
         */
        EventFeature.create = /**
         * @param {?} layer
         * @param {?=} properties
         * @param {?=} geometry
         * @return {?}
         */
            function (layer, properties, geometry) {
                if (properties === void 0) {
                    properties = {};
                }
                if (geometry === void 0) {
                    geometry = null;
                }
                /** @type {?} */
                var feature = toFeature(properties, ( /** @type {?} */(geometry)));
                return new EventFeature(feature, layer);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} routeId
         * @return {THIS}
         */
        EventFeature.prototype.setRouteId = /**
         * @template THIS
         * @this {THIS}
         * @param {?} routeId
         * @return {THIS}
         */
            function (routeId) {
                ( /** @type {?} */(this)).routeId = routeId;
                return ( /** @type {?} */(this)).setValue(routeId, ( /** @type {?} */(this)).layer.routeIdFieldName);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
        EventFeature.prototype.setFromMeasure = /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
            function (measure) {
                ( /** @type {?} */(this)).fromMeasure = measure;
                return ( /** @type {?} */(this)).setValue(( /** @type {?} */(this)).layer.fromMeasureFieldName, measure);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
        EventFeature.prototype.setToMeasure = /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
            function (measure) {
                if (!( /** @type {?} */(this)).isLinear) {
                    throw new Error('Cannot set to measure for a point-based feature');
                }
                ( /** @type {?} */(this)).toMeasure = measure;
                return ( /** @type {?} */(this)).setValue(( /** @type {?} */(this)).layer.toMeasureFieldName, measure);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} fromMeasure
         * @param {?} toMeasure
         * @return {THIS}
         */
        EventFeature.prototype.setMeasureExtent = /**
         * @template THIS
         * @this {THIS}
         * @param {?} fromMeasure
         * @param {?} toMeasure
         * @return {THIS}
         */
            function (fromMeasure, toMeasure) {
                return ( /** @type {?} */(this)).setFromMeasure(fromMeasure)
                    .setToMeasure(toMeasure);
            };
        /**
         * @return {?}
         */
        EventFeature.prototype.clone = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var copyFeature = clone(this.toFeature());
                return new EventFeature(copyFeature, this.layer);
            };
        /**
         * @protected
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        EventFeature.prototype.setGeometryTypeProperties = /**
         * @protected
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
            function () {
                ( /** @type {?} */(this)).isLinear = Boolean(( /** @type {?} */(this)).layer.toMeasureFieldName);
                ( /** @type {?} */(this)).isPoint = !( /** @type {?} */(this)).isLinear;
                ( /** @type {?} */(this)).isPolygon = false;
                return ( /** @type {?} */(this));
            };
        return EventFeature;
    }(LrsFeature));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} feature
     * @param {?} layerId
     * @param {?} lrsMeta
     * @return {?}
     */
    function toLrsFeature(feature, layerId, lrsMeta) {
        /** @type {?} */
        var layerInfo = lrsMeta.getLayerDetail(layerId);
        /** @type {?} */
        var lrsFeature;
        if (layerInfo.isNetworkLayer) {
            lrsFeature = new NetworkFeature(feature, ( /** @type {?} */(layerInfo.layer)));
        }
        else if (layerInfo.isEventLayer) {
            lrsFeature = new EventFeature(feature, ( /** @type {?} */(layerInfo.layer)));
        }
        return lrsFeature;
    }
    // Feature<G extends GeometryObject | null = Geometry, P = GeoJsonProperties> extends GeoJsonObject
    /**
     * @param {?=} properties
     * @param {?=} geometry
     * @return {?}
     */
    function toFeature(properties, geometry) {
        if (properties === void 0) {
            properties = {};
        }
        if (geometry === void 0) {
            geometry = null;
        }
        return {
            type: 'Feature',
            geometry: geometry,
            properties: properties
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @param {?} measure
     * @return {?}
     */
    function getPoint(line, measure) {
        /** @type {?} */
        var pointComparisionDetails = [];
        /** @type {?} */
        var paths = toMultiPartPaths(line);
        paths.forEach(( /**
         * @param {?} coordinates
         * @return {?}
         */function (coordinates) {
            /** @type {?} */
            var details = comparePathWithMeasure(coordinates, measure);
            addRange(pointComparisionDetails, details);
        }));
        /** @type {?} */
        var minPoint = pointComparisionDetails.reduce(( /**
         * @param {?} accumulator
         * @param {?} value
         * @return {?}
         */function (accumulator, value) { return minPointCloserToMeasure(accumulator, value, measure); }));
        /** @type {?} */
        var maxPoint = pointComparisionDetails.reduce(( /**
         * @param {?} accumulator
         * @param {?} value
         * @return {?}
         */function (accumulator, value) { return maxPointCloserToMeasure(accumulator, value, measure); }));
        /** @type {?} */
        var measureDeltaPercent = calculateMeasureDelta(minPoint.pointMeasure, maxPoint.pointMeasure, measure);
        /** @type {?} */
        var x = interpolateX(minPoint.pointCoordinate, maxPoint.pointCoordinate, measureDeltaPercent);
        /** @type {?} */
        var y = interpolateY(minPoint.pointCoordinate, maxPoint.pointCoordinate, measureDeltaPercent);
        return [x, y, 0, measure];
    }
    /**
     * @param {?} __0
     * @param {?} __1
     * @param {?} delta
     * @return {?}
     */
    function interpolateX(_a, _b, delta) {
        var _c = __read(_a, 1), minX = _c[0];
        var _d = __read(_b, 1), maxX = _d[0];
        return minX + delta * (maxX - minX);
    }
    /**
     * @param {?} __0
     * @param {?} __1
     * @param {?} delta
     * @return {?}
     */
    function interpolateY(_a, _b, delta) {
        var _c = __read(_a, 2), minY = _c[1];
        var _d = __read(_b, 2), maxY = _d[1];
        return minY + delta * (maxY - minY);
    }
    /**
     * @param {?} minMeasure
     * @param {?} maxMeasure
     * @param {?} measure
     * @return {?}
     */
    function calculateMeasureDelta(minMeasure, maxMeasure, measure) {
        if (maxMeasure === minMeasure) {
            return 0;
        }
        return (measure - minMeasure) / (maxMeasure - minMeasure);
    }
    /**
     * @param {?} coordinates
     * @param {?} measureToCompare
     * @return {?}
     */
    function comparePathWithMeasure(coordinates, measureToCompare) {
        /** @type {?} */
        var pointComparisionDetailsFromPath = coordinates
            .map(( /**
     * @param {?} coordinate
     * @param {?} index
     * @return {?}
     */function (coordinate, index) { return compareCoordinateWithMeasure(coordinate, measureToCompare, index); }));
        return pointComparisionDetailsFromPath;
    }
    /**
     * @param {?} coordinate
     * @param {?} measureToCompare
     * @param {?} index
     * @return {?}
     */
    function compareCoordinateWithMeasure(coordinate, measureToCompare, index) {
        /** @type {?} */
        var measureFromCoordinate = getMeasureFromPoint(coordinate);
        /** @type {?} */
        var pointDetails = {
            pointCoordinate: coordinate,
            distance: Math.abs(measureFromCoordinate - measureToCompare),
            pointMeasure: measureFromCoordinate,
            index: index
        };
        return pointDetails;
    }
    /**
     * @param {?} accumulator
     * @param {?} value
     * @param {?} measureToCompare
     * @return {?}
     */
    function minPointCloserToMeasure(accumulator, value, measureToCompare) {
        /** @type {?} */
        var isPointCloserToMeasure = value.distance <= accumulator.distance;
        /** @type {?} */
        var isPointLessThanMeasure = value.pointMeasure <= measureToCompare;
        return isPointCloserToMeasure && isPointLessThanMeasure
            ? value
            : accumulator;
    }
    /**
     * @param {?} point1
     * @param {?} point2
     * @param {?} measureToCompare
     * @return {?}
     */
    function maxPointCloserToMeasure(point1, point2, measureToCompare) {
        /** @type {?} */
        var isPointCloserToMeasure = point1.distance <= point2.distance;
        /** @type {?} */
        var isPointGreaterThanMeasure = point1.pointMeasure >= measureToCompare;
        return isPointCloserToMeasure && isPointGreaterThanMeasure
            ? point1
            : point2;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @return {?}
     */
    function toMultiLineString(line) {
        /** @type {?} */
        var coordinates = toMultiPartPaths(line);
        return {
            bbox: null,
            type: 'MultiLineString',
            coordinates: coordinates
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @return {?}
     */
    function toLineString(line) {
        return isArray(line)
            ? {
                bbox: null,
                type: 'LineString',
                coordinates: ( /** @type {?} */(line))
            }
            : ( /** @type {?} */(line));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @return {?}
     */
    function toLineOrMultiLineString(line) {
        /** @type {?} */
        var isCoordinatesArray = isArray(line);
        if (!isCoordinatesArray) {
            return ( /** @type {?} */(line));
        }
        /** @type {?} */
        var coordinates = ( /** @type {?} */(line));
        return isMultiPartLine(coordinates)
            ? toMultiLineString(coordinates)
            : toLineString(( /** @type {?} */(coordinates)));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} degrees
     * @return {?}
     */
    function degreesToRadians(degrees) {
        return degrees * Math.PI / 180;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} point1
     * @param {?} point2
     * @return {?}
     */
    function getDistanceBetweenPoints(point1, point2) {
        /** @type {?} */
        var coordinate1 = toSinglePartPointArray(point1);
        /** @type {?} */
        var coordinate2 = toSinglePartPointArray(point2);
        /** @type {?} */
        var x1 = coordinate1[0];
        /** @type {?} */
        var y1 = coordinate1[1];
        /** @type {?} */
        var x2 = coordinate2[0];
        /** @type {?} */
        var y2 = coordinate2[1];
        return getDistanceBetweenPointValues(x1, y1, x2, y2);
    }
    /**
     * @param {?} x1
     * @param {?} y1
     * @param {?} x2
     * @param {?} y2
     * @return {?}
     */
    function getDistanceBetweenPointValues(x1, y1, x2, y2) {
        // NOTE: This is using the pythagorean theorem (a^2 + b^2 = c^2).
        /** @type {?} */
        var xLength = Math.pow(x2 - x1, 2);
        /** @type {?} */
        var yLength = Math.pow(y2 - y1, 2);
        /** @type {?} */
        var distance$$1 = Math.sqrt(xLength + yLength);
        if (isNaN(distance$$1)) {
            throw new Error("Unable to calculate distance between points (" + x1 + "," + x2 + " and " + y1 + "," + y2 + "). Invalid or missing data was provided");
        }
        return distance$$1;
    }
    /**
     * @param {?} lat1
     * @param {?} lng1
     * @param {?} lat2
     * @param {?} lng2
     * @return {?}
     */
    function getKilometersBetweenLatLng(lat1, lng1, lat2, lng2) {
        // Modified from: https://stackoverflow.com/questions/365826/calculate-distance-between-2-gps-coordinates - RG.
        /** @type {?} */
        var dLat = degreesToRadians(lat2 - lat1);
        /** @type {?} */
        var dLon = degreesToRadians(lng2 - lng1);
        lat1 = degreesToRadians(lat1);
        lat2 = degreesToRadians(lat2);
        /** @type {?} */
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
        /** @type {?} */
        var circumference = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return EARTH_RADIUS_IN_KILOMETERS * circumference;
    }
    /**
     * @param {?} lat1
     * @param {?} lng1
     * @param {?} lat2
     * @param {?} lng2
     * @return {?}
     */
    function getMetersBetweenLatLng(lat1, lng1, lat2, lng2) {
        return getDistanceBetweenLatLng(lat1, lng1, lat2, lng2, LengthUnit.Meter);
    }
    /**
     * @param {?} lat1
     * @param {?} lng1
     * @param {?} lat2
     * @param {?} lng2
     * @return {?}
     */
    function getFeetBetweenLatLng(lat1, lng1, lat2, lng2) {
        return getDistanceBetweenLatLng(lat1, lng1, lat2, lng2, LengthUnit.Foot);
    }
    /**
     * @param {?} lat1
     * @param {?} lng1
     * @param {?} lat2
     * @param {?} lng2
     * @return {?}
     */
    function getMilesBetweenLatLng(lat1, lng1, lat2, lng2) {
        return getDistanceBetweenLatLng(lat1, lng1, lat2, lng2, LengthUnit.Mile);
    }
    /**
     * @param {?} lat1
     * @param {?} lon1
     * @param {?} lat2
     * @param {?} lon2
     * @param {?} outputUnit
     * @return {?}
     */
    function getDistanceBetweenLatLng(lat1, lon1, lat2, lon2, outputUnit) {
        /** @type {?} */
        var distanceInKilometers = getKilometersBetweenLatLng(lat1, lon1, lat2, lon2);
        return convertLengthUnits(distanceInKilometers, LengthUnit.Kilometer, outputUnit);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @param {?} point
     * @param {?=} options
     * @return {?}
     */
    function getMeasure(line, point, options) {
        options = Object.assign({
            lengthUnit: 'miles',
            coordinateSystem: 'wgs84'
        }, options);
        /** @type {?} */
        var closestPointFeature = nearestPointOnLine(line, point);
        if (!closestPointFeature || !closestPointFeature.geometry) {
            throw new Error('Unable to get measure for geometry');
        }
        /** @type {?} */
        var foundPointMeasure = getMeasureFromPoint(closestPointFeature.geometry);
        // If the point happens to land on a verticee, then it will already have a measure.
        if (foundPointMeasure !== null) {
            return foundPointMeasure;
        }
        /** @type {?} */
        var lineGeometry = toLineOrMultiLineString(line);
        if (isMultiPartLine(lineGeometry.coordinates)) {
            throw new Error('MultiLineString is not supported in getMeasure function yet.');
        }
        return interpolateMeasure(( /** @type {?} */(lineGeometry)), closestPointFeature.geometry, options);
    }
    /**
     * @param {?} line
     * @param {?} pointOnLine
     * @param {?} options
     * @return {?}
     */
    function interpolateMeasure(line, pointOnLine, options) {
        /** @type {?} */
        var pointCoordinates = toSinglePartPointArray(pointOnLine);
        /** @type {?} */
        var pointGeometry = { type: 'Point', coordinates: pointCoordinates };
        /** @type {?} */
        var pointFeature = { type: 'Feature', geometry: pointGeometry, properties: {} };
        /** @type {?} */
        var lineFeature = {
            type: 'Feature',
            geometry: line,
            properties: {}
        };
        /** @type {?} */
        var splitResult = lineSplit(lineFeature, pointFeature);
        /** @type {?} */
        var firstFeature = splitResult.features[0];
        /** @type {?} */
        var splitVertex = getLastItem(firstFeature.geometry.coordinates);
        /** @type {?} */
        var lastVertexWithMeasureIndex = firstFeature.geometry.coordinates.length - 2;
        /** @type {?} */
        var lastVertexWithMeasure = firstFeature.geometry.coordinates[lastVertexWithMeasureIndex];
        /** @type {?} */
        var newLineSegment = helpers.lineString([lastVertexWithMeasure, splitVertex]);
        /** @type {?} */
        var measureOffset = options.coordinateSystem === 'flat'
            ? getDistanceBetweenPoints(lastVertexWithMeasure, splitVertex)
            : length(newLineSegment, { units: ( /** @type {?} */(options.lengthUnit)) });
        /** @type {?} */
        var lastVertexMeasure = getMeasureFromPoint(lastVertexWithMeasure);
        return lastVertexMeasure + measureOffset;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NetworkFeature = /** @class */ (function (_super) {
        __extends(NetworkFeature, _super);
        function NetworkFeature(feature, layer, spatialReferenceId) {
            if (spatialReferenceId === void 0) {
                spatialReferenceId = WGS_84_SRID;
            }
            var _this = _super.call(this, feature, layer, spatialReferenceId) || this;
            _this.routeId = _this.getValue(layer.compositeRouteIdFieldName);
            _this.displayValue = _this.displayValue || _this.routeId;
            _this.setMeasureFromGeometry();
            return _this;
        }
        /**
         * @param {?} layer
         * @param {?=} properties
         * @param {?=} geometry
         * @return {?}
         */
        NetworkFeature.create = /**
         * @param {?} layer
         * @param {?=} properties
         * @param {?=} geometry
         * @return {?}
         */
            function (layer, properties, geometry) {
                if (properties === void 0) {
                    properties = {};
                }
                if (geometry === void 0) {
                    geometry = null;
                }
                /** @type {?} */
                var feature = toFeature(properties, ( /** @type {?} */(geometry)));
                return new NetworkFeature(feature, layer);
            };
        /**
         * @param {?} point
         * @return {?}
         */
        NetworkFeature.prototype.getMeasure = /**
         * @param {?} point
         * @return {?}
         */
            function (point) {
                return getMeasure(( /** @type {?} */(this.geometry)), point);
            };
        /**
         * @param {?} measure
         * @return {?}
         */
        NetworkFeature.prototype.getPoint = /**
         * @param {?} measure
         * @return {?}
         */
            function (measure) {
                return getPoint(( /** @type {?} */(this.geometry)), measure);
            };
        /**
         * @return {?}
         */
        NetworkFeature.prototype.clone = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var copyFeature = clone(this.toFeature());
                return new NetworkFeature(copyFeature, this.layer);
            };
        return NetworkFeature;
    }(LrsFeature));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LrsFeatureCollection = /** @class */ (function () {
        function LrsFeatureCollection(collection) {
            this.bbox = collection.bbox;
            this.type = collection.type;
        }
        /**
         * @param {?} features
         * @param {?=} bbox
         * @return {?}
         */
        LrsFeatureCollection.create = /**
         * @param {?} features
         * @param {?=} bbox
         * @return {?}
         */
            function (features, bbox) {
                return new LrsFeatureCollection({
                    type: 'FeatureCollection',
                    features: features,
                    bbox: bbox
                });
            };
        /**
         * @return {?}
         */
        LrsFeatureCollection.prototype.toGeoJson = /**
         * @return {?}
         */
            function () {
                return {
                    type: 'FeatureCollection',
                    bbox: this.bbox,
                    features: this.features.map(( /**
                     * @param {?} feature
                     * @return {?}
                     */function (feature) { return feature.toGeoJson(); }))
                };
            };
        return LrsFeatureCollection;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var EventFeatureCollection = /** @class */ (function (_super) {
        __extends(EventFeatureCollection, _super);
        function EventFeatureCollection(collection, layer, spatialReferenceId) {
            if (spatialReferenceId === void 0) {
                spatialReferenceId = WGS_84_SRID;
            }
            var _this = _super.call(this, collection) || this;
            _this.features = collection.features
                .map(( /**
         * @param {?} f
         * @return {?}
         */function (f) { return new EventFeature(f, layer, spatialReferenceId); }));
            return _this;
        }
        /**
         * @param {?} layer
         * @param {...?} features
         * @return {?}
         */
        EventFeatureCollection.fromFeatures = /**
         * @param {?} layer
         * @param {...?} features
         * @return {?}
         */
            function (layer) {
                var features = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    features[_i - 1] = arguments[_i];
                }
                return new EventFeatureCollection({
                    type: 'FeatureCollection',
                    features: features
                }, layer);
            };
        return EventFeatureCollection;
    }(LrsFeatureCollection));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NetworkFeatureCollection = /** @class */ (function (_super) {
        __extends(NetworkFeatureCollection, _super);
        function NetworkFeatureCollection(collection, layer, spatialReferenceId) {
            if (spatialReferenceId === void 0) {
                spatialReferenceId = WGS_84_SRID;
            }
            var _this = _super.call(this, collection) || this;
            _this.features = collection.features
                .map(( /**
         * @param {?} f
         * @return {?}
         */function (f) { return new NetworkFeature(f, layer, spatialReferenceId); }));
            return _this;
        }
        return NetworkFeatureCollection;
    }(LrsFeatureCollection));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?=} params
     * @param {?=} format
     * @return {?}
     */
    function getEsriMapServiceHttOptions(params, format) {
        if (format === void 0) {
            format = 'json';
        }
        /** @type {?} */
        var headers = new i1$1.HttpHeaders();
        params = params || new i1$1.HttpParams();
        if (format) {
            params = params.set('f', format);
        }
        headers.append('Content-Type', 'application/json');
        headers.append('Access-Control-Allow-Origin', '*');
        /** @type {?} */
        var httpOptions = {
            withCredentials: true,
            headers: headers,
            params: params,
        };
        return httpOptions;
    }
    /**
     * @param {?} httpOption
     * @param {?} params
     * @return {?}
     */
    function addParamsToHttpOptions(httpOption, params) {
        Object
            .keys(params)
            .filter(( /**
     * @param {?} key
     * @return {?}
     */function (key) { return isValue(params[key]); }))
            .forEach(( /**
     * @param {?} key
     * @return {?}
     */function (key) {
            /** @type {?} */
            var value = params[key];
            httpOption.params = httpOption.params.set(key, toFormDataString(value, false));
        }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} queryParameters
     * @return {?}
     */
    function toFormData(queryParameters) {
        /** @type {?} */
        var formData = new FormData();
        Object.keys(queryParameters)
            .map(( /**
     * @param {?} key
     * @return {?}
     */function (key) {
            return ({
                key: key,
                value: toFormDataString(queryParameters[key])
            });
        }))
            .forEach(( /**
     * @param {?} keyValue
     * @return {?}
     */function (keyValue) { return formData.append(keyValue.key, keyValue.value); }));
        return formData;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // Server identifiers.
    /** @type {?} */
    var MAP_SERVER_SERVICE_MATCH_IDENTIFIER = /(\/MapServer$|\/MapServer\/)/;
    /** @type {?} */
    var MAP_SERVER_SERVICE_IDENTIFIER = /(MapServer|MapServer\/)$/;
    /** @type {?} */
    var FEATURE_SERVER_SERVICE_IDENTIFIER = /(FeatureServer|FeatureServer\/)$/;
    /** @type {?} */
    var IMAGE_SERVER_SERVICE_IDENTIFIER = /(ImageServer|ImageServer\/)$'/;
    /** @type {?} */
    var FEATURE_SERVER_LAYER_SERVICE_IDENTIFIER = /FeatureServer\/(\d+|\d+\/)$/;
    /** @type {?} */
    var MAP_SERVER_LAYER_SERVICE_MATCH_IDENTIFIER = /(\/MapServer\/(\d+|\d+\/)|\/MapServer\/(\d+|\d+\/)\/)/;
    /** @type {?} */
    var MAP_SERVER_LAYER_SERVICE_IDENTIFIER = /MapServer\/(\d+|\d+\/)$/;
    /** @type {?} */
    var LRS_SERVER_SERVICE_IDENTIFIER = /(MapServer\/exts\/LRSServer|MapServer\/exts\/LRSServer\/)$/;
    /** @type {?} */
    var LRS_SERVER_LAYERS_SERVICE_IDENTIFIER = /(MapServer\/exts\/LRSServer\/layers|MapServer\/exts\/LRSServer\/layers\/)$/;
    // Map endpoints.
    /** @type {?} */
    var MAP_LAYERS_SERVICE_ENDPOINT = 'layers';
    /** @type {?} */
    var MAP_LAYER_SERVICE_ENDPOINT = '{layerId}';
    /** @type {?} */
    var MAP_LAYER_QUERY_SERVICE_ENDPOINT = '{layerId}/query';
    /** @type {?} */
    var MAP_LAYER_QUERY_RELATED_RECORDS_SERVICE_ENDPOINT = 'layers/{layerId}/queryRelatedRecords';
    // LRS endpoints.
    /** @type {?} */
    var LRS_SERVER_META_ENDPOINT = 'exts/LRSServer';
    /** @type {?} */
    var LRS_LAYERS_SERVICE_ENDPOINT = 'exts/LRSServer/layers';
    /** @type {?} */
    var LRS_SERVER_APPLY_EDITS_ENDPOINT = 'exts/LRSServer/applyEdits';
    // Network endpoints.
    /** @type {?} */
    var LRS_GEOMETRY_TO_MEASURE = 'exts/LRSServer/networkLayers/{layerId}/geometryToMeasure';
    // Portal.
    /** @type {?} */
    var PORTAL_SHARING_ENDPOINT = 'sharing';
    /** @type {?} */
    var PORTAL_OAUTH_AUTHORIZE_ENDPOINT = 'sharing/oauth2/authorize';
    /** @type {?} */
    var PORTAL_OAUTH_TOKEN_ENDPOINT = 'sharing/rest/oauth2/token';
    /** @type {?} */
    var PORTAL_GENERATE_TOKEN_ENDPOINT = 'sharing/generateToken';
    /** @type {?} */
    var PORTAL_REDIRECT_URL_PARAMS_BREAK_CHARACTER = '#';
    /** @type {?} */
    var DEFAULT_PORTAL_OAUTH_REDIRECT_OPTIONS = {
        responseType: 'token',
        urlParamsBreak: PORTAL_REDIRECT_URL_PARAMS_BREAK_CHARACTER,
        redirectUrl: window.location.href
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_GEOMETRY_TO_MEASURE_OPTIONS = {
        locations: [],
        inSR: 4326,
        outSR: 4326,
        f: 'json'
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {...?} options
     * @return {?}
     */
    function getGeometryToMeasureOptions() {
        var options = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            options[_i] = arguments[_i];
        }
        /** @type {?} */
        var mergedOption = Object.assign({}, DEFAULT_GEOMETRY_TO_MEASURE_OPTIONS);
        (options || [])
            .forEach(( /**
     * @param {?} option
     * @return {?}
     */function (option) { return Object.assign(mergedOption, option); }));
        if (util.isDate(mergedOption.temporalViewDate)) {
            mergedOption.temporalViewDate = toUtcEpochDate(( /** @type {?} */(mergedOption.temporalViewDate)));
        }
        return mergedOption;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_MAP_QUERY_OPTIONS = {
        // mapServiceUrl: '',
        // layerId: '',
        where: '1=1',
        text: '',
        objectIds: '',
        time: '',
        geometry: '',
        geometryType: 'esriGeometryEnvelope',
        spatialRel: 'esriSpatialRelIntersects',
        relationParam: '',
        outFields: '*',
        returnGeometry: true,
        returnTrueCurves: false,
        maxAllowableOffset: '',
        geometryPrecision: '',
        inSR: WGS_84_SRID,
        outSR: WGS_84_SRID,
        returnIdsOnly: false,
        returnCountOnly: false,
        orderByFields: '',
        groupByFieldsForStatistics: '',
        outStatistics: '',
        returnZ: false,
        returnM: true,
        gdbVersion: '',
        returnDistinctValues: false,
        resultOffset: '',
        resultRecordCount: '',
        queryByDistance: '',
        returnExtentsOnly: false,
        datumTransformation: '',
        parameterValues: '',
        rangeValues: '',
        f: 'geojson'
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {...?} options
     * @return {?}
     */
    function getMapQueryOptions() {
        var options = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            options[_i] = arguments[_i];
        }
        /** @type {?} */
        var mergedOption = Object.assign({}, DEFAULT_MAP_QUERY_OPTIONS);
        (options || [])
            .forEach(( /**
     * @param {?} option
     * @return {?}
     */function (option) { return Object.assign(mergedOption, option); }));
        return mergedOption;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} options
     * @param {?=} httpParams
     * @return {?}
     */
    function toHttpQueryParams(options, httpParams) {
        httpParams = httpParams || new i1$1.HttpParams();
        Object.keys(options)
            .forEach(( /**
     * @param {?} k
     * @return {?}
     */function (k) {
            /** @type {?} */
            var value = options[k];
            if (isValue(value)) {
                httpParams = httpParams.set(k, value);
            }
        }));
        return httpParams;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * NOTE: There is a bug in ArcGIS Server < v10.5.0 which requies that you do not pass a
     * 'gdbVersion' if that version name is the same version that the layer is published in.
     * We need to strip that GDB version when this occurs.
     * @param {?} layer
     * @param {?=} options
     * @return {?}
     */
    function tryStripGdbVersion(layer, options) {
        if (layer
            && options
            && layer.versionName
            && options.gdbVersion
            && layer.versionName.toLowerCase() === options.gdbVersion.toLowerCase()) {
            options.gdbVersion = undefined;
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} layer
     * @return {?}
     */
    function toLayerId(layer) {
        return isNumber(layer) ? ( /** @type {?} */(layer)) : (( /** @type {?} */(layer))).id;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} layer
     * @param {?} tokens
     * @param {...?} parts
     * @return {?}
     */
    function joinAndFomatWithLayer(layer, tokens) {
        var parts = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parts[_i - 2] = arguments[_i];
        }
        /** @type {?} */
        var layerId = toLayerId(layer);
        return joinAndFomat.apply(void 0, __spread([Object.assign({}, tokens, {
                layerId: layerId
            })], parts));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} info
     * @return {?}
     */
    function isClassBreakInfoEmpty(info) {
        return !info
            || !info.classMaxValue
                && !info.label
                && !info.description
                && !Object.keys(info.symbol || {}).length;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} info
     * @return {?}
     */
    function isUniqueValueInfoEmpty(info) {
        return !info
            || !info.value
                && !info.label
                && !info.description
                && !Object.keys(info.symbol || {}).length;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_UNIQUE_VALUE_INFO = null;
    /** @type {?} */
    var DEFAULT_CLASS_BREAK_VALUE_INFO = null;
    /** @type {?} */
    var DEFAULT_RENDERER_SYMBOL = {
        type: 'esriSLS',
        style: 'esriSLSSolid',
        color: '#000000',
        width: 2
    };
    /**
     * @param {?} symbol
     * @return {?}
     */
    function isRendererSymbolDefault(symbol) {
        return Object.keys(symbol).length === Object.keys(DEFAULT_RENDERER_SYMBOL).length
            && symbol.type === DEFAULT_RENDERER_SYMBOL.type
            && symbol.style === DEFAULT_RENDERER_SYMBOL.style
            && symbol.color === DEFAULT_RENDERER_SYMBOL.color
            && symbol.width === DEFAULT_RENDERER_SYMBOL.width;
    }
    var LayerDrawingInfoRenderer = /** @class */ (function () {
        function LayerDrawingInfoRenderer(base) {
            Object.assign(this, base);
            this.type = this.type || 'simple';
            this.minValue = this.minValue || 0;
            this.classBreakInfos = this.classBreakInfos || [];
            this.uniqueValueInfos = this.uniqueValueInfos || [];
            this.symbol = Object.assign({}, DEFAULT_RENDERER_SYMBOL, this.symbol);
            this.label = this.label || '';
            this.description = this.description || '';
            this.standardizeRenderSymbols();
        }
        Object.defineProperty(LayerDrawingInfoRenderer.prototype, "isSimple", {
            get: /**
             * @return {?}
             */ function () {
                return this.type === 'simple';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerDrawingInfoRenderer.prototype, "isUniqueValue", {
            get: /**
             * @return {?}
             */ function () {
                return this.type === 'uniqueValue';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerDrawingInfoRenderer.prototype, "isClassBreak", {
            get: /**
             * @return {?}
             */ function () {
                return this.type === 'classBreaks';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerDrawingInfoRenderer.prototype, "isEmpty", {
            get: /**
             * @return {?}
             */ function () {
                return !this.minValue
                    && !this.classBreakInfos.length
                    && !this.uniqueValueInfos.length
                    && isRendererSymbolDefault(this.symbol);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerDrawingInfoRenderer.prototype, "field", {
            get: /**
             * @return {?}
             */ function () {
                return this.field1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.field1 = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        LayerDrawingInfoRenderer.prototype.getSymbol = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var symbol = this.symbol || this.defaultSymbol;
                if (this.isUniqueValue) {
                    /** @type {?} */
                    var uniqueValueInfo = this.getUniqueValueInfoOrDefault(value);
                    symbol = isUniqueValueInfoEmpty(uniqueValueInfo) ? null : uniqueValueInfo.symbol;
                }
                else if (this.isClassBreak) {
                    /** @type {?} */
                    var classBreakInfo = this.getClassBreakInfoOrDefault(value);
                    symbol = isClassBreakInfoEmpty(classBreakInfo) ? null : classBreakInfo.symbol;
                }
                return symbol || this.defaultSymbol || null;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        LayerDrawingInfoRenderer.prototype.getUniqueValueInfo = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!this.uniqueValueInfos || !this.uniqueValueInfos.length) {
                    return null;
                }
                return this.uniqueValueInfos.find(( /**
                 * @param {?} info
                 * @return {?}
                 */function (info) {
                    return info.value === value || String(info.value) === String(value);
                }));
            };
        /**
         * @param {?} value
         * @return {?}
         */
        LayerDrawingInfoRenderer.prototype.getUniqueValueInfoOrDefault = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return this.getUniqueValueInfo(value) || DEFAULT_UNIQUE_VALUE_INFO;
            };
        /**
         * @param {?} classValue
         * @return {?}
         */
        LayerDrawingInfoRenderer.prototype.getClassBreakInfo = /**
         * @param {?} classValue
         * @return {?}
         */
            function (classValue) {
                var _this = this;
                if (!this.classBreakInfos || !this.classBreakInfos.length) {
                    return null;
                }
                return this.classBreakInfos.find(( /**
                 * @param {?} value
                 * @param {?} index
                 * @return {?}
                 */function (value, index) { return _this.isValueInClassBreakRange(value, classValue, index); }));
            };
        /**
         * @param {?} value
         * @return {?}
         */
        LayerDrawingInfoRenderer.prototype.getClassBreakInfoOrDefault = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return this.getClassBreakInfo(value) || DEFAULT_CLASS_BREAK_VALUE_INFO;
            };
        /**
         * @param {?} classBreakInfo
         * @param {?} value
         * @param {?} index
         * @return {?}
         */
        LayerDrawingInfoRenderer.prototype.isValueInClassBreakRange = /**
         * @param {?} classBreakInfo
         * @param {?} value
         * @param {?} index
         * @return {?}
         */
            function (classBreakInfo, value, index) {
                /** @type {?} */
                var rangeMin = index === 0 ? this.minValue : this.classBreakInfos[index - 1].classMaxValue;
                /** @type {?} */
                var rangeMax = classBreakInfo.classMaxValue;
                return rangeMin < value && rangeMax > value;
            };
        /**
         * @return {?}
         */
        LayerDrawingInfoRenderer.prototype.clearEmptyInfos = /**
         * @return {?}
         */
            function () {
                removeWhere(this.uniqueValueInfos, ( /**
                 * @param {?} info
                 * @return {?}
                 */function (info) { return isUniqueValueInfoEmpty(info); }));
                removeWhere(this.classBreakInfos, ( /**
                 * @param {?} info
                 * @return {?}
                 */function (info) { return isClassBreakInfoEmpty(info); }));
            };
        /**
         * @param {?=} value
         * @return {?}
         */
        LayerDrawingInfoRenderer.prototype.getBestRepresentativeColor = /**
         * @param {?=} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var symbol = this.defaultSymbol || this.symbol;
                if (this.isUniqueValue && this.uniqueValueInfos.length) {
                    /** @type {?} */
                    var foundInfo = this.getUniqueValueInfo(value);
                    symbol = foundInfo ? foundInfo.symbol : this.uniqueValueInfos[0].symbol;
                }
                else if (this.isClassBreak && this.classBreakInfos.length) {
                    /** @type {?} */
                    var foundInfo = this.getClassBreakInfo(value);
                    symbol = foundInfo ? foundInfo.symbol : this.classBreakInfos[0].symbol;
                }
                return ( /** @type {?} */(symbol.color));
            };
        /**
         * @return {?}
         */
        LayerDrawingInfoRenderer.prototype.standardizeRenderSymbols = /**
         * @return {?}
         */
            function () {
                standardizeRenderSymbol(this.defaultSymbol);
                standardizeRenderSymbol(this.symbol);
                this.uniqueValueInfos.forEach(( /**
                 * @param {?} info
                 * @return {?}
                 */function (info) { return standardizeRenderSymbol(info.symbol); }));
                this.classBreakInfos.forEach(( /**
                 * @param {?} info
                 * @return {?}
                 */function (info) { return standardizeRenderSymbol(info.symbol); }));
            };
        return LayerDrawingInfoRenderer;
    }());
    /**
     * @param {?} symbol
     * @return {?}
     */
    function standardizeRenderSymbol(symbol) {
        if (!symbol) {
            return;
        }
        if (isArray(symbol.color)) {
            symbol.color = rgbToHex(( /** @type {?} */(symbol.color)));
        }
        if (symbol.outline && isArray(symbol.outline.color)) {
            symbol.outline.color = rgbToHex(( /** @type {?} */(symbol.outline.color)));
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LayerDrawingInfo = /** @class */ (function () {
        function LayerDrawingInfo() {
            var baseDrawingInfos = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                baseDrawingInfos[_i] = arguments[_i];
            }
            this.merge.apply(this, __spread(baseDrawingInfos));
            this.transparency = this.transparency || 0;
            this.zIndex = this.zIndex || null;
            this.renderer = new LayerDrawingInfoRenderer(this.renderer);
            this.positionRenderer = new LayerDrawingInfoRenderer(this.positionRenderer);
            this.labelingInfo = this.labelingInfo || null;
        }
        Object.defineProperty(LayerDrawingInfo.prototype, "isEmpty", {
            get: /**
             * @return {?}
             */ function () {
                return !this.transparency
                    && !this.zIndex
                    && this.renderer.isEmpty
                    && this.positionRenderer.isEmpty
                    && !Object.keys(this.labelingInfo || {}).length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LayerDrawingInfo.prototype, "opacity", {
            get: /**
             * @return {?}
             */ function () {
                return transparencyToOpacity(this.transparency);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @template THIS
         * @this {THIS}
         * @param {...?} targetDrawingInfos
         * @return {THIS}
         */
        LayerDrawingInfo.prototype.merge = /**
         * @template THIS
         * @this {THIS}
         * @param {...?} targetDrawingInfos
         * @return {THIS}
         */
            function () {
                var targetDrawingInfos = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    targetDrawingInfos[_i] = arguments[_i];
                }
                /** @type {?} */
                var properties = targetDrawingInfos.map(( /**
                 * @param {?} info
                 * @return {?}
                 */function (info) {
                    return info && (( /** @type {?} */(info))).toProperties
                        ? (( /** @type {?} */(info))).toProperties()
                        : info;
                }));
                Object.assign.apply(Object, __spread([( /** @type {?} */(this))], properties));
                return ( /** @type {?} */(this));
            };
        /**
         * @param {?=} value
         * @return {?}
         */
        LayerDrawingInfo.prototype.getRendererSymbol = /**
         * @param {?=} value
         * @return {?}
         */
            function (value) {
                return this.renderer.getSymbol(value);
            };
        /**
         * @param {?=} value
         * @return {?}
         */
        LayerDrawingInfo.prototype.getPositionRendererSymbol = /**
         * @param {?=} value
         * @return {?}
         */
            function (value) {
                return this.positionRenderer.getSymbol(value);
            };
        /**
         * @param {?=} value
         * @return {?}
         */
        LayerDrawingInfo.prototype.getBestRepresentativeColor = /**
         * @param {?=} value
         * @return {?}
         */
            function (value) {
                return this.renderer.getBestRepresentativeColor(value);
            };
        /**
         * @return {?}
         */
        LayerDrawingInfo.prototype.toProperties = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var infoProperties = {};
                if (this.labelingInfo) {
                    infoProperties.labelingInfo = this.labelingInfo;
                }
                if (this.positionRenderer && !this.positionRenderer.isEmpty) {
                    infoProperties.positionRenderer = this.positionRenderer;
                }
                if (this.renderer && !this.renderer.isEmpty) {
                    infoProperties.renderer = this.renderer;
                }
                if (this.transparency) {
                    infoProperties.transparency = this.transparency;
                }
                return infoProperties;
            };
        return LayerDrawingInfo;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var POINT_GEOMETRY_TYPES = ['point', 'esriGeometryPoint'];
    /** @type {?} */
    var LINEAR_GEOMETRY_TYPES = ['line', 'esriGeometryPolyline'];
    /** @type {?} */
    var POLYGON_GEOMETRY_TYPES = ['polygon', 'esriGeometryPolygon'];
    /**
     * @param {?} geometryType
     * @return {?}
     */
    function isPointGeometryType(geometryType) {
        return POINT_GEOMETRY_TYPES.indexOf(geometryType) > -1;
    }
    /**
     * @param {?} geometryType
     * @return {?}
     */
    function isLinearGeometryType(geometryType) {
        return LINEAR_GEOMETRY_TYPES.indexOf(geometryType) > -1;
    }
    /**
     * @param {?} geometryType
     * @return {?}
     */
    function isPolygonGeometryType(geometryType) {
        return POLYGON_GEOMETRY_TYPES.indexOf(geometryType) > -1;
    }
    var FeatureClassLayer = /** @class */ (function () {
        function FeatureClassLayer() {
            var sources = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i] = arguments[_i];
            }
            Object.assign.apply(Object, __spread([this], sources));
            this.subLayers = this.subLayers || [];
            this.fields = this.fields || [];
            this.indexes = this.indexes || [];
            this.relationships = this.relationships || [];
            this.supportedQueryFormats = this.supportedQueryFormats || [];
            this.drawingInfo = new LayerDrawingInfo(this.drawingInfo);
        }
        Object.defineProperty(FeatureClassLayer.prototype, "isPoint", {
            get: /**
             * @return {?}
             */ function () {
                return isPointGeometryType(this.geometryType);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FeatureClassLayer.prototype, "isLinear", {
            get: /**
             * @return {?}
             */ function () {
                return isLinearGeometryType(this.geometryType);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FeatureClassLayer.prototype, "isPolygon", {
            get: /**
             * @return {?}
             */ function () {
                return isPolygonGeometryType(this.geometryType);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FeatureClassLayer.prototype, "displayFieldAlias", {
            get: /**
             * @return {?}
             */ function () {
                return this.getFieldAlias(this.displayField);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} fieldName
         * @return {?}
         */
        FeatureClassLayer.prototype.getField = /**
         * @param {?} fieldName
         * @return {?}
         */
            function (fieldName) {
                return getField(fieldName, this.fields);
            };
        /**
         * @param {?} fieldName
         * @return {?}
         */
        FeatureClassLayer.prototype.getFieldAlias = /**
         * @param {?} fieldName
         * @return {?}
         */
            function (fieldName) {
                return getFieldAlias(fieldName, this.fields);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} domains
         * @return {THIS}
         */
        FeatureClassLayer.prototype.applyFieldDomains = /**
         * @template THIS
         * @this {THIS}
         * @param {?} domains
         * @return {THIS}
         */
            function (domains) {
                if (domains.length) {
                    ( /** @type {?} */(this)).fields
                        .filter(( /**
                 * @param {?} f
                 * @return {?}
                 */function (f) { return f.domainName; }))
                        .forEach(( /**
                 * @param {?} field
                 * @return {?}
                 */function (field) {
                        return field.domain = domains.find(( /**
                         * @param {?} domain
                         * @return {?}
                         */function (domain) { return domain.name === field.domainName; })) || field.domain;
                    }));
                }
                return ( /** @type {?} */(this));
            };
        /**
         * @return {?}
         */
        FeatureClassLayer.prototype.clone = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var copy = clone(this);
                return new FeatureClassLayer(copy);
            };
        return FeatureClassLayer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var EsriMapServerService = /** @class */ (function (_super) {
        __extends(EsriMapServerService, _super);
        function EsriMapServerService(http, config, dataConfig, log) {
            return _super.call(this, http, config, dataConfig, log) || this;
        }
        /**
         * Retrieves the map service metadata for all layers.
         */
        /**
         * Retrieves the map service metadata for all layers.
         * @param {?} serviceUrl
         * @return {?}
         */
        EsriMapServerService.prototype.getMapLayers = /**
         * Retrieves the map service metadata for all layers.
         * @param {?} serviceUrl
         * @return {?}
         */
            function (serviceUrl) {
                var _this = this;
                /** @type {?} */
                var url = join(serviceUrl, MAP_LAYERS_SERVICE_ENDPOINT);
                return this.http
                    .get(url, getEsriMapServiceHttOptions())
                    .pipe(operators.tap(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return _this.handleEsriResponseError(response, serviceUrl); })));
            };
        /**
         * Retrieves the map service metadata for a given layer (by it's ID).
         */
        /**
         * Retrieves the map service metadata for a given layer (by it's ID).
         * @param {?} serviceUrl
         * @param {?} layerId
         * @return {?}
         */
        EsriMapServerService.prototype.getMapLayer = /**
         * Retrieves the map service metadata for a given layer (by it's ID).
         * @param {?} serviceUrl
         * @param {?} layerId
         * @return {?}
         */
            function (serviceUrl, layerId) {
                var _this = this;
                /** @type {?} */
                var url = joinAndFomatWithLayer(layerId, {}, serviceUrl, MAP_LAYER_SERVICE_ENDPOINT);
                return this.http
                    .get(url, getEsriMapServiceHttOptions())
                    .pipe(operators.tap(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return _this.handleEsriResponseError(response, serviceUrl); })), operators.map(( /**
                 * @param {?} mapLayerMetadata
                 * @return {?}
                 */function (mapLayerMetadata) { return new FeatureClassLayer(mapLayerMetadata); })));
            };
        /**
         * Retrieves the LRS Layers Metadata information from the map service
         */
        /**
         * Retrieves the LRS Layers Metadata information from the map service
         * @param {?} serviceUrl
         * @return {?}
         */
        EsriMapServerService.prototype.getLrsLayers = /**
         * Retrieves the LRS Layers Metadata information from the map service
         * @param {?} serviceUrl
         * @return {?}
         */
            function (serviceUrl) {
                var _this = this;
                /** @type {?} */
                var url = join(serviceUrl, LRS_LAYERS_SERVICE_ENDPOINT);
                return this.http
                    .get(url, getEsriMapServiceHttOptions())
                    .pipe(operators.tap(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return _this.handleEsriResponseError(response, serviceUrl); })));
            };
        /**
         * Retrieves the LRS Server Metadata information from the map service
         */
        /**
         * Retrieves the LRS Server Metadata information from the map service
         * @param {?} serviceUrl
         * @return {?}
         */
        EsriMapServerService.prototype.getLrsServer = /**
         * Retrieves the LRS Server Metadata information from the map service
         * @param {?} serviceUrl
         * @return {?}
         */
            function (serviceUrl) {
                var _this = this;
                /** @type {?} */
                var url = join(serviceUrl, LRS_SERVER_META_ENDPOINT);
                return this.http
                    .get(url, getEsriMapServiceHttOptions())
                    .pipe(operators.tap(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return _this.handleEsriResponseError(response, serviceUrl); })));
            };
        /**
         * @param {?} serviceUrl
         * @param {?=} lrsId
         * @return {?}
         */
        EsriMapServerService.prototype.getVersions = /**
         * @param {?} serviceUrl
         * @param {?=} lrsId
         * @return {?}
         */
            function (serviceUrl, lrsId) {
                return this.getLrsServer(serviceUrl)
                    .pipe(operators.map(( /**
             * @param {?} metadata
             * @return {?}
             */function (metadata) {
                    /** @type {?} */
                    var lrs = metadata ? metadata.lrs[0] : null;
                    if (!lrs) {
                        throw new Error("No LRS infos found");
                    }
                    if (lrsId) {
                        lrs = metadata.lrs.find(( /**
                         * @param {?} lrsInfo
                         * @return {?}
                         */function (lrsInfo) { return lrsInfo.id === lrsId; }));
                        if (!lrs) {
                            throw new Error("No LRS info found with ID '" + lrsId + "'");
                        }
                    }
                    return lrs.versions;
                })));
            };
        /**
         * @param {?} serviceUrl
         * @param {?} networkLayerId
         * @param {?} routeId
         * @param {?} x
         * @param {?} y
         * @param {?=} viewDate
         * @param {?=} inSpatialReferenceId
         * @param {?=} outputSpatialReferenceId
         * @return {?}
         */
        EsriMapServerService.prototype.singleGeometryToMeasure = /**
         * @param {?} serviceUrl
         * @param {?} networkLayerId
         * @param {?} routeId
         * @param {?} x
         * @param {?} y
         * @param {?=} viewDate
         * @param {?=} inSpatialReferenceId
         * @param {?=} outputSpatialReferenceId
         * @return {?}
         */
            function (serviceUrl, networkLayerId, routeId, x, y, viewDate, inSpatialReferenceId, outputSpatialReferenceId) {
                if (inSpatialReferenceId === void 0) {
                    inSpatialReferenceId = 4326;
                }
                if (outputSpatialReferenceId === void 0) {
                    outputSpatialReferenceId = 4326;
                }
                /** @type {?} */
                var locations = [
                    { routeId: routeId, geometry: { x: x, y: y } }
                ];
                return this.geometryToMeasure(serviceUrl, networkLayerId, {
                    locations: locations,
                    temporalViewDate: viewDate,
                    inSR: inSpatialReferenceId,
                    outSR: outputSpatialReferenceId,
                })
                    .pipe(operators.map(( /**
             * @param {?} result
             * @return {?}
             */function (result) {
                    /** @type {?} */
                    var match = { m: null, x: null, y: null, z: null };
                    if (result.locations.length && result.locations[0].results.length) {
                        var _a = __read(result.locations[0].results, 1), found = _a[0];
                        match.m = found.measure;
                        match.x = found.geometry.x;
                        match.y = found.geometry.y;
                    }
                    return match;
                })));
            };
        /**
         * @param {?} serviceUrl
         * @param {?} networkLayerId
         * @param {?} options
         * @return {?}
         */
        EsriMapServerService.prototype.geometryToMeasure = /**
         * @param {?} serviceUrl
         * @param {?} networkLayerId
         * @param {?} options
         * @return {?}
         */
            function (serviceUrl, networkLayerId, options) {
                var _this = this;
                /** @type {?} */
                var endpoint = format(LRS_GEOMETRY_TO_MEASURE, { layerId: networkLayerId });
                /** @type {?} */
                var url = join(serviceUrl, endpoint);
                /** @type {?} */
                var httpOption = getEsriMapServiceHttOptions();
                /** @type {?} */
                var serviceOptions = getGeometryToMeasureOptions(options);
                /** @type {?} */
                var useGetMethod = !this.shouldUsePostMethod(serviceOptions);
                if (useGetMethod) {
                    addParamsToHttpOptions(httpOption, serviceOptions);
                }
                return (useGetMethod
                    ? this.http.get(url, httpOption)
                    : this.http.post(url, toFormData(serviceOptions), httpOption))
                    .pipe(operators.tap(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return _this.handleEsriResponseError(response, serviceUrl); })));
            };
        /**
         * @param {?} serviceUrl
         * @param {?} edits
         * @param {?=} gdbVersion
         * @return {?}
         */
        EsriMapServerService.prototype.applyEdits = /**
         * @param {?} serviceUrl
         * @param {?} edits
         * @param {?=} gdbVersion
         * @return {?}
         */
            function (serviceUrl, edits, gdbVersion) {
                var _this = this;
                /** @type {?} */
                var url = join(serviceUrl, LRS_SERVER_APPLY_EDITS_ENDPOINT);
                /** @type {?} */
                var options = getEsriMapServiceHttOptions();
                /** @type {?} */
                var useGetMethod = !this.shouldUsePostMethod(edits);
                if (useGetMethod) {
                    options.params = options.params
                        .set('edits', JSON.stringify(edits))
                        .set('gdbVersion', gdbVersion);
                }
                return (useGetMethod
                    ? this.http.get(url, options)
                    : this.http.post(url, toFormData({ edits: edits, gdbVersion: gdbVersion }), options))
                    .pipe(operators.tap(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return _this.handleEsriResponseError(response, serviceUrl); })));
            };
        /**
         * @template T
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} field
         * @param {?=} options
         * @return {?}
         */
        EsriMapServerService.prototype.getUniqueValues = /**
         * @template T
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} field
         * @param {?=} options
         * @return {?}
         */
            function (serviceUrl, layer, field, options) {
                /** @type {?} */
                var fieldName = toFieldName(field);
                /** @type {?} */
                var queryOptions = getMapQueryOptions({
                    outFields: fieldName,
                    returnDistinctValues: true,
                    returnGeometry: false,
                }, options);
                return this.query(serviceUrl, toLayerId(layer), queryOptions)
                    .pipe(operators.map(( /**
             * @param {?} collection
             * @return {?}
             */function (collection) {
                    return collection.features.map(( /**
                     * @param {?} f
                     * @return {?}
                     */function (f) { return f.properties[fieldName]; }));
                })));
            };
        /**
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} whereClause
         * @param {?=} options
         * @return {?}
         */
        EsriMapServerService.prototype.getQueryCount = /**
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} whereClause
         * @param {?=} options
         * @return {?}
         */
            function (serviceUrl, layer, whereClause, options) {
                /** @type {?} */
                var queryOptions = getMapQueryOptions({
                    returnCountOnly: true,
                    returnGeometry: false,
                    where: whereClause,
                }, options);
                return this.query(serviceUrl, toLayerId(layer), queryOptions)
                    .pipe(operators.map(( /**
             * @param {?} result
             * @return {?}
             */function (result) {
                    return (result || { count: 0 }).count;
                })));
            };
        /**
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} eventId
         * @param {?=} options
         * @return {?}
         */
        EsriMapServerService.prototype.getEvent = /**
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} eventId
         * @param {?=} options
         * @return {?}
         */
            function (serviceUrl, layer, eventId, options) {
                tryStripGdbVersion(layer, options);
                throw new Error('Not implemented yet');
            };
        /**
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} routeId
         * @param {?} fromMeasure
         * @param {?} toMeasure
         * @param {?=} viewDate
         * @param {?=} options
         * @return {?}
         */
        EsriMapServerService.prototype.queryEvents = /**
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} routeId
         * @param {?} fromMeasure
         * @param {?} toMeasure
         * @param {?=} viewDate
         * @param {?=} options
         * @return {?}
         */
            function (serviceUrl, layer, routeId, fromMeasure, toMeasure, viewDate, options) {
                tryStripGdbVersion(layer, options);
                /** @type {?} */
                var where = this.getWhereBuilder()
                    .withEventLayer(layer)
                    .withRouteId(routeId)
                    .withViewDate(viewDate)
                    .betweenMeasures(fromMeasure, toMeasure)
                    .toWhereClause();
                /** @type {?} */
                var queryOptions = getMapQueryOptions({ where: where, returnGeometry: false }, options);
                return this
                    .query(serviceUrl, layer.id, queryOptions)
                    .pipe(operators.map(( /**
             * @param {?} featureCollection
             * @return {?}
             */function (featureCollection) { return new EventFeatureCollection(featureCollection, layer); })));
            };
        /**
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} searchText
         * @param {?=} options
         * @return {?}
         */
        EsriMapServerService.prototype.searchEventsByText = /**
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} searchText
         * @param {?=} options
         * @return {?}
         */
            function (serviceUrl, layer, searchText, options) {
                var _this = this;
                return this.searchByText(serviceUrl, layer.id, searchText, options)
                    .pipe(operators.tap(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return _this.handleEsriResponseError(response, serviceUrl); })), operators.map(( /**
                 * @param {?} featureCollection
                 * @return {?}
                 */function (featureCollection) { return new EventFeatureCollection(featureCollection, layer); })));
            };
        /**
         * @param {?} serviceUrl
         * @param {?} routeId
         * @param {?} layer
         * @param {?=} viewDate
         * @param {?=} options
         * @return {?}
         */
        EsriMapServerService.prototype.getRoute = /**
         * @param {?} serviceUrl
         * @param {?} routeId
         * @param {?} layer
         * @param {?=} viewDate
         * @param {?=} options
         * @return {?}
         */
            function (serviceUrl, routeId, layer, viewDate, options) {
                tryStripGdbVersion(layer, options);
                /** @type {?} */
                var where = this.getWhereBuilder()
                    .withNetworkLayer(layer)
                    .where(layer.compositeRouteIdFieldName, CriteriaOperator.Equals, routeId)
                    .withViewDate(viewDate)
                    .toWhereClause();
                /** @type {?} */
                var queryOptions = getMapQueryOptions({
                    where: where
                }, options);
                return this
                    .query(serviceUrl, layer.id, queryOptions)
                    .pipe(operators.map(( /**
             * @param {?} x
             * @return {?}
             */function (x) {
                    return x && x.features && x.features.length
                        ? new NetworkFeature(x.features[0], layer)
                        : null;
                })));
            };
        /**
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} whereClause
         * @param {?=} options
         * @return {?}
         */
        EsriMapServerService.prototype.queryRoutes = /**
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} whereClause
         * @param {?=} options
         * @return {?}
         */
            function (serviceUrl, layer, whereClause, options) {
                /** @type {?} */
                var queryOptions = getMapQueryOptions({
                    where: whereClause
                }, options);
                return this.query(serviceUrl, layer.id, queryOptions)
                    .pipe(operators.map(( /**
             * @param {?} featureCollection
             * @return {?}
             */function (featureCollection) { return new NetworkFeatureCollection(featureCollection, layer, options.outSR); })));
            };
        /**
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} searchText
         * @param {?=} options
         * @return {?}
         */
        EsriMapServerService.prototype.searchRoutesByText = /**
         * @param {?} serviceUrl
         * @param {?} layer
         * @param {?} searchText
         * @param {?=} options
         * @return {?}
         */
            function (serviceUrl, layer, searchText, options) {
                return this.searchByText(serviceUrl, layer.id, searchText, options)
                    .pipe(operators.map(( /**
             * @param {?} featureCollection
             * @return {?}
             */function (featureCollection) { return new NetworkFeatureCollection(featureCollection, layer); })));
            };
        /**
         * @param {?} serviceUrl
         * @param {?} layerId
         * @param {?} searchText
         * @param {?=} options
         * @return {?}
         */
        EsriMapServerService.prototype.searchByText = /**
         * @param {?} serviceUrl
         * @param {?} layerId
         * @param {?} searchText
         * @param {?=} options
         * @return {?}
         */
            function (serviceUrl, layerId, searchText, options) {
                /** @type {?} */
                var queryOptions = getMapQueryOptions({
                    text: searchText
                }, options);
                // The where clause must be deleted because if a where clause is specified it will override the search text.
                delete queryOptions.where;
                return this.query(serviceUrl, layerId, queryOptions);
            };
        /**
         * @param {?} serviceUrl
         * @param {?} layerId
         * @param {?} options
         * @return {?}
         */
        EsriMapServerService.prototype.query = /**
         * @param {?} serviceUrl
         * @param {?} layerId
         * @param {?} options
         * @return {?}
         */
            function (serviceUrl, layerId, options) {
                var _this = this;
                /** @type {?} */
                var url = joinAndFomatWithLayer(layerId, options, serviceUrl, MAP_LAYER_QUERY_SERVICE_ENDPOINT);
                /** @type {?} */
                var httpOption = getEsriMapServiceHttOptions();
                /** @type {?} */
                var usePostMethod = this.shouldUsePostMethod(options.where);
                if (!usePostMethod) {
                    httpOption.params = toHttpQueryParams(options, httpOption.params);
                }
                /** @type {?} */
                var source = usePostMethod
                    ? this.http.post(url, options, httpOption)
                    : this.http.get(url, httpOption);
                return source.pipe(operators.map(( /**
                 * @param {?} response
                 * @return {?}
                 */function (response) {
                    _this.handleEsriResponseError(response, url);
                    return ( /** @type {?} */(response));
                })));
            };
        EsriMapServerService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        EsriMapServerService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: EsriConfig },
                { type: DataSourceConfig },
                { type: Logger }
            ];
        };
        /** @nocollapse */ EsriMapServerService.ngInjectableDef = i0.defineInjectable({ factory: function EsriMapServerService_Factory() { return new EsriMapServerService(i0.inject(i1$1.HttpClient), i0.inject(EsriConfig), i0.inject(DataSourceConfig), i0.inject(Logger)); }, token: EsriMapServerService, providedIn: "root" });
        return EsriMapServerService;
    }(BaseEsriService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} url
     * @return {?}
     */
    function isFeatureServerLayerUrl(url) {
        return FEATURE_SERVER_LAYER_SERVICE_IDENTIFIER.test(url);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} url
     * @return {?}
     */
    function isFeatureServerServiceUrl(url) {
        return FEATURE_SERVER_SERVICE_IDENTIFIER.test(url);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} url
     * @return {?}
     */
    function isMapServerServiceUrl(url) {
        return MAP_SERVER_SERVICE_IDENTIFIER.test(url);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} url
     * @return {?}
     */
    function isLrsServerServiceUrl(url) {
        return LRS_SERVER_SERVICE_IDENTIFIER.test(url);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} url
     * @return {?}
     */
    function isLrsServerLayersServiceUrl(url) {
        return LRS_SERVER_LAYERS_SERVICE_IDENTIFIER.test(url);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} urlPattern
     * @param {?} testUrl
     * @return {?}
     */
    function isCacheableEsriServiceRoute(urlPattern, testUrl) {
        var _a;
        _a = __read((testUrl || '').split('?'), 1), testUrl = _a[0];
        return Boolean(urlPattern
            && testUrl
            && new RegExp(urlPattern, 'gi').test(testUrl)
            && isMapServerServiceUrl(testUrl)
            || isFeatureServerServiceUrl(testUrl)
            || isLrsServerServiceUrl(testUrl)
            || isLrsServerLayersServiceUrl(testUrl));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Extracts the layer ID from an ESRI map service URL.
     * \@example
     * extractMapServerLayerId('http://my-service/ags/MapServer/123') // --> 123
     * @param {?} serviceUrl
     * @return {?}
     */
    function extractMapServerLayerId(serviceUrl) {
        /** @type {?} */
        var layerId = null;
        var _a = __read((serviceUrl || '').split(MAP_SERVER_LAYER_SERVICE_MATCH_IDENTIFIER), 3), layerIdPart = _a[2];
        if (layerIdPart) {
            layerIdPart = layerIdPart.replace('/', '');
            layerId = Number(layerIdPart);
        }
        return layerId;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Extracts the service ID from an ESRI map layer service URL.
     * \@example
     * extractMapServerUrl('http://my-service/ags/MapServer/123') // --> 'http://my-service/ags/MapServer'
     * @param {?} serviceUrl
     * @return {?}
     */
    function extractMapServerUrl(serviceUrl) {
        var _a = __read((serviceUrl || '').split(MAP_SERVER_SERVICE_MATCH_IDENTIFIER), 1), base = _a[0];
        return base === serviceUrl
            ? null
            : join(base, 'MapServer');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} url
     * @return {?}
     */
    function isMapServerLayerUrl(url) {
        return MAP_SERVER_LAYER_SERVICE_IDENTIFIER.test(url);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} urlPath
     * @return {?}
     */
    function doesPathIncludePortalAccessCode(urlPath) {
        return urlPath.includes('code=');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} urlPath
     * @return {?}
     */
    function doesPathIncludePortalAccessToken(urlPath) {
        return urlPath.includes('access_token=') && urlPath.includes('expires_in=');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} portalUrlComponent
     * @return {?}
     */
    function getPortalUrl(portalUrlComponent) {
        var _a = __read((portalUrlComponent || '').split(PORTAL_SHARING_ENDPOINT), 1), basePortalUrl = _a[0];
        return basePortalUrl.endsWith('/')
            ? stripTrailingSlash(basePortalUrl)
            : basePortalUrl;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} token
     * @param {?=} portalUrl
     * @return {?}
     */
    function toEsriPortalAccessToken(token, portalUrl) {
        /** @type {?} */
        var portalToken = {
            accessToken: token.access_token || token.accessToken || token.token || null,
            refreshToken: token.refresh_token || token.refreshToken || null,
            expiresIn: token.expires_in || token.expiresIn || 0,
            isSecure: token.ssl || token.isSecure || false,
            server: token.server || portalUrl || null,
            username: token.username || null,
            expires: token.expires || null
        };
        if (portalToken.expires) {
            portalToken.expires = new Date(portalToken.expires);
        }
        if (portalToken.server) {
            getPortalUrl(portalToken.server);
        }
        if (!portalToken.expires) {
            portalToken.expires = addSeconds(portalToken.expiresIn, new Date());
        }
        return portalToken;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} token
     * @return {?}
     */
    function toEsriServerToken(token) {
        /** @type {?} */
        var serverToken = {
            token: token.token || null,
            isSecure: token.ssl || token.isSecure || false,
            expires: token.expires || 0
        };
        if (serverToken.expires) {
            serverToken.expires = new Date(serverToken.expires);
        }
        return serverToken;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?=} urlHash
     * @return {?}
     */
    function removePortalAccessTokenFromHash(urlHash) {
        if (urlHash === void 0) {
            urlHash = window.location.hash;
        }
        /** @type {?} */
        var portalParamsStartIndex = urlHash.lastIndexOf(PORTAL_REDIRECT_URL_PARAMS_BREAK_CHARACTER);
        /** @type {?} */
        var portaAaccessTokenHash = urlHash.substr(portalParamsStartIndex);
        return urlHash.replace(portaAaccessTokenHash, '');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var EsriPortalService = /** @class */ (function (_super) {
        __extends(EsriPortalService, _super);
        function EsriPortalService(http, config, dataConfig, log) {
            return _super.call(this, http, config, dataConfig, log) || this;
        }
        /**
         * @param {?} portalUrl
         * @param {?} clientId
         * @param {?} code
         * @param {?=} bodyData
         * @param {?=} params
         * @return {?}
         */
        EsriPortalService.prototype.getTokenByCode = /**
         * @param {?} portalUrl
         * @param {?} clientId
         * @param {?} code
         * @param {?=} bodyData
         * @param {?=} params
         * @return {?}
         */
            function (portalUrl, clientId, code, bodyData, params) {
                /** @type {?} */
                var data = Object.assign({
                    client_id: clientId,
                    code: code,
                    redirect_uri: removePortalAccessTokenFromHash(window.location.href),
                    grant_type: 'authorization_code'
                }, bodyData);
                /** @type {?} */
                var formData = toFormData(data);
                return this.doPost(portalUrl, PORTAL_OAUTH_TOKEN_ENDPOINT, formData, params)
                    .pipe(operators.map(( /**
             * @param {?} rawToken
             * @return {?}
             */function (rawToken) { return toEsriPortalAccessToken(rawToken, portalUrl); })));
            };
        /**
         * @param {?} portalUrl
         * @param {?} clientId
         * @param {?} refreshToken
         * @param {?=} bodyData
         * @param {?=} params
         * @return {?}
         */
        EsriPortalService.prototype.refreshToken = /**
         * @param {?} portalUrl
         * @param {?} clientId
         * @param {?} refreshToken
         * @param {?=} bodyData
         * @param {?=} params
         * @return {?}
         */
            function (portalUrl, clientId, refreshToken, bodyData, params) {
                /** @type {?} */
                var data = Object.assign({
                    client_id: clientId,
                    refresh_token: refreshToken,
                    grant_type: 'refresh_token'
                }, bodyData);
                /** @type {?} */
                var formData = toFormData(data);
                return this.doPost(portalUrl, PORTAL_OAUTH_TOKEN_ENDPOINT, formData, params)
                    .pipe(operators.map(( /**
             * @param {?} rawToken
             * @return {?}
             */function (rawToken) { return toEsriPortalAccessToken(rawToken, portalUrl); })));
            };
        /**
         * @param {?} portalUrl
         * @param {?} portalAccessToken
         * @param {?} serverUrl
         * @param {?=} params
         * @return {?}
         */
        EsriPortalService.prototype.getServerToken = /**
         * @param {?} portalUrl
         * @param {?} portalAccessToken
         * @param {?} serverUrl
         * @param {?=} params
         * @return {?}
         */
            function (portalUrl, portalAccessToken, serverUrl, params) {
                /** @type {?} */
                var additionalParams = {
                    request: 'getToken',
                    serverUrl: serverUrl,
                    token: portalAccessToken,
                    referer: window.location.host
                };
                return this.doGet(portalUrl, PORTAL_GENERATE_TOKEN_ENDPOINT, additionalParams, params)
                    .pipe(operators.map(( /**
             * @param {?} token
             * @return {?}
             */function (token) { return toEsriServerToken(token); })));
            };
        /**
         * @protected
         * @template T
         * @param {?} portalUrl
         * @param {?} endpoint
         * @param {?} queryParams
         * @param {?=} params
         * @return {?}
         */
        EsriPortalService.prototype.doGet = /**
         * @protected
         * @template T
         * @param {?} portalUrl
         * @param {?} endpoint
         * @param {?} queryParams
         * @param {?=} params
         * @return {?}
         */
            function (portalUrl, endpoint, queryParams, params) {
                var _this = this;
                /** @type {?} */
                var basePortalUrl = getPortalUrl(portalUrl);
                /** @type {?} */
                var url = join(basePortalUrl, endpoint);
                /** @type {?} */
                var httpOption = getEsriMapServiceHttOptions(params);
                addParamsToHttpOptions(httpOption, queryParams);
                return this.http
                    .get(url, httpOption)
                    .pipe(operators.tap(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return _this.handleEsriResponseError(response, url); })));
            };
        /**
         * @protected
         * @template T
         * @param {?} portalUrl
         * @param {?} endpoint
         * @param {?} formData
         * @param {?=} params
         * @return {?}
         */
        EsriPortalService.prototype.doPost = /**
         * @protected
         * @template T
         * @param {?} portalUrl
         * @param {?} endpoint
         * @param {?} formData
         * @param {?=} params
         * @return {?}
         */
            function (portalUrl, endpoint, formData, params) {
                var _this = this;
                /** @type {?} */
                var basePortalUrl = getPortalUrl(portalUrl);
                /** @type {?} */
                var url = join(basePortalUrl, endpoint);
                /** @type {?} */
                var httpOption = getEsriMapServiceHttOptions(params);
                return this.http
                    .post(url, formData, httpOption)
                    .pipe(operators.tap(( /**
             * @param {?} response
             * @return {?}
             */function (response) { return _this.handleEsriResponseError(response, url); })));
            };
        EsriPortalService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        EsriPortalService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: EsriConfig },
                { type: DataSourceConfig },
                { type: Logger }
            ];
        };
        /** @nocollapse */ EsriPortalService.ngInjectableDef = i0.defineInjectable({ factory: function EsriPortalService_Factory() { return new EsriPortalService(i0.inject(i1$1.HttpClient), i0.inject(EsriConfig), i0.inject(DataSourceConfig), i0.inject(Logger)); }, token: EsriPortalService, providedIn: "root" });
        return EsriPortalService;
    }(BaseEsriService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?=} urlHash
     * @return {?}
     */
    function extractPortalAccessToken(urlHash) {
        if (urlHash === void 0) {
            urlHash = window.location.hash;
        }
        /** @type {?} */
        var portalParamsStartIndex = urlHash.lastIndexOf(PORTAL_REDIRECT_URL_PARAMS_BREAK_CHARACTER);
        /** @type {?} */
        var portalParamsHash = trimStart(urlHash.substr(portalParamsStartIndex));
        /** @type {?} */
        var portalParams = getQueryParams(portalParamsHash);
        /** @type {?} */
        var accessToken = portalParams.access_token;
        /** @type {?} */
        var username = portalParams.username;
        /** @type {?} */
        var expiresIn = Number(portalParams.expires_in);
        /** @type {?} */
        var isSecure = Boolean(portalParams.ssl);
        return toEsriPortalAccessToken({
            accessToken: accessToken,
            username: username,
            expiresIn: expiresIn,
            isSecure: isSecure
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} portalUrl
     * @param {?} clientId
     * @param {?=} options
     * @return {?}
     */
    function getPortalOAuthRedirectUrl(portalUrl, clientId, options) {
        if (options === void 0) {
            options = {};
        }
        options = Object.assign({}, DEFAULT_PORTAL_OAUTH_REDIRECT_OPTIONS, options);
        portalUrl = getPortalUrl(portalUrl);
        /** @type {?} */
        var redirectUrl = encodeURIComponent("" + options.redirectUrl + options.urlParamsBreak);
        /** @type {?} */
        var url = join(portalUrl, PORTAL_OAUTH_AUTHORIZE_ENDPOINT);
        return url + "?client_id=" + clientId + "&redirect_uri=" + redirectUrl + "&response_type=" + options.responseType;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} portalUrl
     * @return {?}
     */
    function getPortalSharingUrl(portalUrl) {
        /** @type {?} */
        var basePortalUrl = getPortalUrl(portalUrl);
        return join(basePortalUrl, PORTAL_SHARING_ENDPOINT);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing export-related settings.
     */
    var ExportConfig = /** @class */ (function () {
        function ExportConfig() {
        }
        ExportConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ ExportConfig.ngInjectableDef = i0.defineInjectable({ factory: function ExportConfig_Factory() { return new ExportConfig(); }, token: ExportConfig, providedIn: "root" });
        /**
         * Configuration class for storing export-related settings.
         */
        ExportConfig = __decorate([
            AutoConfig('ExportConfig')
        ], ExportConfig);
        return ExportConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_EXPORT_GEOJSON_FILE_NAME = 'export.geojson';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssExportModule = /** @class */ (function () {
        function TssExportModule() {
        }
        TssExportModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            TssCoreModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssExportModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ExportService = /** @class */ (function () {
        function ExportService() {
        }
        /**
         * @param {?} fileNameTemplate
         * @param {?=} tokens
         * @param {?=} removeEmptyTokens
         * @return {?}
         */
        ExportService.prototype.replaceTokens = /**
         * @param {?} fileNameTemplate
         * @param {?=} tokens
         * @param {?=} removeEmptyTokens
         * @return {?}
         */
            function (fileNameTemplate, tokens, removeEmptyTokens) {
                if (tokens === void 0) {
                    tokens = {};
                }
                return format(fileNameTemplate, Object.assign(this.getReplaceTokens(), tokens), removeEmptyTokens);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?=} fileNameTemplate
         * @param {...?} features
         * @return {THIS}
         */
        ExportService.prototype.exportFeatureCollection = /**
         * @template THIS
         * @this {THIS}
         * @param {?=} fileNameTemplate
         * @param {...?} features
         * @return {THIS}
         */
            function (fileNameTemplate) {
                if (fileNameTemplate === void 0) {
                    fileNameTemplate = DEFAULT_EXPORT_GEOJSON_FILE_NAME;
                }
                var features = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    features[_i - 1] = arguments[_i];
                }
                /** @type {?} */
                var fileName = ( /** @type {?} */(this)).replaceTokens(fileNameTemplate, {
                    featureLength: features.length,
                });
                /** @type {?} */
                var featureCollection = {
                    type: 'FeatureCollection',
                    features: features
                };
                return ( /** @type {?} */(this)).exportFile(( /** @type {?} */(this)).stringify(featureCollection), fileName, JSON_MIME_TYPE);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?=} fileNameTemplate
         * @param {?=} feature
         * @return {THIS}
         */
        ExportService.prototype.exportFeature = /**
         * @template THIS
         * @this {THIS}
         * @param {?=} fileNameTemplate
         * @param {?=} feature
         * @return {THIS}
         */
            function (fileNameTemplate, feature) {
                if (fileNameTemplate === void 0) {
                    fileNameTemplate = DEFAULT_EXPORT_GEOJSON_FILE_NAME;
                }
                return ( /** @type {?} */(this)).exportFile(( /** @type {?} */(this)).stringify(feature), fileNameTemplate, JSON_MIME_TYPE);
            };
        /**
         * @param {?} data
         * @return {?}
         */
        ExportService.prototype.stringify = /**
         * @param {?} data
         * @return {?}
         */
            function (data) {
                return JSON.stringify(data, ( /**
                 * @param {?} key
                 * @param {?} value
                 * @return {?}
                 */function (key, value) {
                    return key.startsWith('$$') ? undefined : value;
                }), 2);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} data
         * @param {?} fileNameTemplate
         * @return {THIS}
         */
        ExportService.prototype.exportJson = /**
         * @template THIS
         * @this {THIS}
         * @param {?} data
         * @param {?} fileNameTemplate
         * @return {THIS}
         */
            function (data, fileNameTemplate) {
                /** @type {?} */
                var jsonString = isString(data)
                    ? ( /** @type {?} */(data))
                    : ( /** @type {?} */(this)).stringify(data);
                return ( /** @type {?} */(this)).exportFile(jsonString, fileNameTemplate, JSON_MIME_TYPE);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} base64Data
         * @param {?} fileNameTemplate
         * @param {?=} contentType
         * @return {THIS}
         */
        ExportService.prototype.exportBase64 = /**
         * @template THIS
         * @this {THIS}
         * @param {?} base64Data
         * @param {?} fileNameTemplate
         * @param {?=} contentType
         * @return {THIS}
         */
            function (base64Data, fileNameTemplate, contentType) {
                /** @type {?} */
                var fileName = ( /** @type {?} */(this)).replaceTokens(fileNameTemplate);
                contentType = contentType || base64MimeType(base64Data);
                /** @type {?} */
                var blob = base64toBlob(base64Data, contentType);
                return ( /** @type {?} */(this)).exportFromUrl(URL.createObjectURL(blob), fileName);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} data
         * @param {?} fileNameTemplate
         * @param {?=} contentType
         * @return {THIS}
         */
        ExportService.prototype.exportFile = /**
         * @template THIS
         * @this {THIS}
         * @param {?} data
         * @param {?} fileNameTemplate
         * @param {?=} contentType
         * @return {THIS}
         */
            function (data, fileNameTemplate, contentType) {
                if (contentType === void 0) {
                    contentType = TEXT_MIME_TYPE;
                }
                /** @type {?} */
                var blob = new Blob([data], { type: contentType });
                /** @type {?} */
                var fileName = ( /** @type {?} */(this)).replaceTokens(fileNameTemplate);
                return ( /** @type {?} */(this)).exportBlob(blob, fileName);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} blob
         * @param {?} fileNameTemplate
         * @return {THIS}
         */
        ExportService.prototype.exportBlob = /**
         * @template THIS
         * @this {THIS}
         * @param {?} blob
         * @param {?} fileNameTemplate
         * @return {THIS}
         */
            function (blob, fileNameTemplate) {
                /** @type {?} */
                var fileName = ( /** @type {?} */(this)).replaceTokens(fileNameTemplate);
                return ( /** @type {?} */(this)).exportFromUrl(window.URL.createObjectURL(blob), fileName);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} url
         * @param {?} fileName
         * @return {THIS}
         */
        ExportService.prototype.exportFromUrl = /**
         * @template THIS
         * @this {THIS}
         * @param {?} url
         * @param {?} fileName
         * @return {THIS}
         */
            function (url, fileName) {
                /** @type {?} */
                var link = document.createElement('a');
                link.href = url;
                link.download = fileName;
                link.click();
                return ( /** @type {?} */(this));
            };
        /**
         * @protected
         * @return {?}
         */
        ExportService.prototype.getReplaceTokens = /**
         * @protected
         * @return {?}
         */
            function () {
                return {
                    date: new Date(),
                    shortDate: formatDate(new Date(), 'yyyy-MM-dd'),
                    year: new Date().getFullYear(),
                };
            };
        ExportService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        ExportService.ctorParameters = function () { return []; };
        /** @nocollapse */ ExportService.ngInjectableDef = i0.defineInjectable({ factory: function ExportService_Factory() { return new ExportService(); }, token: ExportService, providedIn: "root" });
        return ExportService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing geolocation-related settings.
     */
    var GeolocationConfig = /** @class */ (function () {
        function GeolocationConfig() {
            this.gpsDisplayDecimalPlaces = 3;
            this.gpsWarnableAccuracyMeters = 5;
            this.gpsRequiredAccuracyMeters = 10;
            this.gpsWarnableDilutionOfPrecision = 2;
            this.gpsRequiredDilutionOfPrecision = 5;
            this.gpsEnableHighAccuracy = true;
            this.gpsNoAccuracyReading = '--';
            this.allowGpsMocking = true;
            this.emitDuplicateGpsPositions = false;
            this.gpsPositionDuplicatePrecision = DEFAULT_POINT_EQUALITY_PRECISION;
            this.gpsAntennaHeight = 0;
            this.adjustForGpsAntennaHeight = true;
            this.calculateMissingPositionValues = true;
            this.geolocationGeolocatorName = 'Built-in (default)';
            this.geolocationGeolocatorDescription = "Uses the device's built-in GPS sensor within the hardware. " +
                "Devices without a GPS sensor will defer the location retrieval to the Inernet Service Provider (ISP).";
        }
        GeolocationConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ GeolocationConfig.ngInjectableDef = i0.defineInjectable({ factory: function GeolocationConfig_Factory() { return new GeolocationConfig(); }, token: GeolocationConfig, providedIn: "root" });
        /**
         * Configuration class for storing geolocation-related settings.
         */
        GeolocationConfig = __decorate([
            AutoConfig('GeolocationConfig')
        ], GeolocationConfig);
        return GeolocationConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var PATH_BUILDER_EMPTY_CALIBRATION_MEASURE_VALUE = null;
    /** @type {?} */
    var PATH_BUILDER_CALCULATED_M_DEVICE_SOURCE = 'calculated-calibration-point';
    /** @type {?} */
    var GEOLOCATOR_REGISTRY = [];
    /** @type {?} */
    var GEOLOCATION_GEOLOCATOR_ID = 'built-in';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} id
     * @return {?}
     */
    function Geolocatable(id) {
        return ( /**
         * @param {?} constructor
         * @return {?}
         */function (constructor) {
            GEOLOCATOR_REGISTRY.push({ id: id, constructor: constructor });
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var GeolocatorAccuracyUnit = {
        /**
         * The geolocation accuracy reading is in standard meters (default).
         */
        Meter: 'meters',
        /**
         * The geolocation accuracy reading indicates a Position Dilution of Precision (PDOP) value.
         */
        Pdop: 'pdop',
        /**
         * The geolocation accuracy reading indicates a Horizontal Dilution of Precision (HDOP) value.
         */
        Hdop: 'hdop',
        /**
         * The geolocation accuracy reading indicates a Vertical Dilution of Precision (VDOP) value.
         */
        Vdop: 'vdop',
        /**
         * The geolocation accuracy reading indicates a Time Dilution of Precision (TDOP) value.
         */
        Tdop: 'tdop',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
     * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
     * @abstract
     */
    var BaseGeolocator = /** @class */ (function () {
        function BaseGeolocator(log) {
            this.log = log;
            this.capabilities = [];
            this.accuracyUnit = GeolocatorAccuracyUnit.Meter;
        }
        /**
         * @param {?} capability
         * @return {?}
         */
        BaseGeolocator.prototype.hasCapability = /**
         * @param {?} capability
         * @return {?}
         */
            function (capability) {
                return this.capabilities.indexOf(capability) > -1;
            };
        BaseGeolocator.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        BaseGeolocator.ctorParameters = function () {
            return [
                { type: Logger }
            ];
        };
        /** @nocollapse */ BaseGeolocator.ngInjectableDef = i0.defineInjectable({ factory: function BaseGeolocator_Factory() { return new BaseGeolocator(i0.inject(Logger)); }, token: BaseGeolocator, providedIn: "root" });
        return BaseGeolocator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} position
     * @return {?}
     */
    function positionToGpsPosition(position) {
        /** @type {?} */
        var gpsPosition = {
            timestamp: position.timestamp,
            accuracy: position.coords.accuracy,
            altitude: position.coords.altitude,
            altitudeAccuracy: position.coords.altitudeAccuracy,
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            heading: position.coords.heading,
            speed: position.coords.speed,
        };
        return gpsPosition;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var GeolocatorCapability = {
        Accuracy: 'accuracy',
        Altitude: 'altitude',
        AltitudeAccuracy: 'altitude',
        Heading: 'heading',
        Speed: 'speed',
        MagneticVariation: 'magneticVariation',
        Satellites: 'satellites',
        PDOP: 'pdop',
        HDOP: 'hdop',
        VDOP: 'vdop',
        TDOP: 'tdop',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
     * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
     */
    var GeolocationGeolocator = /** @class */ (function (_super) {
        __extends(GeolocationGeolocator, _super);
        function GeolocationGeolocator(log, config) {
            var _this = _super.call(this, log) || this;
            _this.config = config;
            _this.capabilities = [
                GeolocatorCapability.Accuracy,
                GeolocatorCapability.Altitude,
                GeolocatorCapability.AltitudeAccuracy,
                GeolocatorCapability.Heading,
                GeolocatorCapability.Speed,
            ];
            return _this;
        }
        Object.defineProperty(GeolocationGeolocator.prototype, "name", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.geolocationGeolocatorName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocationGeolocator.prototype, "description", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.geolocationGeolocatorDescription;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?=} options
         * @return {?}
         */
        GeolocationGeolocator.prototype.getCurrentPosition = /**
         * @param {?=} options
         * @return {?}
         */
            function (options) {
                var _this = this;
                return new Promise(( /**
                 * @param {?} resolve
                 * @param {?} reject
                 * @return {?}
                 */function (resolve, reject) {
                    return navigator.geolocation
                        .getCurrentPosition(( /**
                 * @param {?} position
                 * @return {?}
                 */function (position) {
                        _this.log.trace("Received current position for " + _this.name);
                        resolve(positionToGpsPosition(position));
                    }), reject, options);
                }));
            };
        /**
         * @param {?=} options
         * @return {?}
         */
        GeolocationGeolocator.prototype.watchPosition = /**
         * @param {?=} options
         * @return {?}
         */
            function (options) {
                var _this = this;
                /** @type {?} */
                var subject = new rxjs.Subject();
                /** @type {?} */
                var watchId = navigator.geolocation.watchPosition(( /**
                 * @param {?} position
                 * @return {?}
                 */function (position) {
                    _this.log.trace("Received watch position for " + _this.name);
                    subject.next(positionToGpsPosition(position));
                }), ( /**
                 * @param {?} error
                 * @return {?}
                 */function (error) { return subject.error(error); }), options);
                return subject.pipe(operators.finalize(( /**
                 * @return {?}
                 */function () { return navigator.geolocation.clearWatch(watchId); })));
            };
        /**
         * @return {?}
         */
        GeolocationGeolocator.prototype.isAvailable = /**
         * @return {?}
         */
            function () {
                return rxjs.of('geolocation' in navigator);
            };
        GeolocationGeolocator.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        GeolocationGeolocator.ctorParameters = function () {
            return [
                { type: Logger },
                { type: GeolocationConfig }
            ];
        };
        /** @nocollapse */ GeolocationGeolocator.ngInjectableDef = i0.defineInjectable({ factory: function GeolocationGeolocator_Factory() { return new GeolocationGeolocator(i0.inject(Logger), i0.inject(GeolocationConfig)); }, token: GeolocationGeolocator, providedIn: "root" });
        /**
         * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
         * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
         */
        GeolocationGeolocator = __decorate([
            Geolocatable(GEOLOCATION_GEOLOCATOR_ID),
            __metadata("design:paramtypes", [Logger, GeolocationConfig])
        ], GeolocationGeolocator);
        return GeolocationGeolocator;
    }(BaseGeolocator));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssGeolocationModule = /** @class */ (function () {
        function TssGeolocationModule() {
        }
        TssGeolocationModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            TssCoreModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [
                            { provide: BaseGeolocator, useClass: GeolocationGeolocator }
                        ],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssGeolocationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} position
     * @param {?} acceptanceThreshold
     * @return {?}
     */
    function isPositionAcceptable(position, acceptanceThreshold) {
        return position && position.accuracy <= acceptanceThreshold;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} position
     * @return {?}
     */
    function isPositionError(position) {
        /** @type {?} */
        var error = ( /** @type {?} */(position));
        /** @type {?} */
        var isError = !error || isNumber(error.code);
        return isError;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} position
     * @return {?}
     */
    function gpsPositionToPoint(position) {
        /** @type {?} */
        var point = [position.longitude, position.latitude];
        if (isDefined(position.altitude)) {
            point[2] = position.altitude;
        }
        return point;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} latitide
     * @return {?}
     */
    function isValidLatitude(latitide) {
        return isNumber(latitide) && isNumberBetweenOrEqual(latitide, -90, 90);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} longitude
     * @return {?}
     */
    function isValidLongitude(longitude) {
        return isNumber(longitude) && isNumberBetweenOrEqual(longitude, -180, 180);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} location
     * @return {?}
     */
    function isValidLocation(location) {
        return isValidLatitude(location.latitude) && isValidLongitude(location.longitude);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} location
     * @return {?}
     */
    function isNotValidLocation(location) {
        return !isValidLocation(location);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} position1
     * @param {?} position2
     * @param {?=} precision
     * @return {?}
     */
    function gpsPositionsAlmostEqual(position1, position2, precision) {
        if (precision === void 0) {
            precision = DEFAULT_POINT_EQUALITY_PRECISION;
        }
        return pointsAlmostEqual(position1.longitude, position1.latitude, position2.longitude, position2.latitude, precision);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Geolocator service. Provides a single point of GPS interaction.
     */
    var GeolocationService = /** @class */ (function () {
        function GeolocationService(geolocator, log, notify, config) {
            this.log = log;
            this.notify = notify;
            this.config = config;
            this.isTrackingPosition = false;
            this.geolocator = geolocator;
            this.positionChangeSubject = new rxjs.ReplaySubject(1);
            this.positionRecievedSubject = new rxjs.Subject();
            this.positionChange = this.positionChangeSubject.asObservable();
            this.positionRecieved = this.positionRecievedSubject.asObservable();
        }
        Object.defineProperty(GeolocationService.prototype, "positionText", {
            get: /**
             * @return {?}
             */ function () {
                return this.position
                    ? this.position.longitude.toFixed(this.config.gpsDisplayDecimalPlaces) + "\n       , " + this.position.latitude.toFixed(this.config.gpsDisplayDecimalPlaces)
                    : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocationService.prototype, "positionReceivedEllapsedTime", {
            get: /**
             * @return {?}
             */ function () {
                if (!this.positionRecievedTime) {
                    return '';
                }
                /** @type {?} */
                var differenceMilliseconds = Date.now() - this.positionRecievedTime.getTime();
                return toReadableTime(differenceMilliseconds) + " ago";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocationService.prototype, "isPositionAcceptable", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var accuracyThreshold = this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Meter
                    ? this.config.gpsRequiredAccuracyMeters
                    : this.config.gpsRequiredDilutionOfPrecision;
                return isPositionAcceptable(this.position, accuracyThreshold);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocationService.prototype, "isPositionUnacceptable", {
            get: /**
             * @return {?}
             */ function () {
                return !this.isPositionAcceptable;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocationService.prototype, "isPositionWarnable", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var accuracyThreshold = this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Meter
                    ? this.config.gpsWarnableAccuracyMeters
                    : this.config.gpsWarnableDilutionOfPrecision;
                return !isPositionAcceptable(this.position, accuracyThreshold);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocationService.prototype, "hasAccuracyCapability", {
            get: /**
             * @return {?}
             */ function () {
                return this.geolocator.capabilities.indexOf(GeolocatorCapability.Accuracy) > -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocationService.prototype, "isPositionAccuracyKnown", {
            get: /**
             * @return {?}
             */ function () {
                return this.position && isNumber(this.position.accuracy);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocationService.prototype, "isPositionAccuracyUnknown", {
            get: /**
             * @return {?}
             */ function () {
                return !this.isPositionAccuracyKnown;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocationService.prototype, "isPositionAccuracyInMeters", {
            get: /**
             * @return {?}
             */ function () {
                return this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Meter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocationService.prototype, "isPositionAccuracyInDilutionOfPrecision", {
            get: /**
             * @return {?}
             */ function () {
                return this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Pdop
                    || this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Hdop
                    || this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Vdop
                    || this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Tdop;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocationService.prototype, "geolocatorService", {
            get: /**
             * @return {?}
             */ function () {
                return this.geolocator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeolocationService.prototype, "accuracyStatement", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var noPosition = !this.position;
                if (noPosition) {
                    return this.config.gpsNoAccuracyReading;
                }
                /** @type {?} */
                var isPositionAccuracyKnown = this.isPositionAccuracyKnown;
                /** @type {?} */
                var accuracy = isPositionAccuracyKnown ? this.position.accuracy : null;
                /** @type {?} */
                var suffix;
                if (isPositionAccuracyKnown && this.geolocator.hasCapability(GeolocatorCapability.Accuracy)) {
                    suffix = this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Meter
                        ? 'm'
                        : String(this.geolocator.accuracyUnit).toUpperCase();
                }
                else if (this.geolocator.hasCapability(GeolocatorCapability.PDOP)) {
                    accuracy = this.position.pdop;
                    suffix = String(GeolocatorCapability.PDOP).toUpperCase();
                }
                else if (this.geolocator.hasCapability(GeolocatorCapability.HDOP)) {
                    accuracy = this.position.hdop;
                    suffix = String(GeolocatorCapability.HDOP).toUpperCase();
                }
                else if (this.geolocator.hasCapability(GeolocatorCapability.VDOP)) {
                    accuracy = this.position.vdop;
                    suffix = String(GeolocatorCapability.VDOP).toUpperCase();
                }
                else if (this.geolocator.hasCapability(GeolocatorCapability.TDOP)) {
                    accuracy = this.position.tdop;
                    suffix = String(GeolocatorCapability.TDOP).toUpperCase();
                }
                if (isNotNumber(accuracy)) {
                    return this.config.gpsNoAccuracyReading;
                }
                return formatNumber(accuracy) + " " + suffix;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        GeolocationService.prototype.enableGpsTracking = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var geoOptions = {
                    enableHighAccuracy: ( /** @type {?} */(this)).config.gpsEnableHighAccuracy
                };
                ( /** @type {?} */(this)).position = null;
                ( /** @type {?} */(this)).tryUnsubscribe();
                ( /** @type {?} */(this)).log.debug("Subscribing to GPS watching for '" + ( /** @type {?} */(this)).geolocator.name + "' with high accuracy set to '" + geoOptions.enableHighAccuracy + "'");
                ( /** @type {?} */(this)).gpsLocatorSubscription = ( /** @type {?} */(this)).geolocator.watchPosition(geoOptions)
                    .subscribe(( /**
             * @template THIS
             * @this {THIS}
             * @param {?} position
             * @return {THIS}
             */function (position) { return ( /** @type {?} */(_this)).onPositionRecieved(position); }), ( /**
                 * @template THIS
                 * @this {THIS}
                 * @param {?} error
                 * @return {THIS}
                 */function (error) { return ( /** @type {?} */(_this)).onLocationError(error); }));
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        GeolocationService.prototype.disableGpsTracking = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
            function () {
                ( /** @type {?} */(this)).isTrackingPosition = false;
                ( /** @type {?} */(this)).tryUnsubscribe();
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} geolocator
         * @return {THIS}
         */
        GeolocationService.prototype.setGeoLocator = /**
         * @template THIS
         * @this {THIS}
         * @param {?} geolocator
         * @return {THIS}
         */
            function (geolocator) {
                ( /** @type {?} */(this)).tryUnsubscribe();
                ( /** @type {?} */(this)).geolocator = geolocator;
                if (( /** @type {?} */(this)).isTrackingPosition) {
                    ( /** @type {?} */(this)).enableGpsTracking();
                }
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} isTrackingLocation
         * @return {THIS}
         */
        GeolocationService.prototype.setGpsTracking = /**
         * @template THIS
         * @this {THIS}
         * @param {?} isTrackingLocation
         * @return {THIS}
         */
            function (isTrackingLocation) {
                if (isTrackingLocation) {
                    ( /** @type {?} */(this)).enableGpsTracking();
                }
                else {
                    ( /** @type {?} */(this)).disableGpsTracking();
                }
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        GeolocationService.prototype.toggleGpsTracking = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
            function () {
                ( /** @type {?} */(this)).setGpsTracking(!( /** @type {?} */(this)).isTrackingPosition);
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
        GeolocationService.prototype.mockGpsPosition = /**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
            function (position) {
                if (!( /** @type {?} */(this)).config.allowGpsMocking) {
                    throw new Error('Permission denied to mock GPS location');
                }
                return ( /** @type {?} */(this)).onPositionRecieved(position);
            };
        /**
         * @protected
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
        GeolocationService.prototype.onPositionRecieved = /**
         * @protected
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
            function (position) {
                if (isPositionError(position)) {
                    ( /** @type {?} */(this)).onLocationError(( /** @type {?} */(position)));
                    return ( /** @type {?} */(this));
                }
                /** @type {?} */
                var gpsPosition = ( /** @type {?} */(position));
                if (isNotValidLocation(gpsPosition)) {
                    return ( /** @type {?} */(this));
                }
                /** @type {?} */
                var isPreviousPointSameAsNew = ( /** @type {?} */(this)).position
                    && gpsPositionsAlmostEqual(( /** @type {?} */(this)).position, gpsPosition, ( /** @type {?} */(this)).config.gpsPositionDuplicatePrecision);
                if (isPreviousPointSameAsNew && !( /** @type {?} */(this)).config.emitDuplicateGpsPositions) {
                    ( /** @type {?} */(this)).positionRecievedSubject.next(gpsPosition);
                    return ( /** @type {?} */(this));
                }
                ( /** @type {?} */(this)).log.trace("Location recieved from '" + ( /** @type {?} */(this)).geolocator.name + "': " + gpsPosition.latitude + ", " + gpsPosition.longitude);
                ( /** @type {?} */(this)).adjustCoordinates(gpsPosition);
                ( /** @type {?} */(this)).position = gpsPosition;
                ( /** @type {?} */(this)).isTrackingPosition = true;
                ( /** @type {?} */(this)).positionRecievedTime = new Date(( /** @type {?} */(this)).position.timestamp || Date.now());
                ( /** @type {?} */(this)).positionRecievedSubject.next(( /** @type {?} */(this)).position);
                ( /** @type {?} */(this)).positionChangeSubject.next(( /** @type {?} */(this)).position);
                return ( /** @type {?} */(this));
            };
        /**
         * @protected
         * @template THIS
         * @this {THIS}
         * @param {?} error
         * @return {THIS}
         */
        GeolocationService.prototype.onLocationError = /**
         * @protected
         * @template THIS
         * @this {THIS}
         * @param {?} error
         * @return {THIS}
         */
            function (error) {
                /** @type {?} */
                var errorMessage = errorMsg('Failed to retrieve location position. {error}', error);
                ( /** @type {?} */(this)).positionChangeSubject.error(error);
                ( /** @type {?} */(this)).log.error(errorMessage);
                ( /** @type {?} */(this)).notify.error(errorMessage);
                return ( /** @type {?} */(this));
            };
        /**
         * @private
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
        GeolocationService.prototype.adjustCoordinates = /**
         * @private
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
            function (position) {
                ( /** @type {?} */(this)).tryAdjustMissingPositionValues(position);
                if (( /** @type {?} */(this)).config.adjustForGpsAntennaHeight && ( /** @type {?} */(this)).config.gpsAntennaHeight) {
                    /** @type {?} */
                    var adjustedHeight = position.altitude - ( /** @type {?} */(this)).config.gpsAntennaHeight;
                    adjustedHeight = adjustedHeight < 0 ? 0 : adjustedHeight;
                    ( /** @type {?} */(this)).log.trace("Adjusting coordinate altitude from " + position.altitude + " to " + adjustedHeight);
                    Object.assign(position, {
                        altitude: adjustedHeight
                    });
                }
                return ( /** @type {?} */(this));
            };
        /**
         * @private
         * @param {?} newPosition
         * @return {?}
         */
        GeolocationService.prototype.tryAdjustMissingPositionValues = /**
         * @private
         * @param {?} newPosition
         * @return {?}
         */
            function (newPosition) {
                /** @type {?} */
                var missingSpeed = isNotValue(newPosition.speed);
                /** @type {?} */
                var missingHeading = isNotValue(newPosition.heading);
                /** @type {?} */
                var positionValuesMissing = missingSpeed || missingHeading;
                /** @type {?} */
                var shouldAdjustPositionValues = this.position && positionValuesMissing && this.config.calculateMissingPositionValues;
                if (shouldAdjustPositionValues) {
                    /** @type {?} */
                    var fromPoint = gpsPositionToPoint(this.position);
                    /** @type {?} */
                    var toPoint = gpsPositionToPoint(newPosition);
                    if (missingSpeed) {
                        // meters per second
                        /** @type {?} */
                        var kilometersTraveled = distance(fromPoint, toPoint, { units: 'kilometers' });
                        if (kilometersTraveled) {
                            /** @type {?} */
                            var metersTraveled = convertLengthUnits(kilometersTraveled, LengthUnit.Kilometer, LengthUnit.Meter);
                            /** @type {?} */
                            var secondsDelta = millisecondsToSeconds(Math.abs(newPosition.timestamp - this.position.timestamp));
                            /** @type {?} */
                            var speed = metersTraveled / secondsDelta;
                            Object.assign(newPosition, { speed: speed });
                        }
                    }
                    if (missingHeading) {
                        /** @type {?} */
                        var heading = bearing(fromPoint, toPoint);
                        Object.assign(newPosition, { heading: heading });
                    }
                }
            };
        /**
         * @private
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        GeolocationService.prototype.tryUnsubscribe = /**
         * @private
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
            function () {
                if (( /** @type {?} */(this)).gpsLocatorSubscription) {
                    ( /** @type {?} */(this)).log.debug("Unsubscribing from watching GPS stream from '" + ( /** @type {?} */(this)).geolocator.name + "'");
                    ( /** @type {?} */(this)).gpsLocatorSubscription.unsubscribe();
                }
                return ( /** @type {?} */(this));
            };
        GeolocationService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        GeolocationService.ctorParameters = function () {
            return [
                { type: BaseGeolocator },
                { type: Logger },
                { type: NotifyService },
                { type: GeolocationConfig }
            ];
        };
        /** @nocollapse */ GeolocationService.ngInjectableDef = i0.defineInjectable({ factory: function GeolocationService_Factory() { return new GeolocationService(i0.inject(BaseGeolocator), i0.inject(Logger), i0.inject(NotifyService), i0.inject(GeolocationConfig)); }, token: GeolocationService, providedIn: "root" });
        return GeolocationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var GeolocatorSourceService = /** @class */ (function () {
        function GeolocatorSourceService(injector) {
            this.injector = injector;
        }
        /**
         * @param {?} id
         * @return {?}
         */
        GeolocatorSourceService.prototype.getGeolocator = /**
         * @param {?} id
         * @return {?}
         */
            function (id) {
                /** @type {?} */
                var registry = GEOLOCATOR_REGISTRY.find(( /**
                 * @param {?} registedSource
                 * @return {?}
                 */function (registedSource) { return registedSource.id === id; }));
                return this.getLocatorFromRegistry(registry);
            };
        /**
         * @return {?}
         */
        GeolocatorSourceService.prototype.getGeolocators = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return GEOLOCATOR_REGISTRY
                    .map(( /**
             * @param {?} registry
             * @return {?}
             */function (registry) { return _this.getLocatorFromRegistry(registry); }));
            };
        /**
         * @param {?} id
         * @return {?}
         */
        GeolocatorSourceService.prototype.getGeolocatorSource = /**
         * @param {?} id
         * @return {?}
         */
            function (id) {
                return this.getGeolocatorSources()
                    .pipe(operators.map(( /**
             * @param {?} devices
             * @return {?}
             */function (devices) {
                    return devices.find(( /**
                     * @param {?} device
                     * @return {?}
                     */function (device) { return device.id === id; }));
                })));
            };
        /**
         * @return {?}
         */
        GeolocatorSourceService.prototype.getAvailableGeolocatorSources = /**
         * @return {?}
         */
            function () {
                return this.getGeolocatorSources()
                    .pipe(operators.map(( /**
             * @param {?} devices
             * @return {?}
             */function (devices) {
                    return devices.filter(( /**
                     * @param {?} device
                     * @return {?}
                     */function (device) { return device.isAvailable; }));
                })));
            };
        /**
         * @return {?}
         */
        GeolocatorSourceService.prototype.getGeolocatorSources = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var availableObservables = GEOLOCATOR_REGISTRY
                    .map(( /**
             * @param {?} registry
             * @return {?}
             */function (registry) {
                    /** @type {?} */
                    var locator = _this.getLocatorFromRegistry(registry);
                    /** @type {?} */
                    var source = {
                        id: registry.id,
                        name: locator.name,
                        description: locator.description,
                        accuracyUnit: locator.accuracyUnit,
                        capabilities: locator.capabilities,
                        isAvailable: false,
                    };
                    return locator.isAvailable()
                        .pipe(operators.tap(( /**
                 * @param {?} available
                 * @return {?}
                 */function (available) { return source.isAvailable = available; })), operators.map(( /**
                     * @return {?}
                     */function () { return source; })));
                }));
                return availableObservables.length === 0
                    ? rxjs.of([])
                    : rxjs.forkJoin(availableObservables);
            };
        /**
         * @private
         * @param {?} registry
         * @return {?}
         */
        GeolocatorSourceService.prototype.getLocatorFromRegistry = /**
         * @private
         * @param {?} registry
         * @return {?}
         */
            function (registry) {
                /** @type {?} */
                var instance = this.injector.get(registry.constructor);
                return instance;
            };
        GeolocatorSourceService.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        GeolocatorSourceService.ctorParameters = function () {
            return [
                { type: i0.Injector }
            ];
        };
        /** @nocollapse */ GeolocatorSourceService.ngInjectableDef = i0.defineInjectable({ factory: function GeolocatorSourceService_Factory() { return new GeolocatorSourceService(i0.inject(i0.INJECTOR)); }, token: GeolocatorSourceService, providedIn: "root" });
        return GeolocatorSourceService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {...?} positions
     * @return {?}
     */
    function gpsPositionsToPoint() {
        var positions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            positions[_i] = arguments[_i];
        }
        return positions.map(( /**
         * @param {?} position
         * @return {?}
         */function (position) { return gpsPositionToPoint(position); }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} latitude
     * @return {?}
     */
    function isNotValidLatitude(latitude) {
        return !isValidLatitude(latitude);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} longitude
     * @return {?}
     */
    function isNotValidLongitude(longitude) {
        return !isValidLongitude(longitude);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_EMPTY_Z_VALUE = 0;
    /** @type {?} */
    var DEFAULT_OPTIONS = {
        units: 'miles',
        hasZValues: true,
        calibrationPositions: []
    };
    /**
     * @param {?} line
     * @param {?=} options
     * @return {?}
     */
    function setMeasuresByGeometricLength(line, options) {
        /** @type {?} */
        var martiPart = toMultiPartPaths(line);
        options = Object.assign({}, DEFAULT_OPTIONS, options);
        /** @type {?} */
        var lastMeasure = 0;
        martiPart.forEach(( /**
         * @param {?} linePart
         * @param {?} partIndex
         * @return {?}
         */function (linePart, partIndex) {
            setMeasureForLine(linePart, lastMeasure, partIndex, options);
            /** @type {?} */
            var lastCoordinateIndex = linePart.length - 1;
            /** @type {?} */
            var lastCoordinate = linePart[lastCoordinateIndex];
            lastMeasure += getMeasureFromPoint(lastCoordinate);
        }));
    }
    /**
     * @param {?} line
     * @param {?} startMeasure
     * @param {?} partIndex
     * @param {?} options
     * @return {?}
     */
    function setMeasureForLine(line, startMeasure, partIndex, options) {
        /** @type {?} */
        var hasCalibrationPoints = options.calibrationPositions.some(( /**
         * @param {?} calibrationPosition
         * @return {?}
         */function (calibrationPosition) {
            return calibrationPosition.partIndex === partIndex;
        }));
        if (hasCalibrationPoints) {
            calibrateLinePart(line, startMeasure, partIndex, options);
        }
        else {
            setLinePartMeasuresByGeometricLength(line, startMeasure, options);
        }
    }
    /**
     * @param {?} line
     * @param {?} startMeasure
     * @param {?} partIndex
     * @param {?} options
     * @return {?}
     */
    function calibrateLinePart(line, startMeasure, partIndex, options) {
        /** @type {?} */
        var calibrationPositions = options.calibrationPositions.filter(( /**
         * @param {?} position
         * @return {?}
         */function (position) { return position.partIndex === partIndex; }));
        /** @type {?} */
        var fromVertexIndex = 0;
        sortAscending(calibrationPositions, ( /**
         * @param {?} calibration
         * @return {?}
         */function (calibration) { return calibration.measure; }));
        calibrationPositions.forEach(( /**
         * @param {?} calibration
         * @return {?}
         */function (calibration) {
            /** @type {?} */
            var fromVertex = line[fromVertexIndex];
            /** @type {?} */
            var toVertex = line[calibration.vertexIndex];
            /** @type {?} */
            var numberOfVerticesInBetween = calibration.vertexIndex - fromVertexIndex;
            /** @type {?} */
            var distanceForSection = Math.abs(calibration.measure - startMeasure);
            /** @type {?} */
            var measureDistributionIncrement = distanceForSection / numberOfVerticesInBetween;
            setMeasure(fromVertex, startMeasure, options.hasZValues);
            setMeasure(toVertex, calibration.measure, options.hasZValues);
            /** @type {?} */
            var inBetweenVertices = getVerticesBetween(line, fromVertexIndex, calibration.vertexIndex);
            inBetweenVertices.forEach(( /**
             * @param {?} vertice
             * @param {?} index
             * @return {?}
             */function (vertice, index) {
                /** @type {?} */
                var partNumber = index + 1;
                /** @type {?} */
                var verticeIncrement = partNumber * measureDistributionIncrement;
                /** @type {?} */
                var measure = startMeasure + verticeIncrement;
                setMeasure(vertice, measure, options.hasZValues);
            }));
            fromVertexIndex = calibration.vertexIndex;
            startMeasure = calibration.measure;
        }));
        /** @type {?} */
        var areMoreVertices = fromVertexIndex < line.length - 1;
        if (areMoreVertices) {
            /** @type {?} */
            var remainingPoints = getVerticesBetween(line, fromVertexIndex - 1, line.length);
            setLinePartMeasuresByGeometricLength(remainingPoints, startMeasure, options);
        }
    }
    /**
     * @param {?} line
     * @param {?} startRangeIndex
     * @param {?} endRangeIndex
     * @return {?}
     */
    function getVerticesBetween(line, startRangeIndex, endRangeIndex) {
        /** @type {?} */
        var index = startRangeIndex + 1;
        /** @type {?} */
        var vertices = [];
        for (; index < endRangeIndex; index++) {
            /** @type {?} */
            var vertice = line[index];
            vertices.push(vertice);
        }
        return vertices;
    }
    /**
     * @param {?} line
     * @param {?} startMeasure
     * @param {?} options
     * @return {?}
     */
    function setLinePartMeasuresByGeometricLength(line, startMeasure, options) {
        /** @type {?} */
        var previousVertex;
        /** @type {?} */
        var vertexMeasure = startMeasure;
        line.forEach(( /**
         * @param {?} vertex
         * @param {?} index
         * @return {?}
         */function (vertex, index) {
            if (index !== 0) {
                /** @type {?} */
                var distanceBetweenVerticees = distance(previousVertex, vertex, options);
                vertexMeasure += distanceBetweenVerticees;
            }
            setMeasure(vertex, vertexMeasure, options.hasZValues);
            previousVertex = vertex;
        }));
    }
    /**
     * @param {?} coordinate
     * @param {?} measure
     * @param {?} hasZValues
     * @return {?}
     */
    function setMeasure(coordinate, measure, hasZValues) {
        /** @type {?} */
        var accountForZValue = hasZValues || coordinate.length > 3;
        /** @type {?} */
        var measureIndex = accountForZValue ? 3 : 2;
        coordinate[measureIndex] = measure;
        if (accountForZValue) {
            ensureZValue(coordinate);
        }
    }
    /**
     * @param {?} coordinate
     * @return {?}
     */
    function ensureZValue(coordinate) {
        if (isNotNumber(coordinate[2])) {
            coordinate[2] = DEFAULT_EMPTY_Z_VALUE;
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var UNPLACED_CALIBRATION_MEASURE_KEY = 'pending';
    /** @type {?} */
    var DEFAULT_OPTIONS$1 = {
        gpsRequiredAccuracyMeters: 10,
        requireAccuracy: true,
        pointEquivalencyPrecision: 8,
        returnZValues: true,
        returnMValues: true,
        mValueUnit: 'miles',
        storeUnfilteredPath: false,
        calibrationMeasureSnappingDistanceDelta: 2,
        calibrationMeasureSnappingDistanceDeltaUnit: LengthUnit.Foot
    };
    var PositionPathBuilder = /** @class */ (function () {
        function PositionPathBuilder(options) {
            this.parts = [[]];
            this.unfilteredPath = [];
            this.calibratedMeasures = new Map();
            this.options = Object.assign({}, DEFAULT_OPTIONS$1, options);
        }
        Object.defineProperty(PositionPathBuilder.prototype, "positionCount", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var counts = this.parts.map(( /**
                 * @param {?} part
                 * @return {?}
                 */function (part) { return part.length; }));
                return sumValues(counts);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PositionPathBuilder.prototype, "currentPartIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this.parts.length - 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PositionPathBuilder.prototype, "currentPart", {
            get: /**
             * @return {?}
             */ function () {
                return this.parts[this.currentPartIndex];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PositionPathBuilder.prototype, "lastPosition", {
            get: /**
             * @return {?}
             */ function () {
                return getLastItem(this.currentPart);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PositionPathBuilder.prototype, "hasPosition", {
            get: /**
             * @return {?}
             */ function () {
                return Boolean(this.lastPosition);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PositionPathBuilder.prototype, "isEmpty", {
            get: /**
             * @return {?}
             */ function () {
                return this.currentPart.length === 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PositionPathBuilder.prototype, "isValidPath", {
            get: /**
             * @return {?}
             */ function () {
                return this.currentPart.length > 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PositionPathBuilder.prototype, "isSinglePoint", {
            get: /**
             * @return {?}
             */ function () {
                return this.parts.length === 1 && this.currentPart.length === 1;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} positionStream
         * @return {THIS}
         */
        PositionPathBuilder.prototype.trackPosition = /**
         * @template THIS
         * @this {THIS}
         * @param {?} positionStream
         * @return {THIS}
         */
            function (positionStream) {
                var _this = this;
                ( /** @type {?} */(this)).trackSubscription = positionStream.subscribe(( /**
                 * @template THIS
                 * @this {THIS}
                 * @param {?} position
                 * @return {THIS}
                 */function (position) { return ( /** @type {?} */(_this)).addPosition(position); }));
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @param {?=} calibrationMeasure
         * @return {THIS}
         */
        PositionPathBuilder.prototype.addPosition = /**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @param {?=} calibrationMeasure
         * @return {THIS}
         */
            function (position, calibrationMeasure) {
                /** @type {?} */
                var accuracyCriteriaMet = !( /** @type {?} */(this)).options.requireAccuracy
                    || isPositionAcceptable(position, ( /** @type {?} */(this)).options.gpsRequiredAccuracyMeters);
                /** @type {?} */
                var positionNotAcceptable = !position || !accuracyCriteriaMet;
                if (positionNotAcceptable) {
                    return ( /** @type {?} */(this)).tryStoreUnfilteredPath(position);
                }
                if (( /** @type {?} */(this)).isEmpty) {
                    return ( /** @type {?} */(this)).forceAddPosition(position);
                }
                /** @type {?} */
                var pointsAtSameLocation = ( /** @type {?} */(this)).arePositionsEquivalent(( /** @type {?} */(this)).lastPosition, position);
                /** @type {?} */
                var bothPointsAtStandStill = ( /** @type {?} */(this)).lastPosition.speed === 0 && position.speed === 0 || pointsAtSameLocation;
                if (bothPointsAtStandStill) {
                    ( /** @type {?} */(this)).tryStoreUnfilteredPath(position)
                        .replaceLastPositionIfBetter(position);
                    return ( /** @type {?} */(this));
                }
                ( /** @type {?} */(this)).forceAddPosition(position);
                if (isNumber(calibrationMeasure)) {
                    ( /** @type {?} */(this)).addCalibrationMeasureToLastPosition(calibrationMeasure);
                }
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        PositionPathBuilder.prototype.startNewPart = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
            function () {
                ( /** @type {?} */(this)).parts.push([]);
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} vertexIndex
         * @param {?=} partIndex
         * @return {THIS}
         */
        PositionPathBuilder.prototype.removePositionByIndex = /**
         * @template THIS
         * @this {THIS}
         * @param {?} vertexIndex
         * @param {?=} partIndex
         * @return {THIS}
         */
            function (vertexIndex, partIndex) {
                if (partIndex === void 0) {
                    partIndex = 0;
                }
                /** @type {?} */
                var part = ( /** @type {?} */(this)).parts[partIndex];
                if (!part) {
                    throw new Error("Invalid part index\" " + partIndex);
                }
                part.splice(vertexIndex, 1);
                /** @type {?} */
                var key = ( /** @type {?} */(this)).getCalibrationMeasureLookupKey(partIndex, vertexIndex);
                if (( /** @type {?} */(this)).calibratedMeasures.has(key)) {
                    ( /** @type {?} */(this)).calibratedMeasures.delete(key);
                }
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
        PositionPathBuilder.prototype.removePosition = /**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
            function (position) {
                /** @type {?} */
                var partIndex = -1;
                /** @type {?} */
                var vertexIndex = -1;
                ( /** @type {?} */(this)).parts.forEach(( /**
                 * @param {?} part
                 * @param {?} index
                 * @return {?}
                 */function (part, index) {
                    /** @type {?} */
                    var foundPositionIndex = part.indexOf(position);
                    if (foundPositionIndex > -1) {
                        partIndex = index;
                        vertexIndex = foundPositionIndex;
                    }
                }));
                if (partIndex > -1 && vertexIndex > -1) {
                    return ( /** @type {?} */(this)).removePositionByIndex(vertexIndex, partIndex);
                }
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
        PositionPathBuilder.prototype.removeCalibrationMeasure = /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
            function (measure) {
                var _this = this;
                Array.from(( /** @type {?} */(this)).calibratedMeasures.values())
                    .filter(( /**
             * @param {?} calibration
             * @return {?}
             */function (calibration) { return calibration.measure === measure; }))
                    .forEach(( /**
             * @template THIS
             * @this {THIS}
             * @param {?} calibration
             * @return {THIS}
             */function (calibration) {
                    return ( /** @type {?} */(_this)).removeCalibrationMeasureByIndex(calibration.vertexIndex, calibration.partIndex);
                }));
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} vertexIndex
         * @param {?=} partIndex
         * @return {THIS}
         */
        PositionPathBuilder.prototype.removeCalibrationMeasureByIndex = /**
         * @template THIS
         * @this {THIS}
         * @param {?} vertexIndex
         * @param {?=} partIndex
         * @return {THIS}
         */
            function (vertexIndex, partIndex) {
                if (partIndex === void 0) {
                    partIndex = 0;
                }
                /** @type {?} */
                var key = ( /** @type {?} */(this)).getCalibrationMeasureLookupKey(partIndex, vertexIndex);
                if (( /** @type {?} */(this)).calibratedMeasures.has(key)) {
                    ( /** @type {?} */(this)).calibratedMeasures.delete(key);
                }
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
        PositionPathBuilder.prototype.addCalibrationMeasure = /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
            function (measure) {
                /** @type {?} */
                var timestamp = new Date().getTime();
                var _a = __read(( /** @type {?} */(this)).currentPart.slice(-1), 1), lastVertex = _a[0];
                if (lastVertex && lastVertex.timestamp && lastVertex.timestamp === timestamp) {
                    return ( /** @type {?} */(this)).addCalibrationMeasureToLastPosition(measure);
                }
                /** @type {?} */
                var partIndex = ( /** @type {?} */(this)).currentPartIndex;
                /** @type {?} */
                var key = UNPLACED_CALIBRATION_MEASURE_KEY;
                ( /** @type {?} */(this)).calibratedMeasures.set(key, {
                    measure: measure,
                    partIndex: partIndex,
                    vertexIndex: null,
                    timestamp: timestamp
                });
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
        PositionPathBuilder.prototype.addCalibrationMeasureToLastPosition = /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
            function (measure) {
                /** @type {?} */
                var partIndex = ( /** @type {?} */(this)).currentPartIndex;
                /** @type {?} */
                var lastVertexIndex = ( /** @type {?} */(this)).currentPart.length - 1;
                return ( /** @type {?} */(this)).addCalibrationMeasureAtIndex(measure, lastVertexIndex, partIndex);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @param {?} vertexIndex
         * @param {?=} partIndex
         * @return {THIS}
         */
        PositionPathBuilder.prototype.addCalibrationMeasureAtIndex = /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @param {?} vertexIndex
         * @param {?=} partIndex
         * @return {THIS}
         */
            function (measure, vertexIndex, partIndex) {
                if (partIndex === void 0) {
                    partIndex = 0;
                }
                /** @type {?} */
                var key = ( /** @type {?} */(this)).getCalibrationMeasureLookupKey(partIndex, vertexIndex);
                ( /** @type {?} */(this)).calibratedMeasures.set(key, {
                    measure: measure,
                    partIndex: partIndex,
                    vertexIndex: vertexIndex,
                    timestamp: new Date().getTime()
                });
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
        PositionPathBuilder.prototype.forceAddPosition = /**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
            function (position) {
                ( /** @type {?} */(this)).tryStoreUnfilteredPath(position);
                ( /** @type {?} */(this)).addPositionToPath(position);
                return ( /** @type {?} */(this));
            };
        /**
         * @param {?=} properties
         * @return {?}
         */
        PositionPathBuilder.prototype.toPointFeature = /**
         * @param {?=} properties
         * @return {?}
         */
            function (properties) {
                if (properties === void 0) {
                    properties = {};
                }
                return {
                    type: 'Feature',
                    geometry: this.toPointGeometry(),
                    properties: properties
                };
            };
        /**
         * @param {?=} properties
         * @return {?}
         */
        PositionPathBuilder.prototype.toLineFeature = /**
         * @param {?=} properties
         * @return {?}
         */
            function (properties) {
                if (properties === void 0) {
                    properties = {};
                }
                return {
                    type: 'Feature',
                    geometry: this.toLineGeometry(),
                    properties: properties
                };
            };
        /**
         * @param {?=} properties
         * @return {?}
         */
        PositionPathBuilder.prototype.toSingleLineFeature = /**
         * @param {?=} properties
         * @return {?}
         */
            function (properties) {
                if (properties === void 0) {
                    properties = {};
                }
                return {
                    type: 'Feature',
                    geometry: this.toSingleLineGeometry(),
                    properties: properties
                };
            };
        /**
         * @param {?=} properties
         * @return {?}
         */
        PositionPathBuilder.prototype.toMultiLineFeature = /**
         * @param {?=} properties
         * @return {?}
         */
            function (properties) {
                if (properties === void 0) {
                    properties = {};
                }
                return {
                    type: 'Feature',
                    geometry: this.toMultiLineGeometry(),
                    properties: properties
                };
            };
        /**
         * @param {?=} properties
         * @return {?}
         */
        PositionPathBuilder.prototype.toPolygonFeature = /**
         * @param {?=} properties
         * @return {?}
         */
            function (properties) {
                if (properties === void 0) {
                    properties = {};
                }
                return {
                    type: 'Feature',
                    geometry: this.toPolygonGeometry(),
                    properties: properties
                };
            };
        /**
         * @param {?=} properties
         * @return {?}
         */
        PositionPathBuilder.prototype.toMultiPolygonFeature = /**
         * @param {?=} properties
         * @return {?}
         */
            function (properties) {
                if (properties === void 0) {
                    properties = {};
                }
                return {
                    type: 'Feature',
                    geometry: this.toMultiPolygonGeometry(),
                    properties: properties
                };
            };
        /**
         * @param {?=} properties
         * @return {?}
         */
        PositionPathBuilder.prototype.toSinglePolygonFeature = /**
         * @param {?=} properties
         * @return {?}
         */
            function (properties) {
                if (properties === void 0) {
                    properties = {};
                }
                return {
                    type: 'Feature',
                    geometry: this.toSinglePolygonGeometry(),
                    properties: properties
                };
            };
        /**
         * @return {?}
         */
        PositionPathBuilder.prototype.toFeature = /**
         * @return {?}
         */
            function () {
                return this.isSinglePoint
                    ? ( /** @type {?} */(this.toPointFeature()))
                    : this.toLineFeature();
            };
        /**
         * @return {?}
         */
        PositionPathBuilder.prototype.toGeometry = /**
         * @return {?}
         */
            function () {
                return this.isSinglePoint
                    ? ( /** @type {?} */(this.toPointGeometry()))
                    : this.toLineGeometry();
            };
        /**
         * @param {?=} calibrateMeasures
         * @return {?}
         */
        PositionPathBuilder.prototype.toSingleLineGeometry = /**
         * @param {?=} calibrateMeasures
         * @return {?}
         */
            function (calibrateMeasures) {
                if (calibrateMeasures === void 0) {
                    calibrateMeasures = true;
                }
                /** @type {?} */
                var line = this.toLineGeometry(calibrateMeasures);
                if (isMultiPartLine(line.coordinates)) {
                    throw new Error('Cannot convert MultiLineString to LineString. Data would be lost');
                }
                return ( /** @type {?} */(line));
            };
        /**
         * @param {?=} calibrateMeasures
         * @return {?}
         */
        PositionPathBuilder.prototype.toMultiLineGeometry = /**
         * @param {?=} calibrateMeasures
         * @return {?}
         */
            function (calibrateMeasures) {
                if (calibrateMeasures === void 0) {
                    calibrateMeasures = true;
                }
                /** @type {?} */
                var line = this.toLineGeometry(calibrateMeasures);
                /** @type {?} */
                var isSinglePartLine = !isMultiPartLine(line.coordinates);
                if (isSinglePartLine) {
                    line = {
                        type: 'MultiLineString',
                        bbox: line.bbox,
                        coordinates: [( /** @type {?} */(line.coordinates))]
                    };
                }
                return ( /** @type {?} */(line));
            };
        /**
         * @param {?=} calibrateMeasures
         * @return {?}
         */
        PositionPathBuilder.prototype.toLineGeometry = /**
         * @param {?=} calibrateMeasures
         * @return {?}
         */
            function (calibrateMeasures) {
                if (calibrateMeasures === void 0) {
                    calibrateMeasures = true;
                }
                /** @type {?} */
                var parts = this.toMultiPartArray();
                /** @type {?} */
                var line = parts.length > 1
                    ? {
                        type: 'MultiLineString',
                        coordinates: parts
                    }
                    : {
                        type: 'LineString',
                        coordinates: parts[0]
                    };
                if (this.options.returnMValues) {
                    /** @type {?} */
                    var calibrationPositions = calibrateMeasures
                        ? Array.from(this.calibratedMeasures.values())
                        : [];
                    setMeasuresByGeometricLength(line, {
                        units: this.options.mValueUnit,
                        hasZValues: this.options.returnZValues,
                        calibrationPositions: calibrationPositions
                    });
                }
                return line;
            };
        /**
         * @return {?}
         */
        PositionPathBuilder.prototype.toMultiPolygonGeometry = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var poly = this.toPolygonGeometry();
                /** @type {?} */
                var isSinglePolygon = poly.type === 'Polygon';
                if (isSinglePolygon) {
                    poly = {
                        type: 'MultiPolygon',
                        bbox: poly.bbox,
                        coordinates: [( /** @type {?} */(poly.coordinates))]
                    };
                }
                return ( /** @type {?} */(poly));
            };
        /**
         * @return {?}
         */
        PositionPathBuilder.prototype.toSinglePolygonGeometry = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var poly = this.toPolygonGeometry();
                /** @type {?} */
                var isMultiPart = poly.type === 'MultiPolygon';
                if (isMultiPart) {
                    throw new Error('Cannot convert MultiPolygon to Polygon. Data would be lost');
                }
                return ( /** @type {?} */(poly));
            };
        /**
         * @return {?}
         */
        PositionPathBuilder.prototype.toPolygonGeometry = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var parts = this.toMultiPartArray();
                parts.forEach(( /**
                 * @param {?} part
                 * @return {?}
                 */function (part) { return _this.ensurePolygonIsClosed(part); }));
                return parts.length > 1
                    ? {
                        type: 'MultiPolygon',
                        coordinates: [parts]
                    }
                    : {
                        type: 'Polygon',
                        coordinates: parts
                    };
            };
        /**
         * @return {?}
         */
        PositionPathBuilder.prototype.toPointGeometry = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var parts = this.toMultiPartArray();
                return parts.length > 1
                    ? { type: 'MultiPoint', coordinates: parts.map(( /**
                             * @param {?} part
                             * @return {?}
                             */function (part) { return part[0]; })) }
                    : { type: 'Point', coordinates: parts[0][0] };
            };
        /**
         * @param {?} position
         * @return {?}
         */
        PositionPathBuilder.prototype.replaceLastPositionIfBetter = /**
         * @param {?} position
         * @return {?}
         */
            function (position) {
                /** @type {?} */
                var wasPositionAdded = true;
                if (this.isEmpty) {
                    this.addPositionToPath(position);
                    return wasPositionAdded;
                }
                /** @type {?} */
                var newPositionHasBetterAccuracy = this.lastPosition.accuracy > position.accuracy;
                if (newPositionHasBetterAccuracy) {
                    this.replaceLastPosition(position);
                }
                else {
                    wasPositionAdded = false;
                }
                return wasPositionAdded;
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
        PositionPathBuilder.prototype.replaceLastPosition = /**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
            function (position) {
                ( /** @type {?} */(this)).currentPart[( /** @type {?} */(this)).currentPart.length - 1] = position;
                return ( /** @type {?} */(this));
            };
        /**
         * @return {?}
         */
        PositionPathBuilder.prototype.getBestPosition = /**
         * @return {?}
         */
            function () {
                throw new Error('Not implemented yet');
            };
        /**
         * @return {?}
         */
        PositionPathBuilder.prototype.getUnfilteredPath = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this.unfilteredPath.map(( /**
                 * @param {?} position
                 * @return {?}
                 */function (position) {
                    /** @type {?} */
                    var unfilteredGpsPosition = Object.assign({
                        included: _this.pathContains(position)
                    }, position);
                    return unfilteredGpsPosition;
                }));
            };
        /**
         * @return {?}
         */
        PositionPathBuilder.prototype.getGeometryPathSummary = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var line = this.toMultiLineGeometry(false);
                return line.coordinates.map(( /**
                 * @param {?} part
                 * @param {?} partIndex
                 * @return {?}
                 */function (part, partIndex) { return _this.getGeometryLinePartSummary(part, partIndex); }));
            };
        /**
         * @param {?} position
         * @return {?}
         */
        PositionPathBuilder.prototype.pathContains = /**
         * @param {?} position
         * @return {?}
         */
            function (position) {
                /** @type {?} */
                var found = this.parts.find(( /**
                 * @param {?} part
                 * @return {?}
                 */function (part) {
                    return part.indexOf(position) > -1;
                }));
                return Boolean(found);
            };
        /**
         * @param {?} partIndex
         * @param {?} vertexIndex
         * @return {?}
         */
        PositionPathBuilder.prototype.getPositionByIndex = /**
         * @param {?} partIndex
         * @param {?} vertexIndex
         * @return {?}
         */
            function (partIndex, vertexIndex) {
                return this.parts[partIndex][vertexIndex];
            };
        /**
         * @return {?}
         */
        PositionPathBuilder.prototype.dispose = /**
         * @return {?}
         */
            function () {
                if (this.trackSubscription) {
                    this.trackSubscription.unsubscribe();
                }
                this.parts.length = 0;
            };
        /**
         * @private
         * @param {?} linePart
         * @param {?} partIndex
         * @return {?}
         */
        PositionPathBuilder.prototype.getGeometryLinePartSummary = /**
         * @private
         * @param {?} linePart
         * @param {?} partIndex
         * @return {?}
         */
            function (linePart, partIndex) {
                var _this = this;
                return linePart.map(( /**
                 * @param {?} vertex
                 * @param {?} vertexIndex
                 * @return {?}
                 */function (vertex, vertexIndex) {
                    /** @type {?} */
                    var position = _this.getPositionByIndex(partIndex, vertexIndex);
                    /** @type {?} */
                    var calibrationKey = _this.getCalibrationMeasureLookupKey(partIndex, vertexIndex);
                    /** @type {?} */
                    var calibrationPointMeasureValue = _this.calibratedMeasures.has(calibrationKey)
                        ? _this.calibratedMeasures.get(calibrationKey).measure
                        : PATH_BUILDER_EMPTY_CALIBRATION_MEASURE_VALUE;
                    return Object.assign({
                        geometricMeasure: getMeasureFromPoint(vertex),
                        partIndex: partIndex,
                        vertexIndex: vertexIndex,
                        calibrationPointMeasureValue: calibrationPointMeasureValue
                    }, position);
                }));
            };
        /**
         * @private
         * @param {?} partIndex
         * @param {?} vertexIndex
         * @return {?}
         */
        PositionPathBuilder.prototype.getCalibrationMeasureLookupKey = /**
         * @private
         * @param {?} partIndex
         * @param {?} vertexIndex
         * @return {?}
         */
            function (partIndex, vertexIndex) {
                return partIndex + "_" + vertexIndex;
            };
        /**
         * @private
         * @return {?}
         */
        PositionPathBuilder.prototype.toMultiPartArray = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var parts = [];
                this.parts.forEach(( /**
                 * @param {?} part
                 * @return {?}
                 */function (part) {
                    /** @type {?} */
                    var coordinates = part.map(( /**
                     * @param {?} position
                     * @return {?}
                     */function (position) {
                        return _this.options.returnZValues
                            ? [position.longitude, position.latitude, position.altitude || 0]
                            : [position.longitude, position.latitude];
                    }));
                    parts.push(coordinates);
                }));
                return parts;
            };
        /**
         * @private
         * @param {?} polygonPoints
         * @return {?}
         */
        PositionPathBuilder.prototype.ensurePolygonIsClosed = /**
         * @private
         * @param {?} polygonPoints
         * @return {?}
         */
            function (polygonPoints) {
                if (polygonPoints.length > 1) {
                    var _a = __read(polygonPoints, 1), first = _a[0];
                    /** @type {?} */
                    var last = getLastItem(polygonPoints);
                    var _b = __read(first, 3), firstLng = _b[0], firstLat = _b[1], firstZ = _b[2];
                    var _c = __read(last, 2), lastLng = _c[0], lastLat = _c[1];
                    /** @type {?} */
                    var doesPolygonNotClose = !this.arePointsEquivalent(firstLng, firstLat, lastLng, lastLat);
                    if (doesPolygonNotClose) {
                        /** @type {?} */
                        var closingPoint = [firstLng, firstLat, firstZ || 0];
                        polygonPoints.push(closingPoint);
                    }
                }
            };
        /**
         * @private
         * @param {?} position
         * @return {?}
         */
        PositionPathBuilder.prototype.addPositionToPath = /**
         * @private
         * @param {?} position
         * @return {?}
         */
            function (position) {
                this.currentPart.push(position);
                if (this.calibratedMeasures.has(UNPLACED_CALIBRATION_MEASURE_KEY)) {
                    this.addPendingCalibrationPoint();
                }
            };
        /**
         * @private
         * @return {?}
         */
        PositionPathBuilder.prototype.addPendingCalibrationPoint = /**
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var calibratonPosition = this.calibratedMeasures.get(UNPLACED_CALIBRATION_MEASURE_KEY);
                /** @type {?} */
                var calibrationTimestamp = calibratonPosition.timestamp;
                var _a = __read(this.currentPart.slice(-2), 2), secondToLastPosition = _a[0], lastPosition = _a[1];
                /** @type {?} */
                var isTimestampBetweenVertices = calibrationTimestamp > secondToLastPosition.timestamp
                    && calibrationTimestamp < lastPosition.timestamp;
                if (isTimestampBetweenVertices) {
                    /** @type {?} */
                    var totalTimeDelta = Math.abs(lastPosition.timestamp - secondToLastPosition.timestamp);
                    /** @type {?} */
                    var offsetTimeDelta = Math.abs(calibrationTimestamp - secondToLastPosition.timestamp);
                    /** @type {?} */
                    var percentOfDistance = offsetTimeDelta / totalTimeDelta;
                    /** @type {?} */
                    var distanceBetweenVerticesKilometers = getDistanceBetweenLatLng(secondToLastPosition.latitude, secondToLastPosition.longitude, lastPosition.latitude, lastPosition.longitude, LengthUnit.Mile);
                    /** @type {?} */
                    var distanceToPreviousVertexKilometers = percentOfDistance * distanceBetweenVerticesKilometers;
                    /** @type {?} */
                    var didSnapCalibrationMeasureToVertes = this.trySnapCalibrationMeasureToVertex(calibratonPosition.measure, distanceBetweenVerticesKilometers, distanceToPreviousVertexKilometers);
                    if (didSnapCalibrationMeasureToVertes) {
                        return;
                    }
                    /** @type {?} */
                    var heading = bearing([secondToLastPosition.longitude, secondToLastPosition.latitude], [lastPosition.longitude, lastPosition.latitude]);
                    /** @type {?} */
                    var newPoint = destination([secondToLastPosition.longitude, secondToLastPosition.latitude], distanceToPreviousVertexKilometers, heading, { units: 'kilometers' });
                    /** @type {?} */
                    var spliceIndexForSecondToLastPosition = this.currentPart.length - 1;
                    /** @type {?} */
                    var newPosition = Object.assign({}, lastPosition, {
                        longitude: newPoint.geometry.coordinates[0],
                        latitude: newPoint.geometry.coordinates[1],
                        deviceSource: PATH_BUILDER_CALCULATED_M_DEVICE_SOURCE
                    });
                    this.calibratedMeasures.delete(UNPLACED_CALIBRATION_MEASURE_KEY);
                    this.addCalibrationMeasureAtIndex(calibratonPosition.measure, spliceIndexForSecondToLastPosition, this.currentPartIndex);
                    this.currentPart.splice(spliceIndexForSecondToLastPosition, 0, newPosition);
                }
                else if (calibrationTimestamp >= lastPosition.timestamp) {
                    this.addCalibrationMeasureToLastPosition(calibratonPosition.measure);
                }
                else {
                    throw new Error("Calibration measure timestamp '" + calibratonPosition.timestamp + "' can not be located between"
                        + (" '" + secondToLastPosition.timestamp + "' and '" + lastPosition.timestamp + "'"));
                }
            };
        /**
         * @private
         * @param {?} calibrationMeasure
         * @param {?} totalVerticeDistanceKilometers
         * @param {?} distanceToPreviousVertexKilometers
         * @return {?}
         */
        PositionPathBuilder.prototype.trySnapCalibrationMeasureToVertex = /**
         * @private
         * @param {?} calibrationMeasure
         * @param {?} totalVerticeDistanceKilometers
         * @param {?} distanceToPreviousVertexKilometers
         * @return {?}
         */
            function (calibrationMeasure, totalVerticeDistanceKilometers, distanceToPreviousVertexKilometers) {
                /** @type {?} */
                var distanceToNextVertexKilometers = totalVerticeDistanceKilometers - distanceToPreviousVertexKilometers;
                /** @type {?} */
                var distanceThresholdKilometers = convertLengthUnits(this.options.calibrationMeasureSnappingDistanceDelta, this.options.calibrationMeasureSnappingDistanceDeltaUnit, LengthUnit.Kilometer);
                /** @type {?} */
                var isPointCloseEnoughToPrevious = distanceToPreviousVertexKilometers < distanceThresholdKilometers;
                /** @type {?} */
                var isPointCloseEnoughToNext = distanceToNextVertexKilometers < distanceThresholdKilometers;
                if (isPointCloseEnoughToPrevious || isPointCloseEnoughToNext) {
                    /** @type {?} */
                    var previousVertexIndex = this.currentPart.length - 2;
                    /** @type {?} */
                    var nextVertexIndex = this.currentPart.length - 1;
                    /** @type {?} */
                    var vertexIndex = distanceToPreviousVertexKilometers < distanceToNextVertexKilometers
                        ? previousVertexIndex
                        : nextVertexIndex;
                    this.addCalibrationMeasureAtIndex(calibrationMeasure, vertexIndex, this.currentPartIndex);
                    this.calibratedMeasures.delete(UNPLACED_CALIBRATION_MEASURE_KEY);
                    return true;
                }
                return false;
            };
        /**
         * @private
         * @param {?} position1
         * @param {?} position2
         * @return {?}
         */
        PositionPathBuilder.prototype.arePositionsEquivalent = /**
         * @private
         * @param {?} position1
         * @param {?} position2
         * @return {?}
         */
            function (position1, position2) {
                return this.arePointsEquivalent(position1.longitude, position1.latitude, position2.longitude, position2.latitude);
            };
        /**
         * @private
         * @param {?} longitude1
         * @param {?} latitude1
         * @param {?} longitude2
         * @param {?} latitude2
         * @return {?}
         */
        PositionPathBuilder.prototype.arePointsEquivalent = /**
         * @private
         * @param {?} longitude1
         * @param {?} latitude1
         * @param {?} longitude2
         * @param {?} latitude2
         * @return {?}
         */
            function (longitude1, latitude1, longitude2, latitude2) {
                return pointsAlmostEqual(longitude1, latitude1, longitude2, latitude2, this.options.pointEquivalencyPrecision);
            };
        /**
         * @private
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
        PositionPathBuilder.prototype.tryStoreUnfilteredPath = /**
         * @private
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
            function (position) {
                if (( /** @type {?} */(this)).options.storeUnfilteredPath) {
                    ( /** @type {?} */(this)).unfilteredPath.push(position);
                }
                return ( /** @type {?} */(this));
            };
        return PositionPathBuilder;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} radians
     * @return {?}
     */
    function radiansToDegrees(radians) {
        return radians * 180 / Math.PI;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing geometry-related settings.
     */
    var GeometryConfig = /** @class */ (function () {
        function GeometryConfig() {
        }
        GeometryConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ GeometryConfig.ngInjectableDef = i0.defineInjectable({ factory: function GeometryConfig_Factory() { return new GeometryConfig(); }, token: GeometryConfig, providedIn: "root" });
        /**
         * Configuration class for storing geometry-related settings.
         */
        GeometryConfig = __decorate([
            AutoConfig('GeometryConfig')
        ], GeometryConfig);
        return GeometryConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @return {?}
     */
    function extractMeasuresFromLine(line) {
        /** @type {?} */
        var measures = [];
        /** @type {?} */
        var paths = toMultiPartPaths(line);
        paths.forEach(( /**
         * @param {?} coordinates
         * @return {?}
         */function (coordinates) {
            /** @type {?} */
            var pathMeasures = coordinates.map(( /**
             * @param {?} coordinate
             * @return {?}
             */function (coordinate) { return getMeasureFromPoint(coordinate); }));
            addRange(measures, pathMeasures);
        }));
        return measures;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} x
     * @return {?}
     */
    function squareRoot(x) {
        return x * x;
    }
    /**
     * @param {?} v
     * @param {?} w
     * @return {?}
     */
    function squareRootDistance(v, w) {
        return squareRoot(v.x - w.x) + squareRoot(v.y - w.y);
    }
    /**
     * @param {?} testPoint
     * @param {?} lineStartPoint
     * @param {?} lineEndPoint
     * @return {?}
     */
    function distanceToSegmentSquared(testPoint, lineStartPoint, lineEndPoint) {
        /** @type {?} */
        var lengthSquared = squareRootDistance(lineStartPoint, lineEndPoint);
        if (lengthSquared === 0) {
            return squareRootDistance(testPoint, lineStartPoint);
        }
        /** @type {?} */
        var part1 = (testPoint.x - lineStartPoint.x) * (lineEndPoint.x - lineStartPoint.x);
        /** @type {?} */
        var part2 = (testPoint.y - lineStartPoint.y) * (lineEndPoint.y - lineStartPoint.y);
        /** @type {?} */
        var formulaPart1 = part1 + part2;
        /** @type {?} */
        var delta = formulaPart1 / lengthSquared;
        if (delta < 0) {
            return squareRootDistance(testPoint, lineStartPoint);
        }
        if (delta > 1) {
            return squareRootDistance(testPoint, lineEndPoint);
        }
        /** @type {?} */
        var xValue = lineStartPoint.x + delta * (lineEndPoint.x - lineStartPoint.x);
        /** @type {?} */
        var yValue = lineStartPoint.y + delta * (lineEndPoint.y - lineStartPoint.y);
        return squareRootDistance(testPoint, { x: xValue, y: yValue });
    }
    /**
     * @param {?} testPoint
     * @param {?} lineStartPoint
     * @param {?} lineEndPoint
     * @return {?}
     */
    function distToSegment(testPoint, lineStartPoint, lineEndPoint) {
        return Math.sqrt(distanceToSegmentSquared(testPoint, lineStartPoint, lineEndPoint));
    }
    /**
     * @param {?} testPoint
     * @param {?} lineStartPoint
     * @param {?} lineEndPoint
     * @return {?}
     */
    function getDistanceToLine(testPoint, lineStartPoint, lineEndPoint) {
        /** @type {?} */
        var testPointArray = toSinglePartPointArray(testPoint);
        /** @type {?} */
        var lineStartPointArray = toSinglePartPointArray(lineStartPoint);
        /** @type {?} */
        var lineEndPointArray = toSinglePartPointArray(lineEndPoint);
        var _a = __read(testPointArray, 2), testPointX = _a[0], testPointY = _a[1];
        var _b = __read(lineStartPointArray, 2), lineStartX = _b[0], lineStartY = _b[1];
        var _c = __read(lineEndPointArray, 2), lineEndX = _c[0], lineEndY = _c[1];
        return distToSegment({ x: testPointX, y: testPointY }, { x: lineStartX, y: lineStartY }, { x: lineEndX, y: lineEndY });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @param {?} point
     * @param {?=} options
     * @return {?}
     */
    function getMeasureFromFlatCoordinateSystem(line, point, options) {
        return getMeasure(line, point, Object.assign({ coordinateSystem: 'flat' }, options));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @param {?} lat
     * @param {?} lng
     * @param {?} options
     * @return {?}
     */
    function getMeasureFromLatLng(line, lat, lng, options) {
        return this.getMeasure(line, [lng, lat], options);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @param {?} point
     * @param {?=} isPointDegrees
     * @return {?}
     */
    function getVerticeeInfos(line, point, isPointDegrees) {
        if (isPointDegrees === void 0) {
            isPointDegrees = true;
        }
        /** @type {?} */
        var pointComparisonDetails = [];
        /** @type {?} */
        var paths = toMultiPartPaths(line);
        paths.forEach(( /**
         * @param {?} coordinates
         * @return {?}
         */function (coordinates) {
            /** @type {?} */
            var details = comparePathWithPoint(coordinates, point, isPointDegrees);
            addRange(pointComparisonDetails, details);
        }));
        /** @type {?} */
        var nearestPoint;
        /** @type {?} */
        var furthestPoint;
        /** @type {?} */
        var minPoint;
        /** @type {?} */
        var maxPoint;
        pointComparisonDetails.forEach(( /**
         * @param {?} pointCandidate
         * @return {?}
         */function (pointCandidate) {
            if (!nearestPoint || pointCandidate.distance < nearestPoint.distance) {
                nearestPoint = pointCandidate;
            }
            if (!furthestPoint || pointCandidate.distance > furthestPoint.distance) {
                furthestPoint = pointCandidate;
            }
            if (!minPoint || pointCandidate.pointMeasure < minPoint.pointMeasure) {
                minPoint = pointCandidate;
            }
            if (!maxPoint || pointCandidate.pointMeasure > maxPoint.pointMeasure) {
                maxPoint = pointCandidate;
            }
        }));
        // const nearestPoint = pointComparisionDetails
        //   .reduce((accumulator, value) => accumulator.distance > value.distance ? value : accumulator);
        /** @type {?} */
        var pointBefore = pointComparisonDetails[nearestPoint.index - 1];
        /** @type {?} */
        var pointAfter = pointComparisonDetails[nearestPoint.index + 1];
        /** @type {?} */
        var nextPoint = pointAfter;
        /** @type {?} */
        var previousPoint = pointBefore;
        // NOTE: this logic handles the rare case where the distance of the test point matches both the next
        // and previous verticee.
        // 0-----4--------------------------100
        //          5
        if (pointBefore && pointAfter) {
            /** @type {?} */
            var beforDistance = getDistanceToLine(point, nearestPoint.pointCoordinate, pointBefore.pointCoordinate);
            /** @type {?} */
            var afterDistance = getDistanceToLine(point, nearestPoint.pointCoordinate, pointAfter.pointCoordinate);
            if (beforDistance < afterDistance) {
                nextPoint = pointBefore;
                previousPoint = pointComparisonDetails[nextPoint.index - 2];
            }
        }
        return {
            nearestPoint: nearestPoint,
            furthestPoint: furthestPoint,
            nextPoint: nextPoint,
            previousPoint: previousPoint,
            minPoint: minPoint,
            maxPoint: maxPoint
        };
    }
    /**
     * @param {?} line
     * @param {?} point
     * @param {?=} isPointDegrees
     * @return {?}
     */
    function getClosestVerticees(line, point, isPointDegrees) {
        if (isPointDegrees === void 0) {
            isPointDegrees = true;
        }
        /** @type {?} */
        var info = getVerticeeInfos(line, point, isPointDegrees);
        return [
            info.nearestPoint ? info.nearestPoint.pointCoordinate : null,
            info.nextPoint ? info.nextPoint.pointCoordinate : null
        ];
    }
    /**
     * @param {?} line
     * @param {?} point
     * @param {?=} isPointDegrees
     * @return {?}
     */
    function getClosestVerticee(line, point, isPointDegrees) {
        if (isPointDegrees === void 0) {
            isPointDegrees = true;
        }
        var _a = __read(getClosestVerticees(line, point, isPointDegrees), 1), firstClosest = _a[0];
        return firstClosest;
    }
    /**
     * @param {?} coordinates
     * @param {?} pointToCompare
     * @param {?} isPointDegrees
     * @return {?}
     */
    function comparePathWithPoint(coordinates, pointToCompare, isPointDegrees) {
        /** @type {?} */
        var pointComparisionDetailsFromPath = coordinates
            .map(( /**
     * @param {?} coordinate
     * @param {?} index
     * @return {?}
     */function (coordinate, index) { return compareCoordinateWithPoint(coordinate, pointToCompare, isPointDegrees, index); }));
        return pointComparisionDetailsFromPath;
    }
    /**
     * @param {?} coordinate
     * @param {?} pointToCompare
     * @return {?}
     */
    function getDegreeDistance(coordinate, pointToCompare) {
        /** @type {?} */
        var coordinate2 = toSinglePartPointArray(pointToCompare);
        return getMetersBetweenLatLng(coordinate[1], coordinate[0], coordinate2[1], coordinate2[0]);
    }
    /**
     * @param {?} coordinate
     * @param {?} pointToCompare
     * @param {?} isPointDegrees
     * @param {?} index
     * @return {?}
     */
    function compareCoordinateWithPoint(coordinate, pointToCompare, isPointDegrees, index) {
        /** @type {?} */
        var distance$$1 = isPointDegrees
            ? getDegreeDistance(coordinate, pointToCompare)
            : getDistanceBetweenPoints(coordinate, pointToCompare);
        /** @type {?} */
        var pointDetails = {
            pointCoordinate: coordinate,
            distance: distance$$1,
            index: index
        };
        return pointDetails;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Determines if a point (value) is within a given bounds (line).
     * @param {?} boundStart The start of the restrcting bounds.
     * @param {?} boundEnd The end of the restricting bounds.
     * @param {?} testValue The value to check against the restricting bounds.
     * @return {?}
     */
    function isPointWithinBounds(boundStart, boundEnd, testValue) {
        return testValue >= boundStart && testValue <= boundEnd;
    }
    /**
     * Determines if a point (value) is within a given bounds (line), but will not match the start and end values.
     * @param {?} boundStart The start of the restrcting bounds.
     * @param {?} boundEnd The end of the restricting bounds.
     * @param {?} testValue The value to check against the restricting bounds.
     * @return {?}
     */
    function isPointWithinButNotIncludingBounds(boundStart, boundEnd, testValue) {
        return testValue > boundStart && testValue < boundEnd;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Determines if two points (a line) are within a given bounds (line).
     * @param {?} boundStart The start of the restrcting bounds.
     * @param {?} boundEnd The end of the restricting bounds.
     * @param {?} testStartValue The start value of the line to check against the restricting bounds.
     * @param {?} testEndValue The end value of the line to check against the restricting bounds.
     * @return {?}
     */
    function isLineWithinBounds(boundStart, boundEnd, testStartValue, testEndValue) {
        /**
         * Runs through:
         * BOUNDS:   10---------15
         * TEST:   8---------------18
         *
         * Starts and runs through:
         * BOUNDS: 0---------15
         * TEST:   0---------------18
         *
         * Ends and runs through:
         * BOUNDS:       5---------18
         * TEST:   0---------------18
         * @type {?}
         */
        var runsThrough = testStartValue < boundStart && testEndValue > boundEnd;
        /** @type {?} */
        var isFullMatch = testStartValue === boundStart && testEndValue === boundEnd;
        /** @type {?} */
        var isStartInBounds = isPointWithinButNotIncludingBounds(boundStart, boundEnd, testStartValue);
        /** @type {?} */
        var isEndInBounds = isPointWithinButNotIncludingBounds(boundStart, boundEnd, testEndValue);
        /** @type {?} */
        var isStartMatch = boundStart === testStartValue;
        /** @type {?} */
        var isEndMatch = boundEnd === testEndValue;
        /** @type {?} */
        var startsAndRunsThrough = isStartMatch && boundStart <= testEndValue;
        /** @type {?} */
        var endsAndRunsThrough = isEndMatch && boundEnd >= testStartValue;
        return runsThrough
            || isFullMatch
            || isStartInBounds
            || isEndInBounds
            || startsAndRunsThrough
            || endsAndRunsThrough;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} line
     * @param {?} point
     * @return {?}
     */
    function isPointOnLineString(line, point) {
        return isPointOnLine(line.coordinates[0], getLastItem(line.coordinates), point);
    }
    /**
     * @param {?} line
     * @param {?} lat
     * @param {?} lng
     * @return {?}
     */
    function isLatLngOnLineString(line, lat, lng) {
        var _a = __read(line.coordinates[0], 2), lineStartLng = _a[0], lineStartLat = _a[1];
        var _b = __read(getLastItem(line.coordinates), 2), lineEndLng = _b[0], lineEndLat = _b[1];
        return isLatLngOnLine(lineStartLat, lineStartLng, lineEndLat, lineEndLng, lat, lng);
    }
    /**
     * @param {?} lineStartLat
     * @param {?} lineStartLng
     * @param {?} lineEndLat
     * @param {?} lineEndLng
     * @param {?} testPointLat
     * @param {?} testPointLng
     * @return {?}
     */
    function isLatLngOnLine(lineStartLat, lineStartLng, lineEndLat, lineEndLng, testPointLat, testPointLng) {
        throw new Error('AHHH!');
    }
    /**
     * @param {?} lineStartPoint
     * @param {?} lineEndPoint
     * @param {?} testPoint
     * @param {?=} tolerance
     * @return {?}
     */
    function isPointOnLine(lineStartPoint, lineEndPoint, testPoint, tolerance) {
        if (tolerance === void 0) {
            tolerance = 0;
        }
        /** @type {?} */
        var startPoint = toSinglePartPointArray(lineStartPoint);
        /** @type {?} */
        var endPoint = toSinglePartPointArray(lineEndPoint);
        /** @type {?} */
        var point = toSinglePartPointArray(testPoint);
        var _a = __read(startPoint, 2), startPointX = _a[0], startPointY = _a[1];
        var _b = __read(endPoint, 2), endPointX = _b[0], endPointY = _b[1];
        var _c = __read(point, 2), testPointX = _c[0], testPointY = _c[1];
        /** @type {?} */
        var slope = (endPointY - startPointY) / (endPointX - startPointX);
        /** @type {?} */
        var y = slope * testPointX + startPointY;
        if ((y <= testPointY + tolerance && y >= testPointY - tolerance) && (testPointX >= startPointX && testPointX <= endPointX)) {
            return true;
        }
        return false;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} startPoint
     * @param {?} endPoint
     * @param {?} testPoint
     * @return {?}
     */
    function calculateCrossProductByPoints(startPoint, endPoint, testPoint) {
        var _a = __read(toSinglePartPointArray(startPoint), 2), x1 = _a[0], y1 = _a[1];
        var _b = __read(toSinglePartPointArray(endPoint), 2), x2 = _b[0], y2 = _b[1];
        var _c = __read(toSinglePartPointArray(testPoint), 2), testX = _c[0], testY = _c[1];
        return calculateCrossProduct(x1, y1, x2, y2, testX, testY);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing Gps Gate-related settings.
     */
    var GpsGateConfig = /** @class */ (function () {
        function GpsGateConfig() {
            this.refreshInterval = 1000;
            this.urlTemplate = 'http://localhost:12175/gps/{endpoint}?noCache={cacheBuster}';
            this.getInfoEndpoint = 'getGpsInfo';
            this.getVersionEndpoint = 'getVersion';
            this.jsonpParameterName = 'jsonp';
            this.geolocatorName = 'GpsGate Client';
            this.geolocatorDescription = 'GpsGate client that can connect to a variety of GPS data sources.';
        }
        GpsGateConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ GpsGateConfig.ngInjectableDef = i0.defineInjectable({ factory: function GpsGateConfig_Factory() { return new GpsGateConfig(); }, token: GpsGateConfig, providedIn: "root" });
        /**
         * Configuration class for storing Gps Gate-related settings.
         */
        GpsGateConfig = __decorate([
            AutoConfig('GpsGateConfig')
        ], GpsGateConfig);
        return GpsGateConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
     * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
     */
    var GpsGateGeolocator = /** @class */ (function (_super) {
        __extends(GpsGateGeolocator, _super);
        function GpsGateGeolocator(log, http, config) {
            var _this = _super.call(this, log) || this;
            _this.http = http;
            _this.config = config;
            _this.capabilities = [
                GeolocatorCapability.Altitude,
                GeolocatorCapability.AltitudeAccuracy,
                GeolocatorCapability.Heading,
                GeolocatorCapability.Speed,
                GeolocatorCapability.HDOP,
            ];
            _this.accuracyUnit = GeolocatorAccuracyUnit.Hdop;
            return _this;
        }
        Object.defineProperty(GpsGateGeolocator.prototype, "name", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.geolocatorName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GpsGateGeolocator.prototype, "description", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.geolocatorDescription;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?=} options
         * @return {?}
         */
        GpsGateGeolocator.prototype.getCurrentPosition = /**
         * @param {?=} options
         * @return {?}
         */
            function (options) {
                var _this = this;
                /** @type {?} */
                var url = format(this.config.urlTemplate, {
                    endpoint: this.config.getInfoEndpoint,
                    cacheBuster: new Date().getTime()
                });
                return this.http.jsonp(url, this.config.jsonpParameterName)
                    .pipe(operators.map(( /**
             * @param {?} info
             * @return {?}
             */function (info) {
                    /** @type {?} */
                    var timestamp = new Date(info.trackPoint.utc).getTime();
                    /** @type {?} */
                    var position = Object.assign({
                        timestamp: timestamp,
                        // NOTE: We are setting accuracy to HDOP because since this geolocator does not have
                        // accuracy capabilities (see capabilities property), accuracy will not be shown within
                        // the UI - rather fallback PDOP, HDOP, VDOP, etc will be used. However, we want to set
                        // the accuracy because this value is what will be used to do collection
                        // accuracy/precision acceptance (acceptable, warning, unaceptable, etc) - RG.
                        accuracy: info.trackPoint.precision.hdop,
                        altitudeAccuracy: null,
                        speed: info.trackPoint.velocity.groundSpeed,
                        heading: info.trackPoint.velocity.heading,
                        hdop: info.trackPoint.precision.hdop
                    }, info.trackPoint.position);
                    _this.log.trace("Received current position for " + _this.name);
                    return position;
                })))
                    .toPromise();
            };
        /**
         * @param {?=} options
         * @return {?}
         */
        GpsGateGeolocator.prototype.watchPosition = /**
         * @param {?=} options
         * @return {?}
         */
            function (options) {
                var _this = this;
                /** @type {?} */
                var lastPosition;
                /** @type {?} */
                var subject = new rxjs.Subject();
                /** @type {?} */
                var interval = setInterval(( /**
                 * @return {?}
                 */function () {
                    _this.getCurrentPosition(options)
                        .then(( /**
                 * @param {?} position
                 * @return {?}
                 */function (position) {
                        if (notEqual(position, lastPosition)) {
                            subject.next(position);
                        }
                        _this.log.trace("Received watch position for " + _this.name);
                        lastPosition = position;
                    }))
                        .catch(( /**
                 * @param {?} error
                 * @return {?}
                 */function (error) { return subject.error(error); }));
                }), this.config.refreshInterval);
                return subject.pipe(operators.finalize(( /**
                 * @return {?}
                 */function () { return clearInterval(interval); })));
            };
        /**
         * @return {?}
         */
        GpsGateGeolocator.prototype.isAvailable = /**
         * @return {?}
         */
            function () {
                return this.getVersion()
                    .pipe(operators.map(( /**
             * @param {?} result
             * @return {?}
             */function (result) { return Boolean(result); })), operators.catchError(( /**
                 * @return {?}
                 */function () { return rxjs.of(false); })));
            };
        /**
         * @return {?}
         */
        GpsGateGeolocator.prototype.getVersion = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var url = format(this.config.urlTemplate, {
                    endpoint: this.config.getVersionEndpoint,
                    cacheBuster: new Date().getTime()
                });
                return this.http.jsonp(url, this.config.jsonpParameterName);
            };
        GpsGateGeolocator.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        GpsGateGeolocator.ctorParameters = function () {
            return [
                { type: Logger },
                { type: i1$1.HttpClient },
                { type: GpsGateConfig }
            ];
        };
        /** @nocollapse */ GpsGateGeolocator.ngInjectableDef = i0.defineInjectable({ factory: function GpsGateGeolocator_Factory() { return new GpsGateGeolocator(i0.inject(Logger), i0.inject(i1$1.HttpClient), i0.inject(GpsGateConfig)); }, token: GpsGateGeolocator, providedIn: "root" });
        /**
         * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
         * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
         */
        GpsGateGeolocator = __decorate([
            Geolocatable('gps-gate'),
            __metadata("design:paramtypes", [Logger, i1$1.HttpClient, GpsGateConfig])
        ], GpsGateGeolocator);
        return GpsGateGeolocator;
    }(BaseGeolocator));
    /**
     * @param {?} position1
     * @param {?} position2
     * @return {?}
     */
    function notEqual(position1, position2) {
        return !equal(position1, position2);
    }
    /**
     * @param {?} position1
     * @param {?} position2
     * @return {?}
     */
    function equal(position1, position2) {
        return position1
            && position2
            && position1.timestamp === position2.timestamp
            && position1.latitude === position2.latitude
            && position1.longitude === position2.longitude
            && position1.accuracy === position2.accuracy
            && position1.speed === position2.speed
            && position1.heading === position2.heading
            && position1.altitude === position2.altitude
            && position1.altitudeAccuracy === position2.altitudeAccuracy
            && position1.pdop === position2.pdop
            && position1.hdop === position2.hdop
            && position1.vdop === position2.vdop
            && position1.tdop === position2.tdop;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssGpsGateModule = /** @class */ (function () {
        function TssGpsGateModule() {
        }
        TssGpsGateModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            TssCoreModule,
                            TssGeolocationModule
                        ],
                        declarations: [],
                        exports: [],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssGpsGateModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CalibrationPointLayer = /** @class */ (function (_super) {
        __extends(CalibrationPointLayer, _super);
        function CalibrationPointLayer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CalibrationPointLayer;
    }(FeatureClassLayer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var CapturePosition = {
        Center: 'center',
        Left: 'left',
        Right: 'right',
        Sld: 'sld',
        Map: 'map',
        Lane: 'lane',
        Shoulder: 'shoulder',
        Curb: 'curb',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CenterlineLayer = /** @class */ (function (_super) {
        __extends(CenterlineLayer, _super);
        function CenterlineLayer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CenterlineLayer;
    }(FeatureClassLayer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LrsDataService = /** @class */ (function () {
        function LrsDataService(mapService, dataSourceService, dataSourceConfig) {
            this.mapService = mapService;
            this.dataSourceService = dataSourceService;
            this.dataSourceConfig = dataSourceConfig;
        }
        /**
         * @template T
         * @param {?} dataSource
         * @param {?} layer
         * @param {?} field
         * @param {?=} whereClause
         * @return {?}
         */
        LrsDataService.prototype.getUniqueValues = /**
         * @template T
         * @param {?} dataSource
         * @param {?} layer
         * @param {?} field
         * @param {?=} whereClause
         * @return {?}
         */
            function (dataSource, layer, field, whereClause) {
                /** @type {?} */
                var mapServiceParams = { gdbVersion: layer.versionName };
                /** @type {?} */
                var httpParams;
                if (whereClause) {
                    mapServiceParams.where = whereClause;
                    httpParams = new i1$1.HttpParams().set('where', whereClause);
                }
                return dataSource.serviceUrl
                    ? this.mapService.getUniqueValues(dataSource.serviceUrl, layer, field, mapServiceParams)
                    : this.dataSourceService.getUniqueColumnValues(dataSource.id, layer.featureClassName, toFieldName(field), httpParams);
            };
        /**
         * @param {?} dataSource
         * @param {?} layer
         * @param {?} whereClause
         * @return {?}
         */
        LrsDataService.prototype.getQueryCount = /**
         * @param {?} dataSource
         * @param {?} layer
         * @param {?} whereClause
         * @return {?}
         */
            function (dataSource, layer, whereClause) {
                return dataSource.serviceUrl
                    ? this.mapService.getQueryCount(dataSource.serviceUrl, layer, whereClause, { gdbVersion: layer.versionName })
                    : this.dataSourceService.getRecordCount(dataSource.id, layer.featureClassName, whereClause, layer.versionName);
            };
        /**
         * @param {?} dataSource
         * @param {?} layer
         * @param {?} routeIds
         * @return {?}
         */
        LrsDataService.prototype.queryRoutesByIds = /**
         * @param {?} dataSource
         * @param {?} layer
         * @param {?} routeIds
         * @return {?}
         */
            function (dataSource, layer, routeIds) {
                if (!routeIds || !routeIds.length) {
                    throw new Error('Failed to query routes. No route IDs supplied.');
                }
                if (!layer.compositeRouteIdFieldName) {
                    throw new Error("Failed to query routes. No 'compositeRouteIdFieldName' property found for layer.");
                }
                /** @type {?} */
                var whereClause = layer.compositeRouteIdFieldName + " IN ('" + routeIds.join("','") + "')";
                return this.queryRoutes(dataSource, layer, whereClause);
            };
        /**
         * @param {?} dataSource
         * @param {?} layer
         * @param {?=} whereClause
         * @return {?}
         */
        LrsDataService.prototype.queryRoutes = /**
         * @param {?} dataSource
         * @param {?} layer
         * @param {?=} whereClause
         * @return {?}
         */
            function (dataSource, layer, whereClause) {
                /** @type {?} */
                var shapeFieldName = getGeometryFieldName(layer.fields);
                return dataSource.serviceUrl
                    ? this.mapService.queryRoutes(dataSource.serviceUrl, layer, whereClause, { gdbVersion: layer.versionName })
                    : this.dataSourceService.querySpatialData(dataSource.id, layer.featureClassName, whereClause, layer.versionName, null, null, true, shapeFieldName);
            };
        /**
         * @param {?} dataSource
         * @param {?} layer
         * @param {?} searchText
         * @return {?}
         */
        LrsDataService.prototype.searchRoutesByText = /**
         * @param {?} dataSource
         * @param {?} layer
         * @param {?} searchText
         * @return {?}
         */
            function (dataSource, layer, searchText) {
                /** @type {?} */
                var useMapService = Boolean(dataSource.serviceUrl);
                /** @type {?} */
                var shapeFieldName = getGeometryFieldName(layer.fields);
                /** @type {?} */
                var whereClause;
                if (!useMapService) {
                    whereClause = new WhereClauseBuilder({
                        quoteFields: !this.dataSourceConfig.skipColumnQuotes
                    })
                        .whereLike(layer.displayField, searchText)
                        .toWhereClause();
                }
                return useMapService
                    ? this.mapService.searchRoutesByText(dataSource.serviceUrl, layer, searchText, { gdbVersion: layer.versionName })
                    : this.dataSourceService.querySpatialData(dataSource.id, layer.featureClassName, whereClause, layer.versionName, null, null, true, shapeFieldName);
            };
        LrsDataService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        LrsDataService.ctorParameters = function () {
            return [
                { type: EsriMapServerService },
                { type: DataSourceService },
                { type: DataSourceConfig }
            ];
        };
        /** @nocollapse */ LrsDataService.ngInjectableDef = i0.defineInjectable({ factory: function LrsDataService_Factory() { return new LrsDataService(i0.inject(EsriMapServerService), i0.inject(DataSourceService), i0.inject(DataSourceConfig)); }, token: LrsDataService, providedIn: "root" });
        return LrsDataService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing global ESRI-related settings.
     */
    var LrsConfig = /** @class */ (function (_super) {
        __extends(LrsConfig, _super);
        function LrsConfig() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.dataSourceLrsMetadataEndpoint = 'api/spatial/data/sources/{dataSourceId}/lrs/meta';
            _this.cacheInSessionLrsMetadata = true;
            return _this;
        }
        LrsConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ LrsConfig.ngInjectableDef = i0.defineInjectable({ factory: function LrsConfig_Factory() { return new LrsConfig(); }, token: LrsConfig, providedIn: "root" });
        /**
         * Configuration class for storing global ESRI-related settings.
         */
        LrsConfig = __decorate([
            AutoConfig('LrsConfig')
        ], LrsConfig);
        return LrsConfig;
    }(ResourceConfig));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DataSourceLrsMetadataService = /** @class */ (function (_super) {
        __extends(DataSourceLrsMetadataService, _super);
        function DataSourceLrsMetadataService(http, config) {
            var _this = _super.call(this, http, {
                url: join(config.serviceUrl, config.dataSourceLrsMetadataEndpoint),
                idFieldName: 'dataSourceId'
            }) || this;
            _this.http = http;
            return _this;
        }
        /**
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        DataSourceLrsMetadataService.prototype.create = /**
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (entity, routeTokens, params) {
                routeTokens = routeTokens || {};
                routeTokens.id = entity.dataSourceId;
                return _super.prototype.create.call(this, entity, routeTokens, params);
            };
        DataSourceLrsMetadataService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        DataSourceLrsMetadataService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: LrsConfig }
            ];
        };
        /** @nocollapse */ DataSourceLrsMetadataService.ngInjectableDef = i0.defineInjectable({ factory: function DataSourceLrsMetadataService_Factory() { return new DataSourceLrsMetadataService(i0.inject(i1$1.HttpClient), i0.inject(LrsConfig)); }, token: DataSourceLrsMetadataService, providedIn: "root" });
        return DataSourceLrsMetadataService;
    }(BaseResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} layer
     * @param {?=} stripLayerTableName
     * @return {?}
     */
    function getLayerTableName(layer, stripLayerTableName) {
        if (stripLayerTableName === void 0) {
            stripLayerTableName = false;
        }
        /** @type {?} */
        var tableName = layer
            ? layer.featureClassName || layer.datasetName
            : null;
        if (stripLayerTableName) {
            tableName = stripTableName(tableName);
        }
        return tableName;
    }
    var LrsLayer = /** @class */ (function (_super) {
        __extends(LrsLayer, _super);
        function LrsLayer() {
            var sources = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spread(sources)) || this;
            _this.capturePositions = _this.capturePositions ? _this.capturePositions : [];
            return _this;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        LrsLayer.prototype.getPositionByValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return this.capturePositions.find(( /**
                 * @param {?} positionDef
                 * @return {?}
                 */function (positionDef) { return positionDef.value === value; }));
            };
        /**
         * @param {?} position
         * @return {?}
         */
        LrsLayer.prototype.getPositions = /**
         * @param {?} position
         * @return {?}
         */
            function (position) {
                return this.capturePositions.filter(( /**
                 * @param {?} positionDef
                 * @return {?}
                 */function (positionDef) { return positionDef.position === position; }));
            };
        /**
         * @param {?} position
         * @return {?}
         */
        LrsLayer.prototype.hasPosition = /**
         * @param {?} position
         * @return {?}
         */
            function (position) {
                /** @type {?} */
                var positions = this.getPositions(position);
                return positions.length > 0;
            };
        Object.defineProperty(LrsLayer.prototype, "hasAnyPositions", {
            get: /**
             * @return {?}
             */ function () {
                return this.capturePositions.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LrsLayer.prototype, "hasLanePosition", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var positions = this.getPositions(CapturePosition.Lane);
                return positions.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LrsLayer.prototype, "hasLeftPosition", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var positions = this.getPositions(CapturePosition.Left);
                return positions.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LrsLayer.prototype, "hasRightPosition", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var positions = this.getPositions(CapturePosition.Right);
                return positions.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LrsLayer.prototype, "hasCenterPosition", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var positions = this.getPositions(CapturePosition.Center);
                return positions.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        return LrsLayer;
    }(FeatureClassLayer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var EventLayer = /** @class */ (function (_super) {
        __extends(EventLayer, _super);
        function EventLayer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return EventLayer;
    }(LrsLayer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} layer
     * @return {?}
     */
    function generateHierarchyFilters(layer) {
        return layer.routeIdFields.map(( /**
         * @param {?} fieldName
         * @param {?} index
         * @return {?}
         */function (fieldName, index) {
            /** @type {?} */
            var isFirst = index === 0;
            /** @type {?} */
            var field = layer.fields.find(( /**
             * @param {?} f
             * @return {?}
             */function (f) { return f.name === fieldName; }));
            if (!field) {
                throw new Error("Invalid network layer 'routeIdFields' configuration. Field '" + fieldName + "' not found on layer.");
            }
            return {
                isRoot: isFirst,
                label: field.alias,
                networkLayerIdFieldName: field.name
            };
        }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var IntersectionLayer = /** @class */ (function (_super) {
        __extends(IntersectionLayer, _super);
        function IntersectionLayer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return IntersectionLayer;
    }(FeatureClassLayer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} layerId
     * @param {...?} layerList
     * @return {?}
     */
    function findLayer(layerId) {
        var layerList = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            layerList[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var layer;
        layerList.forEach(( /**
         * @param {?} layers
         * @return {?}
         */function (layers) {
            layer = layer || (layers || []).find(( /**
             * @param {?} l
             * @return {?}
             */function (l) { return l && l.id === layerId; }));
        }));
        return layer;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NetworkLayer = /** @class */ (function (_super) {
        __extends(NetworkLayer, _super);
        function NetworkLayer() {
            var sources = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spread(sources)) || this;
            _this.routeIdFields = _this.routeIdFields || [];
            _this.eventLayers = _this.eventLayers || [];
            _this.intersectionLayers = _this.intersectionLayers || [];
            _this.hierarchyFilter = _this.hierarchyFilter && _this.hierarchyFilter.length
                ? _this.hierarchyFilter
                : generateHierarchyFilters(_this);
            return _this;
        }
        return NetworkLayer;
    }(LrsLayer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RedlineLayer = /** @class */ (function (_super) {
        __extends(RedlineLayer, _super);
        function RedlineLayer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(RedlineLayer.prototype, "effectiveDateFieldName", {
            get: /**
             * @return {?}
             */ function () {
                return this.fromDateFieldName;
            },
            set: /**
             * @param {?} effectiveDateFieldName
             * @return {?}
             */ function (effectiveDateFieldName) {
                this.fromDateFieldName = effectiveDateFieldName;
            },
            enumerable: true,
            configurable: true
        });
        return RedlineLayer;
    }(LrsLayer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MapServerMetadata = /** @class */ (function () {
        function MapServerMetadata() {
        }
        /**
         * @param {?} source
         * @return {?}
         */
        MapServerMetadata.prototype.assign = /**
         * @param {?} source
         * @return {?}
         */
            function (source) {
                Object.assign(this, source);
                return this;
            };
        /**
         * @return {?}
         */
        MapServerMetadata.prototype.clone = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var copy = clone(this);
                return new MapServerMetadata()
                    .assign(copy);
            };
        return MapServerMetadata;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var LRS_LAYER_VALIDATIONS = new ValidationCheck("Layer '{name}'")
        .add(new ValidationCheck('should have list of fields')
        .pass(( /**
    * @param {?} l
    * @return {?}
    */function (l) { return Boolean(l.fields && l.fields.length); })), new ValidationCheck('should have an ID field in list of fields')
        .pass(( /**
    * @param {?} l
    * @return {?}
    */function (l) { return Boolean(getIdField(l.fields)); })));
    /** @type {?} */
    var LRS_NETWORK_LAYER_VALIDATIONS = new ValidationCheck("Network layer '{name}' (ID: {id})")
        .add(new ValidationCheck("should have a 'Composite Route ID Field Name' value specified")
        .pass(( /**
    * @param {?} l
    * @return {?}
    */function (l) { return Boolean(l.compositeRouteIdFieldName); })));
    /** @type {?} */
    var LRS_EVENT_LAYER_VALIDATIONS = new ValidationCheck("Event layer '{name}' (ID: {id})")
        .add(new ValidationCheck("should have a 'From Measure Field Name' value specified")
        .pass(( /**
    * @param {?} l
    * @return {?}
    */function (l) { return Boolean(l.compositeRouteIdFieldName); })));
    /** @type {?} */
    var LRS_METADATA_VALIDATIONS = new ValidationCheck('LRS Metadata')
        .add(new ValidationCheck('should have network layers')
        .pass(( /**
    * @param {?} x
    * @return {?}
    */function (x) { return Boolean(x.networkLayers && x.networkLayers.length); })), new ValidationCheck('should have event layers')
        .pass(( /**
    * @param {?} x
    * @return {?}
    */function (x) { return Boolean(x.eventLayers && x.eventLayers.length); })));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NonLrsLayer = /** @class */ (function (_super) {
        __extends(NonLrsLayer, _super);
        function NonLrsLayer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return NonLrsLayer;
    }(FeatureClassLayer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} layerId
     * @param {...?} layerList
     * @return {?}
     */
    function find(layerId) {
        var layerList = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            layerList[_i - 1] = arguments[_i];
        }
        return findLayer.apply(void 0, __spread([layerId], layerList));
    }
    var LrsMetadata = /** @class */ (function (_super) {
        __extends(LrsMetadata, _super);
        function LrsMetadata(dataSource) {
            var _this = _super.call(this) || this;
            _this.networkLayers = [];
            _this.eventLayers = [];
            _this.redlineLayers = [];
            _this.centerlineLayers = [];
            _this.calibrationPointLayers = [];
            _this.intersectionLayers = [];
            _this.nonLRSLayers = [];
            _this.lrs = [];
            _this.domains = [];
            if (dataSource) {
                _this.dataSource = dataSource;
                _this.dataSourceId = dataSource.id;
            }
            return _this;
        }
        /**
         * Gets a layer by ID - searching across all types (event layers, network layers, etc).
         */
        /**
         * Gets a layer by ID - searching across all types (event layers, network layers, etc).
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.getLayer = /**
         * Gets a layer by ID - searching across all types (event layers, network layers, etc).
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return find(layerId, this.getAllLayers());
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.getLrsLayer = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return ( /** @type {?} */((find(layerId, this.networkLayers, this.eventLayers, this.redlineLayers))));
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.getLayerDetail = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                // TODO: Come up with a better way to check these layer types.
                // NOTE: We are doing all of these boolean checks instead of just simply calling
                // isEventLayer = this.isEventLayer(layerId) because of performance reasons.
                /** @type {?} */
                var isLrsLayer = this.isLrsLayer(layerId);
                /** @type {?} */
                var isEventLayer = this.isEventLayer(layerId);
                /** @type {?} */
                var isNetworkLayer = !isEventLayer && this.isNetworkLayer(layerId);
                /** @type {?} */
                var isCalibrationPointLayer = !isEventLayer && !isNetworkLayer && this.isCalibrationPointLayer(layerId);
                /** @type {?} */
                var isCenterlineLayer = !isEventLayer && !isNetworkLayer && !isCalibrationPointLayer && this.isCenterlineLayer(layerId);
                /** @type {?} */
                var isIntersectionLayer = !isEventLayer && !isNetworkLayer && !isCalibrationPointLayer && !isCenterlineLayer
                    && this.isIntersectionLayer(layerId);
                /** @type {?} */
                var isRedlineLayer = !isEventLayer && !isNetworkLayer && !isCalibrationPointLayer && !isCenterlineLayer && !isIntersectionLayer
                    && this.isRedlineLayer(layerId);
                /** @type {?} */
                var isTable = !isEventLayer && !isNetworkLayer && !isCalibrationPointLayer && !isCenterlineLayer && !isIntersectionLayer
                    && !isRedlineLayer && this.isTable(layerId);
                /** @type {?} */
                var isNonLRSLayer = !isEventLayer && !isNetworkLayer && !isCalibrationPointLayer && !isCenterlineLayer && !isIntersectionLayer
                    && !isRedlineLayer && !isTable && this.isNonLRSLayer(layerId);
                /** @type {?} */
                var layer = this.getLayer(layerId);
                /** @type {?} */
                var shapeField = layer ? getGeometryField(layer.fields) : null;
                /** @type {?} */
                var idField = layer ? getIdField(layer.fields) : null;
                return {
                    layer: layer,
                    layerId: layerId,
                    isEventLayer: isEventLayer,
                    isNetworkLayer: isNetworkLayer,
                    isCalibrationPointLayer: isCalibrationPointLayer,
                    isCenterlineLayer: isCenterlineLayer,
                    isIntersectionLayer: isIntersectionLayer,
                    isRedlineLayer: isRedlineLayer,
                    isTable: isTable,
                    isNonLRSLayer: isNonLRSLayer,
                    isLrsLayer: isLrsLayer,
                    shapeField: shapeField,
                    idField: idField,
                };
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.isLrsLayer = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return Boolean(this.getLrsLayer(layerId));
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.isNetworkLayer = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return Boolean(find(layerId, this.networkLayers));
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.isEventLayer = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return Boolean(find(layerId, this.eventLayers));
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.isIntersectionLayer = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return Boolean(find(layerId, this.intersectionLayers));
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.isRedlineLayer = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return Boolean(find(layerId, this.redlineLayers));
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.isCenterlineLayer = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return Boolean(find(layerId, this.centerlineLayers));
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.isCalibrationPointLayer = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return Boolean(find(layerId, this.calibrationPointLayers));
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.isNonLRSLayer = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return Boolean(find(layerId, this.nonLRSLayers));
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.isTable = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return Boolean(find(layerId, this.tables));
            };
        /**
         * Merges map server general information into this LRS metadata instance.
         */
        /**
         * Merges map server general information into this LRS metadata instance.
         * @param {?} mapMetadata
         * @return {?}
         */
        LrsMetadata.prototype.mergeMapMetadata = /**
         * Merges map server general information into this LRS metadata instance.
         * @param {?} mapMetadata
         * @return {?}
         */
            function (mapMetadata) {
                mergeMapMetadata(this, mapMetadata);
                return this;
            };
        /**
         * @param {?} mapMetadata
         * @return {?}
         */
        LrsMetadata.prototype.deepMergeMapMetadata = /**
         * @param {?} mapMetadata
         * @return {?}
         */
            function (mapMetadata) {
                deepMergeMapMetadata(this, mapMetadata);
                return this;
            };
        /**
         * Merges other LRS metadata into this LRS metdata instance.
         */
        /**
         * Merges other LRS metadata into this LRS metdata instance.
         * @param {?} lrsMetadata
         * @return {?}
         */
        LrsMetadata.prototype.mergeLrsMetadata = /**
         * Merges other LRS metadata into this LRS metdata instance.
         * @param {?} lrsMetadata
         * @return {?}
         */
            function (lrsMetadata) {
                mergeLrsMetadata(this, lrsMetadata);
                return this;
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.getNetworkLayer = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return ( /** @type {?} */(find(layerId, this.networkLayers)));
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.getEventLayer = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return ( /** @type {?} */(find(layerId, this.eventLayers)));
            };
        /**
         * @param {?} layerId
         * @return {?}
         */
        LrsMetadata.prototype.getIntersectionLayer = /**
         * @param {?} layerId
         * @return {?}
         */
            function (layerId) {
                return ( /** @type {?} */(find(layerId, this.intersectionLayers)));
            };
        /**
         * @return {?}
         */
        LrsMetadata.prototype.getLrsLayers = /**
         * @return {?}
         */
            function () {
                return (( /** @type {?} */(this.eventLayers)))
                    .concat(this.networkLayers)
                    .concat(this.redlineLayers);
            };
        /**
         * @return {?}
         */
        LrsMetadata.prototype.getFeatureClassLayers = /**
         * @return {?}
         */
            function () {
                return (( /** @type {?} */(this.eventLayers)))
                    .concat(this.networkLayers)
                    .concat(this.redlineLayers)
                    .concat(this.calibrationPointLayers)
                    .concat(this.centerlineLayers)
                    .concat(this.nonLRSLayers);
            };
        /**
         * @return {?}
         */
        LrsMetadata.prototype.getAllLayers = /**
         * @return {?}
         */
            function () {
                return (( /** @type {?} */(this.getFeatureClassLayers())))
                    .concat(this.tables)
                    .concat(this.layers);
            };
        /**
         * @param {?} layer
         * @return {?}
         */
        LrsMetadata.prototype.getNetworkIdForLayer = /**
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                /** @type {?} */
                var networkId = null;
                if (this.isEventLayer(layer.id)) {
                    /** @type {?} */
                    var eventLayer = ( /** @type {?} */(layer));
                    networkId = eventLayer.parentNetwork ? eventLayer.parentNetwork.id : null;
                }
                if (isNotValue(networkId)) {
                    this.networkLayers.forEach(( /**
                     * @param {?} network
                     * @return {?}
                     */function (network) {
                        if (network.eventLayers.find(( /**
                         * @param {?} l
                         * @return {?}
                         */function (l) { return l.id === layer.id; }))) {
                            networkId = network.id;
                        }
                    }));
                }
                return networkId;
            };
        /**
         * @param {?} networkLayerId
         * @return {?}
         */
        LrsMetadata.prototype.getEventLayersByNetwork = /**
         * @param {?} networkLayerId
         * @return {?}
         */
            function (networkLayerId) {
                /** @type {?} */
                var networkLayer = this.getNetworkLayer(networkLayerId);
                return this.eventLayers.filter(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) {
                    return layer.parentNetwork
                        && layer.parentNetwork.id === networkLayerId
                        || networkLayer.eventLayers
                            && networkLayer.eventLayers.find(( /**
                             * @param {?} l
                             * @return {?}
                             */function (l) { return l.id === layer.id; }));
                }));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        LrsMetadata.prototype.rebuildLayers = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
            function () {
                var _this = this;
                ( /** @type {?} */(this)).eventLayers = ( /** @type {?} */(this)).eventLayers.map(( /**
                 * @param {?} eventLayer
                 * @return {?}
                 */function (eventLayer) { return new EventLayer(find(eventLayer.id, ( /** @type {?} */(_this)).layers), eventLayer); }));
                ( /** @type {?} */(this)).networkLayers = ( /** @type {?} */(this)).networkLayers.map(( /**
                 * @param {?} networkLayer
                 * @return {?}
                 */function (networkLayer) { return new NetworkLayer(find(networkLayer.id, ( /** @type {?} */(_this)).layers), networkLayer); }));
                ( /** @type {?} */(this)).redlineLayers = ( /** @type {?} */(this)).redlineLayers.map(( /**
                 * @param {?} redlineLayer
                 * @return {?}
                 */function (redlineLayer) { return new RedlineLayer(find(redlineLayer.id, ( /** @type {?} */(_this)).layers), redlineLayer); }));
                ( /** @type {?} */(this)).centerlineLayers = ( /** @type {?} */(this)).centerlineLayers.map(( /**
                 * @param {?} centerlineLayer
                 * @return {?}
                 */function (centerlineLayer) { return new CenterlineLayer(centerlineLayer); }));
                ( /** @type {?} */(this)).calibrationPointLayers = ( /** @type {?} */(this)).calibrationPointLayers.map(( /**
                 * @param {?} calibrationPointLayer
                 * @return {?}
                 */function (calibrationPointLayer) { return new CalibrationPointLayer(calibrationPointLayer); }));
                ( /** @type {?} */(this)).intersectionLayers = ( /** @type {?} */(this)).intersectionLayers.map(( /**
                 * @param {?} intersectionLayer
                 * @return {?}
                 */function (intersectionLayer) { return new IntersectionLayer(intersectionLayer); }));
                ( /** @type {?} */(this)).nonLRSLayers = ( /** @type {?} */(this)).nonLRSLayers.map(( /**
                 * @param {?} nonLrsLayer
                 * @return {?}
                 */function (nonLrsLayer) { return new NonLrsLayer(find(nonLrsLayer.id, ( /** @type {?} */(_this)).layers), nonLrsLayer); }));
                return ( /** @type {?} */(this)).assignCodedValueDomainsToFields();
            };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        LrsMetadata.prototype.assignCodedValueDomainsToFields = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
            function () {
                var _this = this;
                if (( /** @type {?} */(this)).domains.length) {
                    ( /** @type {?} */(this)).getFeatureClassLayers()
                        .forEach(( /**
                 * @param {?} layer
                 * @return {?}
                 */function (layer) { return layer.applyFieldDomains(( /** @type {?} */(_this)).domains); }));
                }
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} source
         * @return {THIS}
         */
        LrsMetadata.prototype.assign = /**
         * @template THIS
         * @this {THIS}
         * @param {?} source
         * @return {THIS}
         */
            function (source) {
                Object.assign(( /** @type {?} */(this)), source);
                return ( /** @type {?} */(this));
            };
        /**
         * @return {?}
         */
        LrsMetadata.prototype.clone = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var copy = clone(this);
                return new LrsMetadata()
                    .assign(copy)
                    .rebuildLayers();
            };
        /**
         * @return {?}
         */
        LrsMetadata.prototype.validate = /**
         * @return {?}
         */
            function () {
                return LRS_METADATA_VALIDATIONS
                    .check(this);
            };
        return LrsMetadata;
    }(MapServerMetadata));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} layerId
     * @param {...?} layerList
     * @return {?}
     */
    function find$1(layerId) {
        var layerList = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            layerList[_i - 1] = arguments[_i];
        }
        return findLayer.apply(void 0, __spread([layerId], layerList));
    }
    /**
     * @param {?} layer
     * @return {?}
     */
    function setLayerDefaults(layer) {
        layer.fields = layer.fields || [];
    }
    /**
     * @param {?} layer
     * @return {?}
     */
    function setNetworkLayerDefaults(layer) {
        if (layer) {
            layer.hierarchyFilter = layer.hierarchyFilter || [];
        }
    }
    /**
     * @param {?} target
     * @param {?} source
     * @return {?}
     */
    function mergeFieldDomains(target, source) {
        mergeDeep(target, source, { ignoreArrays: true });
        if (target && target.codedValues && source && source.codedValues) {
            mergeDeepArray(target.codedValues, source.codedValues, { identifier: 'code' });
        }
    }
    /**
     * @param {?} target
     * @param {?} source
     * @return {?}
     */
    function mergeFields(target, source) {
        target = target || [];
        source = source || [];
        mergeDeepArray(target, source, {
            identifier: 'name',
            beforeMerge: ( /**
             * @param {?} targetField
             * @param {?} sourceField
             * @return {?}
             */function (targetField, sourceField) {
                if (targetField.domain && sourceField.domain && sourceField.domain.codedValues) {
                    /** @type {?} */
                    var doValuesNeedMerged = sourceField.domain.codedValues.filter(( /**
                     * @param {?} c
                     * @return {?}
                     */function (c) { return isNumber(c.order); }));
                    if (doValuesNeedMerged && doValuesNeedMerged.length) {
                        mergeFieldDomains(targetField.domain, sourceField.domain);
                        return false;
                    }
                }
            })
        });
    }
    /**
     * @param {?} target
     * @param {?} source
     * @return {?}
     */
    function mergeLayer(target, source) {
        if (!target || !source) {
            return;
        }
        /** @type {?} */
        var lrsTarget = ( /** @type {?} */(target));
        /** @type {?} */
        var lrsSource = ( /** @type {?} */(source));
        /** @type {?} */
        var targetCapturePositions = lrsTarget.capturePositions || [];
        /** @type {?} */
        var sourceCapturePositions = lrsSource.capturePositions || [];
        /** @type {?} */
        var targetDrawingInfo = ( /** @type {?} */(lrsTarget.drawingInfo));
        /** @type {?} */
        var sourceDrawingInfo = ( /** @type {?} */(lrsSource.drawingInfo));
        /** @type {?} */
        var hasDrawingInfo = Boolean(targetDrawingInfo || sourceDrawingInfo);
        /** @type {?} */
        var drawingInfo = new LayerDrawingInfo(( /** @type {?} */(lrsTarget.drawingInfo)), ( /** @type {?} */(lrsSource.drawingInfo)));
        mergeDeep(target, source, { ignoreArrays: true });
        mergeFields(target.fields, source.fields);
        if (hasDrawingInfo) {
            (( /** @type {?} */(target))).drawingInfo = drawingInfo;
        }
        if (!targetCapturePositions.length && sourceCapturePositions.length) {
            lrsTarget.capturePositions = sourceCapturePositions;
        }
    }
    /**
     * @param {?} target
     * @param {?} source
     * @param {?=} sourceMetadata
     * @param {?=} sort
     * @param {?=} onMergeComplete
     * @return {?}
     */
    function mergeLayers(target, source, sourceMetadata, sort, onMergeComplete) {
        if (sort === void 0) {
            sort = true;
        }
        if (onMergeComplete === void 0) {
            onMergeComplete = null;
        }
        target = target || [];
        source = source || [];
        target.forEach(( /**
         * @param {?} targetLayer
         * @return {?}
         */function (targetLayer) {
            setLayerDefaults(targetLayer);
            mergeLayer(targetLayer, source.find(( /**
             * @param {?} sourceLayer
             * @return {?}
             */function (sourceLayer) { return sourceLayer.id === targetLayer.id; })));
        }));
        // There will be occurences where the source has layers that the target doesn't, which
        // means that the merge will not happen above, because the target is the one being looped.
        source
            .filter(( /**
     * @param {?} src
     * @return {?}
     */function (src) {
            return !target.find(( /**
             * @param {?} x
             * @return {?}
             */function (x) { return src.id === x.id; }));
        }))
            .forEach(( /**
     * @param {?} missing
     * @return {?}
     */function (missing) {
            /** @type {?} */
            var newLayer = missing;
            if (sourceMetadata) {
                /** @type {?} */
                var merger = find$1(missing.id, sourceMetadata.tables, sourceMetadata.layers, sourceMetadata.nonLRSLayers);
                // We want to preseve the original table or layer, so we don't overwrite it here.
                newLayer = Object.assign({}, merger);
                mergeLayer(newLayer, missing);
            }
            setLayerDefaults(newLayer);
            target.push(newLayer);
        }));
        if (sort) {
            target.sort(( /**
             * @param {?} layer1
             * @param {?} layer2
             * @return {?}
             */function (layer1, layer2) { return layer1.order - layer2.order; }));
        }
        if (onMergeComplete) {
            target.forEach(( /**
             * @param {?} targetLayer
             * @return {?}
             */function (targetLayer) {
                onMergeComplete(targetLayer, source.find(( /**
                 * @param {?} sourceLayer
                 * @return {?}
                 */function (sourceLayer) { return sourceLayer.id === targetLayer.id; })));
            }));
        }
    }
    /**
     * @param {?} target
     * @param {?} source
     * @param {?=} sourceMetadata
     * @return {?}
     */
    function mergeNetworkLayers(target, source, sourceMetadata) {
        /** @type {?} */
        var isSorted = true;
        mergeLayers(target, source, sourceMetadata, isSorted, onMergeNetworkLayerComplete);
    }
    /**
     * @param {?} targetLayer
     * @param {?} sourceLayer
     * @return {?}
     */
    function onMergeNetworkLayerComplete(targetLayer, sourceLayer) {
        setNetworkLayerDefaults(targetLayer);
        setNetworkLayerDefaults(sourceLayer);
        if (targetLayer && sourceLayer) {
            mergeDeepArray(targetLayer.hierarchyFilter, sourceLayer.hierarchyFilter, { identifier: 'name' });
        }
    }
    /**
     * @param {?} target
     * @param {...?} source
     * @return {?}
     */
    function mergeLrsMetadata(target) {
        var source = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            source[_i - 1] = arguments[_i];
        }
        source.forEach(( /**
         * @param {?} srcMeta
         * @return {?}
         */function (srcMeta) {
            /** @type {?} */
            var dataSource = srcMeta.dataSource || target.dataSource;
            mergeDeep(target, srcMeta, { ignoreArrays: true });
            if (dataSource) {
                target.dataSource = dataSource;
            }
            mergeNetworkLayers(target.networkLayers, srcMeta.networkLayers, target);
            mergeLayers(target.eventLayers, srcMeta.eventLayers, target);
            mergeLayers(target.calibrationPointLayers, srcMeta.calibrationPointLayers, target);
            mergeLayers(target.intersectionLayers, srcMeta.intersectionLayers, target);
            mergeLayers(target.centerlineLayers, srcMeta.centerlineLayers, target);
            mergeLayers(target.redlineLayers, srcMeta.redlineLayers, target);
            mergeLayers(target.nonLRSLayers, srcMeta.nonLRSLayers, target);
            mergeLayers(target.layers, srcMeta.layers);
            mergeLayers(target.tables, srcMeta.tables);
        }));
    }
    /**
     * @param {?} target
     * @param {...?} source
     * @return {?}
     */
    function mergeMapMetadata(target) {
        var source = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            source[_i - 1] = arguments[_i];
        }
        source.forEach(( /**
         * @param {?} meta
         * @return {?}
         */function (meta) {
            Object.assign(target, meta);
        }));
    }
    /**
     * @param {?} target
     * @param {...?} source
     * @return {?}
     */
    function deepMergeMapMetadata(target) {
        var source = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            source[_i - 1] = arguments[_i];
        }
        source.forEach(( /**
         * @param {?} meta
         * @return {?}
         */function (meta) {
            meta.layers.forEach(( /**
             * @param {?} nonLrsLayerInfo
             * @return {?}
             */function (nonLrsLayerInfo) {
                /** @type {?} */
                var targetLayer = target.getLrsLayer(nonLrsLayerInfo.id);
                if (targetLayer) {
                    /** @type {?} */
                    var baseFields = __spread(nonLrsLayerInfo.fields);
                    mergeFields(baseFields, targetLayer.fields);
                    targetLayer.fields = baseFields;
                    if (nonLrsLayerInfo.geometryType) {
                        targetLayer.geometryType = nonLrsLayerInfo.geometryType;
                    }
                    targetLayer.drawingInfo = new LayerDrawingInfo(nonLrsLayerInfo.drawingInfo, targetLayer.drawingInfo);
                }
            }));
        }));
    }
    /**
     * @param {?} dataSource
     * @param {?} dataSourceLrsMetadata
     * @param {?} mapServerLrsMetadata
     * @param {?} mapServerMetadata
     * @return {?}
     */
    function mergeLrsMetadataSources(dataSource, dataSourceLrsMetadata, mapServerLrsMetadata, mapServerMetadata) {
        /** @type {?} */
        var hasMapServerLrsMetadata = Boolean(mapServerLrsMetadata);
        /** @type {?} */
        var fullLrsMeta = mapServerLrsMetadata
            || dataSourceLrsMetadata
            || new LrsMetadata(dataSource);
        fullLrsMeta.mergeMapMetadata(mapServerMetadata);
        fullLrsMeta.dataSource = fullLrsMeta.dataSource || dataSource;
        fullLrsMeta.dataSourceId = fullLrsMeta.dataSourceId || dataSource.id;
        if (hasMapServerLrsMetadata) {
            // If the map service has LRS metadata then we need to merge the
            // data source LRS metadata into the map service lrs metadata
            // because we want the data source metadata to be priority.
            fullLrsMeta.mergeLrsMetadata(dataSourceLrsMetadata);
        }
        else {
            // We only need to do a dep merge when there is no LRS metadata available in the map service because
            // the map service LRS metadata provides all of the same information as the map server metadata (like fields).
            fullLrsMeta.deepMergeMapMetadata(mapServerMetadata);
        }
        fullLrsMeta.rebuildLayers();
        return fullLrsMeta;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LrsMetadataRetriever = /** @class */ (function () {
        function LrsMetadataRetriever(http, mapServer, dataSourceService, dataSourceLrsMetadataService, notify, log) {
            this.http = http;
            this.mapServer = mapServer;
            this.dataSourceService = dataSourceService;
            this.dataSourceLrsMetadataService = dataSourceLrsMetadataService;
            this.notify = notify;
            this.log = log;
        }
        /**
         * @param {?} dataSource
         * @return {?}
         */
        LrsMetadataRetriever.prototype.withDataSource = /**
         * @param {?} dataSource
         * @return {?}
         */
            function (dataSource) {
                if (isString(dataSource)) {
                    this.dataSourceId = ( /** @type {?} */(dataSource));
                }
                else {
                    this.dataSource = ( /** @type {?} */(dataSource));
                    this.dataSourceId = this.dataSource.id;
                }
                return this;
            };
        /**
         * @param {?} lrsMeta
         * @return {?}
         */
        LrsMetadataRetriever.prototype.withLrsMetadata = /**
         * @param {?} lrsMeta
         * @return {?}
         */
            function (lrsMeta) {
                this.dataSourceLrsMetadata = lrsMeta;
                return this;
            };
        /**
         * @return {?}
         */
        LrsMetadataRetriever.prototype.retrieve = /**
         * @return {?}
         */
            function () {
                if (!this.dataSourceId) {
                    throw new Error('A data source ID must be supplied');
                }
                return rxjs.of(null)
                    .pipe(operators.mergeMap(this.getDataSource.bind(this)), operators.mergeMap(this.getDataSourceLrsMetadata.bind(this)), operators.mergeMap(this.getMapServiceLayers.bind(this)), operators.mergeMap(this.getMapServiceLrsMetadata.bind(this)), operators.mergeMap(this.mergeAll.bind(this)));
            };
        /**
         * @private
         * @return {?}
         */
        LrsMetadataRetriever.prototype.getDataSource = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var observable = this.dataSource
                    ? rxjs.of(this.dataSource)
                    : this.dataSourceService
                        .get(this.dataSourceId)
                        .pipe(operators.tap(( /**
                 * @param {?} dataSource
                 * @return {?}
                 */function (dataSource) { return _this.dataSource = dataSource; })));
                return this.notify
                    .with(observable)
                    .error("Failed to retrieve data source by ID: " + this.dataSourceId + ": {error}")
                    .source;
            };
        /**
         * @private
         * @return {?}
         */
        LrsMetadataRetriever.prototype.getDataSourceLrsMetadata = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var observable = this.dataSourceLrsMetadata
                    ? rxjs.of(this.dataSourceLrsMetadata)
                    : this.dataSourceLrsMetadataService
                        .get(this.dataSourceId)
                        .pipe(operators.tap(( /**
                 * @param {?} meta
                 * @return {?}
                 */function (meta) {
                        _this.dataSourceLrsMetadata = new LrsMetadata(_this.dataSource)
                            .assign(meta);
                        // NOTE: If we don't recieve any data source LRS metadata back then we assume that
                        // the map service has LRS capabiliities - otherwise we have no LRS server data available.
                        if (!meta) {
                            _this.dataSourceLrsMetadata.serviceHasLrsMeta = true;
                        }
                    })));
                return this.notify
                    .with(observable)
                    .error("Failed to retrieve data source LRS metadata by data source ID: " + this.dataSourceId + ": {error}")
                    .source;
            };
        /**
         * @private
         * @return {?}
         */
        LrsMetadataRetriever.prototype.getMapServiceLayers = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var observable = this.mapServerMetadata || !this.dataSource.serviceUrl
                    ? rxjs.of(this.mapServerMetadata)
                    : this.mapServer
                        .getMapLayers(this.dataSource.serviceUrl)
                        .pipe(operators.tap(( /**
                 * @param {?} meta
                 * @return {?}
                 */function (meta) { return _this.mapServerMetadata = new MapServerMetadata().assign(meta); })));
                return this.notify
                    .with(observable)
                    .error("Failed to retrieve map service metadata from URL: " + this.dataSource.serviceUrl + ": {error}")
                    .source;
            };
        /**
         * @private
         * @return {?}
         */
        LrsMetadataRetriever.prototype.getMapServiceLrsMetadata = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var observable = !this.dataSource.serviceUrl || !this.dataSourceLrsMetadata.serviceHasLrsMeta
                    ? rxjs.of(this.mapServerLrsMetadata)
                    : rxjs.forkJoin([
                        this.mapServer.getLrsServer(this.dataSource.serviceUrl),
                        this.mapServer.getLrsLayers(this.dataSource.serviceUrl)
                    ])
                        .pipe(operators.map(( /**
                 * @param {?} meta
                 * @return {?}
                 */function (meta) {
                        var _a = __read(meta, 2), lrsServerMeta = _a[0], lrsLayersMeta = _a[1];
                        /** @type {?} */
                        var lrsMetadata = Object.assign({}, lrsServerMeta, lrsLayersMeta);
                        /** @type {?} */
                        var mapServerLrsMetadata = new LrsMetadata().assign(lrsMetadata);
                        return mapServerLrsMetadata;
                    })), operators.tap(( /**
                     * @param {?} meta
                     * @return {?}
                     */function (meta) { return _this.mapServerLrsMetadata = new LrsMetadata().assign(meta); })));
                return this.notify
                    .with(observable)
                    .error("Failed to retrieve map service LRS metadata from URL: " + this.dataSource.serviceUrl + ": {error}")
                    .source;
            };
        /**
         * @private
         * @return {?}
         */
        LrsMetadataRetriever.prototype.mergeAll = /**
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var fullLrsMeta = mergeLrsMetadataSources(this.dataSource, this.dataSourceLrsMetadata, this.mapServerLrsMetadata, this.mapServerMetadata);
                return rxjs.of(fullLrsMeta);
            };
        return LrsMetadataRetriever;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LrsMetadataService = /** @class */ (function () {
        function LrsMetadataService(http, mapServer, dataSourceService, dataSourceLrsMetadataService, notify, config, log) {
            this.http = http;
            this.mapServer = mapServer;
            this.dataSourceService = dataSourceService;
            this.dataSourceLrsMetadataService = dataSourceLrsMetadataService;
            this.notify = notify;
            this.config = config;
            this.log = log;
            this.lrsCache = [];
        }
        /**
         * @param {?} dataSource
         * @param {?=} lrsMetadata
         * @return {?}
         */
        LrsMetadataService.prototype.get = /**
         * @param {?} dataSource
         * @param {?=} lrsMetadata
         * @return {?}
         */
            function (dataSource, lrsMetadata) {
                var _this = this;
                /** @type {?} */
                var dataSourceId = getDataSourceId(dataSource);
                /** @type {?} */
                var cachedMeta = this.lrsCache.find(( /**
                 * @param {?} cache
                 * @return {?}
                 */function (cache) { return cache.dataSourceId === dataSourceId; }));
                if (cachedMeta) {
                    return rxjs.of(cachedMeta.metaData);
                }
                return new LrsMetadataRetriever(this.http, this.mapServer, this.dataSourceService, this.dataSourceLrsMetadataService, this.notify, this.log)
                    .withDataSource(dataSource)
                    .withLrsMetadata(lrsMetadata)
                    .retrieve()
                    .pipe(operators.tap(( /**
             * @param {?} meta
             * @return {?}
             */function (meta) { return _this.tryCacheLrsMetadata(meta); })));
            };
        /**
         * @private
         * @param {?} meta
         * @return {?}
         */
        LrsMetadataService.prototype.tryCacheLrsMetadata = /**
         * @private
         * @param {?} meta
         * @return {?}
         */
            function (meta) {
                if (this.config.cacheInSessionLrsMetadata) {
                    this.lrsCache.push({
                        dataSourceId: meta.dataSourceId,
                        metaData: meta
                    });
                }
            };
        LrsMetadataService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        LrsMetadataService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: EsriMapServerService },
                { type: DataSourceService },
                { type: DataSourceLrsMetadataService },
                { type: NotifyService },
                { type: LrsConfig },
                { type: Logger }
            ];
        };
        /** @nocollapse */ LrsMetadataService.ngInjectableDef = i0.defineInjectable({ factory: function LrsMetadataService_Factory() { return new LrsMetadataService(i0.inject(i1$1.HttpClient), i0.inject(EsriMapServerService), i0.inject(DataSourceService), i0.inject(DataSourceLrsMetadataService), i0.inject(NotifyService), i0.inject(LrsConfig), i0.inject(Logger)); }, token: LrsMetadataService, providedIn: "root" });
        return LrsMetadataService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RedlineFeature = /** @class */ (function (_super) {
        __extends(RedlineFeature, _super);
        function RedlineFeature(feature, layer) {
            var _this = _super.call(this, feature, layer) || this;
            _this.routeId = _this.getValue(layer.routeIdFieldName);
            _this.fromMeasure = _this.getValue(layer.fromMeasureFieldName);
            _this.toMeasure = _this.getValue(layer.toMeasureFieldName);
            _this.isLinear = Boolean(layer.toMeasureFieldName);
            return _this;
        }
        /**
         * @param {?} layer
         * @param {?=} properties
         * @param {?=} geometry
         * @return {?}
         */
        RedlineFeature.create = /**
         * @param {?} layer
         * @param {?=} properties
         * @param {?=} geometry
         * @return {?}
         */
            function (layer, properties, geometry) {
                if (properties === void 0) {
                    properties = {};
                }
                if (geometry === void 0) {
                    geometry = null;
                }
                /** @type {?} */
                var feature = toFeature(properties, ( /** @type {?} */(geometry)));
                return new RedlineFeature(feature, layer);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
        RedlineFeature.prototype.setFromMeasure = /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
            function (measure) {
                ( /** @type {?} */(this)).fromMeasure = measure;
                return ( /** @type {?} */(this)).setValue(( /** @type {?} */(this)).layer.fromMeasureFieldName, measure);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
        RedlineFeature.prototype.setToMeasure = /**
         * @template THIS
         * @this {THIS}
         * @param {?} measure
         * @return {THIS}
         */
            function (measure) {
                if (!( /** @type {?} */(this)).isLinear) {
                    throw new Error('Cannot set to measure for a point-based feature');
                }
                ( /** @type {?} */(this)).toMeasure = measure;
                return ( /** @type {?} */(this)).setValue(( /** @type {?} */(this)).layer.toMeasureFieldName, measure);
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} fromMeasure
         * @param {?} toMeasure
         * @return {THIS}
         */
        RedlineFeature.prototype.setMeasureExtent = /**
         * @template THIS
         * @this {THIS}
         * @param {?} fromMeasure
         * @param {?} toMeasure
         * @return {THIS}
         */
            function (fromMeasure, toMeasure) {
                return ( /** @type {?} */(this)).setFromMeasure(fromMeasure)
                    .setToMeasure(toMeasure);
            };
        /**
         * @return {?}
         */
        RedlineFeature.prototype.clone = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var copyFeature = clone(this.toFeature());
                return new RedlineFeature(copyFeature, this.layer);
            };
        /**
         * @protected
         * @return {?}
         */
        RedlineFeature.prototype.isGeometryTypeValid = /**
         * @protected
         * @return {?}
         */
            function () {
                return isPolygon(this.geometry) || _super.prototype.isGeometryTypeValid.call(this);
            };
        return RedlineFeature;
    }(LrsFeature));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SYMBOL_LOCATION_TYPES = [
        { alias: 'Left', locationType: 'left' },
        { alias: 'Right', locationType: 'right' },
        { alias: 'Top', locationType: 'top' },
        { alias: 'Bottom', locationType: 'bottom' },
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MapTable = /** @class */ (function () {
        function MapTable() {
            this.fields = [];
            this.indexes = [];
            this.relationships = [];
        }
        return MapTable;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing mapping-related settings.
     */
    var MapsConfig = /** @class */ (function () {
        function MapsConfig() {
        }
        MapsConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ MapsConfig.ngInjectableDef = i0.defineInjectable({ factory: function MapsConfig_Factory() { return new MapsConfig(); }, token: MapsConfig, providedIn: "root" });
        /**
         * Configuration class for storing mapping-related settings.
         */
        MapsConfig = __decorate([
            AutoConfig('MapsConfig')
        ], MapsConfig);
        return MapsConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing motion-related settings.
     */
    var MotionConfig = /** @class */ (function () {
        function MotionConfig() {
            this.allowMotionMocking = true;
        }
        MotionConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ MotionConfig.ngInjectableDef = i0.defineInjectable({ factory: function MotionConfig_Factory() { return new MotionConfig(); }, token: MotionConfig, providedIn: "root" });
        /**
         * Configuration class for storing motion-related settings.
         */
        MotionConfig = __decorate([
            AutoConfig('MotionConfig')
        ], MotionConfig);
        return MotionConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Geolocator service. Provides a single point of motion API.
     */
    var DeviceMotionService = /** @class */ (function () {
        function DeviceMotionService(config) {
            var _this = this;
            this.config = config;
            this.motionChangeSource = new rxjs.Subject();
            this.motionChange = this.motionChangeSource.asObservable();
            rxjs.fromEvent(window, 'ondevicemotion').subscribe(( /**
             * @param {?} event
             * @return {?}
             */function (event) { return _this.emitMotionChange(event); }));
        }
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} motion
         * @return {THIS}
         */
        DeviceMotionService.prototype.mockMotion = /**
         * @template THIS
         * @this {THIS}
         * @param {?} motion
         * @return {THIS}
         */
            function (motion) {
                if (!( /** @type {?} */(this)).config.allowMotionMocking) {
                    throw new Error('Permission denied to mock device motion');
                }
                ( /** @type {?} */(this)).motionChangeSource.next(motion);
                return ( /** @type {?} */(this));
            };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        DeviceMotionService.prototype.emitMotionChange = /**
         * @private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.motionChangeSource.next({
                    x: event.acceleration.x,
                    y: event.acceleration.y,
                    z: event.acceleration.z,
                    withGravityX: event.accelerationIncludingGravity.x,
                    withGravityY: event.accelerationIncludingGravity.y,
                    withGravityZ: event.accelerationIncludingGravity.z,
                    rotationRateAlpha: event.rotationRate.alpha,
                    rotationRateBeta: event.rotationRate.beta,
                    rotationRateGamma: event.rotationRate.gamma,
                });
            };
        DeviceMotionService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        DeviceMotionService.ctorParameters = function () {
            return [
                { type: MotionConfig }
            ];
        };
        /** @nocollapse */ DeviceMotionService.ngInjectableDef = i0.defineInjectable({ factory: function DeviceMotionService_Factory() { return new DeviceMotionService(i0.inject(MotionConfig)); }, token: DeviceMotionService, providedIn: "root" });
        return DeviceMotionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssMotionModule = /** @class */ (function () {
        function TssMotionModule() {
        }
        TssMotionModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssMotionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns the heading based on an orientation (alpha, beta, and gamma).
     * Note: this code was sourced from: https://stackoverflow.com/questions/18112729/calculate-compass-heading-from-deviceorientation-event-api
     * @param {?} orientation
     * @return {?}
     */
    function getHeadingFromOrientation(orientation) {
        // Convert degrees to radians
        /** @type {?} */
        var alphaRad = degreesToRadians(orientation.alpha);
        /** @type {?} */
        var betaRad = degreesToRadians(orientation.beta);
        /** @type {?} */
        var gammaRad = degreesToRadians(orientation.gamma);
        // Calculate equation components
        /** @type {?} */
        var cA = Math.cos(alphaRad);
        /** @type {?} */
        var sA = Math.sin(alphaRad);
        /** @type {?} */
        var sB = Math.sin(betaRad);
        /** @type {?} */
        var cG = Math.cos(gammaRad);
        /** @type {?} */
        var sG = Math.sin(gammaRad);
        // Calculate A, B, C rotation components
        /** @type {?} */
        var rA = -cA * sG - sA * sB * cG;
        /** @type {?} */
        var rB = -sA * sG + cA * sB * cG;
        // Calculate compass heading
        /** @type {?} */
        var compassHeading = Math.atan(rA / rB);
        // Convert from half unit circle to whole unit circle
        compassHeading = rB < 0
            ? compassHeading += Math.PI
            : compassHeading += 2 * Math.PI;
        // Convert radians to degrees
        compassHeading = radiansToDegrees(compassHeading);
        return compassHeading;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing orientation-related settings.
     */
    var OrientationConfig = /** @class */ (function () {
        function OrientationConfig() {
            this.allowOrientationMocking = true;
            this.allowHeadingMocking = true;
        }
        OrientationConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ OrientationConfig.ngInjectableDef = i0.defineInjectable({ factory: function OrientationConfig_Factory() { return new OrientationConfig(); }, token: OrientationConfig, providedIn: "root" });
        /**
         * Configuration class for storing orientation-related settings.
         */
        OrientationConfig = __decorate([
            AutoConfig('OrientationConfig')
        ], OrientationConfig);
        return OrientationConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Geolocator service. Provides a single point of GPS interaction.
     */
    var DeviceOrientationService = /** @class */ (function () {
        function DeviceOrientationService(config) {
            var _this = this;
            this.config = config;
            this.internalDeviceNeedsCalibrated = false;
            this.headingChangeSource = new rxjs.Subject();
            this.orientationChangeSource = new rxjs.Subject();
            this.orientationChange = this.orientationChangeSource.asObservable();
            this.headingChange = rxjs.merge(this.headingChangeSource, this.orientationChange.pipe(operators.map(( /**
             * @param {?} orientation
             * @return {?}
             */function (orientation) { return orientation.heading; }))));
            rxjs.fromEvent(window, 'deviceorientation').subscribe(( /**
             * @param {?} event
             * @return {?}
             */function (event) { return _this.emitOrientationChange(event); }));
            rxjs.fromEvent(window, 'oncompassneedscalibration').subscribe(( /**
             * @return {?}
             */function () { return _this.internalDeviceNeedsCalibrated = true; }));
            rxjs.fromEvent(window, 'compassneedscalibration').subscribe(( /**
             * @return {?}
             */function () { return _this.internalDeviceNeedsCalibrated = true; }));
        }
        Object.defineProperty(DeviceOrientationService.prototype, "deviceNeedsCalibrated", {
            get: /**
             * @return {?}
             */ function () {
                return this.internalDeviceNeedsCalibrated;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} orientation
         * @return {THIS}
         */
        DeviceOrientationService.prototype.mockOrientation = /**
         * @template THIS
         * @this {THIS}
         * @param {?} orientation
         * @return {THIS}
         */
            function (orientation) {
                if (!( /** @type {?} */(this)).config.allowOrientationMocking) {
                    throw new Error('Permission denied to mock device orientation');
                }
                ( /** @type {?} */(this)).orientationChangeSource.next(orientation);
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} heading
         * @return {THIS}
         */
        DeviceOrientationService.prototype.mockHeading = /**
         * @template THIS
         * @this {THIS}
         * @param {?} heading
         * @return {THIS}
         */
            function (heading) {
                if (!( /** @type {?} */(this)).config.allowHeadingMocking) {
                    throw new Error('Permission denied to mock heading');
                }
                ( /** @type {?} */(this)).headingChangeSource.next(heading);
                return ( /** @type {?} */(this));
            };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        DeviceOrientationService.prototype.emitOrientationChange = /**
         * @private
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.orientationChangeSource.next({
                    alpha: event.alpha,
                    beta: event.beta,
                    gamma: event.gamma,
                    heading: getHeadingFromOrientation(event)
                });
            };
        DeviceOrientationService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        DeviceOrientationService.ctorParameters = function () {
            return [
                { type: OrientationConfig }
            ];
        };
        /** @nocollapse */ DeviceOrientationService.ngInjectableDef = i0.defineInjectable({ factory: function DeviceOrientationService_Factory() { return new DeviceOrientationService(i0.inject(OrientationConfig)); }, token: DeviceOrientationService, providedIn: "root" });
        return DeviceOrientationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TssOrientationModule = /** @class */ (function () {
        function TssOrientationModule() {
        }
        TssOrientationModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                        ],
                        declarations: [],
                        exports: [],
                        providers: [],
                        schemas: [i0.CUSTOM_ELEMENTS_SCHEMA]
                    },] }
        ];
        return TssOrientationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Unique token created for each queue worker
     */
    var /**
     * Unique token created for each queue worker
     */ QueueWorkerToken = /** @class */ (function () {
        function QueueWorkerToken() {
            this.isWorking = false;
            this.isCanceled = false;
            this.id = Guid.newGuid().value;
        }
        Object.defineProperty(QueueWorkerToken.prototype, "isComplete", {
            get: /**
             * @return {?}
             */ function () {
                return !this.isWorking;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueueWorkerToken.prototype, "ellapsedSeconds", {
            get: /**
             * @return {?}
             */ function () {
                return getElapsedSeconds(new Date(), this.startTime);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueueWorkerToken.prototype, "totalProcessed", {
            get: /**
             * @return {?}
             */ function () {
                return this.totalComplete + this.totalFailed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueueWorkerToken.prototype, "recordsProcessedPerSecond", {
            get: /**
             * @return {?}
             */ function () {
                return this.totalComplete / this.ellapsedSeconds;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueueWorkerToken.prototype, "recordsProcessedPerMinute", {
            get: /**
             * @return {?}
             */ function () {
                return this.recordsProcessedPerSecond * 60;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        QueueWorkerToken.prototype.start = /**
         * @return {?}
         */
            function () {
                this.reset();
                this.startTime = new Date();
                this.isWorking = true;
                return this;
            };
        /**
         * @return {?}
         */
        QueueWorkerToken.prototype.reset = /**
         * @return {?}
         */
            function () {
                this.isWorking = false;
                this.isCanceled = false;
                this.totalComplete = 0;
                this.totalFailed = 0;
                this.startTime = null;
                this.endTime = null;
                return this;
            };
        /**
         * @param {?} remainingCount
         * @return {?}
         */
        QueueWorkerToken.prototype.calculateRemainingSeconds = /**
         * @param {?} remainingCount
         * @return {?}
         */
            function (remainingCount) {
                return this.isComplete
                    ? 0
                    : calculateRemainingSeconds(this.totalProcessed, this.ellapsedSeconds, remainingCount);
            };
        /**
         * @return {?}
         */
        QueueWorkerToken.prototype.complete = /**
         * @return {?}
         */
            function () {
                this.endTime = new Date();
                this.isWorking = false;
                return this;
            };
        /**
         * @return {?}
         */
        QueueWorkerToken.prototype.cancel = /**
         * @return {?}
         */
            function () {
                this.isCanceled = true;
                this.isWorking = false;
                return this;
            };
        return QueueWorkerToken;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var WorkQueueStatusEventType = {
        UnitOfWorkStarted: 0,
        UnitOfWorkComplete: 1,
        UnitOfWorkStatusUpdate: 2,
        QueueWorkerStarted: 3,
        QueueWorkerComplete: 4,
        QueueStarted: 5,
        QueueComplete: 6,
    };
    WorkQueueStatusEventType[WorkQueueStatusEventType.UnitOfWorkStarted] = 'UnitOfWorkStarted';
    WorkQueueStatusEventType[WorkQueueStatusEventType.UnitOfWorkComplete] = 'UnitOfWorkComplete';
    WorkQueueStatusEventType[WorkQueueStatusEventType.UnitOfWorkStatusUpdate] = 'UnitOfWorkStatusUpdate';
    WorkQueueStatusEventType[WorkQueueStatusEventType.QueueWorkerStarted] = 'QueueWorkerStarted';
    WorkQueueStatusEventType[WorkQueueStatusEventType.QueueWorkerComplete] = 'QueueWorkerComplete';
    WorkQueueStatusEventType[WorkQueueStatusEventType.QueueStarted] = 'QueueStarted';
    WorkQueueStatusEventType[WorkQueueStatusEventType.QueueComplete] = 'QueueComplete';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var WorkQueueStatusTracker = /** @class */ (function () {
        function WorkQueueStatusTracker() {
            this.totalQueueSize = 0;
            this.workers = [];
        }
        Object.defineProperty(WorkQueueStatusTracker.prototype, "workerCount", {
            get: /**
             * @return {?}
             */ function () {
                return this.workers.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "percentComplete", {
            get: /**
             * @return {?}
             */ function () {
                return this.totalQueueSize >= 0
                    ? Math.round(this.totalProcessed / this.totalQueueSize * 100) || 0
                    : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "totalComplete", {
            get: /**
             * @return {?}
             */ function () {
                return this.workers.reduce(( /**
                 * @param {?} accumulator
                 * @param {?} current
                 * @return {?}
                 */function (accumulator, current) { return accumulator + current.totalComplete; }), 0) || 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "totalFailed", {
            get: /**
             * @return {?}
             */ function () {
                return this.workers.reduce(( /**
                 * @param {?} accumulator
                 * @param {?} current
                 * @return {?}
                 */function (accumulator, current) { return accumulator + current.totalFailed; }), 0) || 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "totalProcessed", {
            get: /**
             * @return {?}
             */ function () {
                return this.totalComplete + this.totalFailed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "isWorking", {
            get: /**
             * @return {?}
             */ function () {
                return Boolean(this.runningWorkerCount);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "isComplete", {
            get: /**
             * @return {?}
             */ function () {
                return this.startTime && !this.isWorking;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "isCanceled", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var canceledWorkersCount = this.workers.filter(( /**
                 * @param {?} worker
                 * @return {?}
                 */function (worker) { return worker.isCanceled; })).length;
                return Boolean(canceledWorkersCount && canceledWorkersCount === this.workers.length);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "runningWorkerCount", {
            get: /**
             * @return {?}
             */ function () {
                return this.workers.filter(( /**
                 * @param {?} worker
                 * @return {?}
                 */function (worker) { return worker.isWorking; })).length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "startTime", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var startTimes = this.workers
                    .filter(( /**
             * @param {?} worker
             * @return {?}
             */function (worker) { return worker.startTime; }))
                    .map(( /**
             * @param {?} worker
             * @return {?}
             */function (worker) {
                    return worker.startTime
                        ? worker.startTime.getTime()
                        : null;
                }));
                return new Date(Math.min.apply(Math, __spread(startTimes)));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "endTime", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var startTimes = this.workers
                    .filter(( /**
             * @param {?} worker
             * @return {?}
             */function (worker) { return worker.startTime; }))
                    .map(( /**
             * @param {?} worker
             * @return {?}
             */function (worker) {
                    return worker.startTime
                        ? worker.startTime.getTime()
                        : null;
                }));
                return new Date(Math.max.apply(Math, __spread(startTimes)));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "remainingQueueSize", {
            get: /**
             * @return {?}
             */ function () {
                return this.totalQueueSize - this.totalProcessed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "estimatedSecondsLeft", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var remainingCount = this.remainingQueueSize;
                return remainingCount
                    ? average(this.workers
                        .map(( /**
                 * @param {?} worker
                 * @return {?}
                 */function (worker) { return worker.calculateRemainingSeconds(remainingCount); })))
                    : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueStatusTracker.prototype, "averageRecordsProcessedPerMinute", {
            get: /**
             * @return {?}
             */ function () {
                return average(this.workers
                    .map(( /**
             * @param {?} worker
             * @return {?}
             */function (worker) { return worker.recordsProcessedPerMinute; })));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} totalQueueSize
         * @return {?}
         */
        WorkQueueStatusTracker.prototype.setQueueSize = /**
         * @param {?} totalQueueSize
         * @return {?}
         */
            function (totalQueueSize) {
                this.totalQueueSize = totalQueueSize;
                return this;
            };
        /**
         * @return {?}
         */
        WorkQueueStatusTracker.prototype.complete = /**
         * @return {?}
         */
            function () {
                this.workers.splice(0, this.workers.length);
                this.totalQueueSize = 0;
                return this;
            };
        /**
         * @param {...?} workers
         * @return {?}
         */
        WorkQueueStatusTracker.prototype.addWorker = /**
         * @param {...?} workers
         * @return {?}
         */
            function () {
                var _this = this;
                var workers = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    workers[_i] = arguments[_i];
                }
                workers.forEach(( /**
                 * @param {?} worker
                 * @return {?}
                 */function (worker) {
                    _this.workers.push(worker);
                }));
                return this;
            };
        /**
         * @return {?}
         */
        WorkQueueStatusTracker.prototype.getStatus = /**
         * @return {?}
         */
            function () {
                return {
                    isWorking: this.isWorking,
                    isCanceled: this.isCanceled,
                    isComplete: this.isComplete,
                    totalProcessed: this.totalProcessed,
                    startTime: this.startTime,
                    endTime: this.endTime,
                    percentComplete: this.percentComplete,
                    totalQueueSize: this.totalQueueSize,
                    remainingQueueSize: this.remainingQueueSize,
                    totalComplete: this.totalComplete,
                    totalFailed: this.totalFailed,
                    estimatedSecondsLeft: this.estimatedSecondsLeft,
                    workerCount: this.workers.length,
                };
            };
        return WorkQueueStatusTracker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_WORK_QUEUE_OPTIONS = {
        autoStartWorkers: true,
        workerCount: 1,
    };
    /**
     * Provides the core queueing workflow for basic unit of work queues.
     * High Priority Todos:
     * * Implement worker cancelation into the worker token - RG.
     *
     * Low Priority Todos:
     * * Add queue prioritization - a queue priority flag to pull those items first from the queue - RG.
     * * Change overriding of methods to use metho attributes instead. Example: \@OnWorkComplete.
     * @abstract
     * @template TInput, TOutput
     */
    var /**
     * Provides the core queueing workflow for basic unit of work queues.
     * High Priority Todos:
     * * Implement worker cancelation into the worker token - RG.
     *
     * Low Priority Todos:
     * * Add queue prioritization - a queue priority flag to pull those items first from the queue - RG.
     * * Change overriding of methods to use metho attributes instead. Example: \@OnWorkComplete.
     * @abstract
     * @template TInput, TOutput
     */ WorkQueueManager = /** @class */ (function () {
        function WorkQueueManager(log, options) {
            var _this = this;
            this.log = log;
            this.workerTokens = [];
            this.tracker = new WorkQueueStatusTracker();
            this.options = Object.assign({}, DEFAULT_WORK_QUEUE_OPTIONS);
            this.setOptions(options);
            this.queueChangeObserver = new rxjs.Subject();
            this.queueChange = this.queueChangeObserver.pipe();
            this.queueStarted = this.queueChangeObserver.pipe(operators.filter(( /**
             * @param {?} change
             * @return {?}
             */function (change) { return change.event === WorkQueueStatusEventType.QueueStarted; })));
            this.queueComplete = this.queueChangeObserver.pipe(operators.filter(( /**
             * @param {?} change
             * @return {?}
             */function (change) { return change.event === WorkQueueStatusEventType.QueueComplete; })));
            if (this.options.autoStartWorkers) {
                setTimeout(( /**
                 * @return {?}
                 */function () { return _this.startWork(); }));
            }
        }
        Object.defineProperty(WorkQueueManager.prototype, "isWorking", {
            get: /**
             * @return {?}
             */ function () {
                return this.tracker.isWorking;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkQueueManager.prototype, "status", {
            get: /**
             * @return {?}
             */ function () {
                return this.tracker.getStatus();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Overrides default options.
         * @param options Options to override the defaults.
         */
        /**
         * Overrides default options.
         * @param {?} options Options to override the defaults.
         * @return {?}
         */
        WorkQueueManager.prototype.setOptions = /**
         * Overrides default options.
         * @param {?} options Options to override the defaults.
         * @return {?}
         */
            function (options) {
                Object.assign(this.options, options);
                return this;
            };
        /**
         * Kicks off the queue workflow with the specified number of workers. If
         * the maximum number of workers are currently running, no additional workers
         * will be created (only the delta of allowed and running will be started).
         */
        /**
         * Kicks off the queue workflow with the specified number of workers. If
         * the maximum number of workers are currently running, no additional workers
         * will be created (only the delta of allowed and running will be started).
         * @return {?}
         */
        WorkQueueManager.prototype.startWork = /**
         * Kicks off the queue workflow with the specified number of workers. If
         * the maximum number of workers are currently running, no additional workers
         * will be created (only the delta of allowed and running will be started).
         * @return {?}
         */
            function () {
                var _this = this;
                // We dont' want to change the queue size if the queue is already working
                // because it will mess up the statistics (percent copmlete, etc).
                /** @type {?} */
                var starterSource = rxjs.iif(( /**
                 * @return {?}
                 */function () { return !_this.isWorking; }), this.getRemainingQueueCount()
                    .pipe(operators.tap(( /**
             * @param {?} queueCount
             * @return {?}
             */function (queueCount) { return _this.tracker.setQueueSize(queueCount); }))));
                this.onReady()
                    .pipe(operators.mergeMap(( /**
             * @return {?}
             */function () { return starterSource; })))
                    .subscribe(( /**
             * @return {?}
             */function () {
                    /** @type {?} */
                    var workersToStart = _this.options.workerCount - _this.workerTokens.length;
                    if (workersToStart > 0) {
                        _this.emitQueueChange(null, WorkQueueStatusEventType.QueueStarted);
                    }
                    for (var i = 0; i < workersToStart; i++) {
                        /** @type {?} */
                        var token = new QueueWorkerToken().start();
                        _this.tracker.addWorker(token);
                        _this.workerTokens.push(token);
                        _this.emitQueueChange(token, WorkQueueStatusEventType.QueueWorkerStarted);
                        _this.getNextAndDoWork(token);
                    }
                }));
            };
        /**
         * Stops all workers from processing the queue.
         */
        /**
         * Stops all workers from processing the queue.
         * @return {?}
         */
        WorkQueueManager.prototype.stopWork = /**
         * Stops all workers from processing the queue.
         * @return {?}
         */
            function () {
                this.workerTokens.forEach(( /**
                 * @param {?} token
                 * @return {?}
                 */function (token) { return token.cancel(); }));
            };
        /**
         * Method that determines that the workers are ready to be started. Note, in this implementation it
         * makes use of an empty promise. The main reason for this is to provide a hook for other implementers
         * to setup/initialize the queue before starting the workers. Additionaly, this practices provides a
         * way to run the workers asynchronously.
         */
        /**
         * Method that determines that the workers are ready to be started. Note, in this implementation it
         * makes use of an empty promise. The main reason for this is to provide a hook for other implementers
         * to setup/initialize the queue before starting the workers. Additionaly, this practices provides a
         * way to run the workers asynchronously.
         * @protected
         * @return {?}
         */
        WorkQueueManager.prototype.onReady = /**
         * Method that determines that the workers are ready to be started. Note, in this implementation it
         * makes use of an empty promise. The main reason for this is to provide a hook for other implementers
         * to setup/initialize the queue before starting the workers. Additionaly, this practices provides a
         * way to run the workers asynchronously.
         * @protected
         * @return {?}
         */
            function () {
                return rxjs.of(null);
            };
        /**
         * @protected
         * @param {?} input
         * @return {?}
         */
        WorkQueueManager.prototype.onBeforeWorkStarted = /**
         * @protected
         * @param {?} input
         * @return {?}
         */
            function (input) {
                return rxjs.of(input);
            };
        /**
         * @protected
         * @param {?} data
         * @return {?}
         */
        WorkQueueManager.prototype.onWorkComplete = /**
         * @protected
         * @param {?} data
         * @return {?}
         */
            function (data) {
                return rxjs.of(data);
            };
        /**
         * @protected
         * @param {?} data
         * @param {?} error
         * @return {?}
         */
        WorkQueueManager.prototype.onWorkFailed = /**
         * @protected
         * @param {?} data
         * @param {?} error
         * @return {?}
         */
            function (data, error) {
                return rxjs.of(data, error);
            };
        /**
         * @protected
         * @return {?}
         */
        WorkQueueManager.prototype.getRemainingQueueCount = /**
         * @protected
         * @return {?}
         */
            function () {
                return rxjs.of(-1);
            };
        /**
         * @protected
         * @param {?} token
         * @param {?} event
         * @param {?=} input
         * @param {?=} output
         * @return {?}
         */
        WorkQueueManager.prototype.emitQueueChange = /**
         * @protected
         * @param {?} token
         * @param {?} event
         * @param {?=} input
         * @param {?=} output
         * @return {?}
         */
            function (token, event, input, output) {
                this.queueChangeObserver.next({
                    event: event,
                    input: input,
                    output: output,
                    status: this.tracker.getStatus(),
                    tokenId: token ? token.id : null,
                });
            };
        /**
         * @private
         * @param {?} token
         * @param {?=} input
         * @param {?=} output
         * @return {?}
         */
        WorkQueueManager.prototype.emitWorkStarted = /**
         * @private
         * @param {?} token
         * @param {?=} input
         * @param {?=} output
         * @return {?}
         */
            function (token, input, output) {
                this.emitQueueChange(token, WorkQueueStatusEventType.UnitOfWorkStarted, input, output);
            };
        /**
         * @private
         * @param {?} token
         * @param {?=} input
         * @param {?=} output
         * @return {?}
         */
        WorkQueueManager.prototype.emitWorkComplete = /**
         * @private
         * @param {?} token
         * @param {?=} input
         * @param {?=} output
         * @return {?}
         */
            function (token, input, output) {
                this.emitQueueChange(token, WorkQueueStatusEventType.UnitOfWorkComplete, input, output);
            };
        /**
         * @private
         * @param {?} token
         * @return {?}
         */
        WorkQueueManager.prototype.onWorkerCompleted = /**
         * @private
         * @param {?} token
         * @return {?}
         */
            function (token) {
                if (token.isComplete) {
                    return;
                }
                /** @type {?} */
                var index = this.workerTokens.indexOf(token);
                token.complete();
                if (index !== -1) {
                    this.workerTokens.splice(index, 1);
                }
                this.emitQueueChange(token, WorkQueueStatusEventType.QueueWorkerComplete);
                if (this.workerTokens.length === 0) {
                    this.emitQueueChange(token, WorkQueueStatusEventType.QueueComplete);
                    this.tracker.complete();
                }
            };
        /**
         * @private
         * @param {?} token
         * @param {?} next
         * @return {?}
         */
        WorkQueueManager.prototype.checkIfWorkerComplete = /**
         * @private
         * @param {?} token
         * @param {?} next
         * @return {?}
         */
            function (token, next) {
                if (isNotValue(next)) {
                    this.onWorkerCompleted(token);
                }
            };
        /**
         * @private
         * @param {?} token
         * @return {?}
         */
        WorkQueueManager.prototype.getNextAndDoWork = /**
         * @private
         * @param {?} token
         * @return {?}
         */
            function (token) {
                var _this = this;
                if (token.isCanceled) {
                    this.log.debug("Canceling worker due to canceled toke: " + token.id);
                    this.onWorkerCompleted(token);
                }
                this.log.trace('Retrieving next queue item to start processing');
                /** @type {?} */
                var processingData = { input: null, output: null };
                this.getNext()
                    .pipe(operators.tap(( /**
             * @param {?} input
             * @return {?}
             */function (input) { return processingData.input = input; })), operators.tap(( /**
                 * @param {?} input
                 * @return {?}
                 */function (input) { return _this.checkIfWorkerComplete(token, input); })), operators.takeWhile(( /**
                 * @param {?} input
                 * @return {?}
                 */function (input) { return isValue(input) && !token.isCanceled; })), operators.tap(( /**
                 * @param {?} input
                 * @return {?}
                 */function (input) { return _this.emitWorkStarted(token, input); })), operators.mergeMap(( /**
                 * @param {?} input
                 * @return {?}
                 */function (input) { return _this.onBeforeWorkStarted(input); })), operators.mergeMap(( /**
                 * @param {?} input
                 * @return {?}
                 */function (input) { return _this.doWork(input); })), operators.tap(( /**
                 * @param {?} output
                 * @return {?}
                 */function (output) { return processingData.output = output; })), operators.map(( /**
                 * @return {?}
                 */function () { return processingData; })), operators.mergeMap(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) { return _this.onWorkComplete(data); })))
                    .subscribe(( /**
             * @param {?} data
             * @return {?}
             */function (data) {
                    _this.log.trace('Completed work for item');
                    token.totalComplete++;
                    _this.emitWorkComplete(token, data.input, data.output);
                    _this.getNextAndDoWork(token);
                }), ( /**
                 * @param {?} error
                 * @return {?}
                 */function (error) {
                    _this.log.error("Failed to process item. {error}", error);
                    token.totalFailed++;
                    _this.onWorkFailed(processingData, error)
                        .toPromise()
                        .then(( /**
                 * @return {?}
                 */function () { return _this.getNextAndDoWork(token); }));
                }));
            };
        return WorkQueueManager;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @abstract
     * @template TInput, TOutput
     */
    var /**
     * @abstract
     * @template TInput, TOutput
     */ QueuableWorkQueueManager = /** @class */ (function (_super) {
        __extends(QueuableWorkQueueManager, _super);
        function QueuableWorkQueueManager() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.options = Object.assign({
                autoDequeu: true
            }, DEFAULT_WORK_QUEUE_OPTIONS);
            return _this;
        }
        /**
         * Enqueues multiple items into an array.
         * @param items Items to enqueue.
         *
         * TODO: We want to change this to use "mergeAll" once we
         *  upgrade to rxjs 6, as that is the desired behavior here.
         *
         * // The following works in rxjs 6, but not in 5:
         * of(...sources)
         * .pipe(
         *   mergeAll(),
         *   // NOTE: in rxjs 5
         *   tap((x: TInput) => x)
         * )
         */
        /**
         * Enqueues multiple items into an array.
         * @param {...?} items Items to enqueue.
         *
         * TODO: We want to change this to use "mergeAll" once we
         *  upgrade to rxjs 6, as that is the desired behavior here.
         *
         * // The following works in rxjs 6, but not in 5:
         * of(...sources)
         * .pipe(
         *   mergeAll(),
         *   // NOTE: in rxjs 5
         *   tap((x: TInput) => x)
         * )
         * @return {?}
         */
        QueuableWorkQueueManager.prototype.enqueuMany = /**
         * Enqueues multiple items into an array.
         * @param {...?} items Items to enqueue.
         *
         * TODO: We want to change this to use "mergeAll" once we
         *  upgrade to rxjs 6, as that is the desired behavior here.
         *
         * // The following works in rxjs 6, but not in 5:
         * of(...sources)
         * .pipe(
         *   mergeAll(),
         *   // NOTE: in rxjs 5
         *   tap((x: TInput) => x)
         * )
         * @return {?}
         */
            function () {
                var _this = this;
                var items = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    items[_i] = arguments[_i];
                }
                /** @type {?} */
                var sources = items
                    .map(( /**
             * @param {?} i
             * @return {?}
             */function (i) { return _this.enqueue(i); }));
                return rxjs.forkJoin(sources)
                    .pipe(operators.map(( /**
             * @param {?} results
             * @return {?}
             */function (results) { return results.pop(); })));
            };
        /**
         * Deque many items from the queue.
         * @param items Items do deque.
         */
        /**
         * Deque many items from the queue.
         * @param {...?} items Items do deque.
         * @return {?}
         */
        QueuableWorkQueueManager.prototype.dequeuMany = /**
         * Deque many items from the queue.
         * @param {...?} items Items do deque.
         * @return {?}
         */
            function () {
                var _this = this;
                var items = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    items[_i] = arguments[_i];
                }
                /** @type {?} */
                var sources = items
                    .map(( /**
             * @param {?} i
             * @return {?}
             */function (i) { return _this.dequeue(i); }));
                return rxjs.forkJoin(sources)
                    .pipe(operators.map(( /**
             * @param {?} results
             * @return {?}
             */function (results) { return results.pop(); })));
            };
        /**
         * @protected
         * @param {?} payload
         * @return {?}
         */
        QueuableWorkQueueManager.prototype.onWorkComplete = /**
         * @protected
         * @param {?} payload
         * @return {?}
         */
            function (payload) {
                return rxjs.forkJoin(_super.prototype.onWorkComplete.call(this, payload), this.dequeue(payload.input))
                    .pipe(operators.map(( /**
             * @param {?} result
             * @return {?}
             */function (result) { return result[0]; })));
            };
        return QueuableWorkQueueManager;
    }(WorkQueueManager));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var QueueItemStatus = {
        Queued: 0,
        InProgress: 1,
        Complete: 2,
        Canceled: 3,
        Failed: 4,
    };
    QueueItemStatus[QueueItemStatus.Queued] = 'Queued';
    QueueItemStatus[QueueItemStatus.InProgress] = 'InProgress';
    QueueItemStatus[QueueItemStatus.Complete] = 'Complete';
    QueueItemStatus[QueueItemStatus.Canceled] = 'Canceled';
    QueueItemStatus[QueueItemStatus.Failed] = 'Failed';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration class for storing global queue-related settings.
     */
    var QueueConfig = /** @class */ (function () {
        function QueueConfig() {
        }
        QueueConfig.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */ QueueConfig.ngInjectableDef = i0.defineInjectable({ factory: function QueueConfig_Factory() { return new QueueConfig(); }, token: QueueConfig, providedIn: "root" });
        /**
         * Configuration class for storing global queue-related settings.
         */
        QueueConfig = __decorate([
            AutoConfig('QueueConfig')
        ], QueueConfig);
        return QueueConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PrivilegeService = /** @class */ (function (_super) {
        __extends(PrivilegeService, _super);
        function PrivilegeService(http, config) {
            var _this = _super.call(this, http, {
                url: join(config.serviceUrl, config.privilegesEndpoint)
            }) || this;
            _this.http = http;
            return _this;
        }
        PrivilegeService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        PrivilegeService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: SecurityConfig }
            ];
        };
        /** @nocollapse */ PrivilegeService.ngInjectableDef = i0.defineInjectable({ factory: function PrivilegeService_Factory() { return new PrivilegeService(i0.inject(i1$1.HttpClient), i0.inject(SecurityConfig)); }, token: PrivilegeService, providedIn: "root" });
        return PrivilegeService;
    }(BaseResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MISSING_ROLE_PARAM_EXCEPTION_MSG = 'Missing role ID parameter';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MISSING_PRIVILEGE_PARAM_EXCEPTION_MSG = 'Missing privilege identifier parameter';
    /**
     * Service to provide all CRUD operations for privilege/role assignment.
     *
     * \@example
     * ## Gets privileges for a given role:
     * service.privilegesByRole('879e27e1-b139-4348-86ca-ec4d5651475f')
     *
     * // Which is just a shortcut for:
     * service.query({ roleId: 'admin' });
     *
     */
    var RolePrivilegeService = /** @class */ (function (_super) {
        __extends(RolePrivilegeService, _super);
        function RolePrivilegeService(http, config) {
            var _this = _super.call(this, http, {
                url: join(config.serviceUrl, config.rolesPrivilegesEndpoint),
                idFieldName: 'roleId'
            }) || this;
            _this.http = http;
            return _this;
        }
        /**
         * Retrieves a list of privileges for a given role ID.
         */
        /**
         * Retrieves a list of privileges for a given role ID.
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        RolePrivilegeService.prototype.query = /**
         * Retrieves a list of privileges for a given role ID.
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (routeTokens, params) {
                if (!routeTokens || !routeTokens.roleId) {
                    throw new Error(MISSING_ROLE_PARAM_EXCEPTION_MSG);
                }
                return _super.prototype.query.call(this, routeTokens, params);
            };
        /**
         * This method is not supported for this resource. Please use "privilegesByRole".
         */
        /**
         * This method is not supported for this resource. Please use "privilegesByRole".
         * @param {?} id
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        RolePrivilegeService.prototype.get = /**
         * This method is not supported for this resource. Please use "privilegesByRole".
         * @param {?} id
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (id, routeTokens, params) {
                throw new Error(UNSUPPORTED_GET_EXCEPTION_MSG);
            };
        /**
         * This method is not supported for this resource. Please use "addPrivilegeToRole".
         */
        /**
         * This method is not supported for this resource. Please use "addPrivilegeToRole".
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        RolePrivilegeService.prototype.create = /**
         * This method is not supported for this resource. Please use "addPrivilegeToRole".
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (entity, routeTokens, params) {
                throw new Error(UNSUPPORTED_CREATE_EXCEPTION_MSG);
            };
        /**
         * Updates a privilege assignment (adds a privilege to a role).
         */
        /**
         * Updates a privilege assignment (adds a privilege to a role).
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        RolePrivilegeService.prototype.update = /**
         * Updates a privilege assignment (adds a privilege to a role).
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (entity, routeTokens, params) {
                if (!routeTokens || !routeTokens.roleId) {
                    throw new Error(MISSING_ROLE_PARAM_EXCEPTION_MSG);
                }
                else if (!routeTokens.privilegeId) {
                    throw new Error(MISSING_PRIVILEGE_PARAM_EXCEPTION_MSG);
                }
                return _super.prototype.update.call(this, null, routeTokens, params);
            };
        /**
         * Removes a privilege from a role assignment.
         */
        /**
         * Removes a privilege from a role assignment.
         * @param {?} id
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        RolePrivilegeService.prototype.delete = /**
         * Removes a privilege from a role assignment.
         * @param {?} id
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (id, routeTokens, params) {
                if (!routeTokens || !routeTokens.roleId) {
                    throw new Error(MISSING_ROLE_PARAM_EXCEPTION_MSG);
                }
                else if (!routeTokens.privilegeId) {
                    throw new Error(MISSING_PRIVILEGE_PARAM_EXCEPTION_MSG);
                }
                return _super.prototype.delete.call(this, id, routeTokens, params);
            };
        /**
         * Retrieves all privileges assigned to the given role ID.
         */
        /**
         * Retrieves all privileges assigned to the given role ID.
         * @param {?} roleId
         * @param {?=} params
         * @return {?}
         */
        RolePrivilegeService.prototype.privilegesByRole = /**
         * Retrieves all privileges assigned to the given role ID.
         * @param {?} roleId
         * @param {?=} params
         * @return {?}
         */
            function (roleId, params) {
                return this.query({ roleId: roleId }, params);
            };
        /**
         * Adds a privilege to role.
         */
        /**
         * Adds a privilege to role.
         * @param {?} roleId
         * @param {?} privilegeId
         * @return {?}
         */
        RolePrivilegeService.prototype.addPrivilegeToRole = /**
         * Adds a privilege to role.
         * @param {?} roleId
         * @param {?} privilegeId
         * @return {?}
         */
            function (roleId, privilegeId) {
                return this.update(null, { roleId: roleId, privilegeId: privilegeId });
            };
        /**
         * Removes a privilege from the given role.
         */
        /**
         * Removes a privilege from the given role.
         * @param {?} roleId
         * @param {?} privilegeId
         * @return {?}
         */
        RolePrivilegeService.prototype.removePrivilegeFromRole = /**
         * Removes a privilege from the given role.
         * @param {?} roleId
         * @param {?} privilegeId
         * @return {?}
         */
            function (roleId, privilegeId) {
                return this.delete(roleId, { roleId: roleId, privilegeId: privilegeId });
            };
        RolePrivilegeService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        RolePrivilegeService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: SecurityConfig }
            ];
        };
        /** @nocollapse */ RolePrivilegeService.ngInjectableDef = i0.defineInjectable({ factory: function RolePrivilegeService_Factory() { return new RolePrivilegeService(i0.inject(i1$1.HttpClient), i0.inject(SecurityConfig)); }, token: RolePrivilegeService, providedIn: "root" });
        return RolePrivilegeService;
    }(BaseResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RoleService = /** @class */ (function (_super) {
        __extends(RoleService, _super);
        function RoleService(http, config) {
            var _this = _super.call(this, http, {
                url: join(config.serviceUrl, config.rolesEndpoint)
            }) || this;
            _this.http = http;
            return _this;
        }
        RoleService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        RoleService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: SecurityConfig }
            ];
        };
        /** @nocollapse */ RoleService.ngInjectableDef = i0.defineInjectable({ factory: function RoleService_Factory() { return new RoleService(i0.inject(i1$1.HttpClient), i0.inject(SecurityConfig)); }, token: RoleService, providedIn: "root" });
        return RoleService;
    }(BaseResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MISSING_USER_PARAM_EXCEPTION_MSG = 'Missing user ID parameter';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Service to provide all CRUD operations for user/role assignment.
     *
     * \@example
     * ## Gets roles for a given user:
     * service.rolesByUser('879e27e1-b139-4348-86ca-ec4d5651475f')
     *
     * // Which is just a shortcut for:
     * service.query({ userId: '879e27e1-b139-4348-86ca-ec4d5651475f' });
     *
     */
    var UserRoleService = /** @class */ (function (_super) {
        __extends(UserRoleService, _super);
        function UserRoleService(http, config) {
            var _this = _super.call(this, http, {
                url: join(config.serviceUrl, config.userRolesEndpoint),
                idFieldName: 'userId'
            }) || this;
            _this.http = http;
            return _this;
        }
        /**
         * Retrieves a list of roles for a given user ID.
         */
        /**
         * Retrieves a list of roles for a given user ID.
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        UserRoleService.prototype.query = /**
         * Retrieves a list of roles for a given user ID.
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (routeTokens, params) {
                if (!routeTokens || !routeTokens.userId) {
                    throw new Error(MISSING_USER_PARAM_EXCEPTION_MSG);
                }
                return _super.prototype.query.call(this, routeTokens, params);
            };
        /**
         * This method is not supported for this resource. Please use "rolesByUser".
         */
        /**
         * This method is not supported for this resource. Please use "rolesByUser".
         * @param {?} id
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        UserRoleService.prototype.get = /**
         * This method is not supported for this resource. Please use "rolesByUser".
         * @param {?} id
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (id, routeTokens, params) {
                throw new Error(UNSUPPORTED_GET_EXCEPTION_MSG);
            };
        /**
         * This method is not supported for this resource. Please use "addUserToRole".
         */
        /**
         * This method is not supported for this resource. Please use "addUserToRole".
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        UserRoleService.prototype.create = /**
         * This method is not supported for this resource. Please use "addUserToRole".
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (entity, routeTokens, params) {
                throw new Error(UNSUPPORTED_CREATE_EXCEPTION_MSG);
            };
        /**
         * Updates a users role assignment (adds a role to a user).
         */
        /**
         * Updates a users role assignment (adds a role to a user).
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        UserRoleService.prototype.update = /**
         * Updates a users role assignment (adds a role to a user).
         * @param {?} entity
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (entity, routeTokens, params) {
                if (!routeTokens || !routeTokens.userId) {
                    throw new Error(MISSING_USER_PARAM_EXCEPTION_MSG);
                }
                else if (!routeTokens.roleName) {
                    throw new Error(MISSING_ROLE_PARAM_EXCEPTION_MSG);
                }
                return _super.prototype.update.call(this, null, routeTokens, params);
            };
        /**
         * Removes a user from a role assignment.
         */
        /**
         * Removes a user from a role assignment.
         * @param {?} id
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
        UserRoleService.prototype.delete = /**
         * Removes a user from a role assignment.
         * @param {?} id
         * @param {?=} routeTokens
         * @param {?=} params
         * @return {?}
         */
            function (id, routeTokens, params) {
                if (!routeTokens || !routeTokens.userId) {
                    throw new Error(MISSING_USER_PARAM_EXCEPTION_MSG);
                }
                else if (!routeTokens.roleName) {
                    throw new Error(MISSING_ROLE_PARAM_EXCEPTION_MSG);
                }
                return _super.prototype.delete.call(this, id, routeTokens, params);
            };
        /**
         * Retrieves all roles assigned to the given user ID.
         */
        /**
         * Retrieves all roles assigned to the given user ID.
         * @param {?} userId
         * @param {?=} params
         * @return {?}
         */
        UserRoleService.prototype.rolesByUser = /**
         * Retrieves all roles assigned to the given user ID.
         * @param {?} userId
         * @param {?=} params
         * @return {?}
         */
            function (userId, params) {
                return this.query({ userId: userId }, params);
            };
        /**
         * Adds a user to role.
         */
        /**
         * Adds a user to role.
         * @param {?} userId
         * @param {?} role
         * @param {?=} params
         * @return {?}
         */
        UserRoleService.prototype.addUserToRole = /**
         * Adds a user to role.
         * @param {?} userId
         * @param {?} role
         * @param {?=} params
         * @return {?}
         */
            function (userId, role, params) {
                // NOTE: We pass an arbitrary "_" role name because the route requires a role name,
                // however the role's name is going to be pulled from the role entity on the server.
                // The reason we don't pass "role.name" here is because of issues with IIS not
                // handling decoded backslashes (ex: TSS\TSS Users).
                return _super.prototype.update.call(this, role, { userId: userId, roleName: '_' }, params);
            };
        /**
         * Adds a user to role.
         */
        /**
         * Adds a user to role.
         * @param {?} userId
         * @param {?} roleName
         * @param {?=} params
         * @return {?}
         */
        UserRoleService.prototype.addUserToRoleByName = /**
         * Adds a user to role.
         * @param {?} userId
         * @param {?} roleName
         * @param {?=} params
         * @return {?}
         */
            function (userId, roleName, params) {
                roleName = decodeURIComponent(roleName);
                return this.update(null, { userId: userId, roleName: roleName }, params);
            };
        /**
         * Removes a user from the given role.
         */
        /**
         * Removes a user from the given role.
         * @param {?} userId
         * @param {?} role
         * @param {?=} params
         * @return {?}
         */
        UserRoleService.prototype.removeUserFromRole = /**
         * Removes a user from the given role.
         * @param {?} userId
         * @param {?} role
         * @param {?=} params
         * @return {?}
         */
            function (userId, role, params) {
                return this.removeUserFromRoleByName(userId, role.name, params);
            };
        /**
         * Removes a user from the given role.
         */
        /**
         * Removes a user from the given role.
         * @param {?} userId
         * @param {?} roleName
         * @param {?=} params
         * @return {?}
         */
        UserRoleService.prototype.removeUserFromRoleByName = /**
         * Removes a user from the given role.
         * @param {?} userId
         * @param {?} roleName
         * @param {?=} params
         * @return {?}
         */
            function (userId, roleName, params) {
                roleName = decodeURIComponent(roleName);
                return this.delete(userId, { userId: userId, roleName: roleName }, params);
            };
        UserRoleService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        UserRoleService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: SecurityConfig }
            ];
        };
        /** @nocollapse */ UserRoleService.ngInjectableDef = i0.defineInjectable({ factory: function UserRoleService_Factory() { return new UserRoleService(i0.inject(i1$1.HttpClient), i0.inject(SecurityConfig)); }, token: UserRoleService, providedIn: "root" });
        return UserRoleService;
    }(BaseResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@example
     * ## Get Users that belong to a given role (by ID).
     * service.usersByRoleId('1428a342-8a95-4b6c-b3e9-da135e3ced04')
     *
     * // ...which is just a shortcut for:
     * service.query({}, new HttpParams().set('filterByRoleId', roleName));
     *
     * ## Get Users that belong to a given role (by name).
     * service.usersByRoleName('Admin')
     *
     * // ...which is just a shortcut for:
     * service.query({}, new HttpParams().set('filterByRoleName', roleName));
     */
    var UserService = /** @class */ (function (_super) {
        __extends(UserService, _super);
        function UserService(http, config) {
            var _this = _super.call(this, http, {
                url: join(config.serviceUrl, config.usersEndpoint)
            }) || this;
            _this.http = http;
            return _this;
        }
        /**
         * @param {?} roleId
         * @param {?=} params
         * @return {?}
         */
        UserService.prototype.usersByRoleId = /**
         * @param {?} roleId
         * @param {?=} params
         * @return {?}
         */
            function (roleId, params) {
                params = (params || new i1$1.HttpParams()).set('filterByRoleId', roleId);
                return this.query({}, params);
            };
        /**
         * @param {?} roleName
         * @param {?=} params
         * @return {?}
         */
        UserService.prototype.usersByRoleName = /**
         * @param {?} roleName
         * @param {?=} params
         * @return {?}
         */
            function (roleName, params) {
                params = (params || new i1$1.HttpParams()).set('filterByRoleName', roleName);
                return this.query({}, params);
            };
        /**
         * @param {?} searchText
         * @param {?=} params
         * @return {?}
         */
        UserService.prototype.search = /**
         * @param {?} searchText
         * @param {?=} params
         * @return {?}
         */
            function (searchText, params) {
                params = (params || new i1$1.HttpParams()).set('search', searchText);
                return this.query({}, params);
            };
        UserService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        UserService.ctorParameters = function () {
            return [
                { type: i1$1.HttpClient },
                { type: SecurityConfig }
            ];
        };
        /** @nocollapse */ UserService.ngInjectableDef = i0.defineInjectable({ factory: function UserService_Factory() { return new UserService(i0.inject(i1$1.HttpClient), i0.inject(SecurityConfig)); }, token: UserService, providedIn: "root" });
        return UserService;
    }(BaseResourceService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.ApiService = ApiService;
    exports.AppInitializerFactory = AppInitializerFactory;
    exports.AppInitializerService = AppInitializerService;
    exports.AppProfileService = AppProfileService;
    exports.ALL_APPS_QUERY_ID = ALL_APPS_QUERY_ID;
    exports.TssAppSpatialModule = TssAppSpatialModule;
    exports.DEFAULT_APP_ID = DEFAULT_APP_ID;
    exports.DEFAULT_PROFILE_ID = DEFAULT_PROFILE_ID;
    exports.AppConfig = AppConfig;
    exports.TssAppModule = TssAppModule;
    exports.AppSettingService = AppSettingService;
    exports.ALL_APP_SETTINGS_QUERY_ID = ALL_APP_SETTINGS_QUERY_ID;
    exports.CachePersistence = CachePersistence;
    exports.CacheStrategy = CacheStrategy;
    exports.CacheConfig = CacheConfig;
    exports.CACHE_ONLY_NO_DATA_EXC_MSG = CACHE_ONLY_NO_DATA_EXC_MSG;
    exports.CacheInterceptor = CacheInterceptor;
    exports.TssCacheModule = TssCacheModule;
    exports.CacheService = CacheService;
    exports.CACHE_STORAGE_KEY_PREFIX = CACHE_STORAGE_KEY_PREFIX;
    exports.PersistentCacheStorage = PersistentCacheStorage;
    exports.addIfNotExist = addIfNotExist;
    exports.addRangeToBeginning = addRangeToBeginning;
    exports.addRange = addRange;
    exports.getLastItem = getLastItem;
    exports.removeDuplicates = removeDuplicates;
    exports.removeItem = removeItem;
    exports.removeWhere = removeWhere;
    exports.AutoConfig = AutoConfig;
    exports.clone = clone;
    exports.hexToRgb = hexToRgb;
    exports.isHexColor = isHexColor;
    exports.rgbToHex = rgbToHex;
    exports.transparencyToOpacity = transparencyToOpacity;
    exports.getCookie = getCookie;
    exports.CoreConfig = CoreConfig;
    exports.TssCoreModule = TssCoreModule;
    exports.addDays = addDays;
    exports.addHours = addHours;
    exports.addMilliseconds = addMilliseconds;
    exports.addMinutes = addMinutes;
    exports.addSeconds = addSeconds;
    exports.millisecondsToDays = millisecondsToDays;
    exports.millisecondsToHours = millisecondsToHours;
    exports.millisecondsToMinutes = millisecondsToMinutes;
    exports.millisecondsToSeconds = millisecondsToSeconds;
    exports.toMilliseconds = toMilliseconds;
    exports.toStandardizedQueryDateFormat = toStandardizedQueryDateFormat;
    exports.toUtcDate = toUtcDate;
    exports.toUtcEpochDate = toUtcEpochDate;
    exports.STANDARDIZED_QUERY_DATE_FORMAT = STANDARDIZED_QUERY_DATE_FORMAT;
    exports.ORACLE_DATE_FORMAT = ORACLE_DATE_FORMAT;
    exports.DEFAULT_DATE_FORMAT = DEFAULT_DATE_FORMAT;
    exports.HOURS_PER_DAY = HOURS_PER_DAY;
    exports.MINUTES_PER_HOUR = MINUTES_PER_HOUR;
    exports.SECONDS_PER_MINUTE = SECONDS_PER_MINUTE;
    exports.MILLISECONDS_PER_SECOND = MILLISECONDS_PER_SECOND;
    exports.MILLISECONDS_PER_MINUTE = MILLISECONDS_PER_MINUTE;
    exports.MILLISECONDS_PER_HOUR = MILLISECONDS_PER_HOUR;
    exports.MILLISECONDS_PER_DAY = MILLISECONDS_PER_DAY;
    exports.READABLE_TIME_SUFFIX_MAP = READABLE_TIME_SUFFIX_MAP;
    exports.formatDateForQuery = formatDateForQuery;
    exports.formatDate = formatDate;
    exports.SqlDateFormat = SqlDateFormat;
    exports.getCurrentDateAsUtc = getCurrentDateAsUtc;
    exports.getCurrentDateEpochAsUtc = getCurrentDateEpochAsUtc;
    exports.getElapsedMilliseconds = getElapsedMilliseconds;
    exports.getElapsedSeconds = getElapsedSeconds;
    exports.ReadableTimePipe = ReadableTimePipe;
    exports.secondsToReadableTime = secondsToReadableTime;
    exports.toReadableTime = toReadableTime;
    exports.setDateToBeginningOfDay = setDateToBeginningOfDay;
    exports.setDateToEndOfDay = setDateToEndOfDay;
    exports.subtractDays = subtractDays;
    exports.subtractMinutes = subtractMinutes;
    exports.subtractSeconds = subtractSeconds;
    exports.subtractHours = subtractHours;
    exports.subtractMilliseconds = subtractMilliseconds;
    exports.hasLocalStorage = hasLocalStorage;
    exports.hasWindow = hasWindow;
    exports.OnlineOfflineService = OnlineOfflineService;
    exports.almostEqual = almostEqual;
    exports.DEFAULT_POINT_EQUALITY_PRECISION = DEFAULT_POINT_EQUALITY_PRECISION;
    exports.pointsAlmostEqual = pointsAlmostEqual;
    exports.errorMsg = errorMsg;
    exports.DEFAULT_ERROR_MSG = DEFAULT_ERROR_MSG;
    exports.formatNumber = formatNumber;
    exports.format = format;
    exports.FIRST_LETTER_SEPERATED_BY_SPACE_MATCH_REGEX = FIRST_LETTER_SEPERATED_BY_SPACE_MATCH_REGEX;
    exports.PASCAL_CASE_FIRST_LETTER_MATCH_REGEX = PASCAL_CASE_FIRST_LETTER_MATCH_REGEX;
    exports.LEADING_AND_TRAILING_UNDERSCORE_MATCH_REGEX = LEADING_AND_TRAILING_UNDERSCORE_MATCH_REGEX;
    exports.LEADING_AND_TRAILING_HYPHEN_MATCH_REGEX = LEADING_AND_TRAILING_HYPHEN_MATCH_REGEX;
    exports.UNDERSCORE_MATCH_REGEX = UNDERSCORE_MATCH_REGEX;
    exports.HYPHEN_MATCH_REGEX = HYPHEN_MATCH_REGEX;
    exports.humanize = humanize;
    exports.lowerCaseFirst = lowerCaseFirst;
    exports.trimEnd = trimEnd;
    exports.trim = trim;
    exports.trimStart = trimStart;
    exports.upperCaseEachWord = upperCaseEachWord;
    exports.upperCaseFirstLetter = upperCaseFirstLetter;
    exports.groupBy = groupBy;
    exports.KeysPipe = KeysPipe;
    exports.typeToLevel = typeToLevel;
    exports.levelToType = levelToType;
    exports.LogLevel = LogLevel;
    exports.Logger = Logger;
    exports.base64MimeType = base64MimeType;
    exports.base64toBlob = base64toBlob;
    exports.base64toByteArray = base64toByteArray;
    exports.BASE_64_METADATA_REGEX = BASE_64_METADATA_REGEX;
    exports.JSON_MIME_TYPE = JSON_MIME_TYPE;
    exports.TEXT_MIME_TYPE = TEXT_MIME_TYPE;
    exports.TEXT_FILE_EXTENSION = TEXT_FILE_EXTENSION;
    exports.AUDIO_WEBM_MIME_TYPE = AUDIO_WEBM_MIME_TYPE;
    exports.AUDIO_MP3_MIME_TYPE = AUDIO_MP3_MIME_TYPE;
    exports.AUDIO_MP3_FILE_EXTENSION = AUDIO_MP3_FILE_EXTENSION;
    exports.VIDEO_WEBM_MIME_TYPE = VIDEO_WEBM_MIME_TYPE;
    exports.VIDEO_MP4_MIME_TYPE = VIDEO_MP4_MIME_TYPE;
    exports.VIDEO_MP4_FILE_EXTENSION = VIDEO_MP4_FILE_EXTENSION;
    exports.IMAGE_PNG_FILE_EXTENSION = IMAGE_PNG_FILE_EXTENSION;
    exports.IMAGE_PNG_MIME_TYPE = IMAGE_PNG_MIME_TYPE;
    exports.IMAGE_JPEG_FILE_EXTENSION = IMAGE_JPEG_FILE_EXTENSION;
    exports.IMAGE_JPEG_MIME_TYPE = IMAGE_JPEG_MIME_TYPE;
    exports.stripBase64Metadata = stripBase64Metadata;
    exports.mergeDeepArray = mergeDeepArray;
    exports.mergeDeep = mergeDeep;
    exports.BaseNotificationTracker = BaseNotificationTracker;
    exports.NotificationPromiseTracker = NotificationPromiseTracker;
    exports.NotificationSubscriptionTracker = NotificationSubscriptionTracker;
    exports.NotifyType = NotifyType;
    exports.NotifyService = NotifyService;
    exports.assignValidValues = assignValidValues;
    exports.getValue = getValue;
    exports.setValue = setValue;
    exports.getRandomInteger = getRandomInteger;
    exports.getRandomNumber = getRandomNumber;
    exports.BaseEmptyResourceService = BaseEmptyResourceService;
    exports.BaseResourceService = BaseResourceService;
    exports.NO_URL_ERROR_MSG = NO_URL_ERROR_MSG;
    exports.UNSUPPORTED_GET_EXCEPTION_MSG = UNSUPPORTED_GET_EXCEPTION_MSG;
    exports.UNSUPPORTED_CREATE_EXCEPTION_MSG = UNSUPPORTED_CREATE_EXCEPTION_MSG;
    exports.EMPTY_PARAM_VALUE = EMPTY_PARAM_VALUE;
    exports.ResourceConfig = ResourceConfig;
    exports.round = round;
    exports.SafeUrlPipe = SafeUrlPipe;
    exports.sortAndReorder = sortAndReorder;
    exports.sortByOrder = sortByOrder;
    exports.SortDirection = SortDirection;
    exports.sortAscending = sortAscending;
    exports.sortDescending = sortDescending;
    exports.sort = sort;
    exports.average = average;
    exports.calculateCrossProduct = calculateCrossProduct;
    exports.calculatePercentComplete = calculatePercentComplete;
    exports.calculateRemainingSeconds = calculateRemainingSeconds;
    exports.isNumberBetweenOrEqual = isNumberBetweenOrEqual;
    exports.isNumberBetween = isNumberBetween;
    exports.StatsTracker = StatsTracker;
    exports.sumProperty = sumProperty;
    exports.sumValues = sumValues;
    exports.sum = sum;
    exports.BaseStorage = BaseStorage;
    exports.FileSizePipe = FileSizePipe;
    exports.formatByteSize = formatByteSize;
    exports.getByteSize = getByteSize;
    exports.InMemoryStorage = InMemoryStorage;
    exports.PersistentStorage = PersistentStorage;
    exports.STORAGE_FORMAT_UNITS = STORAGE_FORMAT_UNITS;
    exports.NO_BYTES_FORMATTED = NO_BYTES_FORMATTED;
    exports.extractTokenExpressions = extractTokenExpressions;
    exports.extractTokenValuesFromTemplate = extractTokenValuesFromTemplate;
    exports.extractTokens = extractTokens;
    exports.hasTokens = hasTokens;
    exports.replaceToken = replaceToken;
    exports.replaceTokens = replaceTokens;
    exports.standardizeTokens = standardizeTokens;
    exports.stripTokenBraces = stripTokenBraces;
    exports.TOKEN_EXPRESSION = TOKEN_EXPRESSION;
    exports.FULL_TOKEN_EXPRESSION = FULL_TOKEN_EXPRESSION;
    exports.WILDCARD_EXPRESSION_VALUE = WILDCARD_EXPRESSION_VALUE;
    exports.canBeNumber = canBeNumber;
    exports.canNotBeNumber = canNotBeNumber;
    exports.isArray = isArray;
    exports.isBoolean = isBoolean;
    exports.isDate = isDate;
    exports.isDefined = isDefined;
    exports.isFunction = isFunction;
    exports.isNotArray = isNotArray;
    exports.isNotBoolean = isNotBoolean;
    exports.isNotDate = isNotDate;
    exports.isNotDefined = isNotDefined;
    exports.isNotFunction = isNotFunction;
    exports.isNotNumber = isNotNumber;
    exports.isNotObject = isNotObject;
    exports.isNotPrimitive = isNotPrimitive;
    exports.isNotString = isNotString;
    exports.isNotType = isNotType;
    exports.isNotValue = isNotValue;
    exports.isNumber = isNumber;
    exports.isObject = isObject;
    exports.isPrimitive = isPrimitive;
    exports.isString = isString;
    exports.isType = isType;
    exports.isValue = isValue;
    exports.toPrimitiveType = toPrimitiveType;
    exports.AreaUnit = AreaUnit;
    exports.convertAreaUnits = convertAreaUnits;
    exports.convertLengthUnits = convertLengthUnits;
    exports.fromMeters = fromMeters;
    exports.LengthUnit = LengthUnit;
    exports.MeasurementUnit = MeasurementUnit;
    exports.metersPerSecondToKilometersPerHour = metersPerSecondToKilometersPerHour;
    exports.metersPerSecondToMilesPerHour = metersPerSecondToMilesPerHour;
    exports.toMeters = toMeters;
    exports.LENGTH_UNIT_METER_CONVERSION_FACTOR = LENGTH_UNIT_METER_CONVERSION_FACTOR;
    exports.clean = clean;
    exports.ensureProtocol = ensureProtocol;
    exports.getBaseUrl = getBaseUrl;
    exports.getFirstHashRoutePath = getFirstHashRoutePath;
    exports.getFullUrl = getFullUrl;
    exports.getPostHashRoutePaths = getPostHashRoutePaths;
    exports.getQueryParams = getQueryParams;
    exports.joinAndFomat = joinAndFomat;
    exports.join = join;
    exports.parametersToString = parametersToString;
    exports.removeEmptyParams = removeEmptyParams;
    exports.stripTrailingSlash = stripTrailingSlash;
    exports.EMPTY_PARAMS_REGEX = EMPTY_PARAMS_REGEX;
    exports.using = using;
    exports.INVALID_GUID_ERROR_MSG = INVALID_GUID_ERROR_MSG;
    exports.Guid = Guid;
    exports.uuidValueReplacer = uuidValueReplacer;
    exports.uuid = uuid;
    exports.ValidationCheck = ValidationCheck;
    exports.ValidationResult = ValidationResult;
    exports.CsvConfig = CsvConfig;
    exports.CSV_NEW_LINE = CSV_NEW_LINE;
    exports.CSV_SEPARATOR = CSV_SEPARATOR;
    exports.TssCsvModule = TssCsvModule;
    exports.geometryToCsv = geometryToCsv;
    exports.toCsv = toCsv;
    exports.APPLY_EDITS_SEED_POD_FILE_EXTENSION = APPLY_EDITS_SEED_POD_FILE_EXTENSION;
    exports.DataSourceEditService = DataSourceEditService;
    exports.AttachmentType = AttachmentType;
    exports.AttachmentService = AttachmentService;
    exports.ATTACHMENT_FILE_FORM_KEY = ATTACHMENT_FILE_FORM_KEY;
    exports.ATTACHMENT_DATA_FORM_KEY = ATTACHMENT_DATA_FORM_KEY;
    exports.DataSourceConfig = DataSourceConfig;
    exports.DataSourceProviderType = DataSourceProviderType;
    exports.SELECT_ALL_WHERE_CLAUSE = SELECT_ALL_WHERE_CLAUSE;
    exports.DATA_SOURCE_PROVIDERS = DATA_SOURCE_PROVIDERS;
    exports.DATA_SOURCE_EXAMPLES = DATA_SOURCE_EXAMPLES;
    exports.TssDataSourceModule = TssDataSourceModule;
    exports.DataSourceService = DataSourceService;
    exports.stripTableName = stripTableName;
    exports.getDataSourceId = getDataSourceId;
    exports.getDateFormatForProvider = getDateFormatForProvider;
    exports.isEnterpriseProvider = isEnterpriseProvider;
    exports.isOracleProvider = isOracleProvider;
    exports.SEED_POD_FILE_EXTENSION = SEED_POD_FILE_EXTENSION;
    exports.BaseEsriService = BaseEsriService;
    exports.EsriConfig = EsriConfig;
    exports.EsriMapServerService = EsriMapServerService;
    exports.getEsriMapServiceHttOptions = getEsriMapServiceHttOptions;
    exports.addParamsToHttpOptions = addParamsToHttpOptions;
    exports.MAP_SERVER_SERVICE_MATCH_IDENTIFIER = MAP_SERVER_SERVICE_MATCH_IDENTIFIER;
    exports.MAP_SERVER_SERVICE_IDENTIFIER = MAP_SERVER_SERVICE_IDENTIFIER;
    exports.FEATURE_SERVER_SERVICE_IDENTIFIER = FEATURE_SERVER_SERVICE_IDENTIFIER;
    exports.IMAGE_SERVER_SERVICE_IDENTIFIER = IMAGE_SERVER_SERVICE_IDENTIFIER;
    exports.FEATURE_SERVER_LAYER_SERVICE_IDENTIFIER = FEATURE_SERVER_LAYER_SERVICE_IDENTIFIER;
    exports.MAP_SERVER_LAYER_SERVICE_MATCH_IDENTIFIER = MAP_SERVER_LAYER_SERVICE_MATCH_IDENTIFIER;
    exports.MAP_SERVER_LAYER_SERVICE_IDENTIFIER = MAP_SERVER_LAYER_SERVICE_IDENTIFIER;
    exports.LRS_SERVER_SERVICE_IDENTIFIER = LRS_SERVER_SERVICE_IDENTIFIER;
    exports.LRS_SERVER_LAYERS_SERVICE_IDENTIFIER = LRS_SERVER_LAYERS_SERVICE_IDENTIFIER;
    exports.MAP_LAYERS_SERVICE_ENDPOINT = MAP_LAYERS_SERVICE_ENDPOINT;
    exports.MAP_LAYER_SERVICE_ENDPOINT = MAP_LAYER_SERVICE_ENDPOINT;
    exports.MAP_LAYER_QUERY_SERVICE_ENDPOINT = MAP_LAYER_QUERY_SERVICE_ENDPOINT;
    exports.MAP_LAYER_QUERY_RELATED_RECORDS_SERVICE_ENDPOINT = MAP_LAYER_QUERY_RELATED_RECORDS_SERVICE_ENDPOINT;
    exports.LRS_SERVER_META_ENDPOINT = LRS_SERVER_META_ENDPOINT;
    exports.LRS_LAYERS_SERVICE_ENDPOINT = LRS_LAYERS_SERVICE_ENDPOINT;
    exports.LRS_SERVER_APPLY_EDITS_ENDPOINT = LRS_SERVER_APPLY_EDITS_ENDPOINT;
    exports.LRS_GEOMETRY_TO_MEASURE = LRS_GEOMETRY_TO_MEASURE;
    exports.PORTAL_SHARING_ENDPOINT = PORTAL_SHARING_ENDPOINT;
    exports.PORTAL_OAUTH_AUTHORIZE_ENDPOINT = PORTAL_OAUTH_AUTHORIZE_ENDPOINT;
    exports.PORTAL_OAUTH_TOKEN_ENDPOINT = PORTAL_OAUTH_TOKEN_ENDPOINT;
    exports.PORTAL_GENERATE_TOKEN_ENDPOINT = PORTAL_GENERATE_TOKEN_ENDPOINT;
    exports.PORTAL_REDIRECT_URL_PARAMS_BREAK_CHARACTER = PORTAL_REDIRECT_URL_PARAMS_BREAK_CHARACTER;
    exports.DEFAULT_PORTAL_OAUTH_REDIRECT_OPTIONS = DEFAULT_PORTAL_OAUTH_REDIRECT_OPTIONS;
    exports.TssEsriModule = TssEsriModule;
    exports.isFeatureServerLayerUrl = isFeatureServerLayerUrl;
    exports.isFeatureServerServiceUrl = isFeatureServerServiceUrl;
    exports.DEFAULT_GEOMETRY_TO_MEASURE_OPTIONS = DEFAULT_GEOMETRY_TO_MEASURE_OPTIONS;
    exports.getGeometryToMeasureOptions = getGeometryToMeasureOptions;
    exports.isCacheableEsriServiceRoute = isCacheableEsriServiceRoute;
    exports.joinAndFomatWithLayer = joinAndFomatWithLayer;
    exports.isLrsServerLayersServiceUrl = isLrsServerLayersServiceUrl;
    exports.isLrsServerServiceUrl = isLrsServerServiceUrl;
    exports.extractMapServerLayerId = extractMapServerLayerId;
    exports.extractMapServerUrl = extractMapServerUrl;
    exports.isMapServerLayerUrl = isMapServerLayerUrl;
    exports.isMapServerServiceUrl = isMapServerServiceUrl;
    exports.doesPathIncludePortalAccessCode = doesPathIncludePortalAccessCode;
    exports.doesPathIncludePortalAccessToken = doesPathIncludePortalAccessToken;
    exports.EsriPortalService = EsriPortalService;
    exports.extractPortalAccessToken = extractPortalAccessToken;
    exports.getPortalOAuthRedirectUrl = getPortalOAuthRedirectUrl;
    exports.getPortalSharingUrl = getPortalSharingUrl;
    exports.getPortalUrl = getPortalUrl;
    exports.removePortalAccessTokenFromHash = removePortalAccessTokenFromHash;
    exports.toEsriPortalAccessToken = toEsriPortalAccessToken;
    exports.DEFAULT_MAP_QUERY_OPTIONS = DEFAULT_MAP_QUERY_OPTIONS;
    exports.getMapQueryOptions = getMapQueryOptions;
    exports.toHttpQueryParams = toHttpQueryParams;
    exports.toEsriServerToken = toEsriServerToken;
    exports.tryStripGdbVersion = tryStripGdbVersion;
    exports.ExportConfig = ExportConfig;
    exports.DEFAULT_EXPORT_GEOJSON_FILE_NAME = DEFAULT_EXPORT_GEOJSON_FILE_NAME;
    exports.TssExportModule = TssExportModule;
    exports.ExportService = ExportService;
    exports.GeolocationConfig = GeolocationConfig;
    exports.PATH_BUILDER_EMPTY_CALIBRATION_MEASURE_VALUE = PATH_BUILDER_EMPTY_CALIBRATION_MEASURE_VALUE;
    exports.PATH_BUILDER_CALCULATED_M_DEVICE_SOURCE = PATH_BUILDER_CALCULATED_M_DEVICE_SOURCE;
    exports.GEOLOCATOR_REGISTRY = GEOLOCATOR_REGISTRY;
    exports.GEOLOCATION_GEOLOCATOR_ID = GEOLOCATION_GEOLOCATOR_ID;
    exports.TssGeolocationModule = TssGeolocationModule;
    exports.GeolocationService = GeolocationService;
    exports.BaseGeolocator = BaseGeolocator;
    exports.Geolocatable = Geolocatable;
    exports.GeolocationGeolocator = GeolocationGeolocator;
    exports.GeolocatorAccuracyUnit = GeolocatorAccuracyUnit;
    exports.GeolocatorCapability = GeolocatorCapability;
    exports.GeolocatorSourceService = GeolocatorSourceService;
    exports.gpsPositionToPoint = gpsPositionToPoint;
    exports.gpsPositionsAlmostEqual = gpsPositionsAlmostEqual;
    exports.gpsPositionsToPoint = gpsPositionsToPoint;
    exports.isNotValidLatitude = isNotValidLatitude;
    exports.isNotValidLocation = isNotValidLocation;
    exports.isNotValidLongitude = isNotValidLongitude;
    exports.isPositionError = isPositionError;
    exports.isValidLatitude = isValidLatitude;
    exports.isValidLocation = isValidLocation;
    exports.isValidLongitude = isValidLongitude;
    exports.positionToGpsPosition = positionToGpsPosition;
    exports.isPositionAcceptable = isPositionAcceptable;
    exports.PositionPathBuilder = PositionPathBuilder;
    exports.degreesToRadians = degreesToRadians;
    exports.getMeasureExtent = getMeasureExtent;
    exports.isLine = isLine;
    exports.isPoint = isPoint;
    exports.isPolygon = isPolygon;
    exports.radiansToDegrees = radiansToDegrees;
    exports.setMeasuresByGeometricLength = setMeasuresByGeometricLength;
    exports.GeometryConfig = GeometryConfig;
    exports.SORTED_BY_MEASURE_PROPERTY_FLAG = SORTED_BY_MEASURE_PROPERTY_FLAG;
    exports.EARTH_RADIUS_IN_KILOMETERS = EARTH_RADIUS_IN_KILOMETERS;
    exports.EARTH_RADIUS_IN_METERS = EARTH_RADIUS_IN_METERS;
    exports.WGS_84_SRID = WGS_84_SRID;
    exports.TssGeometryModule = TssGeometryModule;
    exports.extractMeasuresFromLine = extractMeasuresFromLine;
    exports.flattenLine = flattenLine;
    exports.getDistanceToLine = getDistanceToLine;
    exports.getMeasureExtentFromLine = getMeasureExtentFromLine;
    exports.getMeasureFromFlatCoordinateSystem = getMeasureFromFlatCoordinateSystem;
    exports.getMeasureFromLatLng = getMeasureFromLatLng;
    exports.getMeasure = getMeasure;
    exports.getVerticeeInfos = getVerticeeInfos;
    exports.getClosestVerticees = getClosestVerticees;
    exports.getClosestVerticee = getClosestVerticee;
    exports.getPoint = getPoint;
    exports.hasMeasureValues = hasMeasureValues;
    exports.singleLineHasMeasureValues = singleLineHasMeasureValues;
    exports.multiLineHasMeasureValues = multiLineHasMeasureValues;
    exports.isLineWithinBounds = isLineWithinBounds;
    exports.isMultiPartLine = isMultiPartLine;
    exports.isPointOnLineString = isPointOnLineString;
    exports.isLatLngOnLineString = isLatLngOnLineString;
    exports.isLatLngOnLine = isLatLngOnLine;
    exports.isPointOnLine = isPointOnLine;
    exports.multiLineToCoordinates = multiLineToCoordinates;
    exports.singleLineToCoordinates = singleLineToCoordinates;
    exports.sortLineByMeasure = sortLineByMeasure;
    exports.toLineOrMultiLineString = toLineOrMultiLineString;
    exports.toLineString = toLineString;
    exports.toMultiLineString = toMultiLineString;
    exports.toMultiPartPaths = toMultiPartPaths;
    exports.isPointWithinBounds = isPointWithinBounds;
    exports.isPointWithinButNotIncludingBounds = isPointWithinButNotIncludingBounds;
    exports.calculateCrossProductByPoints = calculateCrossProductByPoints;
    exports.getDistanceBetweenPoints = getDistanceBetweenPoints;
    exports.getDistanceBetweenPointValues = getDistanceBetweenPointValues;
    exports.getKilometersBetweenLatLng = getKilometersBetweenLatLng;
    exports.getMetersBetweenLatLng = getMetersBetweenLatLng;
    exports.getFeetBetweenLatLng = getFeetBetweenLatLng;
    exports.getMilesBetweenLatLng = getMilesBetweenLatLng;
    exports.getDistanceBetweenLatLng = getDistanceBetweenLatLng;
    exports.getMeasureExtentFromPoint = getMeasureExtentFromPoint;
    exports.getMeasureFromPoint = getMeasureFromPoint;
    exports.isMultiPartPoint = isMultiPartPoint;
    exports.getSortResultForPoints = getSortResultForPoints;
    exports.sortPointsByMeasure = sortPointsByMeasure;
    exports.toMultiPartPoint = toMultiPartPoint;
    exports.toSinglePartPointArray = toSinglePartPointArray;
    exports.GpsGateGeolocator = GpsGateGeolocator;
    exports.GpsGateConfig = GpsGateConfig;
    exports.TssGpsGateModule = TssGpsGateModule;
    exports.HttpParamInterceptor = HttpParamInterceptor;
    exports.HttpConfig = HttpConfig;
    exports.TssHttpModule = TssHttpModule;
    exports.isRouteMatch = isRouteMatch;
    exports.toFormDataString = toFormDataString;
    exports.toFormData = toFormData;
    exports.CalibrationPointLayer = CalibrationPointLayer;
    exports.CapturePosition = CapturePosition;
    exports.CenterlineLayer = CenterlineLayer;
    exports.evaluteFeatureDataExpression = evaluteFeatureDataExpression;
    exports.extractFeatureDataByLayer = extractFeatureDataByLayer;
    exports.extractFeatureData = extractFeatureData;
    exports.ALL_FIELD_CRITERIA = ALL_FIELD_CRITERIA;
    exports.isDynamicDataExpression = isDynamicDataExpression;
    exports.DYNAMIC_DATA_REGEX = DYNAMIC_DATA_REGEX;
    exports.LrsDataService = LrsDataService;
    exports.DataSourceLrsMetadataService = DataSourceLrsMetadataService;
    exports.EventFeatureCollection = EventFeatureCollection;
    exports.EventFeature = EventFeature;
    exports.EventLayer = EventLayer;
    exports.toLrsFeature = toLrsFeature;
    exports.toFeature = toFeature;
    exports.generateHierarchyFilters = generateHierarchyFilters;
    exports.IntersectionLayer = IntersectionLayer;
    exports.findLayer = findLayer;
    exports.LrsFeatureCollection = LrsFeatureCollection;
    exports.LrsFeature = LrsFeature;
    exports.getLayerTableName = getLayerTableName;
    exports.LrsLayer = LrsLayer;
    exports.mergeFieldDomains = mergeFieldDomains;
    exports.mergeFields = mergeFields;
    exports.mergeLayer = mergeLayer;
    exports.mergeLayers = mergeLayers;
    exports.mergeNetworkLayers = mergeNetworkLayers;
    exports.onMergeNetworkLayerComplete = onMergeNetworkLayerComplete;
    exports.mergeLrsMetadata = mergeLrsMetadata;
    exports.mergeMapMetadata = mergeMapMetadata;
    exports.deepMergeMapMetadata = deepMergeMapMetadata;
    exports.mergeLrsMetadataSources = mergeLrsMetadataSources;
    exports.LrsMetadataRetriever = LrsMetadataRetriever;
    exports.LRS_LAYER_VALIDATIONS = LRS_LAYER_VALIDATIONS;
    exports.LRS_NETWORK_LAYER_VALIDATIONS = LRS_NETWORK_LAYER_VALIDATIONS;
    exports.LRS_EVENT_LAYER_VALIDATIONS = LRS_EVENT_LAYER_VALIDATIONS;
    exports.LRS_METADATA_VALIDATIONS = LRS_METADATA_VALIDATIONS;
    exports.LrsMetadataService = LrsMetadataService;
    exports.LrsMetadata = LrsMetadata;
    exports.getLrsViewDateWhereStatement = getLrsViewDateWhereStatement;
    exports.NO_TEMPORAL_LAYER_SUPPLIED_ERROR_MSG = NO_TEMPORAL_LAYER_SUPPLIED_ERROR_MSG;
    exports.NO_REFERENCE_LAYER_SUPPLIED_ERROR_MSG = NO_REFERENCE_LAYER_SUPPLIED_ERROR_MSG;
    exports.LRS_DATE_WHERE_CLAUSE_TEMPLATE = LRS_DATE_WHERE_CLAUSE_TEMPLATE;
    exports.LRS_POINT_EVENT_WHERE_CLAUSE_TEMPLATE = LRS_POINT_EVENT_WHERE_CLAUSE_TEMPLATE;
    exports.LRS_LINEAR_EVENT_WHERE_CLAUSE_TEMPLATE = LRS_LINEAR_EVENT_WHERE_CLAUSE_TEMPLATE;
    exports.LrsWhereClauseBuilder = LrsWhereClauseBuilder;
    exports.LrsConfig = LrsConfig;
    exports.TssLrsModule = TssLrsModule;
    exports.NetworkFeatureCollection = NetworkFeatureCollection;
    exports.NetworkFeature = NetworkFeature;
    exports.NetworkLayer = NetworkLayer;
    exports.NonLrsLayer = NonLrsLayer;
    exports.RedlineFeature = RedlineFeature;
    exports.RedlineLayer = RedlineLayer;
    exports.isClassBreakInfoEmpty = isClassBreakInfoEmpty;
    exports.isRendererSymbolDefault = isRendererSymbolDefault;
    exports.DEFAULT_UNIQUE_VALUE_INFO = DEFAULT_UNIQUE_VALUE_INFO;
    exports.DEFAULT_CLASS_BREAK_VALUE_INFO = DEFAULT_CLASS_BREAK_VALUE_INFO;
    exports.DEFAULT_RENDERER_SYMBOL = DEFAULT_RENDERER_SYMBOL;
    exports.LayerDrawingInfoRenderer = LayerDrawingInfoRenderer;
    exports.LayerDrawingInfo = LayerDrawingInfo;
    exports.LAYER_RENDER_TYPES = LAYER_RENDER_TYPES;
    exports.LayerRendererTypePipe = LayerRendererTypePipe;
    exports.SYMBOL_LOCATION_TYPES = SYMBOL_LOCATION_TYPES;
    exports.isUniqueValueInfoEmpty = isUniqueValueInfoEmpty;
    exports.isPointGeometryType = isPointGeometryType;
    exports.isLinearGeometryType = isLinearGeometryType;
    exports.isPolygonGeometryType = isPolygonGeometryType;
    exports.POINT_GEOMETRY_TYPES = POINT_GEOMETRY_TYPES;
    exports.LINEAR_GEOMETRY_TYPES = LINEAR_GEOMETRY_TYPES;
    exports.POLYGON_GEOMETRY_TYPES = POLYGON_GEOMETRY_TYPES;
    exports.FeatureClassLayer = FeatureClassLayer;
    exports.getCodedValue = getCodedValue;
    exports.getCodedValueNameOrDefault = getCodedValueNameOrDefault;
    exports.getCodedValueName = getCodedValueName;
    exports.isFieldGeometryType = isFieldGeometryType;
    exports.isObjectIdType = isObjectIdType;
    exports.getGeometryField = getGeometryField;
    exports.getGeometryFieldName = getGeometryFieldName;
    exports.getIdField = getIdField;
    exports.getIdFieldFieldName = getIdFieldFieldName;
    exports.isFieldExpression = isFieldExpression;
    exports.toFieldType = toFieldType;
    exports.toFieldName = toFieldName;
    exports.getField = getField;
    exports.getFieldAlias = getFieldAlias;
    exports.isFieldNumeric = isFieldNumeric;
    exports.isFieldValueNumeric = isFieldValueNumeric;
    exports.FIELD_TYPE_OID = FIELD_TYPE_OID;
    exports.FIELD_TYPE_OID_STRING = FIELD_TYPE_OID_STRING;
    exports.FIELD_TYPE_STRING = FIELD_TYPE_STRING;
    exports.FIELD_TYPE_NUMBER = FIELD_TYPE_NUMBER;
    exports.FIELD_TYPE_XML = FIELD_TYPE_XML;
    exports.FIELD_TYPE_BLOB = FIELD_TYPE_BLOB;
    exports.FIELD_TYPE_DATE = FIELD_TYPE_DATE;
    exports.FIELD_TYPE_DOUBLE = FIELD_TYPE_DOUBLE;
    exports.FIELD_TYPE_GUID = FIELD_TYPE_GUID;
    exports.FIELD_TYPE_GEOMETRY = FIELD_TYPE_GEOMETRY;
    exports.FIELD_TYPE_GLOBALID = FIELD_TYPE_GLOBALID;
    exports.FIELD_TYPE_INTEGER = FIELD_TYPE_INTEGER;
    exports.FIELD_TYPE_RASTER = FIELD_TYPE_RASTER;
    exports.FIELD_TYPE_SINGLE = FIELD_TYPE_SINGLE;
    exports.FIELD_TYPE_SMALL_INTEGER = FIELD_TYPE_SMALL_INTEGER;
    exports.ESRI_FIELD_TYPE_OID = ESRI_FIELD_TYPE_OID;
    exports.ESRI_FIELD_TYPE_STRING = ESRI_FIELD_TYPE_STRING;
    exports.ESRI_FIELD_TYPE_NUMBER = ESRI_FIELD_TYPE_NUMBER;
    exports.ESRI_FIELD_TYPE_XML = ESRI_FIELD_TYPE_XML;
    exports.ESRI_FIELD_TYPE_BLOB = ESRI_FIELD_TYPE_BLOB;
    exports.ESRI_FIELD_TYPE_DATE = ESRI_FIELD_TYPE_DATE;
    exports.ESRI_FIELD_TYPE_DOUBLE = ESRI_FIELD_TYPE_DOUBLE;
    exports.ESRI_FIELD_TYPE_GUID = ESRI_FIELD_TYPE_GUID;
    exports.ESRI_FIELD_TYPE_GEOMETRY = ESRI_FIELD_TYPE_GEOMETRY;
    exports.ESRI_FIELD_TYPE_GLOBALID = ESRI_FIELD_TYPE_GLOBALID;
    exports.ESRI_FIELD_TYPE_INTEGER = ESRI_FIELD_TYPE_INTEGER;
    exports.ESRI_FIELD_TYPE_RASTER = ESRI_FIELD_TYPE_RASTER;
    exports.ESRI_FIELD_TYPE_SINGLE = ESRI_FIELD_TYPE_SINGLE;
    exports.ESRI_FIELD_TYPE_SMALL_INTEGER = ESRI_FIELD_TYPE_SMALL_INTEGER;
    exports.FIELD_METADATA = FIELD_METADATA;
    exports.MapFeature = MapFeature;
    exports.MapServerMetadata = MapServerMetadata;
    exports.MapTable = MapTable;
    exports.TssMapsModule = TssMapsModule;
    exports.MapsConfig = MapsConfig;
    exports.toLayerId = toLayerId;
    exports.FIELD_QUOTE = FIELD_QUOTE;
    exports.CriteriaOperator = CriteriaOperator;
    exports.TargetOperator = TargetOperator;
    exports.ValueOperator = ValueOperator;
    exports.GroupingOperator = GroupingOperator;
    exports.CombiningOperator = CombiningOperator;
    exports.DefaultWhereClauseBuilderOptions = DefaultWhereClauseBuilderOptions;
    exports.WhereClauseBuilder = WhereClauseBuilder;
    exports.DeviceMotionService = DeviceMotionService;
    exports.MotionConfig = MotionConfig;
    exports.TssMotionModule = TssMotionModule;
    exports.DeviceOrientationService = DeviceOrientationService;
    exports.getHeadingFromOrientation = getHeadingFromOrientation;
    exports.OrientationConfig = OrientationConfig;
    exports.TssOrientationModule = TssOrientationModule;
    exports.TssPolyfillModule = TssPolyfillModule;
    exports.PreventDefaultLinkDirective = PreventDefaultLinkDirective;
    exports.QueuableWorkQueueManager = QueuableWorkQueueManager;
    exports.QueueItemStatus = QueueItemStatus;
    exports.QueueWorkerToken = QueueWorkerToken;
    exports.QueueConfig = QueueConfig;
    exports.TssQueueModule = TssQueueModule;
    exports.DEFAULT_WORK_QUEUE_OPTIONS = DEFAULT_WORK_QUEUE_OPTIONS;
    exports.WorkQueueManager = WorkQueueManager;
    exports.WorkQueueStatusEventType = WorkQueueStatusEventType;
    exports.WorkQueueStatusTracker = WorkQueueStatusTracker;
    exports.SignInState = SignInState;
    exports.AuthService = AuthService;
    exports.HasRolesDirective = HasRolesDirective;
    exports.PrivilegeService = PrivilegeService;
    exports.RoleManagerService = RoleManagerService;
    exports.MISSING_PRIVILEGE_PARAM_EXCEPTION_MSG = MISSING_PRIVILEGE_PARAM_EXCEPTION_MSG;
    exports.RolePrivilegeService = RolePrivilegeService;
    exports.RoleService = RoleService;
    exports.MISSING_ROLE_PARAM_EXCEPTION_MSG = MISSING_ROLE_PARAM_EXCEPTION_MSG;
    exports.UserRoleService = UserRoleService;
    exports.SecurityConfig = SecurityConfig;
    exports.MISSING_USER_PARAM_EXCEPTION_MSG = MISSING_USER_PARAM_EXCEPTION_MSG;
    exports.TssSecurityModule = TssSecurityModule;
    exports.TokenInterceptor = TokenInterceptor;
    exports.UserService = UserService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=tss-sdk.umd.js.map