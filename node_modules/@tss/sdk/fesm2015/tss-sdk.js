import { DomSanitizer } from '@angular/platform-browser';
import { Router, RouterModule } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { lineString } from '@turf/helpers';
import nearestPointOnLine from '@turf/nearest-point-on-line';
import lineSplit from '@turf/line-split';
import length from '@turf/length';
import { isNumber, isDate } from 'util';
import destination from '@turf/destination';
import bearing from '@turf/bearing';
import distance from '@turf/distance';
import { CommonModule, DatePipe, DecimalPipe } from '@angular/common';
import { Subject, of, throwError, ReplaySubject, forkJoin, fromEvent, merge, iif } from 'rxjs';
import { publishReplay, tap, catchError, map, finalize, mergeMap, takeWhile, filter } from 'rxjs/operators';
import { __decorate, __awaiter, __metadata } from 'tslib';
import { HttpClient, HttpHeaders, HttpParams, HttpClientModule, HTTP_INTERCEPTORS, HttpResponse } from '@angular/common/http';
import { Injectable, NgModule, CUSTOM_ELEMENTS_SCHEMA, Injector, APP_INITIALIZER, Pipe, Input, Directive, HostListener, TemplateRef, ViewContainerRef, defineInjectable, inject, INJECTOR } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ResourceConfig {
    /**
     * @return {?}
     */
    get hasServiceUrl() {
        return Boolean(this.serviceUrl);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const LogLevel = {
    Trace: 0,
    Debug: 1,
    Info: 2,
    Warn: 3,
    Error: 4,
    Fatal: 5,
};
LogLevel[LogLevel.Trace] = 'Trace';
LogLevel[LogLevel.Debug] = 'Debug';
LogLevel[LogLevel.Info] = 'Info';
LogLevel[LogLevel.Warn] = 'Warn';
LogLevel[LogLevel.Error] = 'Error';
LogLevel[LogLevel.Fatal] = 'Fatal';
/**
 * @param {?} type
 * @return {?}
 */
function typeToLevel(type) {
    if (type === 'trace') {
        return LogLevel.Trace;
    }
    else if (type === 'debug') {
        return LogLevel.Debug;
    }
    else if (type === 'info') {
        return LogLevel.Info;
    }
    else if (type === 'warn') {
        return LogLevel.Warn;
    }
    else if (type === 'error') {
        return LogLevel.Error;
    }
    else if (type === 'fatal') {
        return LogLevel.Fatal;
    }
    else {
        throw new Error(`Unknown log type: '${type}'`);
    }
}
/**
 * @param {?} level
 * @return {?}
 */
function levelToType(level) {
    if (level === LogLevel.Trace) {
        return 'trace';
    }
    else if (level === LogLevel.Debug) {
        return 'debug';
    }
    else if (level === LogLevel.Info) {
        return 'info';
    }
    else if (level === LogLevel.Warn) {
        return 'warn';
    }
    else if (level === LogLevel.Error) {
        return 'error';
    }
    else if (level === LogLevel.Fatal) {
        return 'fatal';
    }
    else {
        throw new Error(`Unknown log level: '${level}'`);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const MeasurementUnit = {
    Imperial: 'imperial',
    Metric: 'metric',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A simple settings/config class for storing key/value pairs with persistence.
 */
class CoreConfig {
    constructor() {
        this.autoConfig = true;
        this.logEnabled = true;
        this.logLevel = LogLevel.Info;
        this.defaultNotifyInfoMsg = 'Info';
        this.defaultNotifyWarnMsg = 'Warning';
        this.defaultNotifyErrorMsg = 'Error';
        this.defaultNotifySuccessMsg = 'Success';
        this.defaultNotifyWaitMsg = 'Wait';
        this.measurementUnit = MeasurementUnit.Imperial;
    }
}
CoreConfig.moduleConfigs = [{ className: 'CoreConfig', injectorToken: CoreConfig }];
CoreConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ CoreConfig.ngInjectableDef = defineInjectable({ factory: function CoreConfig_Factory() { return new CoreConfig(); }, token: CoreConfig, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @param {?} expectedType
 * @return {?}
 */
function isType(val, expectedType) {
    return typeof val === expectedType;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isString(val) {
    return isType(val, 'string');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} config
 * @return {?}
 */
function AutoConfig(config) {
    return (/**
     * @param {?} constructor
     * @return {?}
     */
    (constructor) => {
        /** @type {?} */
        const autoConf = isString(config)
            ? { className: (/** @type {?} */ (config)), injectorToken: constructor }
            : (/** @type {?} */ (config));
        CoreConfig.moduleConfigs.push(autoConf);
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_APP_ID = 'all';
/** @type {?} */
const DEFAULT_PROFILE_ID = 'default';
/**
 * Application related configuration options. These settings are used to
 * drive all general "global" application related behaviour. The settings can be
 * overridden directly in the code, application module, or from the TDS server.
 */
let AppConfig = /**
 * Application related configuration options. These settings are used to
 * drive all general "global" application related behaviour. The settings can be
 * overridden directly in the code, application module, or from the TDS server.
 */
class AppConfig extends ResourceConfig {
    constructor() {
        super(...arguments);
        this.appId = DEFAULT_APP_ID;
        this.queryProfile = true;
        this.profileId = null;
        this.profile = null;
        this.defaultProfileId = DEFAULT_PROFILE_ID;
        this.allowQueryParamInjections = true;
        this.continueOnAppBootstrapError = false;
        this.appSettingsEndpoint = 'api/apps/{appId}/settings/{id}';
        this.appProfileEndpoint = 'api/apps/{appId}/profiles/{id}';
        this.pingEndpoint = 'api/ping';
        this.statusEndpoint = 'api/status';
    }
};
AppConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ AppConfig.ngInjectableDef = defineInjectable({ factory: function AppConfig_Factory() { return new AppConfig(); }, token: AppConfig, providedIn: "root" });
/**
 * Application related configuration options. These settings are used to
 * drive all general "global" application related behaviour. The settings can be
 * overridden directly in the code, application module, or from the TDS server.
 */
AppConfig = __decorate([
    AutoConfig('AppConfig')
], AppConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Port from: https://github.com/jfromaniello/url-join
// TODO: Refactor this to be cleaner - RG.
/**
 * @param {...?} parts
 * @return {?}
 */
function join(...parts) {
    /** @type {?} */
    const resultArray = [];
    /** @type {?} */
    let str;
    if (Array.isArray(parts[0])) {
        parts = parts[0];
    }
    parts[0] = parts[0] || '';
    // If the first part is a plain protocol, we combine it with the next part.
    if (parts[0].match(/^[^/:]+:\/*$/) && parts.length > 1) {
        /** @type {?} */
        const first = parts.shift();
        parts[0] = first + parts[0];
    }
    // There must be two or three slashes in the file protocol, two slashes in anything else.
    if (parts[0].match(/^file:\/\/\//)) {
        parts[0] = parts[0].replace(/^([^/:]+):\/*/, '$1:///');
    }
    else {
        parts[0] = parts[0].replace(/^([^/:]+):\/*/, '$1://');
    }
    for (let i = 0; i < parts.length; i++) {
        /** @type {?} */
        let component = parts[i];
        if (typeof component !== 'string') {
            throw new TypeError('Url must be a string. Received ' + component);
        }
        if (component === '') {
            continue;
        }
        if (i > 0) {
            // Removing the starting slashes for each component but the first.
            component = component.replace(/^[\/]+/, '');
        }
        if (i < parts.length - 1) {
            // Removing the ending slashes for each component but the last.
            component = component.replace(/[\/]+$/, '');
        }
        else {
            // For the last component we will combine multiple slashes to a single one.
            component = component.replace(/[\/]+$/, '/');
        }
        resultArray.push(component);
    }
    str = resultArray.join('/');
    // Each input component is now separated by a single slash except the possible first plain protocol part.
    // Remove trailing slash before parameters or hash.
    str = str.replace(/\/(\?|&|#[^!])/g, '$1');
    // Replace ? in parameters with &.
    /** @type {?} */
    const urlParts = str.split('?');
    str = urlParts.shift() + (urlParts.length > 0 ? '?' : '') + urlParts.join('&');
    return str;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TOKEN_EXPRESSION = new RegExp('{(.*?)}', 'gi');
/** @type {?} */
const FULL_TOKEN_EXPRESSION = new RegExp('{{(.*?)}}', 'gi');
/** @type {?} */
const WILDCARD_EXPRESSION_VALUE = '(.*)';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} template
 * @param {?=} replaceValue
 * @return {?}
 */
function replaceTokens(template, replaceValue = '') {
    return (template || '')
        .replace(FULL_TOKEN_EXPRESSION, replaceValue)
        .replace(TOKEN_EXPRESSION, replaceValue);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} template
 * @param {?} tokenKey
 * @param {?} tokenValue
 * @return {?}
 */
function replaceToken(template, tokenKey, tokenValue) {
    return (template || '')
        .replace(new RegExp(`{{${tokenKey}}}`, 'gi'), tokenValue)
        .replace(new RegExp(`{${tokenKey}}`, 'gi'), tokenValue);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO: Expand this to have the full functionality of:
// https://github.com/davidchambers/string-format
// -RG.
/**
 * @param {?} template
 * @param {?} tokens
 * @param {?=} removeEmptyTokens
 * @return {?}
 */
function format(template, tokens, removeEmptyTokens = false) {
    Object.keys(tokens || {})
        .forEach((/**
     * @param {?} key
     * @return {?}
     */
    key => template = replaceToken(template, key, tokens[key])));
    if (removeEmptyTokens) {
        template = replaceTokens(template);
    }
    return template;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Cleans a URL:
 *  - Removes double-slashes
 * @param {?} url
 * @return {?}
 */
function clean(url) {
    return isString(url)
        ? url.replace(/([^:]\/)\/+/g, '$1')
        : url;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NO_URL_ERROR_MSG = 'No URL configured for resource service.';
/** @type {?} */
const UNSUPPORTED_GET_EXCEPTION_MSG = `The 'Get' method is unsupported for this resource`;
/** @type {?} */
const UNSUPPORTED_CREATE_EXCEPTION_MSG = `The 'Create' method is unsupported for this resource`;
/** @type {?} */
const EMPTY_PARAM_VALUE = '';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class BaseEmptyResourceService {
    /**
     * @param {?} http
     * @param {?} paramsOrUrl
     */
    constructor(http, paramsOrUrl) {
        this.http = http;
        this.config = {
            url: null,
            idFieldName: 'id',
            cleanUrl: true,
        };
        if (isString(paramsOrUrl)) {
            this.config.url = (/** @type {?} */ (paramsOrUrl));
        }
        else {
            Object.assign(this.config, paramsOrUrl);
        }
        if (!this.config.url) {
            throw NO_URL_ERROR_MSG;
        }
    }
    /**
     * @protected
     * @param {?} entity
     * @param {?} endpoint
     * @param {?} tokens
     * @return {?}
     */
    getUrlWithEntity(entity, endpoint, tokens) {
        return this.getUrlWithId(entity ? entity[this.config.idFieldName] : null, endpoint, tokens);
    }
    /**
     * @protected
     * @param {?} id
     * @param {?} endpoint
     * @param {?} tokens
     * @return {?}
     */
    getUrlWithId(id, endpoint, tokens) {
        /** @type {?} */
        const inferredRouteTokens = {};
        inferredRouteTokens[this.config.idFieldName] = id;
        return this.getUrl(endpoint, Object.assign(inferredRouteTokens, tokens));
    }
    /**
     * @protected
     * @param {?} endpoint
     * @param {?} tokens
     * @return {?}
     */
    getUrl(endpoint, tokens) {
        /** @type {?} */
        const url = endpoint
            ? join(this.config.url, endpoint)
            : this.config.url;
        return this.replaceTokens(url, tokens);
    }
    /**
     * @protected
     * @param {?} url
     * @param {?} tokens
     * @return {?}
     */
    replaceTokens(url, tokens) {
        tokens = tokens || {};
        if (this.config.defaultRouteTokens) {
            tokens = Object.assign({}, this.config.defaultRouteTokens, tokens);
        }
        url = format(url, tokens, true);
        if (this.config.cleanUrl) {
            url = clean(url);
        }
        return url;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ApiService extends BaseEmptyResourceService {
    /**
     * @param {?} http
     * @param {?} appConfig
     */
    constructor(http, appConfig) {
        super(http, appConfig.serviceUrl);
        this.appConfig = appConfig;
    }
    /**
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    ping(routeTokens, params) {
        /** @type {?} */
        const url = this.getUrl(this.appConfig.pingEndpoint, routeTokens);
        return this.http.get(url, { params });
    }
    /**
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    status(routeTokens, params) {
        /** @type {?} */
        const url = this.getUrl(this.appConfig.pingEndpoint, routeTokens);
        return this.http.get(url, { params });
    }
}
ApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ApiService.ctorParameters = () => [
    { type: HttpClient },
    { type: AppConfig }
];
/** @nocollapse */ ApiService.ngInjectableDef = defineInjectable({ factory: function ApiService_Factory() { return new ApiService(inject(HttpClient), inject(AppConfig)); }, token: ApiService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Console logger.
 */
class Logger {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this.logs = [];
    }
    /**
     * @return {?}
     */
    get level() {
        return this.config.logLevel;
    }
    /**
     * @return {?}
     */
    get enabled() {
        return this.config.logEnabled;
    }
    /**
     * @return {?}
     */
    get isTrace() {
        return this.level >= LogLevel.Trace;
    }
    /**
     * @return {?}
     */
    get isDebug() {
        return this.level >= LogLevel.Debug;
    }
    /**
     * @return {?}
     */
    get isWarn() {
        return this.level >= LogLevel.Warn;
    }
    /**
     * @return {?}
     */
    get isError() {
        return this.level >= LogLevel.Error;
    }
    /**
     * @return {?}
     */
    get isFatal() {
        return this.level >= LogLevel.Fatal;
    }
    /**
     * @return {?}
     */
    get traceCount() {
        return this.count('trace');
    }
    /**
     * @return {?}
     */
    get debugCount() {
        return this.count('debug');
    }
    /**
     * @return {?}
     */
    get warnCount() {
        return this.count('warn');
    }
    /**
     * @return {?}
     */
    get errorCount() {
        return this.count('error');
    }
    /**
     * @return {?}
     */
    get fatalCount() {
        return this.count('fatal');
    }
    /**
     * @param {?} logType
     * @return {?}
     */
    count(logType) {
        return this.logsByType(logType).length;
    }
    /**
     * @param {?} logType
     * @return {?}
     */
    logsByType(logType) {
        return this.logsByLevel(typeToLevel(logType));
    }
    /**
     * @param {?} logLevel
     * @return {?}
     */
    logsByLevel(logLevel) {
        return this.logs.filter((/**
         * @param {?} l
         * @return {?}
         */
        l => l.level === logLevel));
    }
    /**
     * @param {?} log
     * @return {?}
     */
    logEntry(log) {
        if (this.config.logEnabled && log.level >= this.config.logLevel) {
            this.logs.push(log);
            if (this.isDebug) {
                console.log(`${LogLevel[log.level]}: ${log.msg} ${log.error || ''}`);
            }
        }
        return log;
    }
    /**
     * @param {?} msg
     * @param {?} level
     * @param {?=} error
     * @return {?}
     */
    log(msg, level, error = null) {
        return this.logEntry({
            msg: format(msg, { error }),
            level,
            error,
            created: new Date()
        });
    }
    /**
     * @param {?} msg
     * @return {?}
     */
    trace(msg) {
        return this.log(msg, LogLevel.Trace);
    }
    /**
     * @param {?} msg
     * @return {?}
     */
    debug(msg) {
        return this.log(msg, LogLevel.Debug);
    }
    /**
     * @param {?} msg
     * @return {?}
     */
    info(msg) {
        return this.log(msg, LogLevel.Info);
    }
    /**
     * @param {?} msg
     * @param {?=} error
     * @return {?}
     */
    warn(msg, error = null) {
        return this.log(msg, LogLevel.Warn, error);
    }
    /**
     * @param {?} msg
     * @param {?=} error
     * @return {?}
     */
    error(msg, error = null) {
        return this.log(msg, LogLevel.Error, error);
    }
    /**
     * @param {?} msg
     * @param {?=} error
     * @return {?}
     */
    fatal(msg, error = null) {
        return this.log(msg, LogLevel.Fatal, error);
    }
    /**
     * @return {?}
     */
    clear() {
        this.logs.length = 0;
    }
}
Logger.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
Logger.ctorParameters = () => [
    { type: CoreConfig }
];
/** @nocollapse */ Logger.ngInjectableDef = defineInjectable({ factory: function Logger_Factory() { return new Logger(inject(CoreConfig)); }, token: Logger, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function getByteSize(value) {
    value = value || '';
    // Matches only the 10.. bytes that are non-initial characters in a multi-byte sequence.
    /** @type {?} */
    const match = encodeURIComponent(value).match(/%[89ABab]/g);
    return value.length + (match ? match.length : 0);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const STORAGE_FORMAT_UNITS = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
/** @type {?} */
const NO_BYTES_FORMATTED = '0 KB';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isDefined(val) {
    return !isType(val, 'undefined');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isValue(val) {
    return isDefined(val) && val !== null && val !== '';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} numberOfBytes
 * @param {?=} decimalPlaces
 * @param {?=} lowerCaseUnits
 * @return {?}
 */
function formatByteSize(numberOfBytes, decimalPlaces, lowerCaseUnits = false) {
    /** @type {?} */
    let len = 0;
    if (!numberOfBytes) {
        return NO_BYTES_FORMATTED;
    }
    while (numberOfBytes >= 1024 && ++len) {
        numberOfBytes = numberOfBytes / 1024;
    }
    if (!isValue(decimalPlaces)) {
        decimalPlaces = numberOfBytes >= 10 || len < 1 ? 0 : 1;
    }
    /** @type {?} */
    const fixedNum = numberOfBytes.toFixed(decimalPlaces);
    /** @type {?} */
    const unit = lowerCaseUnits
        ? STORAGE_FORMAT_UNITS[len].toLowerCase()
        : STORAGE_FORMAT_UNITS[len];
    return `${fixedNum} ${unit}`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class BaseStorage {
    constructor() {
        this.keyPrefix = '';
        this.keySuffix = '';
    }
    /**
     * @param {?} key
     * @return {?}
     */
    has(key) {
        return Boolean(this.get(key));
    }
    /**
     * Returns the number of bytes for this storage key.
     * @param {?} key
     * @return {?}
     */
    size(key) {
        /** @type {?} */
        const value = this.get(key);
        return getByteSize(value) + getByteSize(key);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    sizeFormatted(key) {
        return formatByteSize(this.size(key));
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getObject(key) {
        /** @type {?} */
        const value = this.get(key);
        return value ? JSON.parse(value) : null;
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setObject(key, value) {
        this.set(key, JSON.stringify(value));
    }
    /**
     * @protected
     * @param {?} key
     * @return {?}
     */
    formatKey(key) {
        return `${this.keyPrefix}${key}${this.keySuffix}`;
    }
}
BaseStorage.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ BaseStorage.ngInjectableDef = defineInjectable({ factory: function BaseStorage_Factory() { return new BaseStorage(); }, token: BaseStorage, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PersistentStorage extends BaseStorage {
    /**
     * @return {?}
     */
    get length() {
        return localStorage.length;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    get(key) {
        return localStorage.getItem(this.formatKey(key));
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    set(key, value) {
        localStorage.setItem(this.formatKey(key), value);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    remove(key) {
        localStorage.removeItem(this.formatKey(key));
    }
    /**
     * @return {?}
     */
    clear() {
        localStorage.clear();
    }
}
PersistentStorage.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ PersistentStorage.ngInjectableDef = defineInjectable({ factory: function PersistentStorage_Factory() { return new PersistentStorage(); }, token: PersistentStorage, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function hasWindow() {
    return typeof window !== 'undefined';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getFullUrl() {
    return hasWindow() ? location.href : '';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?=} search
 * @return {?}
 */
function getQueryParams(search) {
    /** @type {?} */
    let hashes;
    search = search || getFullUrl();
    if (!search) {
        return {};
    }
    hashes = search.slice(search.indexOf('?') + 1).split('&');
    if (!hashes || !hashes.length || !hashes[0] || hashes.length === 1 && !String(hashes[0]).includes('=')) {
        return {};
    }
    return hashes.reduce((/**
     * @param {?} params
     * @param {?} hash
     * @return {?}
     */
    (params, hash) => {
        const [key, val] = hash.split('=');
        return Object.assign(params, { [key]: decodeURIComponent(val) });
    }), {});
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} list
 * @return {?}
 */
function getLastItem(list) {
    return list[list.length - 1];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} url
 * @return {?}
 */
function getPostHashRoutePaths(url) {
    /** @type {?} */
    const parts = clean(url).split('#');
    /** @type {?} */
    const hashPart = parts.length > 1
        ? getLastItem(parts)
        : null;
    return hashPart && hashPart !== '/'
        ? hashPart
            .split('/')
            .filter((/**
         * @param {?} part
         * @return {?}
         */
        part => Boolean(part) && !part.includes('=')))
        : [];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} url
 * @return {?}
 */
function getFirstHashRoutePath(url) {
    const [postHashParts] = getPostHashRoutePaths(url);
    return postHashParts || null;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isDate$1(val) {
    return val instanceof Date;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isNotValue(val) {
    return !isValue(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function canNotBeNumber(val) {
    return isNaN(Number(val));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function canBeNumber(val) {
    return !canNotBeNumber(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function toPrimitiveType(value) {
    if (isNotValue(value)) {
        return value;
    }
    else if (value === 'true' || value === 'false') {
        return Boolean(value);
    }
    else if (canBeNumber(value)) {
        return Number(value);
    }
    else {
        return value;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function lowerCaseFirst(value) {
    return String(value).charAt(0).toLowerCase() + value.slice(1);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO: Refactor this method and give it proper names.
// This was a copy/paste from online - RG.
/**
 * @param {?} target
 * @param {?} key
 * @param {?} val
 * @return {?}
 */
function setValue(target, key, val) {
    if (!target) {
        return;
    }
    /** @type {?} */
    const ka = key.split(/\./);
    if (ka.length < 2) {
        target[ka[0]] = val;
    }
    else {
        if (!target[ka[0]]) {
            target[ka[0]] = {};
        }
        target = target[ka.shift()];
        setValue(target, ka.join('.'), val);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Security related configuration options. These settings are used to drive all
 * security related behaviour throughout the application. The settings can be
 * overridden directly in the code, application module, or from the TDS server.
 */
let SecurityConfig = /**
 * Security related configuration options. These settings are used to drive all
 * security related behaviour throughout the application. The settings can be
 * overridden directly in the code, application module, or from the TDS server.
 */
class SecurityConfig extends ResourceConfig {
    constructor() {
        super(...arguments);
        this.rolesEnabled = true;
        this.storeToken = true;
        this.autoSignIn = true;
        this.authorizationType = 'Bearer';
        this.tokenEndpoint = 'token';
        this.signOutEndpoint = 'api/account/signout';
        this.userInfoEndpoint = 'api/account/userinfo';
        this.usersEndpoint = 'api/users/{id}';
        this.rolesEndpoint = 'api/roles/{id}';
        this.privilegesEndpoint = 'api/privileges/{id}';
        this.userRolesEndpoint = 'api/users/{userId}/roles/{roleName}';
        this.rolesPrivilegesEndpoint = 'api/roles/{roleId}/privileges/{privilegeId}';
        this.tokenStorageKey = '__tss_token';
        this.tokenInvalidationDateLookup = '__tss_token_invalidate_date';
        this.tdsTokenInclusionExpression = '/api/';
        this.withCredentialsInclusionExpression = '(.*?)';
        this.setWithCredentials = false;
        this.accessToken = null;
        this.defaultUserName = null;
        this.defaultPassword = null;
        this.roleSplitterExp = '[,|]+';
        this.tokenBody = (/**
         * @param {?} userName
         * @param {?} password
         * @return {?}
         */
        (userName, password) => `grant_type=password&username=${userName}&password=${password}`);
    }
};
SecurityConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ SecurityConfig.ngInjectableDef = defineInjectable({ factory: function SecurityConfig_Factory() { return new SecurityConfig(); }, token: SecurityConfig, providedIn: "root" });
/**
 * Security related configuration options. These settings are used to drive all
 * security related behaviour throughout the application. The settings can be
 * overridden directly in the code, application module, or from the TDS server.
 */
SecurityConfig = __decorate([
    AutoConfig('SecurityConfig')
], SecurityConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isArray(val) {
    return Array.isArray(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isNumber$1(val) {
    return isType(val, 'number');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RoleManagerService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this.roles = new Set();
        this.roleSplitterExpr = new RegExp(this.config.roleSplitterExp);
    }
    /**
     * @return {?}
     */
    get enabled() {
        return this.config.rolesEnabled;
    }
    /**
     * @return {?}
     */
    get roleCount() {
        return this.roles.size;
    }
    /**
     * @return {?}
     */
    getRoles() {
        return Array.from(this.roles);
    }
    /**
     * @param {?} roles
     * @return {?}
     */
    setRoles(roles) {
        this.clearRoles();
        this.addRoles(roles);
    }
    /**
     * @param {?} roles
     * @return {?}
     */
    addRoles(roles) {
        if (isString(roles) && ((/** @type {?} */ (roles))).includes(',')) {
            roles = this.toArray(((/** @type {?} */ (roles))));
        }
        if (isArray(roles)) {
            ((/** @type {?} */ (roles))).forEach(this.addRole, this);
        }
        else {
            this.addRole((/** @type {?} */ (roles)));
        }
    }
    /**
     * @param {?} role
     * @return {?}
     */
    addRole(role) {
        this.roles.add(String(role).trim());
    }
    /**
     * @return {?}
     */
    clearRoles() {
        this.roles.clear();
    }
    /**
     * @param {?} role
     * @return {?}
     */
    hasRole(role) {
        if (!this.enabled) {
            return true;
        }
        if (!isValue(role)) {
            return false;
        }
        return this.hasRoles(String(role));
    }
    /**
     * @param {?} roles
     * @return {?}
     */
    hasRoles(roles) {
        /** @type {?} */
        let splitRoles;
        if (!this.enabled) {
            return true;
        }
        if (!isValue(roles)) {
            return false;
        }
        splitRoles = this.toArray(roles);
        return String(roles).includes(',')
            ? this.hasAllRoles(splitRoles)
            : this.hasAnyRoles(splitRoles);
    }
    /**
     * @param {?} roles
     * @return {?}
     */
    hasAllRoles(roles) {
        if (!this.enabled) {
            return true;
        }
        if (!isValue(roles)) {
            return false;
        }
        /** @type {?} */
        const roleList = this.toStringArray(roles);
        return roleList.every(this.forRealHasRole.bind(this));
    }
    /**
     * @param {?} roles
     * @return {?}
     */
    hasAnyRoles(roles) {
        if (!this.enabled) {
            return true;
        }
        if (!isValue(roles)) {
            return false;
        }
        /** @type {?} */
        const roleList = this.toStringArray(roles);
        return roleList.some(this.forRealHasRole.bind(this));
    }
    /**
     * @private
     * @param {?} role
     * @return {?}
     */
    forRealHasRole(role) {
        return this.roles.has(String(role).trim());
    }
    /**
     * @private
     * @param {?} roles
     * @return {?}
     */
    toStringArray(roles) {
        /** @type {?} */
        let rolesList = [];
        if (isString(roles)) {
            rolesList = this.toArray((/** @type {?} */ (roles)));
        }
        else if (isNumber$1(roles)) {
            rolesList.push(String(roles));
        }
        else {
            rolesList = (/** @type {?} */ (roles));
        }
        return rolesList;
    }
    /**
     * @private
     * @param {?} roles
     * @return {?}
     */
    toArray(roles) {
        return String(roles).split(this.roleSplitterExpr);
    }
}
RoleManagerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
RoleManagerService.ctorParameters = () => [
    { type: SecurityConfig }
];
/** @nocollapse */ RoleManagerService.ngInjectableDef = defineInjectable({ factory: function RoleManagerService_Factory() { return new RoleManagerService(inject(SecurityConfig)); }, token: RoleManagerService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const SignInState = {
    SignedIn: 0,
    SignedOut: 1,
    SignInFailed: 2,
    SignOutFailed: 3,
};
SignInState[SignInState.SignedIn] = 'SignedIn';
SignInState[SignInState.SignedOut] = 'SignedOut';
SignInState[SignInState.SignInFailed] = 'SignInFailed';
SignInState[SignInState.SignOutFailed] = 'SignOutFailed';
class AuthService {
    /**
     * @param {?} http
     * @param {?} roleMgr
     * @param {?} config
     * @param {?} storage
     * @param {?} log
     */
    constructor(http, roleMgr, config, storage, log) {
        this.http = http;
        this.roleMgr = roleMgr;
        this.config = config;
        this.storage = storage;
        this.log = log;
        this.stateChangeSubject = new Subject();
        this.rememberMe = config.storeToken;
        this.stateChange = this.stateChangeSubject.asObservable();
        if (config.autoSignIn && !this.isAuthenticated) {
            this.loadStoredToken();
        }
    }
    /**
     * @param {?} userName
     * @param {?} password
     * @param {?=} rememberMe
     * @return {?}
     */
    signIn(userName, password, rememberMe = this.rememberMe) {
        /** @type {?} */
        const observable = this.http.post(`${this.config.serviceUrl}/${this.config.tokenEndpoint}`, this.config.tokenBody(userName, password))
            .pipe(publishReplay(1));
        this.rememberMe = rememberMe;
        observable.subscribe(this.onSignedIn.bind(this), this.onSignInFailed.bind(this));
        return observable;
    }
    /**
     * @return {?}
     */
    signOut() {
        /** @type {?} */
        const signOutUrl = `${this.config.serviceUrl}/${this.config.signOutEndpoint}`;
        if (this.isFederatedAccount) {
            this.log.info(`Signing out. Authentication Type: STS. Forwarded to: ${signOutUrl}`);
            this.onSignedOut();
            if (typeof location !== 'undefined') {
                location.href = signOutUrl;
            }
        }
        else {
            // The only reason this "Account" method is abstracted here is because there is additional stuff that
            // has to happen when you sign out - like removing the user information cache, etc.
            /** @type {?} */
            const obserable = this.http.get(signOutUrl)
                .pipe(publishReplay(1));
            obserable
                .subscribe(this.onSignedOut.bind(this), this.onSignedOutFailed.bind(this));
            return obserable;
        }
    }
    /**
     * @return {?}
     */
    getUserInfo() {
        return this.http.get(`${this.config.serviceUrl}/${this.config.userInfoEndpoint}`);
    }
    /**
     * @return {?}
     */
    getToken() {
        return this.isAuthenticated
            ? this.account.access_token || null
            : null;
    }
    /**
     * @return {?}
     */
    loadStoredToken() {
        /** @type {?} */
        const token = this.getLocalToken();
        /** @type {?} */
        let loaded = false;
        if (token && token['.expires']) {
            /** @type {?} */
            const expiresDate = token['.expires'];
            if (expiresDate > new Date()) {
                this.onSignedIn(token, true);
                loaded = true;
            }
        }
        return loaded;
    }
    /**
     * @param {?} account
     * @param {?=} skipLocalStorage
     * @return {?}
     */
    onSignedIn(account, skipLocalStorage = false) {
        this.account = account;
        this.isAuthenticated = true;
        this.isDomainAccount = (account.foundContextType || '').toLowerCase() === 'domain';
        this.isFederatedAccount = (account.authenticationType || '').toLowerCase() === 'federation';
        // Note, we are exposing the access token through the security config because the token intercepter
        // can not use this auth service - it will result in a cyclic dpendency injection error.
        // See Angular issue: https://github.com/angular/angular/issues/18224
        // TODO: Deprecate "accessToken" property on "SecurityConfig" once this is resolved - RG.
        this.config.accessToken = account.access_token;
        this.roleMgr.setRoles(account.privileges || account.roles);
        if (!skipLocalStorage && this.rememberMe) {
            account.lastSignIn = new Date();
            this.setLocalToken(account);
        }
        this.log.debug('User signed in succesfully');
        this.stateChangeSubject.next(SignInState.SignedIn);
    }
    /**
     * @return {?}
     */
    onSignedOut() {
        // We set the "authenticated" flag state to false so that anyone watching this can see the new state and
        // get rid of the account information that was cached, because it is no longer applicable.
        this.isAuthenticated = false;
        this.isDomainAccount = false;
        this.isFederatedAccount = false;
        this.account = null;
        this.roleMgr.clearRoles();
        this.setLocalToken(null);
        this.log.debug('User signed out succesfully');
        this.stateChangeSubject.next(SignInState.SignedOut);
    }
    /**
     * @private
     * @param {?} err
     * @return {?}
     */
    onSignInFailed(err) {
        this.log.error('Failed to sign in', err);
        this.stateChangeSubject.next(SignInState.SignInFailed);
    }
    /**
     * @private
     * @param {?} err
     * @return {?}
     */
    onSignedOutFailed(err) {
        this.log.error('Failed to sign out', err);
        this.stateChangeSubject.next(SignInState.SignOutFailed);
    }
    /**
     * @private
     * @return {?}
     */
    getLocalToken() {
        try {
            /** @type {?} */
            const token = this.storage.getObject(this.config.tokenStorageKey);
            if (token && token.lastSignIn && isString(token.lastSignIn)) {
                token.lastSignIn = new Date(token.lastSignIn);
            }
            if (token && token['.expires'] && isString(token['.expires'])) {
                token['.expires'] = new Date(Date.parse(token['.expires']));
            }
            return token;
        }
        finally {
            // We don't need to do anything bbecause this is not critical path.
        }
    }
    /**
     * @private
     * @param {?} token
     * @return {?}
     */
    setLocalToken(token) {
        try {
            if (token) {
                this.storage.setObject(this.config.tokenStorageKey, token);
            }
            else {
                this.storage.remove(this.config.tokenStorageKey);
            }
        }
        finally {
            // We don't need to do anything as this is not a core workflow.
        }
    }
}
AuthService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AuthService.ctorParameters = () => [
    { type: HttpClient },
    { type: RoleManagerService },
    { type: SecurityConfig },
    { type: PersistentStorage },
    { type: Logger }
];
/** @nocollapse */ AuthService.ngInjectableDef = defineInjectable({ factory: function AuthService_Factory() { return new AuthService(inject(HttpClient), inject(RoleManagerService), inject(SecurityConfig), inject(PersistentStorage), inject(Logger)); }, token: AuthService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class BaseResourceService extends BaseEmptyResourceService {
    /**
     * @param {?} http
     * @param {?} paramsOrUrl
     */
    constructor(http, paramsOrUrl) {
        super(http, paramsOrUrl);
        this.http = http;
    }
    /**
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    query(routeTokens, params) {
        /** @type {?} */
        const url = this.getUrl(this.config.queryEndpoint, routeTokens);
        return this.http.get(url, { params });
    }
    /**
     * @param {?} id
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    get(id, routeTokens, params) {
        /** @type {?} */
        const url = this.getUrlWithId(id, this.config.getEndpoint, routeTokens);
        return this.http.get(url, { params });
    }
    /**
     * @param {?} entity
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    create(entity, routeTokens, params) {
        /** @type {?} */
        const url = this.getUrl(this.config.createEndpoint, routeTokens);
        return this.http.post(url, entity, { params });
    }
    /**
     * @param {?} entity
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    update(entity, routeTokens, params) {
        /** @type {?} */
        const url = this.getUrlWithEntity(entity, this.config.updateEndpoint, routeTokens);
        return this.http.put(url, entity, { params });
    }
    /**
     * @param {?} id
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    delete(id, routeTokens, params) {
        /** @type {?} */
        const url = this.getUrlWithId(id, this.config.deleteEndpoint, routeTokens);
        return this.http.delete(url, { params });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppProfileService extends BaseResourceService {
    /**
     * @param {?} http
     * @param {?} config
     */
    constructor(http, config) {
        super(http, {
            url: join(config.serviceUrl, config.appProfileEndpoint),
            defaultRouteTokens: {
                appId: config.appId
            }
        });
        this.http = http;
    }
}
AppProfileService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AppProfileService.ctorParameters = () => [
    { type: HttpClient },
    { type: AppConfig }
];
/** @nocollapse */ AppProfileService.ngInjectableDef = defineInjectable({ factory: function AppProfileService_Factory() { return new AppProfileService(inject(HttpClient), inject(AppConfig)); }, token: AppProfileService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Application initialization service that is responsible for bootstrapping
 * the application.
 */
class AppInitializerService {
    /**
     * @param {?} router
     * @param {?} auth
     * @param {?} appProfiles
     * @param {?} log
     * @param {?} config
     * @param {?} storage
     * @param {?} securityConfig
     * @param {?} roleMgr
     * @param {?} injector
     */
    constructor(router, auth, appProfiles, log, config, storage, securityConfig, roleMgr, injector) {
        this.router = router;
        this.auth = auth;
        this.appProfiles = appProfiles;
        this.log = log;
        this.config = config;
        this.storage = storage;
        this.securityConfig = securityConfig;
        this.roleMgr = roleMgr;
        this.injector = injector;
        this.ready = false;
        this.loading = false;
        this.moduleConfigInstances = new Map();
        this.queryParameters = getQueryParams();
        this.onReady = new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this.resolveFn = resolve;
            this.rejectFn = reject;
        }));
    }
    /**
     * Initializes/bootstraps a standard TSS application.
     * @return {?}
     */
    initialize() {
        /** @type {?} */
        const appId = this.config.appId;
        const [firstRoutePath] = this.router.url.split('/');
        /** @type {?} */
        const profileId = this.queryParameters.profileId
            || firstRoutePath
            || getFirstHashRoutePath(getFullUrl())
            || this.config.defaultProfileId;
        // We override module configurations here because the user may be trying to debug the session. The
        // override has to happen again at the end of the process to override any settings that may have
        // been set through the app initialization process.
        this.overrideModuleConfigurationsFromQueryParams();
        this.log.debug(`Initializing application with profile ID: ${profileId}`);
        // We need to try and read any stored security token before we make
        // a request to get profile info, so that the request is authenticated.
        this.auth.loadStoredToken();
        this.populateModuleConfigInstances();
        if (!this.config.queryProfile || !this.config.hasServiceUrl) {
            this.config.profile = {
                name: '',
                appId,
                id: profileId,
            };
            this.log.debug(this.config.hasServiceUrl
                ? `Profile query skipped due to configuration option`
                : `No service URL configured, can't retrieve profile details - skipping profile retrieval`);
            this.overrideModuleConfigurationsFromQueryParams();
            this.ready = true;
            this.resolveFn(this.config.profile);
        }
        else {
            this.loading = true;
            // We need to try and read any stored security token before we make
            // a request to get profile info, so that the request is authenticated.
            this.queryProfile(profileId)
                .then((/**
             * @param {?} profile
             * @return {?}
             */
            (profile) => this.resolveFn(profile)))
                .catch((/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                if (this.config.continueOnAppBootstrapError) {
                    this.resolveFn(this.config.profile);
                }
                else {
                    this.rejectFn(err);
                }
            }));
        }
    }
    /**
     * @private
     * @param {?} profileId
     * @return {?}
     */
    queryProfile(profileId) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this.appProfiles.get(profileId)
                .subscribe((/**
             * @param {?} profile
             * @return {?}
             */
            (profile) => {
                if (!profile) {
                    return reject(`No profile found with ID '${profileId}'`);
                }
                this.config.profileId = profile.id;
                this.config.profile = profile;
                this.checkTokenInvalidationDate();
                this.applyModuleConfigurations();
                this.overrideModuleConfigurationsFromQueryParams();
                this.retrieveUserAccount()
                    .then((/**
                 * @return {?}
                 */
                () => {
                    this.configureRoleManager();
                    this.ready = true;
                    this.loading = false;
                    resolve(profile);
                }))
                    .catch((/**
                 * @param {?} err
                 * @return {?}
                 */
                (err) => {
                    this.loading = false;
                    reject(err);
                }));
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                this.loading = false;
                this.log.error(`Failed to retrieve application profile with app ID '${this.config.appId}' and ID '${profileId}'`);
                reject(err);
            }));
        }));
    }
    /**
     * Gets the date of the cached "invalidation" date.
     * The invalidation date is used to let the server force users to re-authenticate.
     * @private
     * @return {?}
     */
    getCachedTokenInvalidationDate() {
        return new Date(this.storage.get(this.securityConfig.tokenInvalidationDateLookup));
    }
    /**
     * Caches the "invalidation" date.
     * The invalidation date is used to let the server force users to re-authenticate.
     * @private
     * @param {?=} setDate
     * @return {?}
     */
    setCachedTokenExpireDate(setDate) {
        this.log.debug(`Setting cached token invalidation date: ${setDate}`);
        if (setDate) {
            this.log.debug(`Setting token invalidation date to: ${setDate}`);
            this.storage.set(this.securityConfig.tokenInvalidationDateLookup, setDate);
        }
        else {
            this.storage.remove(this.securityConfig.tokenInvalidationDateLookup);
        }
    }
    /**
     * Compares the cached token validation data with the invalidation date from the server.
     * If the invalidation date from the server is new than the cached date, then the user
     * must be forcibly signed out.
     * @private
     * @return {?}
     */
    checkTokenInvalidationDate() {
        /** @type {?} */
        let tokenExpireDate;
        /** @type {?} */
        const siteInfo = this.config.profile && this.config.profile.app && this.config.profile.app.siteInfo
            ? this.config.profile.app.siteInfo
            : null;
        if (siteInfo && siteInfo[AppInitializerService.tokenExpireDateKey]) {
            /** @type {?} */
            const lastTokenInvalidateDate = this.getCachedTokenInvalidationDate();
            tokenExpireDate = new Date(siteInfo[AppInitializerService.tokenExpireDateKey]);
            // Note, we are setting milliseconds to 0 because we don't care about that level of accuracy.
            // Also, the "setMilliseconds" method returns the "timestamp" so we can just compare those two results.
            /** @type {?} */
            const lastTokenValidationDatesMatch = isDate$1(lastTokenInvalidateDate) && isDate$1(tokenExpireDate)
                ? lastTokenInvalidateDate.setMilliseconds(0) === tokenExpireDate.setMilliseconds(0)
                : lastTokenInvalidateDate === tokenExpireDate;
            if (this.auth.account && this.auth.account.lastSignIn < tokenExpireDate && !lastTokenValidationDatesMatch) {
                this.log.info('Signing out user due to token invalidation date from security configuration');
                this.auth.onSignedOut();
            }
            else if (this.auth.account) {
                this.log.debug('User has been authenticated after the token invalidation date');
            }
            if (tokenExpireDate) {
                this.setCachedTokenExpireDate(tokenExpireDate);
            }
        }
    }
    /**
     * Retrieves the user account if the user is already signed in, logs the user out if
     * the token is expired, or refreshes the user account information - depending on
     * the configured authentication provider.
     * @private
     * @return {?}
     */
    retrieveUserAccount() {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            try {
                /** @type {?} */
                let queryingInfo = false;
                /** @type {?} */
                const app = this.config.profile && this.config.profile.app
                    ? this.config.profile.app : null;
                // If the local auth status says that no one is logged in, but the service is recognizing that someone is
                // logged in, then this means that authentication is happening through windows via Active Directory or some
                // other means. We need to get the user info so we can set the app "state" as "logged in".
                if (app && app.security && !this.auth.isAuthenticated && app.security.isAuthenticated) {
                    this.log.debug('Retrieving additional user info do to authentication state');
                    queryingInfo = true;
                    this.auth.getUserInfo().subscribe((/**
                     * @param {?} info
                     * @return {?}
                     */
                    info => {
                        /** @type {?} */
                        const expiresDate = new Date();
                        expiresDate.setDate(expiresDate.getDate() + app.security.accessTokenExpireDays);
                        this.auth.onSignedIn(Object.assign({ '.expires': expiresDate }, info));
                        resolve(info);
                    }), (/**
                     * @param {?} err
                     * @return {?}
                     */
                    err => {
                        reject(err);
                    }));
                }
                else if (this.auth.isAuthenticated && app.security && !app.security.isAuthenticated) {
                    this.log.debug(`Signing out user do to out of sync authentication state`);
                    // Sign out/clear the auth cache because the server says they don't know who this is, but
                    // the client side code thinks it knows who it is.
                    this.auth.onSignedOut();
                }
                if (!queryingInfo) {
                    this.log.debug(`No request made for additional user account info`);
                    resolve(this.auth.account);
                }
            }
            catch (e) {
                this.log.error('Failed to do pre-verification of user on app load. {0}', e);
                reject(e);
            }
        }));
    }
    /**
     * Set module configuration properties based on overrides from an object.
     * This object can come from multiple places - such as the server or query params.
     * See: the "applyModuleConfigurations" and "overrideModuleConfigurations" methods.
     * @private
     * @param {?} sourceMapping
     * @return {?}
     */
    applyModuleConfigurationsFromObject(sourceMapping) {
        sourceMapping = sourceMapping || {};
        this.moduleConfigInstances
            .forEach((/**
         * @param {?} config
         * @return {?}
         */
        config => {
            /** @type {?} */
            const moduleConfigName = config.config.className;
            /** @type {?} */
            const configInstance = config.instance;
            Object.keys(sourceMapping)
                .forEach((/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                /** @type {?} */
                const value = toPrimitiveType(sourceMapping[key]);
                /** @type {?} */
                const modulePrefix = lowerCaseFirst(moduleConfigName + '.');
                /** @type {?} */
                const rootKey = key.replace(modulePrefix, '');
                if (isValue(value) && key.toLowerCase().startsWith(modulePrefix.toLowerCase())) {
                    // A config object has properties in our siteInfo object.
                    this.log.debug(`Setting ${moduleConfigName} property '${rootKey}' to ${value}`);
                    setValue(configInstance, rootKey, value);
                }
            }));
        }));
    }
    /**
     * Set module configuration properties based on overrides from the server.
     * This functionality lets us dynamically override client side configuration
     * through the use of "App Settings" from the server.
     * @private
     * @return {?}
     */
    applyModuleConfigurations() {
        /** @type {?} */
        const profile = this.config.profile;
        if (!profile || !profile.app || !profile.app.siteInfo) {
            return;
        }
        this.applyModuleConfigurationsFromObject(profile.app.siteInfo);
    }
    /**
     * Set module configuration properties based on overrides from the URL query parameters.
     * This functionality lets us dynamically override client side and server side configurations
     * by passing explicit settings through query parameters. A good use case for this is to pass
     * "coreConfig.logLevel=1" as a query parameter in production to debug an issue in a production
     * environment.
     * @private
     * @return {?}
     */
    overrideModuleConfigurationsFromQueryParams() {
        if (this.config.allowQueryParamInjections) {
            this.applyModuleConfigurationsFromObject(this.queryParameters);
        }
    }
    /**
     * Instantiates instances of each configured module configuration object. Properties of
     * these module config instances will later be set based on server-side overides.
     * @private
     * @return {?}
     */
    populateModuleConfigInstances() {
        CoreConfig.moduleConfigs
            .forEach((/**
         * @param {?} moduleAutoConfig
         * @return {?}
         */
        moduleAutoConfig => {
            try {
                // Reason: https://github.com/angular/angular/issues/22063
                // tslint:disable-next-line
                /** @type {?} */
                const configInstance = this.injector.get(moduleAutoConfig.injectorToken);
                this.moduleConfigInstances.set(moduleAutoConfig.injectorToken, {
                    instance: configInstance,
                    config: moduleAutoConfig
                });
                this.log.debug(`Created module configuration instance for: ${moduleAutoConfig.className}`);
                if ('serviceUrl' in configInstance || 'hasServiceUrl' in configInstance) {
                    configInstance.serviceUrl = this.config.serviceUrl;
                }
            }
            catch (err) {
                this.log.error(`Failed to get module config: ${moduleAutoConfig.className}`, err);
            }
        }));
    }
    /**
     * Updates security options based on information retrieved form the application profile.
     * For example, security may be enabled or disabled, guest roles will be set, etc.
     * @private
     * @return {?}
     */
    configureRoleManager() {
        /** @type {?} */
        const security = this.config.profile && this.config.profile.app && this.config.profile.app.security
            ? this.config.profile.app.security : null;
        if (!security) {
            return;
        }
        // We want to explicitly
        if (security.hasOwnProperty('enabled')) {
            this.securityConfig.rolesEnabled = !!security.enabled;
        }
        if (!this.roleMgr.enabled) {
            this.log.warn('Security is disabled');
        }
        security.guestPrivileges = security.guestPrivileges || [];
        this.roleMgr.addRoles(security.guestPrivileges);
        this.log.info(`Configured default roles (guest roles) - total of ${security.guestPrivileges.length}`);
        this.log.info(`User has a total of ${this.roleMgr.roleCount} roles assigned to them`);
    }
}
AppInitializerService.tokenExpireDateKey = 'token-expire-date';
AppInitializerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AppInitializerService.ctorParameters = () => [
    { type: Router },
    { type: AuthService },
    { type: AppProfileService },
    { type: Logger },
    { type: AppConfig },
    { type: PersistentStorage },
    { type: SecurityConfig },
    { type: RoleManagerService },
    { type: Injector }
];
/** @nocollapse */ AppInitializerService.ngInjectableDef = defineInjectable({ factory: function AppInitializerService_Factory() { return new AppInitializerService(inject(Router), inject(AuthService), inject(AppProfileService), inject(Logger), inject(AppConfig), inject(PersistentStorage), inject(SecurityConfig), inject(RoleManagerService), inject(INJECTOR)); }, token: AppInitializerService, providedIn: "root" });
/**
 * Application initialization factory that provides a hook into
 * the Angular bootstrapping process.
 * @param {?} injector
 * @return {?}
 */
function AppInitializerFactory(injector) {
    return (/**
     * @return {?}
     */
    () => {
        /** @type {?} */
        const initializer = injector.get(AppInitializerService);
        initializer.initialize();
        return initializer.onReady;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ALL_APPS_QUERY_ID = 'all';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KeysPipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        /** @type {?} */
        const keys = [];
        Object.keys(value)
            .forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => keys.push({ key, value: value[key] })));
        return keys;
    }
}
KeysPipe.decorators = [
    { type: Pipe, args: [{ name: 'keys' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileSizePipe {
    /**
     * @param {?=} bytes
     * @return {?}
     */
    transform(bytes = 0) {
        return formatByteSize(bytes);
    }
}
FileSizePipe.decorators = [
    { type: Pipe, args: [{ name: 'fileSize' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const STANDARDIZED_QUERY_DATE_FORMAT = `timestamp '{date}'`;
/** @type {?} */
const ORACLE_DATE_FORMAT = `TO_DATE('{date}','YYYY-MM-DD HH24:MI:SS')`;
/** @type {?} */
const DEFAULT_DATE_FORMAT = 'yyyy-MM-dd HH:mm:ss';
/** @type {?} */
const HOURS_PER_DAY = 24;
/** @type {?} */
const MINUTES_PER_HOUR = 60;
/** @type {?} */
const SECONDS_PER_MINUTE = 60;
/** @type {?} */
const MILLISECONDS_PER_SECOND = 1000;
/** @type {?} */
const MILLISECONDS_PER_MINUTE = 60000;
/** @type {?} */
const MILLISECONDS_PER_HOUR = 3600000;
/** @type {?} */
const MILLISECONDS_PER_DAY = 86400000;
/** @type {?} */
const READABLE_TIME_SUFFIX_MAP = {
    ms: 'ms',
    msDecimalPlaces: 0,
    sec: 'sec',
    secDecimalPlaces: 0,
    min: 'min',
    minDecimalPlaces: 2,
    hr: 'hr',
    hrDecimalPlaces: 2,
    days: 'days',
    daysDecimalPlaces: 2,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @param {?} unitOfTime
 * @return {?}
 */
function toMilliseconds(value, unitOfTime) {
    /** @type {?} */
    let conversionFactor;
    if (unitOfTime === 'milliseconds') {
        conversionFactor = 1;
    }
    else if (unitOfTime === 'seconds') {
        conversionFactor = MILLISECONDS_PER_SECOND;
    }
    else if (unitOfTime === 'minutes') {
        conversionFactor = MILLISECONDS_PER_MINUTE;
    }
    else if (unitOfTime === 'hours') {
        conversionFactor = MILLISECONDS_PER_HOUR;
    }
    else if (unitOfTime === 'days') {
        conversionFactor = MILLISECONDS_PER_DAY;
    }
    else {
        throw new Error(`Unsuported unit of time supplied: '${unitOfTime}'`);
    }
    return (value || 0) * conversionFactor;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} milliseconds
 * @return {?}
 */
function millisecondsToSeconds(milliseconds) {
    return milliseconds / MILLISECONDS_PER_SECOND;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} milliseconds
 * @return {?}
 */
function millisecondsToMinutes(milliseconds) {
    return milliseconds / MILLISECONDS_PER_MINUTE;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} milliseconds
 * @return {?}
 */
function millisecondsToHours(milliseconds) {
    return milliseconds / MILLISECONDS_PER_HOUR;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} milliseconds
 * @return {?}
 */
function millisecondsToDays(milliseconds) {
    return milliseconds / MILLISECONDS_PER_DAY;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} milliseconds
 * @param {?=} suffixMap
 * @return {?}
 */
function toReadableTime(milliseconds, suffixMap = {}) {
    // TODO: Get rid of magic numbers below - RG.
    /** @type {?} */
    const formatAsMilliseconds = milliseconds < MILLISECONDS_PER_SECOND;
    /** @type {?} */
    const formatAsSeconds = milliseconds < (MILLISECONDS_PER_MINUTE - 1);
    /** @type {?} */
    const formatAsMinutes = milliseconds < (MILLISECONDS_PER_HOUR - 299);
    /** @type {?} */
    const formatAsHours = milliseconds < (MILLISECONDS_PER_DAY - 18000);
    /** @type {?} */
    let value = milliseconds;
    /** @type {?} */
    let unit;
    /** @type {?} */
    let decimalPlaces;
    suffixMap = suffixMap
        ? Object.assign({}, READABLE_TIME_SUFFIX_MAP, suffixMap)
        : READABLE_TIME_SUFFIX_MAP;
    // We assume the milliseconds was passed in.
    if (formatAsMilliseconds) {
        // The time should be shown in milliseconds.
        unit = suffixMap.ms;
        value = milliseconds;
        decimalPlaces = suffixMap.msDecimalPlaces;
    }
    else if (formatAsSeconds) {
        // The time should be shown in seconds.
        /** @type {?} */
        const seconds = millisecondsToSeconds(milliseconds);
        unit = suffixMap.sec;
        value = seconds;
        decimalPlaces = suffixMap.secDecimalPlaces;
    }
    else if (formatAsMinutes) {
        // The time should be shown in in minutes.
        /** @type {?} */
        const minutes = millisecondsToMinutes(milliseconds);
        unit = suffixMap.min;
        value = minutes;
        decimalPlaces = suffixMap.minDecimalPlaces;
    }
    else if (formatAsHours) {
        // The time should be shown in hours.
        /** @type {?} */
        const hours = millisecondsToHours(milliseconds);
        unit = suffixMap.hr;
        value = hours;
        decimalPlaces = suffixMap.hrDecimalPlaces;
    }
    else {
        // The time should be shown in days.
        /** @type {?} */
        const days = millisecondsToDays(milliseconds);
        unit = suffixMap.days;
        value = days;
        decimalPlaces = suffixMap.daysDecimalPlaces;
    }
    /** @type {?} */
    const numberWithStrippedZeros = Number(value.toFixed(decimalPlaces));
    return `${numberWithStrippedZeros} ${unit}`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ReadableTimePipe {
    /**
     * @param {?} time
     * @param {?=} unit
     * @return {?}
     */
    transform(time, unit = 'milliseconds') {
        /** @type {?} */
        const millis = toMilliseconds(time, unit);
        return toReadableTime(millis);
    }
}
ReadableTimePipe.decorators = [
    { type: Pipe, args: [{ name: 'readableTime' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SafeUrlPipe {
    /**
     * @param {?} sanitizer
     */
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    transform(url) {
        return this.sanitizer.bypassSecurityTrustResourceUrl(url);
    }
}
SafeUrlPipe.decorators = [
    { type: Pipe, args: [{ name: 'safeUrl' },] }
];
/** @nocollapse */
SafeUrlPipe.ctorParameters = () => [
    { type: DomSanitizer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssCoreModule {
}
TssCoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [
                    FileSizePipe,
                    KeysPipe,
                    ReadableTimePipe,
                    SafeUrlPipe,
                ],
                exports: [
                    FileSizePipe,
                    KeysPipe,
                    ReadableTimePipe,
                    SafeUrlPipe
                ],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssGeometryModule {
}
TssGeometryModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TssCoreModule,
                ],
                declarations: [],
                exports: [],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssDataSourceModule {
}
TssDataSourceModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TssCoreModule,
                    HttpClientModule,
                ],
                declarations: [],
                exports: [],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssEsriModule {
}
TssEsriModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    TssCoreModule,
                    TssDataSourceModule,
                ],
                declarations: [],
                exports: [],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LAYER_RENDER_TYPES = [
    { alias: 'Single Value', renderType: 'simple', description: 'Displays a single symbology, regardless of values' },
    { alias: 'Unique Value', renderType: 'uniqueValue', description: 'Displays different symbologies based on a unique value' },
    { alias: 'Class Break', renderType: 'classBreaks', description: 'Displays different symbologies based on a classification of values' },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LayerRendererTypePipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        /** @type {?} */
        const renderType = isString(input)
            ? (/** @type {?} */ (input))
            : ((/** @type {?} */ (input))).type;
        /** @type {?} */
        const definition = LAYER_RENDER_TYPES
            .find((/**
         * @param {?} t
         * @return {?}
         */
        t => t.renderType === renderType));
        return definition.alias;
    }
}
LayerRendererTypePipe.decorators = [
    { type: Pipe, args: [{ name: 'layerRendererType' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssMapsModule {
}
TssMapsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TssCoreModule,
                ],
                declarations: [
                    LayerRendererTypePipe
                ],
                exports: [
                    LayerRendererTypePipe
                ],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssLrsModule {
}
TssLrsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TssCoreModule,
                    TssDataSourceModule,
                    HttpClientModule,
                ],
                declarations: [],
                exports: [],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TokenInterceptor {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        /** @type {?} */
        const withCredsExpr = new RegExp(this.config.withCredentialsInclusionExpression);
        if (this.config.accessToken && new RegExp(this.config.tdsTokenInclusionExpression).test(request.url)) {
            request = request.clone({
                withCredentials: this.config.setWithCredentials && withCredsExpr.test(request.url),
                setHeaders: {
                    Authorization: `${this.config.authorizationType} ${this.config.accessToken}`
                }
            });
        }
        else if (this.config.setWithCredentials && withCredsExpr.test(request.url)) {
            request = request.clone({
                withCredentials: true
            });
        }
        return next.handle(request);
    }
}
TokenInterceptor.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TokenInterceptor.ctorParameters = () => [
    { type: SecurityConfig }
];
/** @nocollapse */ TokenInterceptor.ngInjectableDef = defineInjectable({ factory: function TokenInterceptor_Factory() { return new TokenInterceptor(inject(SecurityConfig)); }, token: TokenInterceptor, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HasRolesDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainer
     * @param {?} roleMgr
     * @param {?} log
     */
    constructor(templateRef, viewContainer, roleMgr, log) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.roleMgr = roleMgr;
        this.log = log;
    }
    /**
     * @param {?} roles
     * @return {?}
     */
    set hasRoles(roles) {
        if (this.roleMgr.hasRoles(roles)) {
            // If condition is true add template to DOM
            this.viewContainer.createEmbeddedView(this.templateRef);
            this.log.trace(`Granted access: ${roles}`);
        }
        else {
            // Else remove template from DOM
            this.viewContainer.clear();
            this.log.trace(`Denied access: ${roles}`);
        }
    }
}
HasRolesDirective.decorators = [
    { type: Directive, args: [{
                // TODO: remove this once this is moved to it's own package - RG.
                // tslint:disable-next-line
                selector: '[hasRoles]'
            },] }
];
/** @nocollapse */
HasRolesDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: RoleManagerService },
    { type: Logger }
];
HasRolesDirective.propDecorators = {
    hasRoles: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssSecurityModule {
}
TssSecurityModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    FormsModule,
                    TssCoreModule
                ],
                declarations: [
                    HasRolesDirective,
                ],
                exports: [
                    HasRolesDirective,
                ],
                providers: [
                    {
                        provide: HTTP_INTERCEPTORS,
                        useClass: TokenInterceptor,
                        multi: true
                    }
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PreventDefaultLinkDirective {
    /**
     * @param {?} event
     * @return {?}
     */
    preventDefault(event) {
        if (!this.href.length) {
            event.preventDefault();
        }
    }
}
PreventDefaultLinkDirective.decorators = [
    { type: Directive, args: [{
                // TODO: remove this once this is moved to it's own package - RG.
                // tslint:disable-next-line
                selector: '[href]'
            },] }
];
PreventDefaultLinkDirective.propDecorators = {
    href: [{ type: Input }],
    preventDefault: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssPolyfillModule {
}
TssPolyfillModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [
                    PreventDefaultLinkDirective,
                ],
                exports: [
                    PreventDefaultLinkDirective,
                ],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Queue module provides data queueing and core unit of work queue functionality.
 */
class TssQueueModule {
}
TssQueueModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [],
                exports: [],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isFunction(val) {
    return isType(val, 'function');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} route
 * @param {?} routeExpression
 * @return {?}
 */
function isRouteMatch(route, routeExpression) {
    /** @type {?} */
    let exp;
    if (isFunction(routeExpression)) {
        return Boolean(((/** @type {?} */ (routeExpression)))(route));
    }
    if (isString(routeExpression)) {
        // NOTE: We are replacing the friendly route matching with real regex.
        /** @type {?} */
        const wildcardExp = new RegExp('[*]', 'gi');
        /** @type {?} */
        const routeAsString = (/** @type {?} */ (routeExpression));
        /** @type {?} */
        const resolvedRoute = replaceTokens(routeAsString, '*')
            .replace(wildcardExp, '.*');
        exp = new RegExp(resolvedRoute, 'i');
    }
    else {
        exp = (/** @type {?} */ (routeExpression));
    }
    return exp.test(route);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing global data caching settings.
 */
let HttpConfig = /**
 * Configuration class for storing global data caching settings.
 */
class HttpConfig {
    constructor() {
        this.paramInjectionsEnabled = true;
        this.paramInjectionDefitions = [];
    }
    /**
     * @return {?}
     */
    get hasInjections() {
        return Boolean(this.paramInjectionDefitions.length);
    }
    /**
     * @param {?} route
     * @param {?} paramName
     * @param {?} paramValue
     * @return {?}
     */
    addOrUpdateParameterInjection(route, paramName, paramValue) {
        /** @type {?} */
        const definition = {
            route,
            paramName,
            paramValue
        };
        /** @type {?} */
        const existingDefinition = this.paramInjectionDefitions.find((/**
         * @param {?} def
         * @return {?}
         */
        def => def.route === route && def.paramName === paramName));
        if (existingDefinition) {
            Object.assign(existingDefinition, definition);
            return existingDefinition;
        }
        else {
            this.paramInjectionDefitions.push(definition);
            return definition;
        }
    }
    /**
     * @param {?} route
     * @param {?} paramName
     * @param {?} paramValue
     * @return {?}
     */
    addParameterInjection(route, paramName, paramValue) {
        /** @type {?} */
        const definition = {
            route,
            paramName,
            paramValue
        };
        this.paramInjectionDefitions.push(definition);
        return definition;
    }
    /**
     * @param {?} route
     * @return {?}
     */
    getInjectionDefinitions(route) {
        return this.paramInjectionDefitions.filter((/**
         * @param {?} def
         * @return {?}
         */
        def => isRouteMatch(route, def.route)));
    }
    /**
     * @param {?} route
     * @return {?}
     */
    getFirstInjectionDefinition(route) {
        return this.paramInjectionDefitions.find((/**
         * @param {?} def
         * @return {?}
         */
        def => isRouteMatch(route, def.route)));
    }
};
HttpConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ HttpConfig.ngInjectableDef = defineInjectable({ factory: function HttpConfig_Factory() { return new HttpConfig(); }, token: HttpConfig, providedIn: "root" });
/**
 * Configuration class for storing global data caching settings.
 */
HttpConfig = __decorate([
    AutoConfig('HttpConfig')
], HttpConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpParamInterceptor {
    /**
     * @param {?} config
     * @param {?} log
     */
    constructor(config, log) {
        this.config = config;
        this.log = log;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        /** @type {?} */
        const httpParamInjections = this.config.paramInjectionsEnabled
            ? this.config.getInjectionDefinitions(request.urlWithParams)
            : [];
        if (httpParamInjections.length) {
            request = this.generateRequestWithParams(request, httpParamInjections);
        }
        return next.handle(request);
    }
    /**
     * @param {?} request
     * @param {?} httpParamInjections
     * @return {?}
     */
    generateRequestWithParams(request, httpParamInjections) {
        /** @type {?} */
        let params = request.params;
        httpParamInjections
            .forEach((/**
         * @param {?} paramInjection
         * @return {?}
         */
        paramInjection => {
            this.log.debug(`Injecting URL '${request.url}' with parameter value (name: '${paramInjection.paramName}')`);
            params = params.set(paramInjection.paramName, paramInjection.paramValue);
        }));
        return request.clone({ params });
    }
}
HttpParamInterceptor.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
HttpParamInterceptor.ctorParameters = () => [
    { type: HttpConfig },
    { type: Logger }
];
/** @nocollapse */ HttpParamInterceptor.ngInjectableDef = defineInjectable({ factory: function HttpParamInterceptor_Factory() { return new HttpParamInterceptor(inject(HttpConfig), inject(Logger)); }, token: HttpParamInterceptor, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssHttpModule {
}
TssHttpModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    TssCoreModule,
                ],
                declarations: [],
                exports: [],
                providers: [
                    {
                        provide: HTTP_INTERCEPTORS,
                        useClass: HttpParamInterceptor,
                        multi: true
                    }
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = AppInitializerFactory;
class TssAppModule {
}
TssAppModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    HttpClientModule,
                    RouterModule,
                    TssCoreModule,
                    TssPolyfillModule,
                    TssHttpModule,
                    TssDataSourceModule,
                    TssQueueModule,
                    TssSecurityModule,
                ],
                declarations: [],
                exports: [],
                providers: [
                    AppProfileService,
                    ApiService,
                    AppInitializerService,
                    {
                        provide: APP_INITIALIZER,
                        useFactory: ɵ0,
                        multi: true,
                        deps: [Injector]
                    }
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssAppSpatialModule {
}
TssAppSpatialModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    TssAppModule,
                    TssEsriModule,
                    TssGeometryModule,
                    TssMapsModule,
                    TssLrsModule,
                ],
                declarations: [],
                exports: [],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ALL_APP_SETTINGS_QUERY_ID = 'all';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppSettingService extends BaseResourceService {
    /**
     * @param {?} http
     * @param {?} config
     */
    constructor(http, config) {
        super(http, {
            url: join(config.serviceUrl, config.appSettingsEndpoint),
            defaultRouteTokens: {
                appId: config.appId
            }
        });
        this.http = http;
    }
    /**
     * Retrieves a list of application settings.
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    queryAllApps(routeTokens, params) {
        routeTokens = routeTokens || {};
        routeTokens.appId = ALL_APP_SETTINGS_QUERY_ID;
        return super.query(routeTokens, params);
    }
}
AppSettingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AppSettingService.ctorParameters = () => [
    { type: HttpClient },
    { type: AppConfig }
];
/** @nocollapse */ AppSettingService.ngInjectableDef = defineInjectable({ factory: function AppSettingService_Factory() { return new AppSettingService(inject(HttpClient), inject(AppConfig)); }, token: AppSettingService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const CachePersistence = {
    Persistent: 'persistent',
    InMemory: 'in-memory',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const CacheStrategy = {
    NetworkFirst: 'network-first',
    CacheFirst: 'cache-first',
    Fastest: 'fastest',
    CacheOnly: 'cache-only',
};

var CacheConfig_1;
/**
 * Configuration class for storing global data caching settings.
 */
let CacheConfig = CacheConfig_1 = /**
 * Configuration class for storing global data caching settings.
 */
class CacheConfig {
    constructor() {
        /**
         * Determines whether caching should be used or not. When disabled, all
         * caching-related functionality is ignored (not used).
         */
        this.cacheEnabled = false;
        /**
         * List of configurations that describe what to cache and how to cache it.
         * The main parts of this configuration include the "route" (how to match what
         * to cache) and the "strategy" (whether to look for content in the cache first
         * or try to make the HTTP request first).
         */
        this.cacheDefitions = [];
        /**
         * When set, this strategy will trump all strategies defined in the "Cache Defintions".
         * WARNING: This is a global setting and can have adverse affects when used improperly.
         * The main use case for this setting is to allow for the global cache strategy of
         * 'cacheOnly', which will allow an application to force an "offline" state (forcing
         * requests to pull from cache only).
         */
        this.forcedGlobalCacheStrategy = null;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    static create(config) {
        return Object.assign(new CacheConfig_1(), config);
    }
    /**
     * @param {...?} defs
     * @return {?}
     */
    static enable(...defs) {
        return CacheConfig_1.create({
            cacheEnabled: true,
            cacheDefitions: defs,
        });
    }
    /**
     * @param {?} route
     * @return {?}
     */
    getCacheDefinition(route) {
        return this.cacheDefitions.find((/**
         * @param {?} def
         * @return {?}
         */
        def => isRouteMatch(route, def.route)));
    }
};
CacheConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ CacheConfig.ngInjectableDef = defineInjectable({ factory: function CacheConfig_Factory() { return new CacheConfig(); }, token: CacheConfig, providedIn: "root" });
/**
 * Configuration class for storing global data caching settings.
 */
CacheConfig = CacheConfig_1 = __decorate([
    AutoConfig('CacheConfig')
], CacheConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CACHE_ONLY_NO_DATA_EXC_MSG = 'No cache available';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CACHE_STORAGE_KEY_PREFIX = 'http-cache:';
/**
 * Configuration class for storing global data caching settings.
 */
class PersistentCacheStorage extends PersistentStorage {
    constructor() {
        super();
        this.keyPrefix = CACHE_STORAGE_KEY_PREFIX;
    }
}
PersistentCacheStorage.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PersistentCacheStorage.ctorParameters = () => [];
/** @nocollapse */ PersistentCacheStorage.ngInjectableDef = defineInjectable({ factory: function PersistentCacheStorage_Factory() { return new PersistentCacheStorage(); }, token: PersistentCacheStorage, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Cache Service is an observables based in-memory cache implementation
 * Keeps track of in-flight observables and sets a default expiry for cached values
 */
class CacheService {
    /**
     * @param {?} cache
     */
    constructor(cache) {
        this.cache = cache;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    get(key) {
        /** @type {?} */
        const cacheItem = this.cache.getObject(key);
        /** @type {?} */
        const now = new Date();
        /** @type {?} */
        let cacheData;
        if (cacheItem && cacheItem.expires && cacheItem.expires.getTime() < now.getTime()) {
            this.cache.remove(key);
        }
        else if (cacheItem) {
            // NOTE: We can't just pull the serialized data, because
            // we need an actual instance of the HttpResponse class.
            cacheData = Object.assign(new HttpResponse(), cacheItem.value);
        }
        else {
            cacheData = null;
        }
        return cacheData;
    }
    /**
     * @param {?} key
     * @param {?} value
     * @param {?=} timeToLive
     * @return {?}
     */
    set(key, value, timeToLive = null) {
        /** @type {?} */
        const expires = timeToLive ? this.getExpireDate(timeToLive) : null;
        /** @type {?} */
        const cacheData = { expires, value };
        this.cache.setObject(key, cacheData);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    has(key) {
        return this.cache.has(key);
    }
    /**
     * @private
     * @param {?=} timeToLive
     * @return {?}
     */
    getExpireDate(timeToLive = null) {
        /** @type {?} */
        const expires = new Date();
        expires.setSeconds(expires.getSeconds() + timeToLive);
        return expires;
    }
}
CacheService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CacheService.ctorParameters = () => [
    { type: PersistentCacheStorage }
];
/** @nocollapse */ CacheService.ngInjectableDef = defineInjectable({ factory: function CacheService_Factory() { return new CacheService(inject(PersistentCacheStorage)); }, token: CacheService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} template
 * @return {?}
 */
function hasTokens(template) {
    return TOKEN_EXPRESSION.test(template);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} template
 * @return {?}
 */
function standardizeTokens(template) {
    return (template || '').replace(/{{/gi, '{').replace(/}}/gi, '}');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function stripTokenBraces(value) {
    return (value || '')
        .replace(new RegExp('{', 'gi'), '')
        .replace(new RegExp('}', 'gi'), '');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} template
 * @param {?} resolvedPath
 * @return {?}
 */
function extractTokenValuesFromTemplate(template, resolvedPath) {
    /** @type {?} */
    const tokens = {};
    template = standardizeTokens(template);
    /** @type {?} */
    const wildcardTemplate = replaceTokens(template, WILDCARD_EXPRESSION_VALUE);
    /** @type {?} */
    const parts = new RegExp(wildcardTemplate).exec(resolvedPath);
    if (parts && parts.length) {
        /** @type {?} */
        const tokensList = template.match(TOKEN_EXPRESSION);
        // Get rid of the full match.
        parts.shift();
        parts.forEach((/**
         * @param {?} templateValue
         * @param {?} index
         * @return {?}
         */
        (templateValue, index) => {
            if (tokensList[index]) {
                /** @type {?} */
                const key = stripTokenBraces(tokensList[index]);
                tokens[key] = (templateValue || '').replace(new RegExp('/', 'gi'), '');
            }
        }));
    }
    return tokens;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} strategy
 * @return {?}
 */
function shouldCheckCacheFirst(strategy) {
    return strategy === CacheStrategy.CacheFirst
        || strategy === CacheStrategy.Fastest
        || strategy === CacheStrategy.CacheOnly;
}
/**
 * @param {?} definition
 * @param {?} requestUrl
 * @return {?}
 */
function getCacheKey(definition, requestUrl) {
    /** @type {?} */
    let cacheKey = definition.cacheId || requestUrl;
    if (hasTokens(cacheKey) && isString(definition.route)) {
        /** @type {?} */
        const tokenValues = extractTokenValuesFromTemplate((/** @type {?} */ (definition.route)), requestUrl);
        cacheKey = format(cacheKey, tokenValues, true);
    }
    return cacheKey;
}
class CacheInterceptor {
    /**
     * @param {?} config
     * @param {?} cache
     * @param {?} log
     */
    constructor(config, cache, log) {
        this.config = config;
        this.cache = cache;
        this.log = log;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        /** @type {?} */
        const allowCaching = request.method === 'GET' && this.config.cacheEnabled;
        /** @type {?} */
        let matchingCacheDefinition;
        // TODO: Handle request method type.
        // TDOO: Handle global use cache only.
        if (allowCaching) {
            matchingCacheDefinition = this.config.getCacheDefinition(request.urlWithParams);
            /** @type {?} */
            const strategy = matchingCacheDefinition
                ? this.config.forcedGlobalCacheStrategy || matchingCacheDefinition.strategy
                : null;
            if (matchingCacheDefinition && shouldCheckCacheFirst(strategy)) {
                /** @type {?} */
                const cacheKey = getCacheKey(matchingCacheDefinition, request.url);
                /** @type {?} */
                const isCacheOnly = strategy === CacheStrategy.CacheOnly;
                /** @type {?} */
                const cachedResponse = this.cache.get(cacheKey);
                if (cachedResponse) {
                    this.log.debug(`Resolving HTTP request from cache: '${request.url}'`);
                    return of(cachedResponse);
                }
                else if (isCacheOnly) {
                    return throwError(new Error(CACHE_ONLY_NO_DATA_EXC_MSG));
                }
            }
        }
        this.log.trace(`Making HTTP request: '${request.url}'`);
        /** @type {?} */
        let continuedResponse = next.handle(request);
        // If a matched cache definition is found, then we need to handle caching when the request when it is complete.
        if (allowCaching && matchingCacheDefinition) {
            continuedResponse = this.cacheResponse(continuedResponse, request, matchingCacheDefinition);
        }
        return continuedResponse;
    }
    /**
     * @private
     * @param {?} source
     * @param {?} request
     * @param {?} cacheDefinition
     * @return {?}
     */
    cacheResponse(source, request, cacheDefinition) {
        /** @type {?} */
        const cacheKey = getCacheKey(cacheDefinition, request.url);
        return source.pipe(tap((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            if (cacheDefinition && event instanceof HttpResponse) {
                this.log.debug(`Caching HTTP request: '${request.url}'`);
                this.cache.set(cacheKey, event, cacheDefinition.expires);
            }
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            /** @type {?} */
            const cachedData = this.cache.get(cacheKey);
            if (cachedData) {
                this.log.debug(`Failed to resolve cacheable HTTP request from URL '${request.url}', fallingback to cache`);
                return of(cachedData);
            }
            else {
                this.log.debug(`Failed to resolve cacheable HTTP request from URL '${request.url}' and no cached data available`);
                throw error;
            }
        })));
    }
}
CacheInterceptor.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CacheInterceptor.ctorParameters = () => [
    { type: CacheConfig },
    { type: CacheService },
    { type: Logger }
];
/** @nocollapse */ CacheInterceptor.ngInjectableDef = defineInjectable({ factory: function CacheInterceptor_Factory() { return new CacheInterceptor(inject(CacheConfig), inject(CacheService), inject(Logger)); }, token: CacheInterceptor, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssCacheModule {
}
TssCacheModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    TssCoreModule,
                ],
                declarations: [],
                exports: [],
                providers: [
                    CacheConfig,
                    PersistentCacheStorage,
                    CacheService,
                    {
                        provide: HTTP_INTERCEPTORS,
                        useClass: CacheInterceptor,
                        multi: true
                    }
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} list
 * @param {...?} itemsToAdd
 * @return {?}
 */
function addIfNotExist(list, ...itemsToAdd) {
    itemsToAdd.forEach((/**
     * @param {?} item
     * @return {?}
     */
    item => {
        if (list.indexOf(item) === -1) {
            list.push(item);
        }
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} list
 * @param {?} itemsToAdd
 * @return {?}
 */
function addRangeToBeginning(list, itemsToAdd) {
    list.unshift(...itemsToAdd);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} list
 * @param {?} itemsToAdd
 * @return {?}
 */
function addRange(list, itemsToAdd) {
    list.push(...itemsToAdd);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} list
 * @return {?}
 */
function removeDuplicates(list) {
    return list
        .filter((/**
     * @param {?} element
     * @param {?} position
     * @param {?} filteredList
     * @return {?}
     */
    (element, position, filteredList) => filteredList.indexOf(element) === position));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} list
 * @param {...?} itemsToDelete
 * @return {?}
 */
function removeItem(list, ...itemsToDelete) {
    itemsToDelete.forEach((/**
     * @param {?} itemToDelete
     * @return {?}
     */
    itemToDelete => {
        /** @type {?} */
        const index = list.indexOf(itemToDelete);
        /** @type {?} */
        const numberOfItemsToRemove = 1;
        if (index > -1) {
            list.splice(index, numberOfItemsToRemove);
        }
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} list
 * @param {?} predicate
 * @return {?}
 */
function removeWhere(list, predicate) {
    /** @type {?} */
    const itemsToRemove = list.filter((/**
     * @param {?} t
     * @return {?}
     */
    t => predicate(t)));
    removeItem(list, ...itemsToRemove);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} objectToClone
 * @return {?}
 */
function clone(objectToClone) {
    return JSON.parse(JSON.stringify(objectToClone));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} hex
 * @return {?}
 */
function hexToRgb(hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    /** @type {?} */
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    /** @type {?} */
    let result = null;
    hex = hex.replace(shorthandRegex, (/**
     * @param {?} _
     * @param {?} red
     * @param {?} green
     * @param {?} blue
     * @return {?}
     */
    (_, red, green, blue) => {
        return red + red + green + green + blue + blue;
    }));
    /** @type {?} */
    const matchResult = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (matchResult) {
        /** @type {?} */
        const red = parseInt(matchResult[1], 16);
        /** @type {?} */
        const blue = parseInt(matchResult[2], 16);
        /** @type {?} */
        const green = parseInt(matchResult[3], 16);
        result = [red, blue, green];
    }
    return result;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} colorTest
 * @return {?}
 */
function isHexColor(colorTest) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(colorTest);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} rgb
 * @return {?}
 */
function rgbToHex(rgb) {
    /** @type {?} */
    const red = rgb[0];
    /** @type {?} */
    const green = rgb[1];
    /** @type {?} */
    const blue = rgb[2];
    // tslint:disable-next-line
    return `#${((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1)}`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} transparency
 * @return {?}
 */
function transparencyToOpacity(transparency) {
    return 1 - (transparency * 0.01);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Given a cookie key `name`, returns the value of
 * the cookie or `null`, if the key is not found.
 * @param {?} name
 * @return {?}
 */
function getCookie(name) {
    /** @type {?} */
    const nameMatchLength = name.length + 1;
    return document.cookie
        .split(';')
        .map((/**
     * @param {?} c
     * @return {?}
     */
    c => c.trim()))
        .filter((/**
     * @param {?} cookie
     * @return {?}
     */
    cookie => cookie.substring(0, nameMatchLength) === `${name}=`))
        .map((/**
     * @param {?} cookie
     * @return {?}
     */
    cookie => decodeURIComponent(cookie.substring(nameMatchLength))))[0] || null;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} milliseconds
 * @param {?=} date
 * @return {?}
 */
function addMilliseconds(milliseconds, date) {
    date = date || new Date();
    /** @type {?} */
    const time = date.getTime();
    /** @type {?} */
    const newTime = time + milliseconds;
    date.setTime(newTime);
    return date;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} minutes
 * @param {?=} date
 * @return {?}
 */
function addMinutes(minutes, date) {
    return addMilliseconds(minutes * MILLISECONDS_PER_MINUTE, date);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} days
 * @param {?=} date
 * @return {?}
 */
function addDays(days, date) {
    return addMinutes(days * HOURS_PER_DAY, date);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} hours
 * @param {?=} date
 * @return {?}
 */
function addHours(hours, date) {
    return addMinutes(hours * MINUTES_PER_HOUR, date);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} seconds
 * @param {?=} date
 * @return {?}
 */
function addSeconds(seconds, date) {
    return addMilliseconds(seconds * MILLISECONDS_PER_SECOND, date);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} date
 * @return {?}
 */
function toUtcDate(date) {
    return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} date
 * @param {?=} dateFormat
 * @return {?}
 */
function formatDate(date, dateFormat = DEFAULT_DATE_FORMAT) {
    /** @type {?} */
    const dateTransformer = new DatePipe('en-US');
    if (dateFormat === STANDARDIZED_QUERY_DATE_FORMAT || dateFormat === ORACLE_DATE_FORMAT) {
        return format(dateFormat, {
            date: dateTransformer.transform(date, DEFAULT_DATE_FORMAT)
        });
    }
    /** @type {?} */
    const formattedDate = dateTransformer.transform(date, dateFormat);
    return `${formattedDate}`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} date
 * @return {?}
 */
function toStandardizedQueryDateFormat(date) {
    // Attribute query expects UTC time, so convert from local time.
    // The date formatter uses local time, so create a new Date object
    // whose local time is set to UTC time from the input date.
    date = toUtcDate(date);
    return formatDate(date, STANDARDIZED_QUERY_DATE_FORMAT);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} date
 * @return {?}
 */
function toUtcEpochDate(date) {
    return toUtcDate(date).getTime();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} date
 * @param {?=} dateFormat
 * @return {?}
 */
function formatDateForQuery(date, dateFormat = DEFAULT_DATE_FORMAT) {
    /** @type {?} */
    let quoteDate = true;
    if (dateFormat === STANDARDIZED_QUERY_DATE_FORMAT || dateFormat === ORACLE_DATE_FORMAT) {
        quoteDate = false;
    }
    /** @type {?} */
    const formattedDate = formatDate(date, dateFormat);
    return quoteDate ? `'${formattedDate}'` : `${formattedDate}`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const SqlDateFormat = {
    Standardized: 0,
    Literal: 1,
    Oracle: 2,
};
SqlDateFormat[SqlDateFormat.Standardized] = 'Standardized';
SqlDateFormat[SqlDateFormat.Literal] = 'Literal';
SqlDateFormat[SqlDateFormat.Oracle] = 'Oracle';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getCurrentDateAsUtc() {
    return toUtcDate(new Date());
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getCurrentDateEpochAsUtc() {
    return toUtcDate(new Date()).getTime();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} start
 * @param {?=} end
 * @return {?}
 */
function getElapsedMilliseconds(start, end) {
    end = end || new Date();
    return Math.abs(start.getTime() - end.getTime());
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} start
 * @param {?=} end
 * @return {?}
 */
function getElapsedSeconds(start, end) {
    return getElapsedMilliseconds(start, end) / 1000;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} seconds
 * @param {?=} suffixMap
 * @return {?}
 */
function secondsToReadableTime(seconds, suffixMap = {}) {
    return toReadableTime(seconds * MILLISECONDS_PER_SECOND, suffixMap);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} date
 * @return {?}
 */
function setDateToBeginningOfDay(date) {
    date.setHours(0, 0, 0, 0);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} date
 * @return {?}
 */
function setDateToEndOfDay(date) {
    date.setHours(23, 59, 59);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} days
 * @param {?=} date
 * @return {?}
 */
function subtractDays(days, date) {
    return addDays(days * -1, date);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} minutes
 * @param {?=} date
 * @return {?}
 */
function subtractMinutes(minutes, date) {
    return addMinutes(minutes * -1, date);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} minutes
 * @param {?=} date
 * @return {?}
 */
function subtractSeconds(minutes, date) {
    return addSeconds(minutes * -1, date);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} hours
 * @param {?=} date
 * @return {?}
 */
function subtractHours(hours, date) {
    return addHours(hours * -1, date);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} milliseconds
 * @param {?=} date
 * @return {?}
 */
function subtractMilliseconds(milliseconds, date) {
    return addMilliseconds(milliseconds * -1, date);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function hasLocalStorage() {
    return hasWindow() && Boolean(window.localStorage);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OnlineOfflineService {
    constructor() {
        this.internalConnectionChanged = new Subject();
        this.connectionChanged = this.internalConnectionChanged.asObservable();
        window.addEventListener('online', (/**
         * @return {?}
         */
        () => this.updateOnlineStatus()));
        window.addEventListener('offline', (/**
         * @return {?}
         */
        () => this.updateOnlineStatus()));
    }
    /**
     * @return {?}
     */
    get isOnline() {
        return !!window.navigator.onLine;
    }
    /**
     * @private
     * @return {?}
     */
    updateOnlineStatus() {
        this.internalConnectionChanged.next(window.navigator.onLine);
    }
}
OnlineOfflineService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
OnlineOfflineService.ctorParameters = () => [];
/** @nocollapse */ OnlineOfflineService.ngInjectableDef = defineInjectable({ factory: function OnlineOfflineService_Factory() { return new OnlineOfflineService(); }, token: OnlineOfflineService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_POINT_EQUALITY_PRECISION = 7;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns true if the two arguments are equal within the given precision.
 * @param {?} number1
 * @param {?} number2
 * @param {?=} precision
 * @return {?}
 */
function almostEqual(number1, number2, precision = DEFAULT_POINT_EQUALITY_PRECISION) {
    /** @type {?} */
    const tolerance = 0.5 * Math.pow(10, -precision);
    return Math.abs(number1 - number2) < tolerance;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} x1
 * @param {?} y1
 * @param {?} x2
 * @param {?} y2
 * @param {?=} precision
 * @return {?}
 */
function pointsAlmostEqual(x1, y1, x2, y2, precision = DEFAULT_POINT_EQUALITY_PRECISION) {
    return almostEqual(x1, x2, precision) && almostEqual(y1, y2, precision);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_ERROR_MSG = 'An error occurred';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} errorOrMsg
 * @param {?=} error
 * @return {?}
 */
function errorMsg(errorOrMsg, error) {
    /** @type {?} */
    let exceptionDetails;
    errorOrMsg = errorOrMsg || DEFAULT_ERROR_MSG;
    if (isString(errorOrMsg)) {
        exceptionDetails = error ? errorMsg(error) : '';
        return format(errorOrMsg, { error: exceptionDetails });
    }
    return errorMsg(errorOrMsg.innerException
        || errorOrMsg.InnerException
        || errorOrMsg.exceptionMessage
        || errorOrMsg.ExceptionMessage
        || errorOrMsg.message
        || errorOrMsg.Message
        || errorOrMsg.msg
        || errorOrMsg.Msg
        || errorOrMsg.error_description
        || errorOrMsg.error
        || errorOrMsg.Error
        || errorOrMsg.data
        || errorOrMsg.Data
        || errorOrMsg.exception
        || errorOrMsg.Exception);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @param {?=} digits
 * @param {?=} locale
 * @return {?}
 */
function formatNumber(value, digits, locale) {
    return new DecimalPipe('en-US').transform(value, digits, locale);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FIRST_LETTER_SEPERATED_BY_SPACE_MATCH_REGEX = /^[a-z]|\s[a-z]/gm;
/** @type {?} */
const PASCAL_CASE_FIRST_LETTER_MATCH_REGEX = /(?=[A-Z])/;
/** @type {?} */
const LEADING_AND_TRAILING_UNDERSCORE_MATCH_REGEX = /^[\s_]+|[\s_]+$/gm;
/** @type {?} */
const LEADING_AND_TRAILING_HYPHEN_MATCH_REGEX = /^[\s-]+|[\s-]+$/gm;
/** @type {?} */
const UNDERSCORE_MATCH_REGEX = /[_\s]+/gm;
/** @type {?} */
const HYPHEN_MATCH_REGEX = /[-\s]+/gm;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} text
 * @return {?}
 */
function upperCaseEachWord(text) {
    return (text || '')
        .replace(FIRST_LETTER_SEPERATED_BY_SPACE_MATCH_REGEX, (/**
     * @param {?} match
     * @return {?}
     */
    match => match.toUpperCase()));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function upperCaseFirstLetter(value) {
    return String(value).charAt(0).toUpperCase() + value.slice(1);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} text
 * @param {?=} upperCaseAllWords
 * @return {?}
 */
function humanize(text, upperCaseAllWords = true) {
    /** @type {?} */
    const result = (text || '')
        .split(PASCAL_CASE_FIRST_LETTER_MATCH_REGEX)
        .join(' ')
        .replace(LEADING_AND_TRAILING_UNDERSCORE_MATCH_REGEX, '')
        .replace(LEADING_AND_TRAILING_HYPHEN_MATCH_REGEX, '')
        .replace(UNDERSCORE_MATCH_REGEX, ' ')
        .replace(HYPHEN_MATCH_REGEX, ' ')
        .toLowerCase();
    return upperCaseAllWords
        ? upperCaseEachWord(result)
        : upperCaseFirstLetter(result);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @param {?=} trimCharacter
 * @return {?}
 */
function trimEnd(value, trimCharacter = ' ') {
    if (value.endsWith(trimCharacter)) {
        value = value.substr(0, value.length - 1);
    }
    return value;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @param {?=} trimCharacter
 * @return {?}
 */
function trimStart(value, trimCharacter = ' ') {
    if (value.startsWith(trimCharacter)) {
        value = value.substr(1);
    }
    return value;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @param {?=} trimCharacter
 * @return {?}
 */
function trim(value, trimCharacter = ' ') {
    value = trimStart(value, trimCharacter);
    value = trimEnd(value, trimCharacter);
    return value;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Key, Value
 * @param {?} list
 * @param {?} keyGetter
 * @return {?}
 */
function groupBy(list, keyGetter) {
    /** @type {?} */
    const map$$1 = new Map();
    list.forEach((/**
     * @param {?} item
     * @return {?}
     */
    (item) => {
        /** @type {?} */
        const key = keyGetter(item);
        /** @type {?} */
        const collection = map$$1.get(key);
        if (!collection) {
            map$$1.set(key, [item]);
        }
        else {
            collection.push(item);
        }
    }));
    return map$$1;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const BASE_64_METADATA_REGEX = /data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/;
/** @type {?} */
const JSON_MIME_TYPE = 'application/json';
// Text files.
/** @type {?} */
const TEXT_MIME_TYPE = 'text/plain';
/** @type {?} */
const TEXT_FILE_EXTENSION = '.txt';
// Audio.
/** @type {?} */
const AUDIO_WEBM_MIME_TYPE = 'audio/webm';
/** @type {?} */
const AUDIO_MP3_MIME_TYPE = 'audio/mpeg-3';
/** @type {?} */
const AUDIO_MP3_FILE_EXTENSION = '.mp3';
// Video.
/** @type {?} */
const VIDEO_WEBM_MIME_TYPE = 'video/webm;codecs=h264';
/** @type {?} */
const VIDEO_MP4_MIME_TYPE = 'video/mp4';
/** @type {?} */
const VIDEO_MP4_FILE_EXTENSION = '.mp4';
// Images.
/** @type {?} */
const IMAGE_PNG_FILE_EXTENSION = '.png';
/** @type {?} */
const IMAGE_PNG_MIME_TYPE = 'image/png';
/** @type {?} */
const IMAGE_JPEG_FILE_EXTENSION = '.jpeg';
/** @type {?} */
const IMAGE_JPEG_MIME_TYPE = 'image/jpeg';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} encoded
 * @return {?}
 */
function base64MimeType(encoded) {
    /** @type {?} */
    let result = null;
    /** @type {?} */
    const mime = encoded.match(BASE_64_METADATA_REGEX);
    if (mime && mime.length) {
        result = mime[1];
    }
    return result;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} base64
 * @return {?}
 */
function stripBase64Metadata(base64) {
    /** @type {?} */
    const result = base64.split(',');
    return getLastItem(result).trim();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} base64Data
 * @return {?}
 */
function base64toByteArray(base64Data) {
    /** @type {?} */
    const sliceSize = 1024;
    /** @type {?} */
    const strippedBase64Data = stripBase64Metadata(base64Data);
    /** @type {?} */
    const byteCharacters = atob(strippedBase64Data);
    /** @type {?} */
    const bytesLength = byteCharacters.length;
    /** @type {?} */
    const slicesCount = Math.ceil(bytesLength / sliceSize);
    /** @type {?} */
    const byteArrays = new Array(slicesCount);
    /** @type {?} */
    let sliceIndex;
    for (sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
        /** @type {?} */
        const begin = sliceIndex * sliceSize;
        /** @type {?} */
        const end = Math.min(begin + sliceSize, bytesLength);
        /** @type {?} */
        const bytes = new Array(end - begin);
        /** @type {?} */
        let offset;
        /** @type {?} */
        let i;
        for (offset = begin, i = 0; offset < end; ++i, ++offset) {
            bytes[i] = byteCharacters[offset].charCodeAt(0);
        }
        byteArrays[sliceIndex] = new Uint8Array(bytes);
    }
    return byteArrays;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} base64Data
 * @param {?=} contentType
 * @return {?}
 */
function base64toBlob(base64Data, contentType = null) {
    contentType = contentType || base64MimeType(base64Data);
    return new Blob(base64toByteArray(base64Data), { type: contentType });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isObject(val) {
    return isType(val, 'object') && !Array.isArray(val) && isValue(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Deep merge two objects.
 * @param {?} target
 * @param {?} source
 * @param {?=} options
 * @return {?}
 */
function mergeDeep(target, source, options = {}) {
    if (isObject(target) && isObject(source)) {
        Object.keys(source).forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            /** @type {?} */
            const value = source[key];
            if (isObject(value)) {
                if (!target[key]) {
                    target[key] = {};
                }
                mergeDeep(target[key], value, options);
            }
            else {
                /** @type {?} */
                let doCopy = true;
                if (options.ignoreArrays && Array.isArray(value)
                    || isFunction(value) && !options.copyFunctions) {
                    doCopy = false;
                }
                if (doCopy) {
                    Object.assign(target, { [key]: value });
                }
            }
        }));
    }
    return target;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} target
 * @param {?} source
 * @param {?=} options
 * @return {?}
 */
function mergeDeepArray(target, source, options) {
    if (!target || !source) {
        return;
    }
    options = Object.assign({}, {
        identifier: 'id',
        addMissing: true,
        beforeMerge: (/**
         * @return {?}
         */
        () => undefined),
        afterMerge: (/**
         * @return {?}
         */
        () => undefined),
    }, options);
    target.forEach((/**
     * @param {?} targetItem
     * @return {?}
     */
    targetItem => {
        /** @type {?} */
        const targetId = targetItem[options.identifier];
        /** @type {?} */
        const match = source.find((/**
         * @param {?} s
         * @return {?}
         */
        s => targetId && s[options.identifier] === targetId));
        if (match) {
            /** @type {?} */
            const continueWithMerge = options.beforeMerge(targetItem, match);
            if (continueWithMerge !== false) {
                mergeDeep(targetItem, match);
            }
            options.afterMerge(targetItem, match);
        }
    }));
    if (options.addMissing) {
        source
            .filter((/**
         * @param {?} src
         * @return {?}
         */
        src => !target.find((/**
         * @param {?} x
         * @return {?}
         */
        x => src[options.identifier] && src[options.identifier] === x[options.identifier]))))
            .forEach((/**
         * @param {?} missing
         * @return {?}
         */
        missing => target.push(missing)));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class BaseNotificationTracker {
    /**
     * @param {?} notify
     * @param {?=} log
     * @param {?=} config
     */
    constructor(notify, log, config = { logErrors: true }) {
        this.notify = notify;
        this.log = log;
        this.config = config;
        this.eventWatchers = [];
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    wait(message, title, config) {
        this.waitResponse = this.notify.wait(message, title, config);
        // This method needs implemented in each implementation.
        this.emit('wait');
        return this;
    }
    /**
     * @param {?} predicate
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    waitIf(predicate, message, title, config) {
        /** @type {?} */
        const doWait = isFunction(predicate)
            ? ((/** @type {?} */ (predicate)))()
            : Boolean(predicate);
        return doWait ? this.wait(message, title, config) : this;
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    success(message, title, config) {
        this.config.showSuccess = true;
        this.config.successMsg = message;
        this.config.successTitle = title;
        this.config.successConfiguration = config;
        this.emit('success');
        return this;
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    error(message, title, config) {
        this.config.showError = true;
        this.config.errorMsg = message;
        this.config.errorTitle = title;
        this.config.errorConfiguration = config;
        this.emit('error');
        return this;
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    warn(message, title, config) {
        this.config.showWarn = true;
        this.config.warnMsg = message;
        this.config.warnTitle = title;
        this.config.warnConfiguration = config;
        this.emit('warn');
        return this;
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    info(message, title, config) {
        this.config.showInfo = true;
        this.config.infoMsg = message;
        this.config.infoTitle = title;
        this.config.infoConfiguration = config;
        this.emit('info');
        return this;
    }
    /**
     * @param {?} onDone
     * @return {?}
     */
    finally(onDone) {
        this.onDone = onDone;
        this.emit('finally');
        return this;
    }
    /**
     * @param {?} eventType
     * @param {?} callback
     * @return {?}
     */
    on(eventType, callback) {
        this.eventWatchers.push({ eventType, callback });
    }
    /**
     * @protected
     * @param {?} eventType
     * @param {?=} event
     * @return {?}
     */
    emit(eventType, event) {
        this.eventWatchers
            .filter((/**
         * @param {?} watcher
         * @return {?}
         */
        watcher => watcher.eventType === eventType))
            .forEach((/**
         * @param {?} watcher
         * @return {?}
         */
        watcher => watcher.callback(event)));
    }
    /**
     * @protected
     * @param {?=} response
     * @return {?}
     */
    done(response) {
        if (this.waitResponse) {
            this.notify.clear(this.waitResponse.notifyId, this.waitResponse.containerId);
        }
        if (this.onDone) {
            this.onDone(response);
        }
    }
    /**
     * @protected
     * @param {?} response
     * @return {?}
     */
    onSuccess(response) {
        if (this.config.showSuccess) {
            this.notify.success(this.config.successMsg, this.config.successTitle, this.config.successConfiguration);
        }
        if (this.config.showInfo) {
            this.notify.info(this.config.infoMsg, this.config.infoTitle, this.config.infoConfiguration);
        }
        this.done(response);
    }
    /**
     * @protected
     * @param {?} error
     * @return {?}
     */
    onFail(error) {
        /** @type {?} */
        const responseError = (error.error || error) || error;
        /** @type {?} */
        const msg = errorMsg(this.config.errorMsg, responseError);
        if (this.log && this.config.logErrors) {
            this.log.error(msg);
        }
        if (this.config.showError) {
            this.notify.error(msg, this.config.errorTitle, responseError, this.config.errorConfiguration);
        }
        if (this.config.showWarn) {
            this.notify.warn(msg, this.config.infoTitle, this.config.warnConfiguration);
        }
        this.done();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class NotificationPromiseTracker extends BaseNotificationTracker {
    /**
     * @param {?} source
     * @param {?} notify
     * @param {?=} log
     * @param {?=} config
     */
    constructor(source, notify, log, config = {}) {
        super(notify, log, config);
        this.source = source;
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @return {?}
     */
    wait(message, title) {
        super.wait(message, title);
        this.source = this.source
            .then((/**
         * @param {?} result
         * @return {?}
         */
        (result) => {
            this.onSuccess(result);
            return result;
        }))
            .catch((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.onFail(error);
            throw error;
        }));
        return this;
    }
    /**
     * @param {?} predicate
     * @param {?} message
     * @param {?=} title
     * @return {?}
     */
    waitIf(predicate, message, title) {
        return (/** @type {?} */ (super.waitIf(predicate, message, title)));
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @return {?}
     */
    success(message, title) {
        return (/** @type {?} */ (super.success(message, title)));
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @return {?}
     */
    error(message, title) {
        return (/** @type {?} */ (super.error(message, title)));
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @return {?}
     */
    warn(message, title) {
        return (/** @type {?} */ (super.warn(message, title)));
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @return {?}
     */
    info(message, title) {
        return (/** @type {?} */ (super.info(message, title)));
    }
    /**
     * @param {?} onDone
     * @return {?}
     */
    finally(onDone) {
        return (/** @type {?} */ (super.finally(onDone)));
    }
    /**
     * @param {?=} onfulfilled
     * @return {?}
     */
    then(onfulfilled) {
        return this.source.then(onfulfilled);
    }
    /**
     * @param {?=} onrejected
     * @return {?}
     */
    catch(onrejected) {
        return this.source.catch(onrejected);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class NotificationSubscriptionTracker extends BaseNotificationTracker {
    /**
     * @param {?} source
     * @param {?} notify
     * @param {?=} log
     * @param {?=} config
     */
    constructor(source, notify, log, config = {}) {
        super(notify, log, config);
        this.source = source;
        // We need to do a timeout here so that the chained events coming in after this method will be fired
        // before this subscription is added - this is necessary for any synchronous/immediate observables.
        this.source = this.source.pipe(tap((/**
         * @param {?} x
         * @return {?}
         */
        (x) => {
            setTimeout((/**
             * @return {?}
             */
            () => this.onSuccess(x)));
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            setTimeout((/**
             * @return {?}
             */
            () => this.onFail(error)));
        })));
        if (this.config.useSingletonSubscriptionEmission) {
            this.source = this.source.pipe(publishReplay());
        }
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    wait(message, title, config) {
        return (/** @type {?} */ (super.wait(message, title, config)));
    }
    /**
     * @param {?} predicate
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    waitIf(predicate, message, title, config) {
        return (/** @type {?} */ (super.waitIf(predicate, message, title, config)));
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    success(message, title, config) {
        return (/** @type {?} */ (super.success(message, title, config)));
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    error(message, title, config) {
        return (/** @type {?} */ (super.error(message, title, config)));
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    warn(message, title, config) {
        return (/** @type {?} */ (super.warn(message, title, config)));
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    info(message, title, config) {
        return (/** @type {?} */ (super.info(message, title, config)));
    }
    /**
     * @param {?} onDone
     * @return {?}
     */
    finally(onDone) {
        return (/** @type {?} */ (super.finally(onDone)));
    }
    /**
     * @param {?=} next
     * @param {?=} error
     * @param {?=} complete
     * @return {?}
     */
    subscribe(next, error, complete) {
        return this.source.subscribe(next, error, complete);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const NotifyType = {
    Wait: 0,
    Success: 1,
    Info: 2,
    Warn: 3,
    Error: 4,
};
NotifyType[NotifyType.Wait] = 'Wait';
NotifyType[NotifyType.Success] = 'Success';
NotifyType[NotifyType.Info] = 'Info';
NotifyType[NotifyType.Warn] = 'Warn';
NotifyType[NotifyType.Error] = 'Error';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Notification service.
 */
class NotifyService {
    /**
     * @param {?} config
     * @param {?} log
     */
    constructor(config, log) {
        this.config = config;
        this.log = log;
    }
    /**
     * @param {?} type
     * @param {?} message
     * @param {?} title
     * @param {?=} config
     * @return {?}
     */
    notify(type, message, title, config) {
        // Add actual notification implementation here.
        return {};
    }
    /**
     * @param {?=} notifyId
     * @param {?=} containerId
     * @return {?}
     */
    clear(notifyId, containerId) {
    }
    /**
     * @template T
     * @param {?} source
     * @return {?}
     */
    with(source) {
        return new NotificationSubscriptionTracker(source, this, this.log);
    }
    /**
     * @template T
     * @param {?} source
     * @return {?}
     */
    promise(source) {
        return new NotificationPromiseTracker(source, this, this.log);
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    wait(message, title = this.config.defaultNotifyWaitMsg, config) {
        return this.notify(NotifyType.Wait, message, title, config);
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    success(message, title = this.config.defaultNotifySuccessMsg, config) {
        return this.notify(NotifyType.Success, message, title, config);
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} error
     * @param {?=} config
     * @return {?}
     */
    error(message, title = this.config.defaultNotifyErrorMsg, error = null, config) {
        return this.notify(NotifyType.Error, format(message, { error }), title, config);
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} error
     * @param {?=} config
     * @return {?}
     */
    warn(message, title = this.config.defaultNotifyWarnMsg, error = null, config) {
        return this.notify(NotifyType.Warn, format(message, { error }), title, config);
    }
    /**
     * @param {?} message
     * @param {?=} title
     * @param {?=} config
     * @return {?}
     */
    info(message, title = this.config.defaultNotifyInfoMsg, config) {
        return this.notify(NotifyType.Info, message, title, config);
    }
}
NotifyService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
NotifyService.ctorParameters = () => [
    { type: CoreConfig },
    { type: Logger }
];
/** @nocollapse */ NotifyService.ngInjectableDef = defineInjectable({ factory: function NotifyService_Factory() { return new NotifyService(inject(CoreConfig), inject(Logger)); }, token: NotifyService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Assigns values from one object to another, but only for values that are valid (not null, undefined, or empty string).
 * Restriction properties can be passed in to specificy explicitly which properties to assign (if valid).
 * @template T
 * @param {?} targetItem
 * @param {?} sourceItem
 * @param {...?} restrictionProperties
 * @return {?}
 */
function assignValidValues(targetItem, sourceItem, ...restrictionProperties) {
    if (restrictionProperties.length === 0) {
        restrictionProperties = Object.keys(sourceItem);
    }
    restrictionProperties
        .filter((/**
     * @param {?} property
     * @return {?}
     */
    property => isValue(sourceItem[property])))
        .forEach((/**
     * @param {?} property
     * @return {?}
     */
    property => targetItem[property] = sourceItem[property]));
    return targetItem;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO: Refactor this method and give it proper names.
// This was a copy/paste from online - RG.
/**
 * @param {?} obj
 * @param {?} path
 * @return {?}
 */
function getValue(obj, path) {
    /** @type {?} */
    const arr = path.split('.');
    while (arr.length && obj) {
        obj = obj[arr.shift()];
    }
    return obj;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns a random integer between min (inclusive) and max (inclusive)
 * Using Math.round() will give you a non-uniform distribution!
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
function getRandomInteger(min = 0, max = 1000) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns a random number between min (inclusive) and max (exclusive)
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
function getRandomNumber(min = 0, max = 10) {
    return Math.random() * (max - min) + min;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} numberToRound
 * @param {?=} decimalPlaces
 * @return {?}
 */
function round(numberToRound, decimalPlaces = 3) {
    return isNumber$1(numberToRound)
        ? Number(numberToRound.toFixed(decimalPlaces))
        : numberToRound;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} list
 * @return {?}
 */
function sortByOrder(list) {
    /** @type {?} */
    let compareResult = -1;
    list
        .sort((/**
     * @param {?} compare1
     * @param {?} compare2
     * @return {?}
     */
    (compare1, compare2) => {
        if (!isNumber$1(compare2.order) || compare1.order < compare2.order) {
            compareResult = -1;
        }
        else if (!isNumber$1(compare1.order) || compare1.order > compare2.order) {
            compareResult = 1;
        }
        else if (compare1.order === compare2.order) {
            compareResult = 0;
        }
        return compareResult;
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} list
 * @return {?}
 */
function sortAndReorder(list) {
    sortByOrder(list);
    list
        .forEach((/**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    (item, index) => item.order = index + 1));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const SortDirection = {
    Ascending: 0,
    Descending: 1,
};
SortDirection[SortDirection.Ascending] = 'Ascending';
SortDirection[SortDirection.Descending] = 'Descending';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} list
 * @param {...?} sortProperties
 * @return {?}
 */
function sortAscending(list, ...sortProperties) {
    return sort(list, SortDirection.Ascending, ...sortProperties);
}
/**
 * @template T
 * @param {?} list
 * @param {...?} sortProperties
 * @return {?}
 */
function sortDescending(list, ...sortProperties) {
    return sort(list, SortDirection.Descending, ...sortProperties);
}
/**
 * @template T
 * @param {?} list
 * @param {?=} direction
 * @param {...?} sortProperties
 * @return {?}
 */
function sort(list, direction = SortDirection.Ascending, ...sortProperties) {
    list.sort((/**
     * @param {?} item1
     * @param {?} item2
     * @return {?}
     */
    (item1, item2) => {
        /** @type {?} */
        let sortResponse = 0;
        if (sortProperties && sortProperties.length) {
            sortProperties.forEach((/**
             * @param {?} property
             * @return {?}
             */
            property => {
                if (sortResponse === 0) {
                    /** @type {?} */
                    const value1 = getPropertyValue(item1, property);
                    /** @type {?} */
                    const value2 = getPropertyValue(item2, property);
                    sortResponse = getSortResultForString(value1, value2, direction);
                }
            }));
        }
        else {
            sortResponse = getSortResultForString(item1, item2, direction);
        }
        return sortResponse;
    }));
    return list;
}
/**
 * @template T
 * @param {?} item
 * @param {?} property
 * @return {?}
 */
function getPropertyValue(item, property) {
    return isFunction(property)
        ? ((/** @type {?} */ (property)))(item)
        : item[(/** @type {?} */ (property))];
}
/**
 * @param {?} value1
 * @param {?} value2
 * @param {?} direction
 * @return {?}
 */
function getSortResultForString(value1, value2, direction) {
    return direction === SortDirection.Ascending
        ? getSortResultForStringAscending(value1, value2)
        : getSortResultForStringDescending(value1, value2);
}
/**
 * @param {?} value
 * @return {?}
 */
function ensureValue(value) {
    return value === null || value === undefined ? '' : value;
}
/**
 * @param {?} value1
 * @param {?} value2
 * @return {?}
 */
function getSortResultForStringAscending(value1, value2) {
    value1 = ensureValue(value1);
    value2 = ensureValue(value2);
    /** @type {?} */
    const compare1 = isString(value1) ? value1.toUpperCase() : value1;
    /** @type {?} */
    const compare2 = isString(value2) ? value2.toUpperCase() : value2;
    /** @type {?} */
    let compareResult = 0;
    if (compare1 < compare2) {
        compareResult = -1;
    }
    else if (compare1 > compare2) {
        compareResult = 1;
    }
    // NOTE: 0 = equals, 1 = greater, -1 less than.
    return compareResult;
}
/**
 * @param {?} value1
 * @param {?} value2
 * @return {?}
 */
function getSortResultForStringDescending(value1, value2) {
    /** @type {?} */
    const compare1 = isString(value1) ? value1.toUpperCase() : value1;
    /** @type {?} */
    const compare2 = isString(value2) ? value2.toUpperCase() : value2;
    /** @type {?} */
    let compareResult = 0;
    if (compare1 > compare2) {
        compareResult = -1;
    }
    else if (compare1 < compare2) {
        compareResult = 1;
    }
    // NOTE: 0 = equals, 1 = greater, -1 less than.
    return compareResult;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} list
 * @return {?}
 */
function average(list) {
    list = list.filter((/**
     * @param {?} value
     * @return {?}
     */
    value => isNumber$1(value)));
    /** @type {?} */
    const total = list.reduce((/**
     * @param {?} current
     * @param {?} accumulating
     * @return {?}
     */
    (current, accumulating) => current + accumulating), 0);
    return total / list.length;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} x1
 * @param {?} y1
 * @param {?} x2
 * @param {?} y2
 * @param {?} testX
 * @param {?} testY
 * @return {?}
 */
function calculateCrossProduct(x1, y1, x2, y2, testX, testY) {
    return (testX - x1) * (y2 - y1) - (testY - y1) * (x2 - x1);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} partialValue
 * @param {?} totalValue
 * @return {?}
 */
function calculatePercentComplete(partialValue, totalValue) {
    return (100 * partialValue) / totalValue;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} totalProcessed
 * @param {?} ellapsedSeconds
 * @param {?} remainingCount
 * @return {?}
 */
function calculateRemainingSeconds(totalProcessed, ellapsedSeconds, remainingCount) {
    /** @type {?} */
    let estimatedSecondsRemaining = -1;
    if (totalProcessed > 0) {
        estimatedSecondsRemaining = ellapsedSeconds / totalProcessed * remainingCount;
    }
    return estimatedSecondsRemaining;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} testNumber
 * @param {?} rangeStart
 * @param {?} rangeEnd
 * @return {?}
 */
function isNumberBetweenOrEqual(testNumber, rangeStart, rangeEnd) {
    /** @type {?} */
    const minRange = Math.min(rangeStart, rangeEnd);
    /** @type {?} */
    const maxRange = Math.max(rangeStart, rangeEnd);
    return testNumber >= minRange && testNumber <= maxRange;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} testNumber
 * @param {?} rangeStart
 * @param {?} rangeEnd
 * @return {?}
 */
function isNumberBetween(testNumber, rangeStart, rangeEnd) {
    /** @type {?} */
    const minRange = Math.min(rangeStart, rangeEnd);
    /** @type {?} */
    const maxRange = Math.max(rangeStart, rangeEnd);
    return testNumber > minRange && testNumber < maxRange;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} list
 * @param {?} predicate
 * @return {?}
 */
function sum(list, predicate) {
    return list
        .reduce((/**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    (a, b) => {
        /** @type {?} */
        let value = predicate(b);
        value = isNumber$1(value) ? value : 0;
        return a + value;
    }), 0);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StatsTracker {
    /**
     * @param {...?} progressables
     */
    constructor(...progressables) {
        this.progressables = progressables || [];
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} progressable
     * @return {THIS}
     */
    add(progressable) {
        (/** @type {?} */ (this)).progressables.push(progressable);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getPercentComplete() {
        /** @type {?} */
        const totalPercentComplete = sum(this.progressables, (/**
         * @param {?} p
         * @return {?}
         */
        p => p.percentComplete));
        /** @type {?} */
        const overallComplete = totalPercentComplete / this.progressables.length;
        return Math.round(overallComplete);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} list
 * @param {?} property
 * @return {?}
 */
function sumProperty(list, property) {
    return sum(list, (/**
     * @param {?} value
     * @return {?}
     */
    (value) => value[property]));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} list
 * @return {?}
 */
function sumValues(list) {
    return sum(list, (/**
     * @param {?} value
     * @return {?}
     */
    value => value));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InMemoryStorage extends BaseStorage {
    constructor() {
        super(...arguments);
        this.cache = new Map();
    }
    /**
     * @return {?}
     */
    get length() {
        return this.cache.size;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    get(key) {
        return this.cache.get(this.formatKey(key));
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    set(key, value) {
        this.cache.set(this.formatKey(key), value);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    remove(key) {
        this.cache.delete(this.formatKey(key));
    }
    /**
     * @return {?}
     */
    clear() {
        this.cache.clear();
    }
}
InMemoryStorage.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ InMemoryStorage.ngInjectableDef = defineInjectable({ factory: function InMemoryStorage_Factory() { return new InMemoryStorage(); }, token: InMemoryStorage, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} template
 * @return {?}
 */
function extractTokens(template) {
    template = standardizeTokens(template);
    return template.match(new RegExp(TOKEN_EXPRESSION));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} template
 * @return {?}
 */
function extractTokenExpressions(template) {
    return extractTokens(template)
        .map((/**
     * @param {?} tokenDefinition
     * @return {?}
     */
    tokenDefinition => stripTokenBraces(tokenDefinition)));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isBoolean(val) {
    return isType(val, 'boolean');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isNotArray(val) {
    return !isArray(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isNotBoolean(val) {
    return !isBoolean(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isNotDate(val) {
    return !isDate$1(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isNotDefined(val) {
    return !isDefined(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isNotFunction(val) {
    return !isFunction(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isNotNumber(val) {
    return !isNumber$1(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isNotObject(val) {
    return !isObject(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isPrimitive(val) {
    return isNotFunction(val) && this.isNotObject(val) && isNotArray(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isNotPrimitive(val) {
    return !isPrimitive(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function isNotString(val) {
    return !isString(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @param {?} expectedType
 * @return {?}
 */
function isNotType(val, expectedType) {
    return !isType(val, expectedType);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const AreaUnit = {
    Acres: 'acres',
    Hectares: 'hectares',
    SquareFeet: 'square-feet',
    SquareMeters: 'square-meters',
    SquareMiles: 'square-miles',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} fromUnit
 * @param {?} toUnit
 * @return {?}
 */
function convertAreaUnits(fromUnit, toUnit) {
    throw new Error(`'convertAreaUnits' is not implemented yet`);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const LengthUnit = {
    Foot: 'foot',
    Degree: 'degree',
    Radian: 'radian',
    Mile: 'mile',
    Meter: 'meter',
    Kilometer: 'kilometer',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getMeterConversionFactors() {
    /** @type {?} */
    const factors = {};
    factors[LengthUnit.Foot] = 0.3048;
    factors[LengthUnit.Kilometer] = 1000;
    factors[LengthUnit.Meter] = 1;
    factors[LengthUnit.Mile] = 1609.34;
    return factors;
}
/** @type {?} */
const LENGTH_UNIT_METER_CONVERSION_FACTOR = getMeterConversionFactors();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @param {?} fromUnit
 * @return {?}
 */
function toMeters(value, fromUnit) {
    /** @type {?} */
    const conversionFactor = LENGTH_UNIT_METER_CONVERSION_FACTOR[fromUnit];
    if (isNotNumber(conversionFactor)) {
        throw new Error(`Can not convert unsupported unit: '${fromUnit}'`);
    }
    return value * conversionFactor;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @param {?} toUnit
 * @return {?}
 */
function fromMeters(value, toUnit) {
    /** @type {?} */
    const conversionFactor = LENGTH_UNIT_METER_CONVERSION_FACTOR[toUnit];
    if (!isNumber$1(conversionFactor)) {
        throw new Error(`Can not convert unsupported unit: '${toUnit}'`);
    }
    return value / conversionFactor;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} fromValue
 * @param {?} fromUnit
 * @param {?} toUnit
 * @return {?}
 */
function convertLengthUnits(fromValue, fromUnit, toUnit) {
    /** @type {?} */
    const fromValueInMeters = toMeters(fromValue, fromUnit);
    return fromMeters(fromValueInMeters, toUnit);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} metersPerSecond
 * @return {?}
 */
function metersPerSecondToKilometersPerHour(metersPerSecond) {
    return metersPerSecond * 3.6;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} metersPerSecond
 * @return {?}
 */
function metersPerSecondToMilesPerHour(metersPerSecond) {
    return metersPerSecond * 2.237;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} url
 * @return {?}
 */
function ensureProtocol(url) {
    if (hasWindow() && String(url).startsWith('//')) {
        url = `${window.location.protocol}${url}`;
    }
    return url;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} url
 * @return {?}
 */
function getBaseUrl(url) {
    let [someUrl] = clean(url).split('#');
    [someUrl] = someUrl.split('?');
    return someUrl;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} tokens
 * @param {...?} parts
 * @return {?}
 */
function joinAndFomat(tokens, ...parts) {
    /** @type {?} */
    const url = join(...parts);
    return format(url, tokens);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} queryParameters
 * @return {?}
 */
function parametersToString(queryParameters) {
    return Object
        .keys(queryParameters)
        .filter((/**
     * @param {?} key
     * @return {?}
     */
    key => isValue(queryParameters[key])))
        .map((/**
     * @param {?} key
     * @return {?}
     */
    key => {
        /** @type {?} */
        const value = isObject(queryParameters[key])
            ? JSON.stringify(queryParameters[key])
            : queryParameters[key];
        return `${key}=${value}`;
    }))
        .join('&');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const EMPTY_PARAMS_REGEX = /(&?\w+=((?=$)|(?=&)))/g;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} url
 * @return {?}
 */
function removeEmptyParams(url) {
    return url.replace(EMPTY_PARAMS_REGEX, '');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} url
 * @return {?}
 */
function stripTrailingSlash(url) {
    return trimEnd(url, '/');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Provides a syntax that ensures the correct use of Disposable objects.
 * @template T
 * @param {?} resource
 * @param {?} func
 * @return {?}
 */
function using(resource, func) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield func(resource);
        }
        finally {
            yield resource.dispose();
        }
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const INVALID_GUID_ERROR_MSG = 'Invalid GUID value provided';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} replaceValue
 * @return {?}
 */
function uuidValueReplacer(replaceValue) {
    // tslint:disable-next-line
    /** @type {?} */
    const randomValue = Math.random() * 16 | 0;
    // tslint:disable-next-line
    /** @type {?} */
    const value = replaceValue === 'x' ? randomValue : (randomValue & 0x3 | 0x8);
    return value.toString(16);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
        .replace(new RegExp('[xy]', 'g'), uuidValueReplacer);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Represents a Global Unique Identifier (GUID). GUID creation ported from:
 * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 */
class Guid {
    /**
     * @param {?=} value
     */
    constructor(value) {
        this.value = value || Guid.empty;
        if (!Guid.isValid(value)) {
            throw new Error(INVALID_GUID_ERROR_MSG);
        }
    }
    /**
     * @return {?}
     */
    get isEmpty() {
        return this.value === Guid.empty;
    }
    /**
     * @return {?}
     */
    static newGuid() {
        return new Guid(uuid());
    }
    /**
     * @param {?} str
     * @return {?}
     */
    static isValid(str) {
        /** @type {?} */
        const validRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return validRegex.test(str);
    }
    /**
     * @param {?} guid
     * @return {?}
     */
    equals(guid) {
        return guid.toString() === this.toString();
    }
    /**
     * @return {?}
     */
    toString() {
        return this.value;
    }
    /**
     * @return {?}
     */
    toJSON() {
        return this.value;
    }
}
Guid.empty = '00000000-0000-0000-0000-000000000000';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidationResult {
    constructor() {
        this.violaters = [];
    }
    /**
     * @return {?}
     */
    get failed() {
        return this.ran && !this.passed;
    }
    /**
     * @return {?}
     */
    get skipped() {
        return this.validationSkipped;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set skipped(value) {
        this.validationSkipped = value;
        this.ran = true;
    }
    /**
     * @param {?} inner
     * @return {?}
     */
    add(inner) {
        if (inner.failed) {
            this.passed = false;
        }
        if (inner.warned) {
            this.warned = true;
        }
        return this;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let BASE_ID = 1;
/**
 * @template T
 */
class ValidationCheck {
    /**
     * @param {?} description
     * @param {?=} passCheck
     */
    constructor(description, passCheck) {
        this.subChecks = [];
        this.description = description;
        this.passCheck = passCheck;
        this.id = BASE_ID++;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    hasId(id) {
        this.id = id;
        return this;
    }
    /**
     * @param {?} description
     * @return {?}
     */
    message(description) {
        this.description = description;
        return this;
    }
    /**
     * @param {?=} passCheck
     * @return {?}
     */
    pass(passCheck) {
        this.passCheck = passCheck;
        return this;
    }
    /**
     * @param {?=} failCheck
     * @return {?}
     */
    fail(failCheck) {
        this.failCheck = failCheck;
        return this;
    }
    /**
     * @param {?=} warnCheck
     * @return {?}
     */
    warn(warnCheck) {
        this.warnCheck = warnCheck;
        return this;
    }
    /**
     * @param {?=} onlyIfCheck
     * @return {?}
     */
    onlyIf(onlyIfCheck) {
        this.onlyIfCheck = onlyIfCheck;
        return this;
    }
    /**
     * @param {...?} innerChecks
     * @return {?}
     */
    add(...innerChecks) {
        innerChecks.forEach((/**
         * @param {?} inner
         * @return {?}
         */
        inner => this.subChecks.push(inner)));
        return this;
    }
    /**
     * @param {?} target
     * @return {?}
     */
    check(target) {
        /** @type {?} */
        const result = new ValidationResult();
        if (this.onlyIfCheck && !this.onlyIfCheck(target)) {
            result.skipped = true;
            return result;
        }
        if (this.passCheck) {
            result.passed = this.passCheck(target);
        }
        if (this.failCheck) {
            result.passed = !this.failCheck(target);
        }
        if (this.warnCheck) {
            result.warned = !this.warnCheck(target);
        }
        if (this.subChecks) {
            this.subChecks.forEach((/**
             * @param {?} c
             * @return {?}
             */
            c => {
                /** @type {?} */
                const innerResult = c.check(target);
                result.add(innerResult);
            }));
        }
        return result;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing csv-related settings.
 */
let CsvConfig = /**
 * Configuration class for storing csv-related settings.
 */
class CsvConfig {
};
CsvConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ CsvConfig.ngInjectableDef = defineInjectable({ factory: function CsvConfig_Factory() { return new CsvConfig(); }, token: CsvConfig, providedIn: "root" });
/**
 * Configuration class for storing csv-related settings.
 */
CsvConfig = __decorate([
    AutoConfig('CsvConfig')
], CsvConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CSV_NEW_LINE = '\r';
/** @type {?} */
const CSV_SEPARATOR = ',';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssCsvModule {
}
TssCsvModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TssCoreModule,
                ],
                declarations: [],
                exports: [],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} data
 * @param {...?} properties
 * @return {?}
 */
function toCsv(data, ...properties) {
    const [firstItem] = data;
    /** @type {?} */
    let csv = '';
    if (firstItem) {
        // NOTE: We need to clone the object here because we can't trust on Object.keys working
        // on every object type. For example, a true "coordinate", object.keys doesn't work - RG.
        properties = properties && properties.length
            ? properties
            : Object.keys(clone(firstItem));
        /** @type {?} */
        const header = `${properties.join(CSV_SEPARATOR)}`;
        /** @type {?} */
        const csvLines = data.map((/**
         * @param {?} point
         * @return {?}
         */
        point => {
            /** @type {?} */
            const fields = properties.map((/**
             * @param {?} property
             * @return {?}
             */
            property => {
                /** @type {?} */
                const value = point[property];
                /** @type {?} */
                const hasPropertyValue = isDefined(value);
                return hasPropertyValue ? value : '';
            }));
            return fields.join(CSV_SEPARATOR);
        }));
        csv = `${header}${CSV_NEW_LINE}${csvLines.join(CSV_NEW_LINE)}`;
    }
    return csv;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} geometry
 * @return {?}
 */
function isLine(geometry) {
    return Boolean(geometry
        && geometry.type
        && String(geometry.type)
            .toLowerCase()
            .includes('linestring'));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @return {?}
 */
function isMultiPartLine(line) {
    return Boolean(line
        && line.length
        && isArray(line[0])
        && isArray(line[0][0]));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @return {?}
 */
function toMultiPartPaths(line) {
    if (isArray(line)) {
        /** @type {?} */
        const lineAsArray = ((/** @type {?} */ (line)));
        return isMultiPartLine(lineAsArray)
            ? lineAsArray
            : [lineAsArray];
    }
    else {
        /** @type {?} */
        const lineGeometry = (/** @type {?} */ (line));
        return lineGeometry.type === 'LineString'
            ? [lineGeometry.coordinates]
            : lineGeometry.coordinates;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @return {?}
 */
function flattenLine(line) {
    /** @type {?} */
    const flattenedPoints = [];
    /** @type {?} */
    const multipParts = toMultiPartPaths(line);
    multipParts.forEach((/**
     * @param {?} part
     * @return {?}
     */
    (part) => {
        part.forEach((/**
         * @param {?} position
         * @return {?}
         */
        (position) => {
            flattenedPoints.push(position);
        }));
    }));
    return flattenedPoints;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} geometry
 * @return {?}
 */
function isPoint(geometry) {
    return geometry && geometry.type
        ? geometry.type === 'Point' || geometry.type === 'MultiPoint'
        : false;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} point
 * @return {?}
 */
function isMultiPartPoint(point) {
    /** @type {?} */
    const coordinates = isArray(point)
        ? ((/** @type {?} */ (point)))
        : ((/** @type {?} */ (point))).coordinates;
    return Boolean(coordinates
        && coordinates.length
        && isArray(coordinates[0]));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} point
 * @return {?}
 */
function toMultiPartPoint(point) {
    /** @type {?} */
    const coordinates = isArray(point)
        ? ((/** @type {?} */ (point)))
        : ((/** @type {?} */ (point))).coordinates;
    return isMultiPartPoint(coordinates)
        ? (/** @type {?} */ (coordinates))
        : [(/** @type {?} */ (coordinates))];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} geometry
 * @return {?}
 */
function isPolygon(geometry) {
    return geometry && geometry.type
        ? geometry.type === 'Polygon' || geometry.type === 'MultiPolygon'
        : false;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} geometry
 * @param {...?} verticeeOrdinalNames
 * @return {?}
 */
function geometryToCsv(geometry, ...verticeeOrdinalNames) {
    /** @type {?} */
    const pointInfos = [];
    /** @type {?} */
    let verticees = [];
    if (isLine(geometry)) {
        verticees = flattenLine((/** @type {?} */ (geometry)));
    }
    else if (isPoint(geometry)) {
        verticees = toMultiPartPoint((/** @type {?} */ (geometry)));
    }
    else if (isPolygon(geometry)) {
        /** @type {?} */
        const polygon = (/** @type {?} */ (geometry));
        verticees = flattenLine(polygon.coordinates);
    }
    else {
        throw new Error('Unknown or unsupported geometry type provided');
    }
    verticees.map((/**
     * @param {?} verticee
     * @return {?}
     */
    verticee => {
        /** @type {?} */
        const info = {};
        pointInfos.push(info);
        if (!verticeeOrdinalNames || !verticeeOrdinalNames.length) {
            verticeeOrdinalNames = ['x', 'y'];
            if (verticee.length > 2) {
                verticeeOrdinalNames.push('z');
            }
            if (verticee.length > 3) {
                verticeeOrdinalNames.push('m');
            }
        }
        verticeeOrdinalNames.forEach((/**
         * @param {?} name
         * @param {?} index
         * @return {?}
         */
        (name, index) => {
            info[name] = verticee[index];
        }));
    }));
    return toCsv(pointInfos);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const APPLY_EDITS_SEED_POD_FILE_EXTENSION = '.tssedits';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing global ESRI-related settings.
 */
let DataSourceConfig = /**
 * Configuration class for storing global ESRI-related settings.
 */
class DataSourceConfig extends ResourceConfig {
    constructor() {
        super(...arguments);
        this.dataSourcesEndpoint = 'api/data/sources/{id}';
        this.tablesEndpoint = 'api/data/sources/{id}/tables';
        this.columnsEndpoint = 'api/data/sources/{id}/tables/{table}/columns/{column}/{action}';
        this.tableActionEndpoint = 'api/data/sources/{id}/tables/{table}/{action}/{subaction}';
        this.editDataEndpoint = 'api/data/sources/{id}/tables/{table}/edit';
        this.applyEditsEndpoint = 'api/data/sources/{id}/applyedits';
        this.attachmentsEndpoint = 'api/attachments/{id}/{action}';
        this.skipColumnQuotes = false;
    }
};
DataSourceConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ DataSourceConfig.ngInjectableDef = defineInjectable({ factory: function DataSourceConfig_Factory() { return new DataSourceConfig(); }, token: DataSourceConfig, providedIn: "root" });
/**
 * Configuration class for storing global ESRI-related settings.
 */
DataSourceConfig = __decorate([
    AutoConfig('DataSourceConfig')
], DataSourceConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataSourceEditService extends BaseEmptyResourceService {
    /**
     * @param {?} http
     * @param {?} dsConfig
     */
    constructor(http, dsConfig) {
        super(http, {
            url: dsConfig.serviceUrl
        });
        this.http = http;
        this.dsConfig = dsConfig;
    }
    /**
     * @param {?} data
     * @param {?=} params
     * @return {?}
     */
    applyEdits(data, params) {
        if (!data) {
            throw new Error('Missing or invalid apply edits seed data provided');
        }
        else if (!data.dataSourceId) {
            throw new Error(`Missing 'dataSourceId' from the apply edits seed data`);
        }
        /** @type {?} */
        const url = this.getUrlWithId(data.dataSourceId, this.dsConfig.applyEditsEndpoint, {});
        return this.http.post(url, data, { params });
    }
    /**
     * @param {?} dataSourceId
     * @param {?} table
     * @param {?} feature
     * @param {?=} version
     * @param {?=} params
     * @return {?}
     */
    createRecord(dataSourceId, table, feature, version, params) {
        /** @type {?} */
        const url = this.getUrlWithId(dataSourceId, this.dsConfig.editDataEndpoint, { table });
        params = (params || new HttpParams())
            .set('version', version || EMPTY_PARAM_VALUE);
        return this.http.post(url, feature, { params });
    }
}
DataSourceEditService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DataSourceEditService.ctorParameters = () => [
    { type: HttpClient },
    { type: DataSourceConfig }
];
/** @nocollapse */ DataSourceEditService.ngInjectableDef = defineInjectable({ factory: function DataSourceEditService_Factory() { return new DataSourceEditService(inject(HttpClient), inject(DataSourceConfig)); }, token: DataSourceEditService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const AttachmentType = {
    Video: 'video',
    Image: 'image',
    Audio: 'audio',
    Text: 'text',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @param {?=} encodeData
 * @return {?}
 */
function toFormDataString(value, encodeData = true) {
    /** @type {?} */
    let stringValue;
    if (isNotValue(value)) {
        stringValue = '';
    }
    else if (isObject(value) || isArray(value)) {
        stringValue = JSON.stringify(value);
    }
    else {
        stringValue = value.toString();
    }
    return isValue(stringValue) && encodeData ?
        encodeURIComponent(stringValue)
        : stringValue;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ATTACHMENT_FILE_FORM_KEY = 'file';
/** @type {?} */
const ATTACHMENT_DATA_FORM_KEY = 'attachment';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AttachmentService extends BaseResourceService {
    /**
     * @param {?} http
     * @param {?} dsConfig
     */
    constructor(http, dsConfig) {
        super(http, {
            url: dsConfig.serviceUrl,
            queryEndpoint: dsConfig.attachmentsEndpoint,
            getEndpoint: dsConfig.attachmentsEndpoint,
            updateEndpoint: dsConfig.attachmentsEndpoint,
            deleteEndpoint: dsConfig.attachmentsEndpoint,
            createEndpoint: dsConfig.attachmentsEndpoint,
        });
        this.http = http;
    }
    /**
     * @param {?} attachment
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    create(attachment, routeTokens, params) {
        /** @type {?} */
        const url = this.getUrl(this.config.createEndpoint, routeTokens);
        /** @type {?} */
        const formData = new FormData();
        /** @type {?} */
        let fileData;
        if (attachment.type === AttachmentType.Image && isString(attachment.data)) {
            fileData = base64toBlob((/** @type {?} */ (attachment.data)));
        }
        else if (attachment.type === AttachmentType.Text) {
            fileData = new Blob([attachment.data]);
        }
        else {
            fileData = (/** @type {?} */ (attachment.data));
        }
        delete attachment.data;
        formData.append(ATTACHMENT_FILE_FORM_KEY, fileData);
        formData.append(ATTACHMENT_DATA_FORM_KEY, toFormDataString(attachment));
        return this.http.post(url, formData, { params, reportProgress: true });
    }
    /**
     * @param {?} attachmentId
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    download(attachmentId, routeTokens, params) {
        // TODO: Complete - RG.
        // const url = this.getUrl(this.config.getEndpoint, Object.assign({ action: 'download' }, routeTokens));
        throw new Error('Not implemented yet');
    }
}
AttachmentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AttachmentService.ctorParameters = () => [
    { type: HttpClient },
    { type: DataSourceConfig }
];
/** @nocollapse */ AttachmentService.ngInjectableDef = defineInjectable({ factory: function AttachmentService_Factory() { return new AttachmentService(inject(HttpClient), inject(DataSourceConfig)); }, token: AttachmentService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const DataSourceProviderType = {
    SqlServer: 'System.Data.SqlClient',
    SqlLite: 'System.Data.SQLite',
    SqlCompactEdition: 'System.Data.SqlServerCe.4.0',
    Oracle: 'Oracle.ManagedDataAccess.Client',
    OracleDevArt: 'Devart.Data.Oracle',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SELECT_ALL_WHERE_CLAUSE = '1=1';
/** @type {?} */
const DATA_SOURCE_PROVIDERS = [
    { alias: 'SQL Server', provider: DataSourceProviderType.SqlServer, canUseEF: true, schedulingCompatible: true },
    { alias: 'SQLite', provider: DataSourceProviderType.SqlLite, canUseEF: false, schedulingCompatible: true },
    {
        alias: 'SQL Server Compact Edition',
        provider: DataSourceProviderType.SqlCompactEdition,
        canUseEF: true,
        schedulingCompatible: false
    },
    { alias: 'Oracle', provider: DataSourceProviderType.Oracle, canUseEF: false, schedulingCompatible: false },
    { alias: 'Oracle', provider: DataSourceProviderType.OracleDevArt, canUseEF: true, efOnly: true, schedulingCompatible: false }
];
/** @type {?} */
const DATA_SOURCE_EXAMPLES = [
    {
        name: 'SQL Server Connection',
        providerName: DataSourceProviderType.SqlServer,
        connectionString: 'data source=YOUR_HOST, 1433;initial catalog=YOUR_DB;persist security info=True;'
            + 'user id=YOUR_USER;password=YOUR_PASSWORD;MultipleActiveResultSets=true;'
    },
    {
        name: 'SQL Server Compact (SQL CE) Connection',
        providerName: DataSourceProviderType.SqlCompactEdition,
        connectionString: 'Data Source=|DataDirectory|\\YOUR_DB_NAME.sdf;Max Database Size=4091'
    },
    {
        name: 'SQLite',
        providerName: DataSourceProviderType.SqlLite,
        connectionString: 'Data Source=|DataDirectory|\\YOUR_DB_NAME.sqlite;Version=3'
    },
    {
        name: 'Oracle Connection (without TNS names entry)',
        providerName: DataSourceProviderType.Oracle,
        connectionString: 'Data Source=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)'
            + '(HOST=YOUR_HOST)(PORT=1522)))(CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=YOUR_SERVICE)));'
            + 'User Id=YOUR_USER;Password=YOUR_PASSWORD;'
    },
    {
        name: 'Oracle Connection (with TNS names entry)',
        providerName: DataSourceProviderType.Oracle,
        connectionString: 'Data Source=YOUR_SOURCE;User Id=YOUR_USER;Password=YOUR_PASSWORD;'
    },
    {
        name: 'Oracle Connection (without TNS names entry)',
        providerName: DataSourceProviderType.OracleDevArt,
        connectionString: 'Data Source=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)'
            + '(HOST=YOUR_HOST)(PORT=1522)))(CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=YOUR_SERVICE)));'
            + 'User Id=YOUR_USER;Password=YOUR_PASSWORD;'
    },
    {
        name: 'Oracle Connection (with TNS names entry)',
        providerName: DataSourceProviderType.OracleDevArt,
        connectionString: 'Data Source=YOUR_SOURCE;User Id=YOUR_USER;Password=YOUR_PASSWORD;'
    }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataSourceService extends BaseResourceService {
    /**
     * @param {?} http
     * @param {?} dsConfig
     */
    constructor(http, dsConfig) {
        super(http, {
            url: dsConfig.serviceUrl,
            queryEndpoint: dsConfig.dataSourcesEndpoint,
            getEndpoint: dsConfig.dataSourcesEndpoint,
            updateEndpoint: dsConfig.dataSourcesEndpoint,
            deleteEndpoint: dsConfig.dataSourcesEndpoint,
            createEndpoint: dsConfig.dataSourcesEndpoint,
        });
        this.http = http;
        this.dsConfig = dsConfig;
    }
    /**
     * @param {?} entity
     * @param {?} useEntityFramework
     * @param {?=} params
     * @return {?}
     */
    testConnection(entity, useEntityFramework, params) {
        throw new Error('Not implemented yet');
    }
    /**
     * @param {?} id
     * @param {?=} params
     * @return {?}
     */
    testExistingConnection(id, params) {
        throw new Error('Not implemented yet');
    }
    // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables'
    /**
     * @param {?} dataSourceId
     * @param {?=} params
     * @return {?}
     */
    getTables(dataSourceId, params) {
        /** @type {?} */
        const url = this.getUrlWithId(dataSourceId, this.dsConfig.tablesEndpoint, {});
        return this.http.get(url, { params });
    }
    // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables/details'
    /**
     * @param {?} dataSourceId
     * @param {?=} params
     * @return {?}
     */
    getTableDetails(dataSourceId, params) {
        /** @type {?} */
        const url = this.getUrlWithId(dataSourceId, this.dsConfig.tableActionEndpoint, {
            action: 'details'
        });
        return this.http.get(url, { params });
    }
    // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables/:table/columns/:column/:action',
    /**
     * @param {?} dataSourceId
     * @param {?} table
     * @param {?=} params
     * @return {?}
     */
    getColumns(dataSourceId, table, params) {
        /** @type {?} */
        const url = this.getUrlWithId(dataSourceId, this.dsConfig.columnsEndpoint, { table });
        return this.http.get(url, { params });
    }
    // api/data/sources/test_1051_sql/tables/RH.DIVIDED_ROADS/columns/SurveyDirection/values?unique=false
    /**
     * @template T
     * @param {?} dataSourceId
     * @param {?} table
     * @param {?} column
     * @param {?=} unique
     * @param {?=} params
     * @return {?}
     */
    getColumnValues(dataSourceId, table, column, unique = false, params) {
        /** @type {?} */
        const url = this.getUrlWithId(dataSourceId, this.dsConfig.columnsEndpoint, {
            table,
            column,
            action: 'values'
        });
        params = (params || new HttpParams()).set('unique', String(unique));
        return this.http.get(url, { params });
    }
    // api/data/sources/test_1051_sql/tables/RH.DIVIDED_ROADS/columns/SurveyDirection/values?unique=true
    /**
     * @template T
     * @param {?} dataSourceId
     * @param {?} table
     * @param {?} column
     * @param {?=} params
     * @return {?}
     */
    getUniqueColumnValues(dataSourceId, table, column, params) {
        return this.getColumnValues(dataSourceId, table, column, true, params);
    }
    // 'http:' + this.appConfig.serviceUrl + '/api/data/sources/:id/tables/:count'
    /**
     * @param {?} dataSourceId
     * @param {?} table
     * @param {?=} whereClause
     * @param {?=} version
     * @param {?=} params
     * @return {?}
     */
    getRecordCount(dataSourceId, table, whereClause = SELECT_ALL_WHERE_CLAUSE, version, params) {
        /** @type {?} */
        const url = this.getUrlWithId(dataSourceId, this.dsConfig.tableActionEndpoint, {
            table,
            action: 'count'
        });
        params = (params || new HttpParams())
            .set('where', whereClause)
            .set('version', version || EMPTY_PARAM_VALUE);
        return this.http.get(url, { params });
    }
    // api/data/sources/test_1051_sql/tables/RH.DIVIDED_ROADS/query/details?page=1&pageSize=25&where=1%3D1
    /**
     * @param {?} dataSourceId
     * @param {?} table
     * @param {?} whereClause
     * @param {?=} version
     * @param {?=} page
     * @param {?=} pageSize
     * @param {?=} includeGeometry
     * @param {?=} shapeField
     * @param {?=} params
     * @return {?}
     */
    queryData(dataSourceId, table, whereClause, version, page, pageSize, includeGeometry, shapeField, params) {
        return this.querySpatialData(dataSourceId, table, whereClause, version, page, pageSize, includeGeometry, shapeField, 'json', params);
    }
    /**
     * @param {?} dataSourceId
     * @param {?} table
     * @param {?} whereClause
     * @param {?=} version
     * @param {?=} page
     * @param {?=} pageSize
     * @param {?=} includeGeometry
     * @param {?=} shapeField
     * @param {?=} params
     * @return {?}
     */
    queryGeoJsonData(dataSourceId, table, whereClause, version, page, pageSize, includeGeometry, shapeField, params) {
        return this.querySpatialData(dataSourceId, table, whereClause, version, page, pageSize, includeGeometry, shapeField, 'geojson', params);
    }
    /**
     * @template T
     * @param {?} dataSourceId
     * @param {?} table
     * @param {?} whereClause
     * @param {?=} version
     * @param {?=} page
     * @param {?=} pageSize
     * @param {?=} includeGeometry
     * @param {?=} shapeField
     * @param {?=} format
     * @param {?=} params
     * @return {?}
     */
    querySpatialData(dataSourceId, table, whereClause, version, page, pageSize, includeGeometry, shapeField, format, params) {
        /** @type {?} */
        const url = this.getUrlWithId(dataSourceId, this.dsConfig.tableActionEndpoint, {
            table,
            action: 'query/details'
        });
        params = (params || new HttpParams())
            .set('where', whereClause || EMPTY_PARAM_VALUE)
            .set('version', version || EMPTY_PARAM_VALUE)
            .set('page', isValue(page) ? String(page) : EMPTY_PARAM_VALUE)
            .set('pageSize', isValue(pageSize) ? String(pageSize) : EMPTY_PARAM_VALUE)
            .set('includeGeometry', isValue(includeGeometry) ? String(includeGeometry) : EMPTY_PARAM_VALUE)
            .set('shapeField', shapeField || EMPTY_PARAM_VALUE)
            .set('format', format || EMPTY_PARAM_VALUE);
        return this.http.get(url, { params });
    }
}
DataSourceService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DataSourceService.ctorParameters = () => [
    { type: HttpClient },
    { type: DataSourceConfig }
];
/** @nocollapse */ DataSourceService.ngInjectableDef = defineInjectable({ factory: function DataSourceService_Factory() { return new DataSourceService(inject(HttpClient), inject(DataSourceConfig)); }, token: DataSourceService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} tableName
 * @return {?}
 */
function stripTableName(tableName) {
    return (tableName || '').split('.').slice(-1)[0];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} dataSource
 * @return {?}
 */
function getDataSourceId(dataSource) {
    /** @type {?} */
    let dataSourceId;
    if (isString(dataSource)) {
        dataSourceId = (/** @type {?} */ (dataSource));
    }
    else {
        /** @type {?} */
        const src = (/** @type {?} */ (dataSource));
        if (src) {
            dataSourceId = src.id;
        }
    }
    return dataSourceId;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} providerType
 * @return {?}
 */
function isOracleProvider(providerType) {
    return providerType === DataSourceProviderType.Oracle || providerType === DataSourceProviderType.OracleDevArt;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} providerType
 * @return {?}
 */
function getDateFormatForProvider(providerType) {
    if (!providerType) {
        return STANDARDIZED_QUERY_DATE_FORMAT;
    }
    else if (isOracleProvider(providerType)) {
        return ORACLE_DATE_FORMAT;
    }
    else {
        return DEFAULT_DATE_FORMAT;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} providerType
 * @return {?}
 */
function isEnterpriseProvider(providerType) {
    return providerType === DataSourceProviderType.SqlServer
        || providerType === DataSourceProviderType.Oracle
        || providerType === DataSourceProviderType.OracleDevArt;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SEED_POD_FILE_EXTENSION = '.tss';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FIELD_TYPE_OID = 'id';
/** @type {?} */
const FIELD_TYPE_OID_STRING = 'id-string';
/** @type {?} */
const FIELD_TYPE_STRING = 'string';
/** @type {?} */
const FIELD_TYPE_NUMBER = 'number';
/** @type {?} */
const FIELD_TYPE_XML = 'xml';
/** @type {?} */
const FIELD_TYPE_BLOB = 'blob';
/** @type {?} */
const FIELD_TYPE_DATE = 'date';
/** @type {?} */
const FIELD_TYPE_DOUBLE = 'double';
/** @type {?} */
const FIELD_TYPE_GUID = 'guid';
/** @type {?} */
const FIELD_TYPE_GEOMETRY = 'geometry';
/** @type {?} */
const FIELD_TYPE_GLOBALID = 'globalId';
/** @type {?} */
const FIELD_TYPE_INTEGER = 'integer';
/** @type {?} */
const FIELD_TYPE_RASTER = 'raster';
/** @type {?} */
const FIELD_TYPE_SINGLE = 'single';
/** @type {?} */
const FIELD_TYPE_SMALL_INTEGER = 'int';
/** @type {?} */
const ESRI_FIELD_TYPE_OID = 'esriFieldTypeOID';
/** @type {?} */
const ESRI_FIELD_TYPE_STRING = 'esriFieldTypeString';
/** @type {?} */
const ESRI_FIELD_TYPE_NUMBER = 'esriFieldTypeNumber';
/** @type {?} */
const ESRI_FIELD_TYPE_XML = 'esriFieldTypeXML';
/** @type {?} */
const ESRI_FIELD_TYPE_BLOB = 'esriFieldTypeBlob';
/** @type {?} */
const ESRI_FIELD_TYPE_DATE = 'esriFieldTypeDate';
/** @type {?} */
const ESRI_FIELD_TYPE_DOUBLE = 'esriFieldTypeDouble';
/** @type {?} */
const ESRI_FIELD_TYPE_GUID = 'esriFieldTypeGUID';
/** @type {?} */
const ESRI_FIELD_TYPE_GEOMETRY = 'esriFieldTypeGeometry';
/** @type {?} */
const ESRI_FIELD_TYPE_GLOBALID = 'esriFieldTypeGlobalID';
/** @type {?} */
const ESRI_FIELD_TYPE_INTEGER = 'esriFieldTypeInteger';
/** @type {?} */
const ESRI_FIELD_TYPE_RASTER = 'esriFieldTypeRaster';
/** @type {?} */
const ESRI_FIELD_TYPE_SINGLE = 'esriFieldTypeSingle';
/** @type {?} */
const ESRI_FIELD_TYPE_SMALL_INTEGER = 'esriFieldTypeSmallInteger';
/** @type {?} */
const FIELD_METADATA = [
    { alias: 'ID', isNumeric: true, types: [FIELD_TYPE_OID, ESRI_FIELD_TYPE_OID] },
    { alias: 'ID', isNumeric: false, types: [FIELD_TYPE_OID_STRING] },
    { alias: 'string', isNumeric: false, types: [FIELD_TYPE_STRING, ESRI_FIELD_TYPE_STRING] },
    { alias: 'number', isNumeric: true, types: [FIELD_TYPE_NUMBER, ESRI_FIELD_TYPE_NUMBER] },
    { alias: 'double', isNumeric: true, types: [FIELD_TYPE_DOUBLE, ESRI_FIELD_TYPE_DOUBLE] },
    { alias: 'int', isNumeric: true, types: [FIELD_TYPE_INTEGER, ESRI_FIELD_TYPE_INTEGER, ESRI_FIELD_TYPE_SMALL_INTEGER] },
    { alias: 'date', isNumeric: false, types: [FIELD_TYPE_DATE, ESRI_FIELD_TYPE_DATE] },
    { alias: 'geometry', isNumeric: false, types: [FIELD_TYPE_GEOMETRY, ESRI_FIELD_TYPE_GEOMETRY] },
    { alias: 'xml', isNumeric: false, types: [FIELD_TYPE_XML, ESRI_FIELD_TYPE_XML] },
    { alias: 'blob', isNumeric: false, types: [FIELD_TYPE_BLOB, ESRI_FIELD_TYPE_BLOB] },
    { alias: 'guid', isNumeric: false, types: [FIELD_TYPE_GUID, ESRI_FIELD_TYPE_GUID] },
    { alias: 'globalId', isNumeric: false, types: [FIELD_TYPE_GLOBALID, ESRI_FIELD_TYPE_GLOBALID] },
    { alias: 'integer', isNumeric: true, types: [FIELD_TYPE_INTEGER, ESRI_FIELD_TYPE_INTEGER] },
    { alias: 'raster', isNumeric: false, types: [FIELD_TYPE_RASTER, ESRI_FIELD_TYPE_RASTER] },
    { alias: 'single', isNumeric: false, types: [FIELD_TYPE_SINGLE, ESRI_FIELD_TYPE_SINGLE] },
];
/**
 * @param {?} fieldType
 * @return {?}
 */
function isFieldGeometryType(fieldType) {
    return fieldType === 'esriFieldTypeGeometry' || fieldType === 'geometry';
}
/**
 * @param {?} fieldType
 * @return {?}
 */
function isObjectIdType(fieldType) {
    return fieldType === 'esriFieldTypeOID' || fieldType === 'id';
}
/**
 * @param {?} fields
 * @return {?}
 */
function getGeometryField(fields) {
    return (fields || []).find((/**
     * @param {?} f
     * @return {?}
     */
    f => isFieldGeometryType(f.type)));
}
/**
 * @param {?} fields
 * @return {?}
 */
function getGeometryFieldName(fields) {
    /** @type {?} */
    const field = getGeometryField(fields);
    return field ? field.name : null;
}
/**
 * @param {?} fields
 * @return {?}
 */
function getIdField(fields) {
    return (fields || []).find((/**
     * @param {?} f
     * @return {?}
     */
    f => isObjectIdType(f.type)));
}
/**
 * @param {?} fields
 * @return {?}
 */
function getIdFieldFieldName(fields) {
    /** @type {?} */
    const field = getIdField(fields);
    return field ? field.name : null;
}
/**
 * @param {?} fieldNameOrExpression
 * @return {?}
 */
function isFieldExpression(fieldNameOrExpression) {
    return hasTokens(fieldNameOrExpression);
}
/**
 * @param {?} field
 * @return {?}
 */
function toFieldType(field) {
    return isString(field)
        ? (/** @type {?} */ (field))
        : ((/** @type {?} */ (field))).type;
}
/**
 * @param {?} field
 * @return {?}
 */
function toFieldName(field) {
    return isString(field) ? (/** @type {?} */ (field)) : ((/** @type {?} */ (field))).name;
}
/**
 * @param {?} fieldName
 * @param {?} fields
 * @return {?}
 */
function getField(fieldName, fields) {
    return fields.find((/**
     * @param {?} f
     * @return {?}
     */
    f => f.name === fieldName)) || null;
}
/**
 * @param {?} fieldName
 * @param {?} fields
 * @return {?}
 */
function getFieldAlias(fieldName, fields) {
    /** @type {?} */
    let fieldAlias = null;
    /** @type {?} */
    const field = getField(fieldName, fields);
    if (field && field.alias) {
        fieldAlias = field.alias;
    }
    return fieldAlias;
}
/**
 * @param {?} field
 * @return {?}
 */
function isFieldNumeric(field) {
    /** @type {?} */
    const fieldType = toFieldType(field);
    /** @type {?} */
    const match = FIELD_METADATA
        .filter((/**
     * @param {?} f
     * @return {?}
     */
    f => f.isNumeric))
        .find((/**
     * @param {?} f
     * @return {?}
     */
    f => f.types.indexOf(fieldType) > -1));
    return Boolean(match);
}
/**
 * @param {?} field
 * @param {?} value
 * @return {?}
 */
function isFieldValueNumeric(field, value) {
    /** @type {?} */
    const fieldType = toFieldType(field);
    if (isObjectIdType(fieldType) && canNotBeNumber(value)) {
        return false;
    }
    return isFieldNumeric(field);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FIELD_QUOTE = '"';
/** @enum {string} */
const CriteriaOperator = {
    Equals: '=',
    DoesNotEqual: '<>',
    // In = 'IN',
    // OneOf, NotOneOf, Between, NotBetween, Contains...
    GreaterThan: '>',
    LessThan: '<',
    GreaterOrEqualTo: '>=',
    LessThanOrEqualTo: '<=',
};
/** @enum {string} */
const TargetOperator = {
    Is: 'IS',
    Not: 'NOT',
    In: 'IN',
    Like: 'LIKE',
    Between: 'BETWEEN',
};
/** @enum {string} */
const ValueOperator = {
    Wildcard: '%',
    Null: 'NULL',
};
/** @enum {string} */
const GroupingOperator = {
    OpenParenthesis: '(',
    ClosedParenthesis: ')',
    Parenthesis: '()',
};
/** @enum {string} */
const CombiningOperator = {
    And: 'AND',
    Or: 'OR',
};
/** @type {?} */
const DefaultWhereClauseBuilderOptions = {
    quoteFields: true
};
class WhereClauseBuilder {
    /**
     * @param {?=} options
     */
    constructor(options) {
        this.statements = [];
        this.options = Object.assign({}, DefaultWhereClauseBuilderOptions, options);
    }
    /**
     * @return {?}
     */
    get criteriaCount() {
        return this.statements.length;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} statement
     * @return {THIS}
     */
    add(statement) {
        (/** @type {?} */ (this)).statements.push(statement);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} field
     * @param {?} value
     * @return {THIS}
     */
    whereEqual(field, value) {
        return value === null
            ? (/** @type {?} */ (this)).whereIsNull(field.name)
            : (/** @type {?} */ (this)).where(field.name, CriteriaOperator.Equals, value, isFieldValueNumeric(field, value));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} field
     * @param {?} value
     * @return {THIS}
     */
    whereLike(field, value) {
        return (/** @type {?} */ (this)).add(`${(/** @type {?} */ (this)).formatField(field)} ${TargetOperator.Like} '%${value}%'`);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} field
     * @param {?} value
     * @return {THIS}
     */
    whereStartsWith(field, value) {
        return (/** @type {?} */ (this)).add(`${(/** @type {?} */ (this)).formatField(field)} ${TargetOperator.Like} '${value}%'`);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} field
     * @param {?} value
     * @return {THIS}
     */
    whereEndsWith(field, value) {
        return (/** @type {?} */ (this)).add(`${(/** @type {?} */ (this)).formatField(field)} ${TargetOperator.Like} '%${value}'`);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} field
     * @param {?} value
     * @return {THIS}
     */
    whereNotEqual(field, value) {
        return value === null
            ? (/** @type {?} */ (this)).whereIsNotNull(field.name)
            : (/** @type {?} */ (this)).where(field.name, CriteriaOperator.DoesNotEqual, value, isFieldValueNumeric(field, value));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} field
     * @return {THIS}
     */
    whereIsNull(field) {
        return (/** @type {?} */ (this)).add(`${(/** @type {?} */ (this)).formatField(field)} ${TargetOperator.Is} ${ValueOperator.Null}`);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} field
     * @return {THIS}
     */
    whereIsNotNull(field) {
        return (/** @type {?} */ (this)).add(`${(/** @type {?} */ (this)).formatField(field)} ${TargetOperator.Is} ${TargetOperator.Not} ${ValueOperator.Null}`);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} field
     * @param {?} operator
     * @param {?} value
     * @param {?=} isNumeric
     * @return {THIS}
     */
    where(field, operator, value, isNumeric = false) {
        value = isNumeric ? value : `'${value}'`;
        (/** @type {?} */ (this)).add(`${(/** @type {?} */ (this)).formatField(field)}${operator}${value}`);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} field
     * @param {?} value
     * @return {THIS}
     */
    whereNumeric(field, value) {
        (/** @type {?} */ (this)).where(field, value, true);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    toWhereClause() {
        return this.statements.join(` ${CombiningOperator.And} `);
    }
    /**
     * @return {?}
     */
    toString() {
        return this.toWhereClause();
    }
    /**
     * @return {?}
     */
    clear() {
        this.statements.length = 0;
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    formatField(field) {
        field = field || '';
        /** @type {?} */
        const addQuotes = this.options.quoteFields;
        if (addQuotes) {
            if (!field.startsWith(FIELD_QUOTE)) {
                field = `${FIELD_QUOTE}${field}`;
            }
            if (!field.endsWith(FIELD_QUOTE)) {
                field = `${field}${FIELD_QUOTE}`;
            }
        }
        else {
            /** @type {?} */
            const quoteRegex = new RegExp(FIELD_QUOTE, 'i');
            return field.replace(quoteRegex, '');
        }
        return field;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NO_TEMPORAL_LAYER_SUPPLIED_ERROR_MSG = 'No LRS temporal layers supplied';
/** @type {?} */
const NO_REFERENCE_LAYER_SUPPLIED_ERROR_MSG = 'No LRS reference layer supplied';
/** @type {?} */
const LRS_DATE_WHERE_CLAUSE_TEMPLATE = '(({fromDateFieldName} IS NULL OR {fromDateFieldName} <= {dateEndOfDay})'
    + ' AND ({toDateFieldName} IS NULL OR {toDateFieldName} > {date}))';
/** @type {?} */
const LRS_POINT_EVENT_WHERE_CLAUSE_TEMPLATE = `({fromMeasureFieldName} between {fromMeasure} and {toMeasure})`;
/** @type {?} */
const LRS_LINEAR_EVENT_WHERE_CLAUSE_TEMPLATE = `(({fromMeasureFieldName} between {fromMeasure} AND {toMeasure})`
    + ` OR ({toMeasureFieldName} between {fromMeasure} AND {toMeasure}) OR ({fromMeasureFieldName} < {fromMeasure}`
    + ` AND {toMeasureFieldName} > {toMeasure})) AND NOT (({fromMeasureFieldName} < {fromMeasure}`
    + ` AND {toMeasureFieldName} <= {fromMeasure}) OR ({toMeasureFieldName} > {toMeasure} AND {fromMeasureFieldName} >= {toMeasure}))`;
/**
 * @param {?} fromDateFieldName
 * @param {?} toDateFieldName
 * @param {?=} dbType
 * @param {?=} viewDate
 * @return {?}
 */
function getLrsViewDateWhereStatement(fromDateFieldName, toDateFieldName, dbType, viewDate) {
    viewDate = toUtcDate(viewDate || new Date());
    setDateToBeginningOfDay(viewDate);
    // TODO: Look into whether we need to actually use end of day or not
    // Currently we are just setting it to same as 'date' - RG.
    /** @type {?} */
    const dateFormat = getDateFormatForProvider(dbType);
    return format(LRS_DATE_WHERE_CLAUSE_TEMPLATE, {
        fromDateFieldName,
        toDateFieldName,
        date: formatDateForQuery(viewDate, dateFormat),
        dateEndOfDay: formatDateForQuery(viewDate, dateFormat),
    });
}
class LrsWhereClauseBuilder extends WhereClauseBuilder {
    /**
     * @param {?=} options
     */
    constructor(options) {
        super(options);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} sourceData
     * @return {THIS}
     */
    withDataSource(sourceData) {
        return (/** @type {?} */ (this)).withDataProvider(sourceData.providerName);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} sourceDbType
     * @return {THIS}
     */
    withDataProvider(sourceDbType) {
        (/** @type {?} */ (this)).sourceDbType = sourceDbType;
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} eventLayer
     * @return {THIS}
     */
    withEventLayer(eventLayer) {
        return (/** @type {?} */ (this)).withTemporalLayer(eventLayer)
            .withReferenceLayer(eventLayer);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} referenceLayer
     * @return {THIS}
     */
    withReferenceLayer(referenceLayer) {
        (/** @type {?} */ (this)).referenceLayer = referenceLayer;
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} networkLayer
     * @return {THIS}
     */
    withNetworkLayer(networkLayer) {
        return (/** @type {?} */ (this)).withTemporalLayer(networkLayer);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} temporalLayer
     * @return {THIS}
     */
    withTemporalLayer(temporalLayer) {
        (/** @type {?} */ (this)).temporalLayer = temporalLayer;
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} routeId
     * @param {?=} routeIdFieldName
     * @return {THIS}
     */
    withRouteId(routeId, routeIdFieldName) {
        return (/** @type {?} */ (this)).where(routeIdFieldName || (/** @type {?} */ (this)).referenceLayer.routeIdFieldName, CriteriaOperator.Equals, routeId);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?=} viewDate
     * @param {?=} fromDateFieldName
     * @param {?=} toDateFieldName
     * @return {THIS}
     */
    withViewDate(viewDate, fromDateFieldName, toDateFieldName) {
        if ((/** @type {?} */ (this)).temporalLayer) {
            fromDateFieldName = fromDateFieldName || (/** @type {?} */ (this)).temporalLayer.fromDateFieldName;
            toDateFieldName = toDateFieldName || (/** @type {?} */ (this)).temporalLayer.toDateFieldName;
        }
        /** @type {?} */
        const hasDateFieldInfo = Boolean((/** @type {?} */ (this)).temporalLayer || fromDateFieldName && toDateFieldName);
        if (!hasDateFieldInfo) {
            throw new Error(NO_TEMPORAL_LAYER_SUPPLIED_ERROR_MSG);
        }
        if (fromDateFieldName && toDateFieldName) {
            /** @type {?} */
            const dateClause = getLrsViewDateWhereStatement((/** @type {?} */ (this)).formatField(fromDateFieldName), (/** @type {?} */ (this)).formatField(toDateFieldName), (/** @type {?} */ (this)).sourceDbType, viewDate);
            (/** @type {?} */ (this)).add(dateClause);
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} fromMeasure
     * @param {?} toMeasure
     * @param {?=} fromMeasureFieldName
     * @param {?=} toMeasureFieldName
     * @return {THIS}
     */
    betweenMeasures(fromMeasure, toMeasure, fromMeasureFieldName, toMeasureFieldName) {
        if ((/** @type {?} */ (this)).referenceLayer) {
            fromMeasureFieldName = fromMeasureFieldName || (/** @type {?} */ (this)).referenceLayer.fromMeasureFieldName;
            toMeasureFieldName = toMeasureFieldName || (/** @type {?} */ (this)).referenceLayer.toMeasureFieldName;
        }
        /** @type {?} */
        const hasMeasureFieldInfo = Boolean((/** @type {?} */ (this)).referenceLayer || fromMeasureFieldName);
        if (!hasMeasureFieldInfo) {
            throw new Error(NO_REFERENCE_LAYER_SUPPLIED_ERROR_MSG);
        }
        /** @type {?} */
        const whereTemplate = toMeasureFieldName
            ? LRS_LINEAR_EVENT_WHERE_CLAUSE_TEMPLATE
            : LRS_POINT_EVENT_WHERE_CLAUSE_TEMPLATE;
        /** @type {?} */
        const measureClause = format(whereTemplate, {
            fromMeasureFieldName: (/** @type {?} */ (this)).formatField(fromMeasureFieldName),
            toMeasureFieldName: (/** @type {?} */ (this)).formatField(toMeasureFieldName),
            fromMeasure,
            toMeasure,
        });
        return (/** @type {?} */ (this)).add(measureClause);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class BaseEsriService {
    /**
     * @param {?} http
     * @param {?} config
     * @param {?} dataConfig
     * @param {?} log
     */
    constructor(http, config, dataConfig, log) {
        this.http = http;
        this.config = config;
        this.dataConfig = dataConfig;
        this.log = log;
    }
    /**
     * @protected
     * @param {?} payload
     * @return {?}
     */
    shouldUsePostMethod(payload) {
        return this.config.arcgisQueryMethodStrategy === 'force-post'
            || JSON.stringify(payload || '').length > this.config.arcgisMaxWhereLengthGetThreshold;
    }
    /**
     * @protected
     * @template T
     * @param {?} response
     * @param {?} url
     * @return {?}
     */
    handleEsriResponseError(response, url) {
        /** @type {?} */
        const error = (/** @type {?} */ (response));
        if (error && error.error) {
            /** @type {?} */
            const returnError = new Error(`Failed to query map service: ${error.error.message}`);
            this.log.error(`Failed to execute map service request: ${url}`, returnError);
            throw returnError;
        }
    }
    /**
     * @protected
     * @return {?}
     */
    getWhereBuilder() {
        return new LrsWhereClauseBuilder({ quoteFields: !this.dataConfig.skipColumnQuotes });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing global ESRI-related settings.
 */
let EsriConfig = /**
 * Configuration class for storing global ESRI-related settings.
 */
class EsriConfig {
    constructor() {
        this.arcgis = {};
        this.arcgisQueryMethodStrategy = 'prefer-get';
        this.arcgisMaxWhereLengthGetThreshold = 3500;
    }
    /**
     * @return {?}
     */
    get hasGeometryUrl() {
        return Boolean(this.arcgis && this.arcgis.geometryUrl);
    }
    /**
     * @return {?}
     */
    get arcGisGeometryUrl() {
        return this.hasGeometryUrl ? this.arcgis.geometryUrl : null;
    }
};
EsriConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ EsriConfig.ngInjectableDef = defineInjectable({ factory: function EsriConfig_Factory() { return new EsriConfig(); }, token: EsriConfig, providedIn: "root" });
/**
 * Configuration class for storing global ESRI-related settings.
 */
EsriConfig = __decorate([
    AutoConfig('EsriConfig')
], EsriConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SORTED_BY_MEASURE_PROPERTY_FLAG = '$$$sorted';
/** @type {?} */
const EARTH_RADIUS_IN_KILOMETERS = 6371;
/** @type {?} */
const EARTH_RADIUS_IN_METERS = 6371008.8;
/** @type {?} */
const WGS_84_SRID = 4326;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} point
 * @return {?}
 */
function toSinglePartPointArray(point) {
    return isArray(point)
        ? ((/** @type {?} */ (point)))
        : ((/** @type {?} */ (point))).coordinates;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} firstPoint
 * @param {?} secondPoint
 * @return {?}
 */
function getSortResultForPoints(firstPoint, secondPoint) {
    /** @type {?} */
    const first = toSinglePartPointArray(firstPoint);
    /** @type {?} */
    const second = toSinglePartPointArray(secondPoint);
    /** @type {?} */
    const firstCoordinateMeasure = getLastItem(first);
    /** @type {?} */
    const secondCoordinateMeasure = getLastItem(second);
    return firstCoordinateMeasure - secondCoordinateMeasure;
}
/**
 * @param {?} points
 * @param {?=} cacheSort
 * @return {?}
 */
function sortPointsByMeasure(points, cacheSort = false) {
    if (points[SORTED_BY_MEASURE_PROPERTY_FLAG]) {
        return;
    }
    /** @type {?} */
    const coordinates = toMultiPartPoint(points);
    /** @type {?} */
    const coordinatesHaveMeasureValue = Boolean(coordinates.length
        && coordinates[0].length > 2);
    if (coordinatesHaveMeasureValue) {
        coordinates.sort(getSortResultForPoints);
        if (cacheSort) {
            points[SORTED_BY_MEASURE_PROPERTY_FLAG] = true;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @return {?}
 */
function singleLineToCoordinates(line) {
    return isArray(line)
        ? (/** @type {?} */ (line))
        : ((/** @type {?} */ (line))).coordinates;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @return {?}
 */
function multiLineToCoordinates(line) {
    return isArray(line)
        ? (/** @type {?} */ (line))
        : ((/** @type {?} */ (line))).coordinates;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @return {?}
 */
function hasMeasureValues(line) {
    /** @type {?} */
    const paths = toMultiPartPaths(line);
    return multiLineHasMeasureValues(paths);
}
/**
 * @param {?} line
 * @return {?}
 */
function singleLineHasMeasureValues(line) {
    /** @type {?} */
    const coordinates = singleLineToCoordinates(line);
    return Boolean(coordinates
        && coordinates.length
        && coordinates[0].length > 2);
}
/**
 * @param {?} line
 * @return {?}
 */
function multiLineHasMeasureValues(line) {
    /** @type {?} */
    const coordinates = multiLineToCoordinates(line);
    return Boolean(coordinates.length
        && singleLineHasMeasureValues(coordinates[0]));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @return {?}
 */
function sortLineByMeasure(line) {
    if (line[SORTED_BY_MEASURE_PROPERTY_FLAG]) {
        // There's no need to waste time sorting this geometry if it's already been done.
        return;
    }
    /** @type {?} */
    const paths = toMultiPartPaths(line);
    if (!multiLineHasMeasureValues(paths)) {
        // We can not continue sorting if the coordinates do not have measure values in them.
        return;
    }
    // We need to sort all of the inner coordinates first, and then the outer paths
    // because we don't know the min/max of the inner coordinates until this is done.
    paths.forEach((/**
     * @param {?} coordinates
     * @return {?}
     */
    (coordinates) => sortPointsByMeasure(coordinates)));
    paths.sort((/**
     * @param {?} firstCoordinate
     * @param {?} secondCoordinate
     * @return {?}
     */
    (firstCoordinate, secondCoordinate) => {
        /** @type {?} */
        const firstCoordinateFirstPoint = firstCoordinate[0];
        /** @type {?} */
        const secondCoordinateFirstPoint = secondCoordinate[0];
        return getSortResultForPoints(firstCoordinateFirstPoint, secondCoordinateFirstPoint);
    }));
    line[SORTED_BY_MEASURE_PROPERTY_FLAG] = true;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} point
 * @return {?}
 */
function getMeasureFromPoint(point) {
    /** @type {?} */
    const coordinate = toSinglePartPointArray(point);
    /** @type {?} */
    const hasMeasureValues = Boolean(coordinate
        && coordinate.length
        && coordinate.length > 2);
    return hasMeasureValues
        ? getLastItem(coordinate)
        : null;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @return {?}
 */
function getMeasureExtentFromLine(line) {
    /** @type {?} */
    const paths = toMultiPartPaths(line);
    /** @type {?} */
    let min;
    /** @type {?} */
    let max;
    if (paths.length) {
        sortLineByMeasure(line);
        /** @type {?} */
        const firstPath = paths[0];
        /** @type {?} */
        const lastPath = getLastItem(paths);
        /** @type {?} */
        const firstCoordinate = firstPath[0];
        /** @type {?} */
        const lastCoordinate = getLastItem(lastPath);
        min = getMeasureFromPoint(firstCoordinate);
        max = getMeasureFromPoint(lastCoordinate);
    }
    return {
        min,
        max
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} point
 * @return {?}
 */
function getMeasureExtentFromPoint(point) {
    /** @type {?} */
    const points = toMultiPartPoint(point);
    /** @type {?} */
    const firstPoint = points[0];
    /** @type {?} */
    const lastPoint = getLastItem(points);
    /** @type {?} */
    let min;
    /** @type {?} */
    let max;
    sortPointsByMeasure(points);
    min = getMeasureFromPoint(firstPoint);
    max = getMeasureFromPoint(lastPoint);
    return { min, max };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} geometry
 * @return {?}
 */
function getMeasureExtent(geometry) {
    /** @type {?} */
    let extent;
    if (isLine(geometry)) {
        /** @type {?} */
        const lineGeometry = (/** @type {?} */ (geometry));
        extent = getMeasureExtentFromLine(lineGeometry);
    }
    else {
        /** @type {?} */
        const point = (/** @type {?} */ (geometry));
        extent = getMeasureExtentFromPoint(point);
    }
    return extent;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} field
 * @param {?} value
 * @return {?}
 */
function getCodedValue(field, value) {
    return field.domain
        ? field.domain.codedValues.find((/**
         * @param {?} codedValue
         * @return {?}
         */
        codedValue => codedValue.code === value))
        : undefined;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} field
 * @param {?} value
 * @return {?}
 */
function getCodedValueName(field, value) {
    /** @type {?} */
    const codedValue = getCodedValue(field, value);
    return codedValue
        ? codedValue.name
        : undefined;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} field
 * @param {?} value
 * @return {?}
 */
function getCodedValueNameOrDefault(field, value) {
    /** @type {?} */
    const name = getCodedValueName(field, value);
    return isValue(name)
        ? name
        : String(value);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DYNAMIC_DATA_REGEX = new RegExp('^layer_(\\d+)_field_(\\w+|\\*):?(\\w+)?', 'i');
/**
 * @param {?} expression
 * @return {?}
 */
function isDynamicDataExpression(expression) {
    return DYNAMIC_DATA_REGEX.test(expression);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ALL_FIELD_CRITERIA = '*';
/**
 * @template T
 * @param {?} layerId
 * @param {?=} field
 * @param {...?} features
 * @return {?}
 */
function extractFeatureDataByLayer(layerId, field = '*', ...features) {
    return extractFeatureData(field, ...features.filter((/**
     * @param {?} feature
     * @return {?}
     */
    feature => feature.layerId === layerId)));
}
/**
 * @template T
 * @param {?=} field
 * @param {...?} features
 * @return {?}
 */
function extractFeatureData(field = ALL_FIELD_CRITERIA, ...features) {
    return features.map((/**
     * @param {?} feature
     * @return {?}
     */
    feature => field === ALL_FIELD_CRITERIA
        ? feature.properties
        : feature.properties[field]));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} dataValues
 * @return {?}
 */
function dataValuesToNumbers(dataValues) {
    return dataValues
        .filter((/**
     * @param {?} value
     * @return {?}
     */
    value => isNumber(value)))
        .map((/**
     * @param {?} value
     * @return {?}
     */
    value => Number(value)));
}
/**
 * @param {?} expression
 * @param {...?} features
 * @return {?}
 */
function evaluateSingleDynamicDataExpression(expression, ...features) {
    /** @type {?} */
    const parsedValue = expression.match(DYNAMIC_DATA_REGEX);
    /** @type {?} */
    let expressionValue;
    if (parsedValue && parsedValue.length > 2) {
        /** @type {?} */
        const layerId = Number(parsedValue[1]);
        /** @type {?} */
        const field = parsedValue[2];
        /** @type {?} */
        const subsetKeyword = (/** @type {?} */ ((parsedValue[3] || 'first').toLocaleLowerCase()));
        /** @type {?} */
        const dataValues = extractFeatureDataByLayer(layerId, field, ...features);
        if (subsetKeyword === 'first') {
            expressionValue = dataValues[0];
        }
        else if (subsetKeyword === 'last') {
            expressionValue = dataValues[dataValues.length - 1];
        }
        else if (subsetKeyword === 'sum' || subsetKeyword === 'add') {
            /** @type {?} */
            const numberValues = dataValuesToNumbers(dataValues);
            expressionValue = sumValues(numberValues);
        }
        else if (subsetKeyword === 'avg' || subsetKeyword === 'average') {
            /** @type {?} */
            const numberValues = dataValuesToNumbers(dataValues);
            expressionValue = average(numberValues);
        }
        else if (subsetKeyword === 'concat') {
            expressionValue = dataValues.join(', ');
        }
        else if (subsetKeyword === 'min') {
            /** @type {?} */
            const numberValues = dataValuesToNumbers(dataValues);
            expressionValue = Math.min(...numberValues);
        }
        else if (subsetKeyword === 'max') {
            /** @type {?} */
            const numberValues = dataValuesToNumbers(dataValues);
            expressionValue = Math.max(...numberValues);
        }
        else {
            throw new Error(`Unsupported dynamic data expression subset keyword '${subsetKeyword}'`);
        }
        return isObject(expressionValue)
            ? JSON.stringify(expressionValue)
            : String(expressionValue);
    }
}
/**
 * @param {?} expression
 * @param {...?} features
 * @return {?}
 */
function evaluateDynamicDataExpression(expression, ...features) {
    /** @type {?} */
    const tokenExpressions = extractTokenExpressions(expression);
    /** @type {?} */
    let evaluationResult = expression;
    tokenExpressions
        .filter((/**
     * @param {?} tokenExpression
     * @return {?}
     */
    tokenExpression => isDynamicDataExpression(tokenExpression)))
        .forEach((/**
     * @param {?} tokenExpression
     * @return {?}
     */
    tokenExpression => {
        /** @type {?} */
        const value = evaluateSingleDynamicDataExpression(tokenExpression, ...features);
        evaluationResult = replaceToken(evaluationResult, tokenExpression, value);
    }));
    return evaluationResult;
}
/**
 * @param {?} expression
 * @param {...?} features
 * @return {?}
 */
function evaluteFeatureDataExpression(expression, ...features) {
    /** @type {?} */
    const evaluationResult = evaluateDynamicDataExpression(expression, ...features);
    /** @type {?} */
    const firstFeatureProperties = features && features.length
        ? features[0].properties
        : {};
    /** @type {?} */
    const replaceTokens = Object.assign({}, firstFeatureProperties, {
        RecordCount: features.length,
    });
    return format(evaluationResult, replaceTokens);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MapFeature {
    /**
     * @return {?}
     */
    get layerId() {
        return this.layer ? this.layer.id : null;
    }
    /**
     * @return {?}
     */
    get hasZ() {
        return this.layer.hasZ;
    }
    /**
     * @return {?}
     */
    get hasM() {
        return this.layer.hasM;
    }
    /**
     * @param {?} feature
     * @param {?} layer
     * @param {?=} spatialReferenceId
     */
    constructor(feature, layer, spatialReferenceId = WGS_84_SRID) {
        this.id = feature.id;
        this.properties = feature.properties;
        this.type = feature.type;
        this.bbox = feature.bbox;
        this.layer = layer;
        this.spatialReferenceId = spatialReferenceId;
        /** @type {?} */
        const idFieldName = this.getIdFieldName();
        this.id = this.id || this.getValue(idFieldName);
        this.displayValue = this.getValue(layer.displayField);
        this.setGeometry(feature.geometry);
    }
    /**
     * @return {?}
     */
    getIdFieldName() {
        return getIdFieldFieldName(this.layer.fields);
    }
    /**
     * @param {?} fieldNameOrExpression
     * @return {?}
     */
    getValue(fieldNameOrExpression) {
        return isFieldExpression(fieldNameOrExpression)
            ? evaluteFeatureDataExpression(fieldNameOrExpression, this)
            : this.properties && this.properties[fieldNameOrExpression];
    }
    /**
     * @param {?} fieldName
     * @return {?}
     */
    getCodedValueNameOrDefault(fieldName) {
        /** @type {?} */
        const value = this.getValue(fieldName);
        /** @type {?} */
        const field = this.layer.getField(fieldName);
        return getCodedValueNameOrDefault(field, value);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} fieldName
     * @param {?} value
     * @return {THIS}
     */
    setValue(fieldName, value) {
        (/** @type {?} */ (this)).properties[fieldName] = value;
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} id
     * @return {THIS}
     */
    setId(id) {
        (/** @type {?} */ (this)).id = id;
        (/** @type {?} */ (this)).setValue(getIdFieldFieldName((/** @type {?} */ (this)).layer.fields), id);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} geometry
     * @return {THIS}
     */
    setGeometry(geometry) {
        (/** @type {?} */ (this)).geometry = geometry;
        return (/** @type {?} */ (this)).setGeometryTypeProperties();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    setMeasureFromGeometry() {
        if ((/** @type {?} */ (this)).geometry) {
            /** @type {?} */
            const extent = getMeasureExtent((/** @type {?} */ (this)).geometry);
            (/** @type {?} */ (this)).fromMeasure = extent.min;
            (/** @type {?} */ (this)).toMeasure = extent.max;
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    isSpatialReferenceWgs84() {
        return this.spatialReferenceId === WGS_84_SRID;
    }
    /**
     * @return {?}
     */
    clone() {
        /** @type {?} */
        const copyFeature = clone(this.toFeature());
        return new MapFeature(copyFeature, this.layer);
    }
    /**
     * @return {?}
     */
    toFeature() {
        /** @type {?} */
        const feature = {
            type: 'Feature',
            geometry: this.geometry,
            properties: this.properties,
            id: this.id,
            bbox: this.bbox,
        };
        return feature;
    }
    /**
     * @return {?}
     */
    toGeoJson() {
        return this.toFeature();
    }
    /**
     * @protected
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    setGeometryTypeProperties() {
        (/** @type {?} */ (this)).isLinear = isLine((/** @type {?} */ (this)).geometry);
        (/** @type {?} */ (this)).isPoint = isPoint((/** @type {?} */ (this)).geometry);
        (/** @type {?} */ (this)).isPolygon = isPolygon((/** @type {?} */ (this)).geometry);
        return (/** @type {?} */ (this));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LrsFeature extends MapFeature {
    /**
     * @return {?}
     */
    get layerId() {
        return this.layer ? this.layer.id : null;
    }
    /**
     * @return {?}
     */
    get fromDate() {
        return this.getValue(this.layer.fromDateFieldName);
    }
    /**
     * @return {?}
     */
    get toDate() {
        return this.getValue(this.layer.toDateFieldName);
    }
    /**
     * @return {?}
     */
    get isRetired() {
        return Boolean(this.toDate);
    }
    /**
     * @return {?}
     */
    get isActive() {
        return !this.isRetired;
    }
    /**
     * @param {?} feature
     * @param {?} layer
     * @param {?=} spatialReferenceId
     */
    constructor(feature, layer, spatialReferenceId = WGS_84_SRID) {
        super(feature, layer, spatialReferenceId);
        if (this.geometry && this.isGeometryTypeInvalid()) {
            throw new Error(`Unsupported geometry type of ${this.geometry.type} detected.`);
        }
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} date
     * @return {THIS}
     */
    setFromDate(date) {
        return (/** @type {?} */ (this)).setValue((/** @type {?} */ (this)).layer.fromDateFieldName, date);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} date
     * @return {THIS}
     */
    setToDate(date) {
        return (/** @type {?} */ (this)).setValue((/** @type {?} */ (this)).layer.toDateFieldName, date);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    retire() {
        if ((/** @type {?} */ (this)).layer.toDateFieldName) {
            (/** @type {?} */ (this)).setValue((/** @type {?} */ (this)).layer.toDateFieldName, new Date());
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    clone() {
        /** @type {?} */
        const copyFeature = clone(this.toFeature());
        return new LrsFeature(copyFeature, this.layer);
    }
    /**
     * @protected
     * @return {?}
     */
    isGeometryTypeValid() {
        return isLine(this.geometry) || isPoint(this.geometry);
    }
    /**
     * @private
     * @return {?}
     */
    isGeometryTypeInvalid() {
        return !this.isGeometryTypeValid();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EventFeature extends LrsFeature {
    /**
     * @param {?} feature
     * @param {?} layer
     * @param {?=} spatialReferenceId
     */
    constructor(feature, layer, spatialReferenceId = WGS_84_SRID) {
        super(feature, layer, spatialReferenceId);
        this.routeId = this.getValue(layer.routeIdFieldName);
        this.fromMeasure = this.getValue(layer.fromMeasureFieldName);
        this.toMeasure = this.getValue(layer.toMeasureFieldName);
    }
    /**
     * @param {?} layer
     * @param {?=} properties
     * @param {?=} geometry
     * @return {?}
     */
    static create(layer, properties = {}, geometry = null) {
        /** @type {?} */
        const feature = toFeature(properties, (/** @type {?} */ (geometry)));
        return new EventFeature(feature, layer);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} routeId
     * @return {THIS}
     */
    setRouteId(routeId) {
        (/** @type {?} */ (this)).routeId = routeId;
        return (/** @type {?} */ (this)).setValue(routeId, (/** @type {?} */ (this)).layer.routeIdFieldName);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} measure
     * @return {THIS}
     */
    setFromMeasure(measure) {
        (/** @type {?} */ (this)).fromMeasure = measure;
        return (/** @type {?} */ (this)).setValue((/** @type {?} */ (this)).layer.fromMeasureFieldName, measure);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} measure
     * @return {THIS}
     */
    setToMeasure(measure) {
        if (!(/** @type {?} */ (this)).isLinear) {
            throw new Error('Cannot set to measure for a point-based feature');
        }
        (/** @type {?} */ (this)).toMeasure = measure;
        return (/** @type {?} */ (this)).setValue((/** @type {?} */ (this)).layer.toMeasureFieldName, measure);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} fromMeasure
     * @param {?} toMeasure
     * @return {THIS}
     */
    setMeasureExtent(fromMeasure, toMeasure) {
        return (/** @type {?} */ (this)).setFromMeasure(fromMeasure)
            .setToMeasure(toMeasure);
    }
    /**
     * @return {?}
     */
    clone() {
        /** @type {?} */
        const copyFeature = clone(this.toFeature());
        return new EventFeature(copyFeature, this.layer);
    }
    /**
     * @protected
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    setGeometryTypeProperties() {
        (/** @type {?} */ (this)).isLinear = Boolean((/** @type {?} */ (this)).layer.toMeasureFieldName);
        (/** @type {?} */ (this)).isPoint = !(/** @type {?} */ (this)).isLinear;
        (/** @type {?} */ (this)).isPolygon = false;
        return (/** @type {?} */ (this));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} feature
 * @param {?} layerId
 * @param {?} lrsMeta
 * @return {?}
 */
function toLrsFeature(feature, layerId, lrsMeta) {
    /** @type {?} */
    const layerInfo = lrsMeta.getLayerDetail(layerId);
    /** @type {?} */
    let lrsFeature;
    if (layerInfo.isNetworkLayer) {
        lrsFeature = new NetworkFeature(feature, (/** @type {?} */ (layerInfo.layer)));
    }
    else if (layerInfo.isEventLayer) {
        lrsFeature = new EventFeature(feature, (/** @type {?} */ (layerInfo.layer)));
    }
    return lrsFeature;
}
// Feature<G extends GeometryObject | null = Geometry, P = GeoJsonProperties> extends GeoJsonObject
/**
 * @param {?=} properties
 * @param {?=} geometry
 * @return {?}
 */
function toFeature(properties = {}, geometry = null) {
    return {
        type: 'Feature',
        geometry,
        properties
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @param {?} measure
 * @return {?}
 */
function getPoint(line, measure) {
    /** @type {?} */
    const pointComparisionDetails = [];
    /** @type {?} */
    const paths = toMultiPartPaths(line);
    paths.forEach((/**
     * @param {?} coordinates
     * @return {?}
     */
    (coordinates) => {
        /** @type {?} */
        const details = comparePathWithMeasure(coordinates, measure);
        addRange(pointComparisionDetails, details);
    }));
    /** @type {?} */
    const minPoint = pointComparisionDetails.reduce((/**
     * @param {?} accumulator
     * @param {?} value
     * @return {?}
     */
    (accumulator, value) => minPointCloserToMeasure(accumulator, value, measure)));
    /** @type {?} */
    const maxPoint = pointComparisionDetails.reduce((/**
     * @param {?} accumulator
     * @param {?} value
     * @return {?}
     */
    (accumulator, value) => maxPointCloserToMeasure(accumulator, value, measure)));
    /** @type {?} */
    const measureDeltaPercent = calculateMeasureDelta(minPoint.pointMeasure, maxPoint.pointMeasure, measure);
    /** @type {?} */
    const x = interpolateX(minPoint.pointCoordinate, maxPoint.pointCoordinate, measureDeltaPercent);
    /** @type {?} */
    const y = interpolateY(minPoint.pointCoordinate, maxPoint.pointCoordinate, measureDeltaPercent);
    return [x, y, 0, measure];
}
/**
 * @param {?} __0
 * @param {?} __1
 * @param {?} delta
 * @return {?}
 */
function interpolateX([minX], [maxX], delta) {
    return minX + delta * (maxX - minX);
}
/**
 * @param {?} __0
 * @param {?} __1
 * @param {?} delta
 * @return {?}
 */
function interpolateY([, minY], [, maxY], delta) {
    return minY + delta * (maxY - minY);
}
/**
 * @param {?} minMeasure
 * @param {?} maxMeasure
 * @param {?} measure
 * @return {?}
 */
function calculateMeasureDelta(minMeasure, maxMeasure, measure) {
    if (maxMeasure === minMeasure) {
        return 0;
    }
    return (measure - minMeasure) / (maxMeasure - minMeasure);
}
/**
 * @param {?} coordinates
 * @param {?} measureToCompare
 * @return {?}
 */
function comparePathWithMeasure(coordinates, measureToCompare) {
    /** @type {?} */
    const pointComparisionDetailsFromPath = coordinates
        .map((/**
     * @param {?} coordinate
     * @param {?} index
     * @return {?}
     */
    (coordinate, index) => compareCoordinateWithMeasure(coordinate, measureToCompare, index)));
    return pointComparisionDetailsFromPath;
}
/**
 * @param {?} coordinate
 * @param {?} measureToCompare
 * @param {?} index
 * @return {?}
 */
function compareCoordinateWithMeasure(coordinate, measureToCompare, index) {
    /** @type {?} */
    const measureFromCoordinate = getMeasureFromPoint(coordinate);
    /** @type {?} */
    const pointDetails = {
        pointCoordinate: coordinate,
        distance: Math.abs(measureFromCoordinate - measureToCompare),
        pointMeasure: measureFromCoordinate,
        index
    };
    return pointDetails;
}
/**
 * @param {?} accumulator
 * @param {?} value
 * @param {?} measureToCompare
 * @return {?}
 */
function minPointCloserToMeasure(accumulator, value, measureToCompare) {
    /** @type {?} */
    const isPointCloserToMeasure = value.distance <= accumulator.distance;
    /** @type {?} */
    const isPointLessThanMeasure = value.pointMeasure <= measureToCompare;
    return isPointCloserToMeasure && isPointLessThanMeasure
        ? value
        : accumulator;
}
/**
 * @param {?} point1
 * @param {?} point2
 * @param {?} measureToCompare
 * @return {?}
 */
function maxPointCloserToMeasure(point1, point2, measureToCompare) {
    /** @type {?} */
    const isPointCloserToMeasure = point1.distance <= point2.distance;
    /** @type {?} */
    const isPointGreaterThanMeasure = point1.pointMeasure >= measureToCompare;
    return isPointCloserToMeasure && isPointGreaterThanMeasure
        ? point1
        : point2;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @return {?}
 */
function toMultiLineString(line) {
    /** @type {?} */
    const coordinates = toMultiPartPaths(line);
    return {
        bbox: null,
        type: 'MultiLineString',
        coordinates
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @return {?}
 */
function toLineString(line) {
    return isArray(line)
        ? {
            bbox: null,
            type: 'LineString',
            coordinates: (/** @type {?} */ (line))
        }
        : (/** @type {?} */ (line));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @return {?}
 */
function toLineOrMultiLineString(line) {
    /** @type {?} */
    const isCoordinatesArray = isArray(line);
    if (!isCoordinatesArray) {
        return (/** @type {?} */ (line));
    }
    /** @type {?} */
    const coordinates = (/** @type {?} */ (line));
    return isMultiPartLine(coordinates)
        ? toMultiLineString(coordinates)
        : toLineString((/** @type {?} */ (coordinates)));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} degrees
 * @return {?}
 */
function degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} point1
 * @param {?} point2
 * @return {?}
 */
function getDistanceBetweenPoints(point1, point2) {
    /** @type {?} */
    const coordinate1 = toSinglePartPointArray(point1);
    /** @type {?} */
    const coordinate2 = toSinglePartPointArray(point2);
    /** @type {?} */
    const x1 = coordinate1[0];
    /** @type {?} */
    const y1 = coordinate1[1];
    /** @type {?} */
    const x2 = coordinate2[0];
    /** @type {?} */
    const y2 = coordinate2[1];
    return getDistanceBetweenPointValues(x1, y1, x2, y2);
}
/**
 * @param {?} x1
 * @param {?} y1
 * @param {?} x2
 * @param {?} y2
 * @return {?}
 */
function getDistanceBetweenPointValues(x1, y1, x2, y2) {
    // NOTE: This is using the pythagorean theorem (a^2 + b^2 = c^2).
    /** @type {?} */
    const xLength = Math.pow(x2 - x1, 2);
    /** @type {?} */
    const yLength = Math.pow(y2 - y1, 2);
    /** @type {?} */
    const distance$$1 = Math.sqrt(xLength + yLength);
    if (isNaN(distance$$1)) {
        throw new Error(`Unable to calculate distance between points (${x1},${x2} and ${y1},${y2}). Invalid or missing data was provided`);
    }
    return distance$$1;
}
/**
 * @param {?} lat1
 * @param {?} lng1
 * @param {?} lat2
 * @param {?} lng2
 * @return {?}
 */
function getKilometersBetweenLatLng(lat1, lng1, lat2, lng2) {
    // Modified from: https://stackoverflow.com/questions/365826/calculate-distance-between-2-gps-coordinates - RG.
    /** @type {?} */
    const dLat = degreesToRadians(lat2 - lat1);
    /** @type {?} */
    const dLon = degreesToRadians(lng2 - lng1);
    lat1 = degreesToRadians(lat1);
    lat2 = degreesToRadians(lat2);
    /** @type {?} */
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
    /** @type {?} */
    const circumference = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return EARTH_RADIUS_IN_KILOMETERS * circumference;
}
/**
 * @param {?} lat1
 * @param {?} lng1
 * @param {?} lat2
 * @param {?} lng2
 * @return {?}
 */
function getMetersBetweenLatLng(lat1, lng1, lat2, lng2) {
    return getDistanceBetweenLatLng(lat1, lng1, lat2, lng2, LengthUnit.Meter);
}
/**
 * @param {?} lat1
 * @param {?} lng1
 * @param {?} lat2
 * @param {?} lng2
 * @return {?}
 */
function getFeetBetweenLatLng(lat1, lng1, lat2, lng2) {
    return getDistanceBetweenLatLng(lat1, lng1, lat2, lng2, LengthUnit.Foot);
}
/**
 * @param {?} lat1
 * @param {?} lng1
 * @param {?} lat2
 * @param {?} lng2
 * @return {?}
 */
function getMilesBetweenLatLng(lat1, lng1, lat2, lng2) {
    return getDistanceBetweenLatLng(lat1, lng1, lat2, lng2, LengthUnit.Mile);
}
/**
 * @param {?} lat1
 * @param {?} lon1
 * @param {?} lat2
 * @param {?} lon2
 * @param {?} outputUnit
 * @return {?}
 */
function getDistanceBetweenLatLng(lat1, lon1, lat2, lon2, outputUnit) {
    /** @type {?} */
    const distanceInKilometers = getKilometersBetweenLatLng(lat1, lon1, lat2, lon2);
    return convertLengthUnits(distanceInKilometers, LengthUnit.Kilometer, outputUnit);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @param {?} point
 * @param {?=} options
 * @return {?}
 */
function getMeasure(line, point, options) {
    options = Object.assign({
        lengthUnit: 'miles',
        coordinateSystem: 'wgs84'
    }, options);
    /** @type {?} */
    const closestPointFeature = nearestPointOnLine(line, point);
    if (!closestPointFeature || !closestPointFeature.geometry) {
        throw new Error('Unable to get measure for geometry');
    }
    /** @type {?} */
    const foundPointMeasure = getMeasureFromPoint(closestPointFeature.geometry);
    // If the point happens to land on a verticee, then it will already have a measure.
    if (foundPointMeasure !== null) {
        return foundPointMeasure;
    }
    /** @type {?} */
    const lineGeometry = toLineOrMultiLineString(line);
    if (isMultiPartLine(lineGeometry.coordinates)) {
        throw new Error('MultiLineString is not supported in getMeasure function yet.');
    }
    return interpolateMeasure((/** @type {?} */ (lineGeometry)), closestPointFeature.geometry, options);
}
/**
 * @param {?} line
 * @param {?} pointOnLine
 * @param {?} options
 * @return {?}
 */
function interpolateMeasure(line, pointOnLine, options) {
    /** @type {?} */
    const pointCoordinates = toSinglePartPointArray(pointOnLine);
    /** @type {?} */
    const pointGeometry = { type: 'Point', coordinates: pointCoordinates };
    /** @type {?} */
    const pointFeature = { type: 'Feature', geometry: pointGeometry, properties: {} };
    /** @type {?} */
    const lineFeature = {
        type: 'Feature',
        geometry: line,
        properties: {}
    };
    /** @type {?} */
    const splitResult = lineSplit(lineFeature, pointFeature);
    /** @type {?} */
    const firstFeature = splitResult.features[0];
    /** @type {?} */
    const splitVertex = getLastItem(firstFeature.geometry.coordinates);
    /** @type {?} */
    const lastVertexWithMeasureIndex = firstFeature.geometry.coordinates.length - 2;
    /** @type {?} */
    const lastVertexWithMeasure = firstFeature.geometry.coordinates[lastVertexWithMeasureIndex];
    /** @type {?} */
    const newLineSegment = lineString([lastVertexWithMeasure, splitVertex]);
    /** @type {?} */
    const measureOffset = options.coordinateSystem === 'flat'
        ? getDistanceBetweenPoints(lastVertexWithMeasure, splitVertex)
        : length(newLineSegment, { units: (/** @type {?} */ (options.lengthUnit)) });
    /** @type {?} */
    const lastVertexMeasure = getMeasureFromPoint(lastVertexWithMeasure);
    return lastVertexMeasure + measureOffset;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NetworkFeature extends LrsFeature {
    /**
     * @param {?} feature
     * @param {?} layer
     * @param {?=} spatialReferenceId
     */
    constructor(feature, layer, spatialReferenceId = WGS_84_SRID) {
        super(feature, layer, spatialReferenceId);
        this.routeId = this.getValue(layer.compositeRouteIdFieldName);
        this.displayValue = this.displayValue || this.routeId;
        this.setMeasureFromGeometry();
    }
    /**
     * @param {?} layer
     * @param {?=} properties
     * @param {?=} geometry
     * @return {?}
     */
    static create(layer, properties = {}, geometry = null) {
        /** @type {?} */
        const feature = toFeature(properties, (/** @type {?} */ (geometry)));
        return new NetworkFeature(feature, layer);
    }
    /**
     * @param {?} point
     * @return {?}
     */
    getMeasure(point) {
        return getMeasure((/** @type {?} */ (this.geometry)), point);
    }
    /**
     * @param {?} measure
     * @return {?}
     */
    getPoint(measure) {
        return getPoint((/** @type {?} */ (this.geometry)), measure);
    }
    /**
     * @return {?}
     */
    clone() {
        /** @type {?} */
        const copyFeature = clone(this.toFeature());
        return new NetworkFeature(copyFeature, this.layer);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LrsFeatureCollection {
    /**
     * @param {?} collection
     */
    constructor(collection) {
        this.bbox = collection.bbox;
        this.type = collection.type;
    }
    /**
     * @param {?} features
     * @param {?=} bbox
     * @return {?}
     */
    static create(features, bbox) {
        return new LrsFeatureCollection({
            type: 'FeatureCollection',
            features,
            bbox
        });
    }
    /**
     * @return {?}
     */
    toGeoJson() {
        return {
            type: 'FeatureCollection',
            bbox: this.bbox,
            features: this.features.map((/**
             * @param {?} feature
             * @return {?}
             */
            feature => feature.toGeoJson()))
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EventFeatureCollection extends LrsFeatureCollection {
    /**
     * @param {?} collection
     * @param {?} layer
     * @param {?=} spatialReferenceId
     */
    constructor(collection, layer, spatialReferenceId = WGS_84_SRID) {
        super(collection);
        this.features = collection.features
            .map((/**
         * @param {?} f
         * @return {?}
         */
        f => new EventFeature(f, layer, spatialReferenceId)));
    }
    /**
     * @param {?} layer
     * @param {...?} features
     * @return {?}
     */
    static fromFeatures(layer, ...features) {
        return new EventFeatureCollection({
            type: 'FeatureCollection',
            features
        }, layer);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NetworkFeatureCollection extends LrsFeatureCollection {
    /**
     * @param {?} collection
     * @param {?} layer
     * @param {?=} spatialReferenceId
     */
    constructor(collection, layer, spatialReferenceId = WGS_84_SRID) {
        super(collection);
        this.features = collection.features
            .map((/**
         * @param {?} f
         * @return {?}
         */
        f => new NetworkFeature(f, layer, spatialReferenceId)));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?=} params
 * @param {?=} format
 * @return {?}
 */
function getEsriMapServiceHttOptions(params, format = 'json') {
    /** @type {?} */
    const headers = new HttpHeaders();
    params = params || new HttpParams();
    if (format) {
        params = params.set('f', format);
    }
    headers.append('Content-Type', 'application/json');
    headers.append('Access-Control-Allow-Origin', '*');
    /** @type {?} */
    const httpOptions = {
        withCredentials: true,
        headers,
        params,
    };
    return httpOptions;
}
/**
 * @param {?} httpOption
 * @param {?} params
 * @return {?}
 */
function addParamsToHttpOptions(httpOption, params) {
    Object
        .keys(params)
        .filter((/**
     * @param {?} key
     * @return {?}
     */
    key => isValue(params[key])))
        .forEach((/**
     * @param {?} key
     * @return {?}
     */
    key => {
        /** @type {?} */
        const value = params[key];
        httpOption.params = httpOption.params.set(key, toFormDataString(value, false));
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} queryParameters
 * @return {?}
 */
function toFormData(queryParameters) {
    /** @type {?} */
    const formData = new FormData();
    Object.keys(queryParameters)
        .map((/**
     * @param {?} key
     * @return {?}
     */
    key => ({
        key,
        value: toFormDataString(queryParameters[key])
    })))
        .forEach((/**
     * @param {?} keyValue
     * @return {?}
     */
    keyValue => formData.append(keyValue.key, keyValue.value)));
    return formData;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Server identifiers.
/** @type {?} */
const MAP_SERVER_SERVICE_MATCH_IDENTIFIER = /(\/MapServer$|\/MapServer\/)/;
/** @type {?} */
const MAP_SERVER_SERVICE_IDENTIFIER = /(MapServer|MapServer\/)$/;
/** @type {?} */
const FEATURE_SERVER_SERVICE_IDENTIFIER = /(FeatureServer|FeatureServer\/)$/;
/** @type {?} */
const IMAGE_SERVER_SERVICE_IDENTIFIER = /(ImageServer|ImageServer\/)$'/;
/** @type {?} */
const FEATURE_SERVER_LAYER_SERVICE_IDENTIFIER = /FeatureServer\/(\d+|\d+\/)$/;
/** @type {?} */
const MAP_SERVER_LAYER_SERVICE_MATCH_IDENTIFIER = /(\/MapServer\/(\d+|\d+\/)|\/MapServer\/(\d+|\d+\/)\/)/;
/** @type {?} */
const MAP_SERVER_LAYER_SERVICE_IDENTIFIER = /MapServer\/(\d+|\d+\/)$/;
/** @type {?} */
const LRS_SERVER_SERVICE_IDENTIFIER = /(MapServer\/exts\/LRSServer|MapServer\/exts\/LRSServer\/)$/;
/** @type {?} */
const LRS_SERVER_LAYERS_SERVICE_IDENTIFIER = /(MapServer\/exts\/LRSServer\/layers|MapServer\/exts\/LRSServer\/layers\/)$/;
// Map endpoints.
/** @type {?} */
const MAP_LAYERS_SERVICE_ENDPOINT = 'layers';
/** @type {?} */
const MAP_LAYER_SERVICE_ENDPOINT = '{layerId}';
/** @type {?} */
const MAP_LAYER_QUERY_SERVICE_ENDPOINT = '{layerId}/query';
/** @type {?} */
const MAP_LAYER_QUERY_RELATED_RECORDS_SERVICE_ENDPOINT = 'layers/{layerId}/queryRelatedRecords';
// LRS endpoints.
/** @type {?} */
const LRS_SERVER_META_ENDPOINT = 'exts/LRSServer';
/** @type {?} */
const LRS_LAYERS_SERVICE_ENDPOINT = 'exts/LRSServer/layers';
/** @type {?} */
const LRS_SERVER_APPLY_EDITS_ENDPOINT = 'exts/LRSServer/applyEdits';
// Network endpoints.
/** @type {?} */
const LRS_GEOMETRY_TO_MEASURE = 'exts/LRSServer/networkLayers/{layerId}/geometryToMeasure';
// Portal.
/** @type {?} */
const PORTAL_SHARING_ENDPOINT = 'sharing';
/** @type {?} */
const PORTAL_OAUTH_AUTHORIZE_ENDPOINT = 'sharing/oauth2/authorize';
/** @type {?} */
const PORTAL_OAUTH_TOKEN_ENDPOINT = 'sharing/rest/oauth2/token';
/** @type {?} */
const PORTAL_GENERATE_TOKEN_ENDPOINT = 'sharing/generateToken';
/** @type {?} */
const PORTAL_REDIRECT_URL_PARAMS_BREAK_CHARACTER = '#';
/** @type {?} */
const DEFAULT_PORTAL_OAUTH_REDIRECT_OPTIONS = {
    responseType: 'token',
    urlParamsBreak: PORTAL_REDIRECT_URL_PARAMS_BREAK_CHARACTER,
    redirectUrl: window.location.href
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_GEOMETRY_TO_MEASURE_OPTIONS = {
    locations: [],
    inSR: 4326,
    outSR: 4326,
    f: 'json'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {...?} options
 * @return {?}
 */
function getGeometryToMeasureOptions(...options) {
    /** @type {?} */
    const mergedOption = Object.assign({}, DEFAULT_GEOMETRY_TO_MEASURE_OPTIONS);
    (options || [])
        .forEach((/**
     * @param {?} option
     * @return {?}
     */
    option => Object.assign(mergedOption, option)));
    if (isDate(mergedOption.temporalViewDate)) {
        mergedOption.temporalViewDate = toUtcEpochDate((/** @type {?} */ (mergedOption.temporalViewDate)));
    }
    return mergedOption;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_MAP_QUERY_OPTIONS = {
    // mapServiceUrl: '',
    // layerId: '',
    where: '1=1',
    text: '',
    objectIds: '',
    time: '',
    geometry: '',
    geometryType: 'esriGeometryEnvelope',
    spatialRel: 'esriSpatialRelIntersects',
    relationParam: '',
    outFields: '*',
    returnGeometry: true,
    returnTrueCurves: false,
    maxAllowableOffset: '',
    geometryPrecision: '',
    inSR: WGS_84_SRID,
    outSR: WGS_84_SRID,
    returnIdsOnly: false,
    returnCountOnly: false,
    orderByFields: '',
    groupByFieldsForStatistics: '',
    outStatistics: '',
    returnZ: false,
    returnM: true,
    gdbVersion: '',
    returnDistinctValues: false,
    resultOffset: '',
    resultRecordCount: '',
    queryByDistance: '',
    returnExtentsOnly: false,
    datumTransformation: '',
    parameterValues: '',
    rangeValues: '',
    f: 'geojson'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {...?} options
 * @return {?}
 */
function getMapQueryOptions(...options) {
    /** @type {?} */
    const mergedOption = Object.assign({}, DEFAULT_MAP_QUERY_OPTIONS);
    (options || [])
        .forEach((/**
     * @param {?} option
     * @return {?}
     */
    option => Object.assign(mergedOption, option)));
    return mergedOption;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} options
 * @param {?=} httpParams
 * @return {?}
 */
function toHttpQueryParams(options, httpParams) {
    httpParams = httpParams || new HttpParams();
    Object.keys(options)
        .forEach((/**
     * @param {?} k
     * @return {?}
     */
    k => {
        /** @type {?} */
        const value = options[k];
        if (isValue(value)) {
            httpParams = httpParams.set(k, value);
        }
    }));
    return httpParams;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * NOTE: There is a bug in ArcGIS Server < v10.5.0 which requies that you do not pass a
 * 'gdbVersion' if that version name is the same version that the layer is published in.
 * We need to strip that GDB version when this occurs.
 * @param {?} layer
 * @param {?=} options
 * @return {?}
 */
function tryStripGdbVersion(layer, options) {
    if (layer
        && options
        && layer.versionName
        && options.gdbVersion
        && layer.versionName.toLowerCase() === options.gdbVersion.toLowerCase()) {
        options.gdbVersion = undefined;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} layer
 * @return {?}
 */
function toLayerId(layer) {
    return isNumber$1(layer) ? (/** @type {?} */ (layer)) : ((/** @type {?} */ (layer))).id;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} layer
 * @param {?} tokens
 * @param {...?} parts
 * @return {?}
 */
function joinAndFomatWithLayer(layer, tokens, ...parts) {
    /** @type {?} */
    const layerId = toLayerId(layer);
    return joinAndFomat(Object.assign({}, tokens, {
        layerId
    }), ...parts);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} info
 * @return {?}
 */
function isClassBreakInfoEmpty(info) {
    return !info
        || !info.classMaxValue
            && !info.label
            && !info.description
            && !Object.keys(info.symbol || {}).length;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} info
 * @return {?}
 */
function isUniqueValueInfoEmpty(info) {
    return !info
        || !info.value
            && !info.label
            && !info.description
            && !Object.keys(info.symbol || {}).length;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_UNIQUE_VALUE_INFO = null;
/** @type {?} */
const DEFAULT_CLASS_BREAK_VALUE_INFO = null;
/** @type {?} */
const DEFAULT_RENDERER_SYMBOL = {
    type: 'esriSLS',
    style: 'esriSLSSolid',
    color: '#000000',
    width: 2
};
/**
 * @param {?} symbol
 * @return {?}
 */
function isRendererSymbolDefault(symbol) {
    return Object.keys(symbol).length === Object.keys(DEFAULT_RENDERER_SYMBOL).length
        && symbol.type === DEFAULT_RENDERER_SYMBOL.type
        && symbol.style === DEFAULT_RENDERER_SYMBOL.style
        && symbol.color === DEFAULT_RENDERER_SYMBOL.color
        && symbol.width === DEFAULT_RENDERER_SYMBOL.width;
}
class LayerDrawingInfoRenderer {
    /**
     * @return {?}
     */
    get isSimple() {
        return this.type === 'simple';
    }
    /**
     * @return {?}
     */
    get isUniqueValue() {
        return this.type === 'uniqueValue';
    }
    /**
     * @return {?}
     */
    get isClassBreak() {
        return this.type === 'classBreaks';
    }
    /**
     * @return {?}
     */
    get isEmpty() {
        return !this.minValue
            && !this.classBreakInfos.length
            && !this.uniqueValueInfos.length
            && isRendererSymbolDefault(this.symbol);
    }
    /**
     * @return {?}
     */
    get field() {
        return this.field1;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set field(value) {
        this.field1 = value;
    }
    /**
     * @param {?=} base
     */
    constructor(base) {
        Object.assign(this, base);
        this.type = this.type || 'simple';
        this.minValue = this.minValue || 0;
        this.classBreakInfos = this.classBreakInfos || [];
        this.uniqueValueInfos = this.uniqueValueInfos || [];
        this.symbol = Object.assign({}, DEFAULT_RENDERER_SYMBOL, this.symbol);
        this.label = this.label || '';
        this.description = this.description || '';
        this.standardizeRenderSymbols();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getSymbol(value) {
        /** @type {?} */
        let symbol = this.symbol || this.defaultSymbol;
        if (this.isUniqueValue) {
            /** @type {?} */
            const uniqueValueInfo = this.getUniqueValueInfoOrDefault(value);
            symbol = isUniqueValueInfoEmpty(uniqueValueInfo) ? null : uniqueValueInfo.symbol;
        }
        else if (this.isClassBreak) {
            /** @type {?} */
            const classBreakInfo = this.getClassBreakInfoOrDefault(value);
            symbol = isClassBreakInfoEmpty(classBreakInfo) ? null : classBreakInfo.symbol;
        }
        return symbol || this.defaultSymbol || null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getUniqueValueInfo(value) {
        if (!this.uniqueValueInfos || !this.uniqueValueInfos.length) {
            return null;
        }
        return this.uniqueValueInfos.find((/**
         * @param {?} info
         * @return {?}
         */
        info => info.value === value || String(info.value) === String(value)));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getUniqueValueInfoOrDefault(value) {
        return this.getUniqueValueInfo(value) || DEFAULT_UNIQUE_VALUE_INFO;
    }
    /**
     * @param {?} classValue
     * @return {?}
     */
    getClassBreakInfo(classValue) {
        if (!this.classBreakInfos || !this.classBreakInfos.length) {
            return null;
        }
        return this.classBreakInfos.find((/**
         * @param {?} value
         * @param {?} index
         * @return {?}
         */
        (value, index) => this.isValueInClassBreakRange(value, classValue, index)));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getClassBreakInfoOrDefault(value) {
        return this.getClassBreakInfo(value) || DEFAULT_CLASS_BREAK_VALUE_INFO;
    }
    /**
     * @param {?} classBreakInfo
     * @param {?} value
     * @param {?} index
     * @return {?}
     */
    isValueInClassBreakRange(classBreakInfo, value, index) {
        /** @type {?} */
        const rangeMin = index === 0 ? this.minValue : this.classBreakInfos[index - 1].classMaxValue;
        /** @type {?} */
        const rangeMax = classBreakInfo.classMaxValue;
        return rangeMin < value && rangeMax > value;
    }
    /**
     * @return {?}
     */
    clearEmptyInfos() {
        removeWhere(this.uniqueValueInfos, (/**
         * @param {?} info
         * @return {?}
         */
        info => isUniqueValueInfoEmpty(info)));
        removeWhere(this.classBreakInfos, (/**
         * @param {?} info
         * @return {?}
         */
        info => isClassBreakInfoEmpty(info)));
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    getBestRepresentativeColor(value) {
        /** @type {?} */
        let symbol = this.defaultSymbol || this.symbol;
        if (this.isUniqueValue && this.uniqueValueInfos.length) {
            /** @type {?} */
            const foundInfo = this.getUniqueValueInfo(value);
            symbol = foundInfo ? foundInfo.symbol : this.uniqueValueInfos[0].symbol;
        }
        else if (this.isClassBreak && this.classBreakInfos.length) {
            /** @type {?} */
            const foundInfo = this.getClassBreakInfo(value);
            symbol = foundInfo ? foundInfo.symbol : this.classBreakInfos[0].symbol;
        }
        return (/** @type {?} */ (symbol.color));
    }
    /**
     * @return {?}
     */
    standardizeRenderSymbols() {
        standardizeRenderSymbol(this.defaultSymbol);
        standardizeRenderSymbol(this.symbol);
        this.uniqueValueInfos.forEach((/**
         * @param {?} info
         * @return {?}
         */
        info => standardizeRenderSymbol(info.symbol)));
        this.classBreakInfos.forEach((/**
         * @param {?} info
         * @return {?}
         */
        info => standardizeRenderSymbol(info.symbol)));
    }
}
/**
 * @param {?} symbol
 * @return {?}
 */
function standardizeRenderSymbol(symbol) {
    if (!symbol) {
        return;
    }
    if (isArray(symbol.color)) {
        symbol.color = rgbToHex((/** @type {?} */ (symbol.color)));
    }
    if (symbol.outline && isArray(symbol.outline.color)) {
        symbol.outline.color = rgbToHex((/** @type {?} */ (symbol.outline.color)));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LayerDrawingInfo {
    /**
     * @return {?}
     */
    get isEmpty() {
        return !this.transparency
            && !this.zIndex
            && this.renderer.isEmpty
            && this.positionRenderer.isEmpty
            && !Object.keys(this.labelingInfo || {}).length;
    }
    /**
     * @return {?}
     */
    get opacity() {
        return transparencyToOpacity(this.transparency);
    }
    /**
     * @param {...?} baseDrawingInfos
     */
    constructor(...baseDrawingInfos) {
        this.merge(...baseDrawingInfos);
        this.transparency = this.transparency || 0;
        this.zIndex = this.zIndex || null;
        this.renderer = new LayerDrawingInfoRenderer(this.renderer);
        this.positionRenderer = new LayerDrawingInfoRenderer(this.positionRenderer);
        this.labelingInfo = this.labelingInfo || null;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {...?} targetDrawingInfos
     * @return {THIS}
     */
    merge(...targetDrawingInfos) {
        /** @type {?} */
        const properties = targetDrawingInfos.map((/**
         * @param {?} info
         * @return {?}
         */
        info => info && ((/** @type {?} */ (info))).toProperties
            ? ((/** @type {?} */ (info))).toProperties()
            : info));
        Object.assign((/** @type {?} */ (this)), ...properties);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    getRendererSymbol(value) {
        return this.renderer.getSymbol(value);
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    getPositionRendererSymbol(value) {
        return this.positionRenderer.getSymbol(value);
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    getBestRepresentativeColor(value) {
        return this.renderer.getBestRepresentativeColor(value);
    }
    /**
     * @return {?}
     */
    toProperties() {
        /** @type {?} */
        const infoProperties = {};
        if (this.labelingInfo) {
            infoProperties.labelingInfo = this.labelingInfo;
        }
        if (this.positionRenderer && !this.positionRenderer.isEmpty) {
            infoProperties.positionRenderer = this.positionRenderer;
        }
        if (this.renderer && !this.renderer.isEmpty) {
            infoProperties.renderer = this.renderer;
        }
        if (this.transparency) {
            infoProperties.transparency = this.transparency;
        }
        return infoProperties;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const POINT_GEOMETRY_TYPES = ['point', 'esriGeometryPoint'];
/** @type {?} */
const LINEAR_GEOMETRY_TYPES = ['line', 'esriGeometryPolyline'];
/** @type {?} */
const POLYGON_GEOMETRY_TYPES = ['polygon', 'esriGeometryPolygon'];
/**
 * @param {?} geometryType
 * @return {?}
 */
function isPointGeometryType(geometryType) {
    return POINT_GEOMETRY_TYPES.indexOf(geometryType) > -1;
}
/**
 * @param {?} geometryType
 * @return {?}
 */
function isLinearGeometryType(geometryType) {
    return LINEAR_GEOMETRY_TYPES.indexOf(geometryType) > -1;
}
/**
 * @param {?} geometryType
 * @return {?}
 */
function isPolygonGeometryType(geometryType) {
    return POLYGON_GEOMETRY_TYPES.indexOf(geometryType) > -1;
}
class FeatureClassLayer {
    /**
     * @return {?}
     */
    get isPoint() {
        return isPointGeometryType(this.geometryType);
    }
    /**
     * @return {?}
     */
    get isLinear() {
        return isLinearGeometryType(this.geometryType);
    }
    /**
     * @return {?}
     */
    get isPolygon() {
        return isPolygonGeometryType(this.geometryType);
    }
    /**
     * @return {?}
     */
    get displayFieldAlias() {
        return this.getFieldAlias(this.displayField);
    }
    /**
     * @param {...?} sources
     */
    constructor(...sources) {
        Object.assign(this, ...sources);
        this.subLayers = this.subLayers || [];
        this.fields = this.fields || [];
        this.indexes = this.indexes || [];
        this.relationships = this.relationships || [];
        this.supportedQueryFormats = this.supportedQueryFormats || [];
        this.drawingInfo = new LayerDrawingInfo(this.drawingInfo);
    }
    /**
     * @param {?} fieldName
     * @return {?}
     */
    getField(fieldName) {
        return getField(fieldName, this.fields);
    }
    /**
     * @param {?} fieldName
     * @return {?}
     */
    getFieldAlias(fieldName) {
        return getFieldAlias(fieldName, this.fields);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} domains
     * @return {THIS}
     */
    applyFieldDomains(domains) {
        if (domains.length) {
            (/** @type {?} */ (this)).fields
                .filter((/**
             * @param {?} f
             * @return {?}
             */
            f => f.domainName))
                .forEach((/**
             * @param {?} field
             * @return {?}
             */
            field => field.domain = domains.find((/**
             * @param {?} domain
             * @return {?}
             */
            domain => domain.name === field.domainName)) || field.domain));
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    clone() {
        /** @type {?} */
        const copy = clone(this);
        return new FeatureClassLayer(copy);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EsriMapServerService extends BaseEsriService {
    /**
     * @param {?} http
     * @param {?} config
     * @param {?} dataConfig
     * @param {?} log
     */
    constructor(http, config, dataConfig, log) {
        super(http, config, dataConfig, log);
    }
    /**
     * Retrieves the map service metadata for all layers.
     * @param {?} serviceUrl
     * @return {?}
     */
    getMapLayers(serviceUrl) {
        /** @type {?} */
        const url = join(serviceUrl, MAP_LAYERS_SERVICE_ENDPOINT);
        return this.http
            .get(url, getEsriMapServiceHttOptions())
            .pipe(tap((/**
         * @param {?} response
         * @return {?}
         */
        (response) => this.handleEsriResponseError(response, serviceUrl))));
    }
    /**
     * Retrieves the map service metadata for a given layer (by it's ID).
     * @param {?} serviceUrl
     * @param {?} layerId
     * @return {?}
     */
    getMapLayer(serviceUrl, layerId) {
        /** @type {?} */
        const url = joinAndFomatWithLayer(layerId, {}, serviceUrl, MAP_LAYER_SERVICE_ENDPOINT);
        return this.http
            .get(url, getEsriMapServiceHttOptions())
            .pipe(tap((/**
         * @param {?} response
         * @return {?}
         */
        (response) => this.handleEsriResponseError(response, serviceUrl))), map((/**
         * @param {?} mapLayerMetadata
         * @return {?}
         */
        mapLayerMetadata => new FeatureClassLayer(mapLayerMetadata))));
    }
    /**
     * Retrieves the LRS Layers Metadata information from the map service
     * @param {?} serviceUrl
     * @return {?}
     */
    getLrsLayers(serviceUrl) {
        /** @type {?} */
        const url = join(serviceUrl, LRS_LAYERS_SERVICE_ENDPOINT);
        return this.http
            .get(url, getEsriMapServiceHttOptions())
            .pipe(tap((/**
         * @param {?} response
         * @return {?}
         */
        (response) => this.handleEsriResponseError(response, serviceUrl))));
    }
    /**
     * Retrieves the LRS Server Metadata information from the map service
     * @param {?} serviceUrl
     * @return {?}
     */
    getLrsServer(serviceUrl) {
        /** @type {?} */
        const url = join(serviceUrl, LRS_SERVER_META_ENDPOINT);
        return this.http
            .get(url, getEsriMapServiceHttOptions())
            .pipe(tap((/**
         * @param {?} response
         * @return {?}
         */
        (response) => this.handleEsriResponseError(response, serviceUrl))));
    }
    /**
     * @param {?} serviceUrl
     * @param {?=} lrsId
     * @return {?}
     */
    getVersions(serviceUrl, lrsId) {
        return this.getLrsServer(serviceUrl)
            .pipe(map((/**
         * @param {?} metadata
         * @return {?}
         */
        (metadata) => {
            /** @type {?} */
            let lrs = metadata ? metadata.lrs[0] : null;
            if (!lrs) {
                throw new Error(`No LRS infos found`);
            }
            if (lrsId) {
                lrs = metadata.lrs.find((/**
                 * @param {?} lrsInfo
                 * @return {?}
                 */
                lrsInfo => lrsInfo.id === lrsId));
                if (!lrs) {
                    throw new Error(`No LRS info found with ID '${lrsId}'`);
                }
            }
            return lrs.versions;
        })));
    }
    /**
     * @param {?} serviceUrl
     * @param {?} networkLayerId
     * @param {?} routeId
     * @param {?} x
     * @param {?} y
     * @param {?=} viewDate
     * @param {?=} inSpatialReferenceId
     * @param {?=} outputSpatialReferenceId
     * @return {?}
     */
    singleGeometryToMeasure(serviceUrl, networkLayerId, routeId, x, y, viewDate, inSpatialReferenceId = 4326, outputSpatialReferenceId = 4326) {
        /** @type {?} */
        const locations = [
            { routeId, geometry: { x, y } }
        ];
        return this.geometryToMeasure(serviceUrl, networkLayerId, {
            locations,
            temporalViewDate: viewDate,
            inSR: inSpatialReferenceId,
            outSR: outputSpatialReferenceId,
        })
            .pipe(map((/**
         * @param {?} result
         * @return {?}
         */
        result => {
            /** @type {?} */
            const match = { m: null, x: null, y: null, z: null };
            if (result.locations.length && result.locations[0].results.length) {
                const [found] = result.locations[0].results;
                match.m = found.measure;
                match.x = found.geometry.x;
                match.y = found.geometry.y;
            }
            return match;
        })));
    }
    /**
     * @param {?} serviceUrl
     * @param {?} networkLayerId
     * @param {?} options
     * @return {?}
     */
    geometryToMeasure(serviceUrl, networkLayerId, options) {
        /** @type {?} */
        const endpoint = format(LRS_GEOMETRY_TO_MEASURE, { layerId: networkLayerId });
        /** @type {?} */
        const url = join(serviceUrl, endpoint);
        /** @type {?} */
        const httpOption = getEsriMapServiceHttOptions();
        /** @type {?} */
        const serviceOptions = getGeometryToMeasureOptions(options);
        /** @type {?} */
        const useGetMethod = !this.shouldUsePostMethod(serviceOptions);
        if (useGetMethod) {
            addParamsToHttpOptions(httpOption, serviceOptions);
        }
        return (useGetMethod
            ? this.http.get(url, httpOption)
            : this.http.post(url, toFormData(serviceOptions), httpOption))
            .pipe(tap((/**
         * @param {?} response
         * @return {?}
         */
        response => this.handleEsriResponseError(response, serviceUrl))));
    }
    /**
     * @param {?} serviceUrl
     * @param {?} edits
     * @param {?=} gdbVersion
     * @return {?}
     */
    applyEdits(serviceUrl, edits, gdbVersion) {
        /** @type {?} */
        const url = join(serviceUrl, LRS_SERVER_APPLY_EDITS_ENDPOINT);
        /** @type {?} */
        const options = getEsriMapServiceHttOptions();
        /** @type {?} */
        const useGetMethod = !this.shouldUsePostMethod(edits);
        if (useGetMethod) {
            options.params = options.params
                .set('edits', JSON.stringify(edits))
                .set('gdbVersion', gdbVersion);
        }
        return (useGetMethod
            ? this.http.get(url, options)
            : this.http.post(url, toFormData({ edits, gdbVersion }), options))
            .pipe(tap((/**
         * @param {?} response
         * @return {?}
         */
        response => this.handleEsriResponseError(response, serviceUrl))));
    }
    /**
     * @template T
     * @param {?} serviceUrl
     * @param {?} layer
     * @param {?} field
     * @param {?=} options
     * @return {?}
     */
    getUniqueValues(serviceUrl, layer, field, options) {
        /** @type {?} */
        const fieldName = toFieldName(field);
        /** @type {?} */
        const queryOptions = getMapQueryOptions({
            outFields: fieldName,
            returnDistinctValues: true,
            returnGeometry: false,
        }, options);
        return this.query(serviceUrl, toLayerId(layer), queryOptions)
            .pipe(map((/**
         * @param {?} collection
         * @return {?}
         */
        collection => {
            return collection.features.map((/**
             * @param {?} f
             * @return {?}
             */
            f => f.properties[fieldName]));
        })));
    }
    /**
     * @param {?} serviceUrl
     * @param {?} layer
     * @param {?} whereClause
     * @param {?=} options
     * @return {?}
     */
    getQueryCount(serviceUrl, layer, whereClause, options) {
        /** @type {?} */
        const queryOptions = getMapQueryOptions({
            returnCountOnly: true,
            returnGeometry: false,
            where: whereClause,
        }, options);
        return this.query(serviceUrl, toLayerId(layer), queryOptions)
            .pipe(map((/**
         * @param {?} result
         * @return {?}
         */
        (result) => {
            return (result || { count: 0 }).count;
        })));
    }
    /**
     * @param {?} serviceUrl
     * @param {?} layer
     * @param {?} eventId
     * @param {?=} options
     * @return {?}
     */
    getEvent(serviceUrl, layer, eventId, options) {
        tryStripGdbVersion(layer, options);
        throw new Error('Not implemented yet');
    }
    /**
     * @param {?} serviceUrl
     * @param {?} layer
     * @param {?} routeId
     * @param {?} fromMeasure
     * @param {?} toMeasure
     * @param {?=} viewDate
     * @param {?=} options
     * @return {?}
     */
    queryEvents(serviceUrl, layer, routeId, fromMeasure, toMeasure, viewDate, options) {
        tryStripGdbVersion(layer, options);
        /** @type {?} */
        const where = this.getWhereBuilder()
            .withEventLayer(layer)
            .withRouteId(routeId)
            .withViewDate(viewDate)
            .betweenMeasures(fromMeasure, toMeasure)
            .toWhereClause();
        /** @type {?} */
        const queryOptions = getMapQueryOptions({ where, returnGeometry: false }, options);
        return this
            .query(serviceUrl, layer.id, queryOptions)
            .pipe(map((/**
         * @param {?} featureCollection
         * @return {?}
         */
        featureCollection => new EventFeatureCollection(featureCollection, layer))));
    }
    /**
     * @param {?} serviceUrl
     * @param {?} layer
     * @param {?} searchText
     * @param {?=} options
     * @return {?}
     */
    searchEventsByText(serviceUrl, layer, searchText, options) {
        return this.searchByText(serviceUrl, layer.id, searchText, options)
            .pipe(tap((/**
         * @param {?} response
         * @return {?}
         */
        response => this.handleEsriResponseError(response, serviceUrl))), map((/**
         * @param {?} featureCollection
         * @return {?}
         */
        featureCollection => new EventFeatureCollection(featureCollection, layer))));
    }
    /**
     * @param {?} serviceUrl
     * @param {?} routeId
     * @param {?} layer
     * @param {?=} viewDate
     * @param {?=} options
     * @return {?}
     */
    getRoute(serviceUrl, routeId, layer, viewDate, options) {
        tryStripGdbVersion(layer, options);
        /** @type {?} */
        const where = this.getWhereBuilder()
            .withNetworkLayer(layer)
            .where(layer.compositeRouteIdFieldName, CriteriaOperator.Equals, routeId)
            .withViewDate(viewDate)
            .toWhereClause();
        /** @type {?} */
        const queryOptions = getMapQueryOptions({
            where
        }, options);
        return this
            .query(serviceUrl, layer.id, queryOptions)
            .pipe(map((/**
         * @param {?} x
         * @return {?}
         */
        x => {
            return x && x.features && x.features.length
                ? new NetworkFeature(x.features[0], layer)
                : null;
        })));
    }
    /**
     * @param {?} serviceUrl
     * @param {?} layer
     * @param {?} whereClause
     * @param {?=} options
     * @return {?}
     */
    queryRoutes(serviceUrl, layer, whereClause, options) {
        /** @type {?} */
        const queryOptions = getMapQueryOptions({
            where: whereClause
        }, options);
        return this.query(serviceUrl, layer.id, queryOptions)
            .pipe(map((/**
         * @param {?} featureCollection
         * @return {?}
         */
        featureCollection => new NetworkFeatureCollection(featureCollection, layer, options.outSR))));
    }
    /**
     * @param {?} serviceUrl
     * @param {?} layer
     * @param {?} searchText
     * @param {?=} options
     * @return {?}
     */
    searchRoutesByText(serviceUrl, layer, searchText, options) {
        return this.searchByText(serviceUrl, layer.id, searchText, options)
            .pipe(map((/**
         * @param {?} featureCollection
         * @return {?}
         */
        featureCollection => new NetworkFeatureCollection(featureCollection, layer))));
    }
    /**
     * @param {?} serviceUrl
     * @param {?} layerId
     * @param {?} searchText
     * @param {?=} options
     * @return {?}
     */
    searchByText(serviceUrl, layerId, searchText, options) {
        /** @type {?} */
        const queryOptions = getMapQueryOptions({
            text: searchText
        }, options);
        // The where clause must be deleted because if a where clause is specified it will override the search text.
        delete queryOptions.where;
        return this.query(serviceUrl, layerId, queryOptions);
    }
    /**
     * @param {?} serviceUrl
     * @param {?} layerId
     * @param {?} options
     * @return {?}
     */
    query(serviceUrl, layerId, options) {
        /** @type {?} */
        const url = joinAndFomatWithLayer(layerId, options, serviceUrl, MAP_LAYER_QUERY_SERVICE_ENDPOINT);
        /** @type {?} */
        const httpOption = getEsriMapServiceHttOptions();
        /** @type {?} */
        const usePostMethod = this.shouldUsePostMethod(options.where);
        if (!usePostMethod) {
            httpOption.params = toHttpQueryParams(options, httpOption.params);
        }
        /** @type {?} */
        const source = usePostMethod
            ? this.http.post(url, options, httpOption)
            : this.http.get(url, httpOption);
        return source.pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            this.handleEsriResponseError(response, url);
            return (/** @type {?} */ (response));
        })));
    }
}
EsriMapServerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
EsriMapServerService.ctorParameters = () => [
    { type: HttpClient },
    { type: EsriConfig },
    { type: DataSourceConfig },
    { type: Logger }
];
/** @nocollapse */ EsriMapServerService.ngInjectableDef = defineInjectable({ factory: function EsriMapServerService_Factory() { return new EsriMapServerService(inject(HttpClient), inject(EsriConfig), inject(DataSourceConfig), inject(Logger)); }, token: EsriMapServerService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} url
 * @return {?}
 */
function isFeatureServerLayerUrl(url) {
    return FEATURE_SERVER_LAYER_SERVICE_IDENTIFIER.test(url);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} url
 * @return {?}
 */
function isFeatureServerServiceUrl(url) {
    return FEATURE_SERVER_SERVICE_IDENTIFIER.test(url);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} url
 * @return {?}
 */
function isMapServerServiceUrl(url) {
    return MAP_SERVER_SERVICE_IDENTIFIER.test(url);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} url
 * @return {?}
 */
function isLrsServerServiceUrl(url) {
    return LRS_SERVER_SERVICE_IDENTIFIER.test(url);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} url
 * @return {?}
 */
function isLrsServerLayersServiceUrl(url) {
    return LRS_SERVER_LAYERS_SERVICE_IDENTIFIER.test(url);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} urlPattern
 * @param {?} testUrl
 * @return {?}
 */
function isCacheableEsriServiceRoute(urlPattern, testUrl) {
    [testUrl] = (testUrl || '').split('?');
    return Boolean(urlPattern
        && testUrl
        && new RegExp(urlPattern, 'gi').test(testUrl)
        && isMapServerServiceUrl(testUrl)
        || isFeatureServerServiceUrl(testUrl)
        || isLrsServerServiceUrl(testUrl)
        || isLrsServerLayersServiceUrl(testUrl));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Extracts the layer ID from an ESRI map service URL.
 * \@example
 * extractMapServerLayerId('http://my-service/ags/MapServer/123') // --> 123
 * @param {?} serviceUrl
 * @return {?}
 */
function extractMapServerLayerId(serviceUrl) {
    /** @type {?} */
    let layerId = null;
    let [, , layerIdPart] = (serviceUrl || '').split(MAP_SERVER_LAYER_SERVICE_MATCH_IDENTIFIER);
    if (layerIdPart) {
        layerIdPart = layerIdPart.replace('/', '');
        layerId = Number(layerIdPart);
    }
    return layerId;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Extracts the service ID from an ESRI map layer service URL.
 * \@example
 * extractMapServerUrl('http://my-service/ags/MapServer/123') // --> 'http://my-service/ags/MapServer'
 * @param {?} serviceUrl
 * @return {?}
 */
function extractMapServerUrl(serviceUrl) {
    const [base] = (serviceUrl || '').split(MAP_SERVER_SERVICE_MATCH_IDENTIFIER);
    return base === serviceUrl
        ? null
        : join(base, 'MapServer');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} url
 * @return {?}
 */
function isMapServerLayerUrl(url) {
    return MAP_SERVER_LAYER_SERVICE_IDENTIFIER.test(url);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} urlPath
 * @return {?}
 */
function doesPathIncludePortalAccessCode(urlPath) {
    return urlPath.includes('code=');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} urlPath
 * @return {?}
 */
function doesPathIncludePortalAccessToken(urlPath) {
    return urlPath.includes('access_token=') && urlPath.includes('expires_in=');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} portalUrlComponent
 * @return {?}
 */
function getPortalUrl(portalUrlComponent) {
    const [basePortalUrl] = (portalUrlComponent || '').split(PORTAL_SHARING_ENDPOINT);
    return basePortalUrl.endsWith('/')
        ? stripTrailingSlash(basePortalUrl)
        : basePortalUrl;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} token
 * @param {?=} portalUrl
 * @return {?}
 */
function toEsriPortalAccessToken(token, portalUrl) {
    /** @type {?} */
    const portalToken = {
        accessToken: token.access_token || token.accessToken || token.token || null,
        refreshToken: token.refresh_token || token.refreshToken || null,
        expiresIn: token.expires_in || token.expiresIn || 0,
        isSecure: token.ssl || token.isSecure || false,
        server: token.server || portalUrl || null,
        username: token.username || null,
        expires: token.expires || null
    };
    if (portalToken.expires) {
        portalToken.expires = new Date(portalToken.expires);
    }
    if (portalToken.server) {
        getPortalUrl(portalToken.server);
    }
    if (!portalToken.expires) {
        portalToken.expires = addSeconds(portalToken.expiresIn, new Date());
    }
    return portalToken;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} token
 * @return {?}
 */
function toEsriServerToken(token) {
    /** @type {?} */
    const serverToken = {
        token: token.token || null,
        isSecure: token.ssl || token.isSecure || false,
        expires: token.expires || 0
    };
    if (serverToken.expires) {
        serverToken.expires = new Date(serverToken.expires);
    }
    return serverToken;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?=} urlHash
 * @return {?}
 */
function removePortalAccessTokenFromHash(urlHash = window.location.hash) {
    /** @type {?} */
    const portalParamsStartIndex = urlHash.lastIndexOf(PORTAL_REDIRECT_URL_PARAMS_BREAK_CHARACTER);
    /** @type {?} */
    const portaAaccessTokenHash = urlHash.substr(portalParamsStartIndex);
    return urlHash.replace(portaAaccessTokenHash, '');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EsriPortalService extends BaseEsriService {
    /**
     * @param {?} http
     * @param {?} config
     * @param {?} dataConfig
     * @param {?} log
     */
    constructor(http, config, dataConfig, log) {
        super(http, config, dataConfig, log);
    }
    /**
     * @param {?} portalUrl
     * @param {?} clientId
     * @param {?} code
     * @param {?=} bodyData
     * @param {?=} params
     * @return {?}
     */
    getTokenByCode(portalUrl, clientId, code, bodyData, params) {
        /** @type {?} */
        const data = Object.assign({
            client_id: clientId,
            code,
            redirect_uri: removePortalAccessTokenFromHash(window.location.href),
            grant_type: 'authorization_code'
        }, bodyData);
        /** @type {?} */
        const formData = toFormData(data);
        return this.doPost(portalUrl, PORTAL_OAUTH_TOKEN_ENDPOINT, formData, params)
            .pipe(map((/**
         * @param {?} rawToken
         * @return {?}
         */
        rawToken => toEsriPortalAccessToken(rawToken, portalUrl))));
    }
    /**
     * @param {?} portalUrl
     * @param {?} clientId
     * @param {?} refreshToken
     * @param {?=} bodyData
     * @param {?=} params
     * @return {?}
     */
    refreshToken(portalUrl, clientId, refreshToken, bodyData, params) {
        /** @type {?} */
        const data = Object.assign({
            client_id: clientId,
            refresh_token: refreshToken,
            grant_type: 'refresh_token'
        }, bodyData);
        /** @type {?} */
        const formData = toFormData(data);
        return this.doPost(portalUrl, PORTAL_OAUTH_TOKEN_ENDPOINT, formData, params)
            .pipe(map((/**
         * @param {?} rawToken
         * @return {?}
         */
        rawToken => toEsriPortalAccessToken(rawToken, portalUrl))));
    }
    /**
     * @param {?} portalUrl
     * @param {?} portalAccessToken
     * @param {?} serverUrl
     * @param {?=} params
     * @return {?}
     */
    getServerToken(portalUrl, portalAccessToken, serverUrl, params) {
        /** @type {?} */
        const additionalParams = {
            request: 'getToken',
            serverUrl,
            token: portalAccessToken,
            referer: window.location.host
        };
        return this.doGet(portalUrl, PORTAL_GENERATE_TOKEN_ENDPOINT, additionalParams, params)
            .pipe(map((/**
         * @param {?} token
         * @return {?}
         */
        token => toEsriServerToken(token))));
    }
    /**
     * @protected
     * @template T
     * @param {?} portalUrl
     * @param {?} endpoint
     * @param {?} queryParams
     * @param {?=} params
     * @return {?}
     */
    doGet(portalUrl, endpoint, queryParams, params) {
        /** @type {?} */
        const basePortalUrl = getPortalUrl(portalUrl);
        /** @type {?} */
        const url = join(basePortalUrl, endpoint);
        /** @type {?} */
        const httpOption = getEsriMapServiceHttOptions(params);
        addParamsToHttpOptions(httpOption, queryParams);
        return this.http
            .get(url, httpOption)
            .pipe(tap((/**
         * @param {?} response
         * @return {?}
         */
        (response) => this.handleEsriResponseError(response, url))));
    }
    /**
     * @protected
     * @template T
     * @param {?} portalUrl
     * @param {?} endpoint
     * @param {?} formData
     * @param {?=} params
     * @return {?}
     */
    doPost(portalUrl, endpoint, formData, params) {
        /** @type {?} */
        const basePortalUrl = getPortalUrl(portalUrl);
        /** @type {?} */
        const url = join(basePortalUrl, endpoint);
        /** @type {?} */
        const httpOption = getEsriMapServiceHttOptions(params);
        return this.http
            .post(url, formData, httpOption)
            .pipe(tap((/**
         * @param {?} response
         * @return {?}
         */
        (response) => this.handleEsriResponseError(response, url))));
    }
}
EsriPortalService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
EsriPortalService.ctorParameters = () => [
    { type: HttpClient },
    { type: EsriConfig },
    { type: DataSourceConfig },
    { type: Logger }
];
/** @nocollapse */ EsriPortalService.ngInjectableDef = defineInjectable({ factory: function EsriPortalService_Factory() { return new EsriPortalService(inject(HttpClient), inject(EsriConfig), inject(DataSourceConfig), inject(Logger)); }, token: EsriPortalService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?=} urlHash
 * @return {?}
 */
function extractPortalAccessToken(urlHash = window.location.hash) {
    /** @type {?} */
    const portalParamsStartIndex = urlHash.lastIndexOf(PORTAL_REDIRECT_URL_PARAMS_BREAK_CHARACTER);
    /** @type {?} */
    const portalParamsHash = trimStart(urlHash.substr(portalParamsStartIndex));
    /** @type {?} */
    const portalParams = getQueryParams(portalParamsHash);
    /** @type {?} */
    const accessToken = portalParams.access_token;
    /** @type {?} */
    const username = portalParams.username;
    /** @type {?} */
    const expiresIn = Number(portalParams.expires_in);
    /** @type {?} */
    const isSecure = Boolean(portalParams.ssl);
    return toEsriPortalAccessToken({
        accessToken,
        username,
        expiresIn,
        isSecure
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} portalUrl
 * @param {?} clientId
 * @param {?=} options
 * @return {?}
 */
function getPortalOAuthRedirectUrl(portalUrl, clientId, options = {}) {
    options = Object.assign({}, DEFAULT_PORTAL_OAUTH_REDIRECT_OPTIONS, options);
    portalUrl = getPortalUrl(portalUrl);
    /** @type {?} */
    const redirectUrl = encodeURIComponent(`${options.redirectUrl}${options.urlParamsBreak}`);
    /** @type {?} */
    const url = join(portalUrl, PORTAL_OAUTH_AUTHORIZE_ENDPOINT);
    return `${url}?client_id=${clientId}&redirect_uri=${redirectUrl}&response_type=${options.responseType}`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} portalUrl
 * @return {?}
 */
function getPortalSharingUrl(portalUrl) {
    /** @type {?} */
    const basePortalUrl = getPortalUrl(portalUrl);
    return join(basePortalUrl, PORTAL_SHARING_ENDPOINT);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing export-related settings.
 */
let ExportConfig = /**
 * Configuration class for storing export-related settings.
 */
class ExportConfig {
};
ExportConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ ExportConfig.ngInjectableDef = defineInjectable({ factory: function ExportConfig_Factory() { return new ExportConfig(); }, token: ExportConfig, providedIn: "root" });
/**
 * Configuration class for storing export-related settings.
 */
ExportConfig = __decorate([
    AutoConfig('ExportConfig')
], ExportConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_EXPORT_GEOJSON_FILE_NAME = 'export.geojson';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssExportModule {
}
TssExportModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TssCoreModule,
                ],
                declarations: [],
                exports: [],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ExportService {
    constructor() {
    }
    /**
     * @param {?} fileNameTemplate
     * @param {?=} tokens
     * @param {?=} removeEmptyTokens
     * @return {?}
     */
    replaceTokens(fileNameTemplate, tokens = {}, removeEmptyTokens) {
        return format(fileNameTemplate, Object.assign(this.getReplaceTokens(), tokens), removeEmptyTokens);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?=} fileNameTemplate
     * @param {...?} features
     * @return {THIS}
     */
    exportFeatureCollection(fileNameTemplate = DEFAULT_EXPORT_GEOJSON_FILE_NAME, ...features) {
        /** @type {?} */
        const fileName = (/** @type {?} */ (this)).replaceTokens(fileNameTemplate, {
            featureLength: features.length,
        });
        /** @type {?} */
        const featureCollection = {
            type: 'FeatureCollection',
            features
        };
        return (/** @type {?} */ (this)).exportFile((/** @type {?} */ (this)).stringify(featureCollection), fileName, JSON_MIME_TYPE);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?=} fileNameTemplate
     * @param {?=} feature
     * @return {THIS}
     */
    exportFeature(fileNameTemplate = DEFAULT_EXPORT_GEOJSON_FILE_NAME, feature) {
        return (/** @type {?} */ (this)).exportFile((/** @type {?} */ (this)).stringify(feature), fileNameTemplate, JSON_MIME_TYPE);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    stringify(data) {
        return JSON.stringify(data, (/**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        (key, value) => {
            return key.startsWith('$$') ? undefined : value;
        }), 2);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} data
     * @param {?} fileNameTemplate
     * @return {THIS}
     */
    exportJson(data, fileNameTemplate) {
        /** @type {?} */
        const jsonString = isString(data)
            ? (/** @type {?} */ (data))
            : (/** @type {?} */ (this)).stringify(data);
        return (/** @type {?} */ (this)).exportFile(jsonString, fileNameTemplate, JSON_MIME_TYPE);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} base64Data
     * @param {?} fileNameTemplate
     * @param {?=} contentType
     * @return {THIS}
     */
    exportBase64(base64Data, fileNameTemplate, contentType) {
        /** @type {?} */
        const fileName = (/** @type {?} */ (this)).replaceTokens(fileNameTemplate);
        contentType = contentType || base64MimeType(base64Data);
        /** @type {?} */
        const blob = base64toBlob(base64Data, contentType);
        return (/** @type {?} */ (this)).exportFromUrl(URL.createObjectURL(blob), fileName);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} data
     * @param {?} fileNameTemplate
     * @param {?=} contentType
     * @return {THIS}
     */
    exportFile(data, fileNameTemplate, contentType = TEXT_MIME_TYPE) {
        /** @type {?} */
        const blob = new Blob([data], { type: contentType });
        /** @type {?} */
        const fileName = (/** @type {?} */ (this)).replaceTokens(fileNameTemplate);
        return (/** @type {?} */ (this)).exportBlob(blob, fileName);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} blob
     * @param {?} fileNameTemplate
     * @return {THIS}
     */
    exportBlob(blob, fileNameTemplate) {
        /** @type {?} */
        const fileName = (/** @type {?} */ (this)).replaceTokens(fileNameTemplate);
        return (/** @type {?} */ (this)).exportFromUrl(window.URL.createObjectURL(blob), fileName);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} url
     * @param {?} fileName
     * @return {THIS}
     */
    exportFromUrl(url, fileName) {
        /** @type {?} */
        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        link.click();
        return (/** @type {?} */ (this));
    }
    /**
     * @protected
     * @return {?}
     */
    getReplaceTokens() {
        return {
            date: new Date(),
            shortDate: formatDate(new Date(), 'yyyy-MM-dd'),
            year: new Date().getFullYear(),
        };
    }
}
ExportService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ExportService.ctorParameters = () => [];
/** @nocollapse */ ExportService.ngInjectableDef = defineInjectable({ factory: function ExportService_Factory() { return new ExportService(); }, token: ExportService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing geolocation-related settings.
 */
let GeolocationConfig = /**
 * Configuration class for storing geolocation-related settings.
 */
class GeolocationConfig {
    constructor() {
        this.gpsDisplayDecimalPlaces = 3;
        this.gpsWarnableAccuracyMeters = 5;
        this.gpsRequiredAccuracyMeters = 10;
        this.gpsWarnableDilutionOfPrecision = 2;
        this.gpsRequiredDilutionOfPrecision = 5;
        this.gpsEnableHighAccuracy = true;
        this.gpsNoAccuracyReading = '--';
        this.allowGpsMocking = true;
        this.emitDuplicateGpsPositions = false;
        this.gpsPositionDuplicatePrecision = DEFAULT_POINT_EQUALITY_PRECISION;
        this.gpsAntennaHeight = 0;
        this.adjustForGpsAntennaHeight = true;
        this.calculateMissingPositionValues = true;
        this.geolocationGeolocatorName = 'Built-in (default)';
        this.geolocationGeolocatorDescription = `Uses the device's built-in GPS sensor within the hardware. ` +
            `Devices without a GPS sensor will defer the location retrieval to the Inernet Service Provider (ISP).`;
    }
};
GeolocationConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ GeolocationConfig.ngInjectableDef = defineInjectable({ factory: function GeolocationConfig_Factory() { return new GeolocationConfig(); }, token: GeolocationConfig, providedIn: "root" });
/**
 * Configuration class for storing geolocation-related settings.
 */
GeolocationConfig = __decorate([
    AutoConfig('GeolocationConfig')
], GeolocationConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PATH_BUILDER_EMPTY_CALIBRATION_MEASURE_VALUE = null;
/** @type {?} */
const PATH_BUILDER_CALCULATED_M_DEVICE_SOURCE = 'calculated-calibration-point';
/** @type {?} */
const GEOLOCATOR_REGISTRY = [];
/** @type {?} */
const GEOLOCATION_GEOLOCATOR_ID = 'built-in';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} id
 * @return {?}
 */
function Geolocatable(id) {
    return (/**
     * @param {?} constructor
     * @return {?}
     */
    (constructor) => {
        GEOLOCATOR_REGISTRY.push({ id, constructor });
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const GeolocatorAccuracyUnit = {
    /**
     * The geolocation accuracy reading is in standard meters (default).
     */
    Meter: 'meters',
    /**
     * The geolocation accuracy reading indicates a Position Dilution of Precision (PDOP) value.
     */
    Pdop: 'pdop',
    /**
     * The geolocation accuracy reading indicates a Horizontal Dilution of Precision (HDOP) value.
     */
    Hdop: 'hdop',
    /**
     * The geolocation accuracy reading indicates a Vertical Dilution of Precision (VDOP) value.
     */
    Vdop: 'vdop',
    /**
     * The geolocation accuracy reading indicates a Time Dilution of Precision (TDOP) value.
     */
    Tdop: 'tdop',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
 * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
 * @abstract
 */
class BaseGeolocator {
    /**
     * @param {?} log
     */
    constructor(log) {
        this.log = log;
        this.capabilities = [];
        this.accuracyUnit = GeolocatorAccuracyUnit.Meter;
    }
    /**
     * @param {?} capability
     * @return {?}
     */
    hasCapability(capability) {
        return this.capabilities.indexOf(capability) > -1;
    }
}
BaseGeolocator.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
BaseGeolocator.ctorParameters = () => [
    { type: Logger }
];
/** @nocollapse */ BaseGeolocator.ngInjectableDef = defineInjectable({ factory: function BaseGeolocator_Factory() { return new BaseGeolocator(inject(Logger)); }, token: BaseGeolocator, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} position
 * @return {?}
 */
function positionToGpsPosition(position) {
    /** @type {?} */
    const gpsPosition = {
        timestamp: position.timestamp,
        accuracy: position.coords.accuracy,
        altitude: position.coords.altitude,
        altitudeAccuracy: position.coords.altitudeAccuracy,
        latitude: position.coords.latitude,
        longitude: position.coords.longitude,
        heading: position.coords.heading,
        speed: position.coords.speed,
    };
    return gpsPosition;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const GeolocatorCapability = {
    Accuracy: 'accuracy',
    Altitude: 'altitude',
    AltitudeAccuracy: 'altitude',
    Heading: 'heading',
    Speed: 'speed',
    MagneticVariation: 'magneticVariation',
    Satellites: 'satellites',
    PDOP: 'pdop',
    HDOP: 'hdop',
    VDOP: 'vdop',
    TDOP: 'tdop',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
 * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
 */
let GeolocationGeolocator = /**
 * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
 * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
 */
class GeolocationGeolocator extends BaseGeolocator {
    /**
     * @param {?} log
     * @param {?} config
     */
    constructor(log, config) {
        super(log);
        this.config = config;
        this.capabilities = [
            GeolocatorCapability.Accuracy,
            GeolocatorCapability.Altitude,
            GeolocatorCapability.AltitudeAccuracy,
            GeolocatorCapability.Heading,
            GeolocatorCapability.Speed,
        ];
    }
    /**
     * @return {?}
     */
    get name() {
        return this.config.geolocationGeolocatorName;
    }
    /**
     * @return {?}
     */
    get description() {
        return this.config.geolocationGeolocatorDescription;
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    getCurrentPosition(options) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => navigator.geolocation
            .getCurrentPosition((/**
         * @param {?} position
         * @return {?}
         */
        (position) => {
            this.log.trace(`Received current position for ${this.name}`);
            resolve(positionToGpsPosition(position));
        }), reject, options)));
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    watchPosition(options) {
        /** @type {?} */
        const subject = new Subject();
        /** @type {?} */
        const watchId = navigator.geolocation.watchPosition((/**
         * @param {?} position
         * @return {?}
         */
        position => {
            this.log.trace(`Received watch position for ${this.name}`);
            subject.next(positionToGpsPosition(position));
        }), (/**
         * @param {?} error
         * @return {?}
         */
        error => subject.error(error)), options);
        return subject.pipe(finalize((/**
         * @return {?}
         */
        () => navigator.geolocation.clearWatch(watchId))));
    }
    /**
     * @return {?}
     */
    isAvailable() {
        return of('geolocation' in navigator);
    }
};
GeolocationGeolocator.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
GeolocationGeolocator.ctorParameters = () => [
    { type: Logger },
    { type: GeolocationConfig }
];
/** @nocollapse */ GeolocationGeolocator.ngInjectableDef = defineInjectable({ factory: function GeolocationGeolocator_Factory() { return new GeolocationGeolocator(inject(Logger), inject(GeolocationConfig)); }, token: GeolocationGeolocator, providedIn: "root" });
/**
 * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
 * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
 */
GeolocationGeolocator = __decorate([
    Geolocatable(GEOLOCATION_GEOLOCATOR_ID),
    __metadata("design:paramtypes", [Logger, GeolocationConfig])
], GeolocationGeolocator);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssGeolocationModule {
}
TssGeolocationModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TssCoreModule,
                ],
                declarations: [],
                exports: [],
                providers: [
                    { provide: BaseGeolocator, useClass: GeolocationGeolocator }
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} position
 * @param {?} acceptanceThreshold
 * @return {?}
 */
function isPositionAcceptable(position, acceptanceThreshold) {
    return position && position.accuracy <= acceptanceThreshold;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} position
 * @return {?}
 */
function isPositionError(position) {
    /** @type {?} */
    const error = (/** @type {?} */ (position));
    /** @type {?} */
    const isError = !error || isNumber$1(error.code);
    return isError;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} position
 * @return {?}
 */
function gpsPositionToPoint(position) {
    /** @type {?} */
    const point = [position.longitude, position.latitude];
    if (isDefined(position.altitude)) {
        point[2] = position.altitude;
    }
    return point;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} latitide
 * @return {?}
 */
function isValidLatitude(latitide) {
    return isNumber$1(latitide) && isNumberBetweenOrEqual(latitide, -90, 90);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} longitude
 * @return {?}
 */
function isValidLongitude(longitude) {
    return isNumber$1(longitude) && isNumberBetweenOrEqual(longitude, -180, 180);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} location
 * @return {?}
 */
function isValidLocation(location) {
    return isValidLatitude(location.latitude) && isValidLongitude(location.longitude);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} location
 * @return {?}
 */
function isNotValidLocation(location) {
    return !isValidLocation(location);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} position1
 * @param {?} position2
 * @param {?=} precision
 * @return {?}
 */
function gpsPositionsAlmostEqual(position1, position2, precision = DEFAULT_POINT_EQUALITY_PRECISION) {
    return pointsAlmostEqual(position1.longitude, position1.latitude, position2.longitude, position2.latitude, precision);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Geolocator service. Provides a single point of GPS interaction.
 */
class GeolocationService {
    /**
     * @param {?} geolocator
     * @param {?} log
     * @param {?} notify
     * @param {?} config
     */
    constructor(geolocator, log, notify, config) {
        this.log = log;
        this.notify = notify;
        this.config = config;
        this.isTrackingPosition = false;
        this.geolocator = geolocator;
        this.positionChangeSubject = new ReplaySubject(1);
        this.positionRecievedSubject = new Subject();
        this.positionChange = this.positionChangeSubject.asObservable();
        this.positionRecieved = this.positionRecievedSubject.asObservable();
    }
    /**
     * @return {?}
     */
    get positionText() {
        return this.position
            ? `${this.position.longitude.toFixed(this.config.gpsDisplayDecimalPlaces)}
       , ${this.position.latitude.toFixed(this.config.gpsDisplayDecimalPlaces)}`
            : '';
    }
    /**
     * @return {?}
     */
    get positionReceivedEllapsedTime() {
        if (!this.positionRecievedTime) {
            return '';
        }
        /** @type {?} */
        const differenceMilliseconds = Date.now() - this.positionRecievedTime.getTime();
        return `${toReadableTime(differenceMilliseconds)} ago`;
    }
    /**
     * @return {?}
     */
    get isPositionAcceptable() {
        /** @type {?} */
        const accuracyThreshold = this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Meter
            ? this.config.gpsRequiredAccuracyMeters
            : this.config.gpsRequiredDilutionOfPrecision;
        return isPositionAcceptable(this.position, accuracyThreshold);
    }
    /**
     * @return {?}
     */
    get isPositionUnacceptable() {
        return !this.isPositionAcceptable;
    }
    /**
     * @return {?}
     */
    get isPositionWarnable() {
        /** @type {?} */
        const accuracyThreshold = this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Meter
            ? this.config.gpsWarnableAccuracyMeters
            : this.config.gpsWarnableDilutionOfPrecision;
        return !isPositionAcceptable(this.position, accuracyThreshold);
    }
    /**
     * @return {?}
     */
    get hasAccuracyCapability() {
        return this.geolocator.capabilities.indexOf(GeolocatorCapability.Accuracy) > -1;
    }
    /**
     * @return {?}
     */
    get isPositionAccuracyKnown() {
        return this.position && isNumber$1(this.position.accuracy);
    }
    /**
     * @return {?}
     */
    get isPositionAccuracyUnknown() {
        return !this.isPositionAccuracyKnown;
    }
    /**
     * @return {?}
     */
    get isPositionAccuracyInMeters() {
        return this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Meter;
    }
    /**
     * @return {?}
     */
    get isPositionAccuracyInDilutionOfPrecision() {
        return this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Pdop
            || this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Hdop
            || this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Vdop
            || this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Tdop;
    }
    /**
     * @return {?}
     */
    get geolocatorService() {
        return this.geolocator;
    }
    /**
     * @return {?}
     */
    get accuracyStatement() {
        /** @type {?} */
        const noPosition = !this.position;
        if (noPosition) {
            return this.config.gpsNoAccuracyReading;
        }
        /** @type {?} */
        const isPositionAccuracyKnown = this.isPositionAccuracyKnown;
        /** @type {?} */
        let accuracy = isPositionAccuracyKnown ? this.position.accuracy : null;
        /** @type {?} */
        let suffix;
        if (isPositionAccuracyKnown && this.geolocator.hasCapability(GeolocatorCapability.Accuracy)) {
            suffix = this.geolocator.accuracyUnit === GeolocatorAccuracyUnit.Meter
                ? 'm'
                : String(this.geolocator.accuracyUnit).toUpperCase();
        }
        else if (this.geolocator.hasCapability(GeolocatorCapability.PDOP)) {
            accuracy = this.position.pdop;
            suffix = String(GeolocatorCapability.PDOP).toUpperCase();
        }
        else if (this.geolocator.hasCapability(GeolocatorCapability.HDOP)) {
            accuracy = this.position.hdop;
            suffix = String(GeolocatorCapability.HDOP).toUpperCase();
        }
        else if (this.geolocator.hasCapability(GeolocatorCapability.VDOP)) {
            accuracy = this.position.vdop;
            suffix = String(GeolocatorCapability.VDOP).toUpperCase();
        }
        else if (this.geolocator.hasCapability(GeolocatorCapability.TDOP)) {
            accuracy = this.position.tdop;
            suffix = String(GeolocatorCapability.TDOP).toUpperCase();
        }
        if (isNotNumber(accuracy)) {
            return this.config.gpsNoAccuracyReading;
        }
        return `${formatNumber(accuracy)} ${suffix}`;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    enableGpsTracking() {
        /** @type {?} */
        const geoOptions = {
            enableHighAccuracy: (/** @type {?} */ (this)).config.gpsEnableHighAccuracy
        };
        (/** @type {?} */ (this)).position = null;
        (/** @type {?} */ (this)).tryUnsubscribe();
        (/** @type {?} */ (this)).log.debug(`Subscribing to GPS watching for '${(/** @type {?} */ (this)).geolocator.name}' with high accuracy set to '${geoOptions.enableHighAccuracy}'`);
        (/** @type {?} */ (this)).gpsLocatorSubscription = (/** @type {?} */ (this)).geolocator.watchPosition(geoOptions)
            .subscribe((/**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
        position => (/** @type {?} */ (this)).onPositionRecieved(position)), (/**
         * @template THIS
         * @this {THIS}
         * @param {?} error
         * @return {THIS}
         */
        error => (/** @type {?} */ (this)).onLocationError(error)));
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    disableGpsTracking() {
        (/** @type {?} */ (this)).isTrackingPosition = false;
        (/** @type {?} */ (this)).tryUnsubscribe();
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} geolocator
     * @return {THIS}
     */
    setGeoLocator(geolocator) {
        (/** @type {?} */ (this)).tryUnsubscribe();
        (/** @type {?} */ (this)).geolocator = geolocator;
        if ((/** @type {?} */ (this)).isTrackingPosition) {
            (/** @type {?} */ (this)).enableGpsTracking();
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} isTrackingLocation
     * @return {THIS}
     */
    setGpsTracking(isTrackingLocation) {
        if (isTrackingLocation) {
            (/** @type {?} */ (this)).enableGpsTracking();
        }
        else {
            (/** @type {?} */ (this)).disableGpsTracking();
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    toggleGpsTracking() {
        (/** @type {?} */ (this)).setGpsTracking(!(/** @type {?} */ (this)).isTrackingPosition);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @return {THIS}
     */
    mockGpsPosition(position) {
        if (!(/** @type {?} */ (this)).config.allowGpsMocking) {
            throw new Error('Permission denied to mock GPS location');
        }
        return (/** @type {?} */ (this)).onPositionRecieved(position);
    }
    /**
     * @protected
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @return {THIS}
     */
    onPositionRecieved(position) {
        if (isPositionError(position)) {
            (/** @type {?} */ (this)).onLocationError((/** @type {?} */ (position)));
            return (/** @type {?} */ (this));
        }
        /** @type {?} */
        const gpsPosition = (/** @type {?} */ (position));
        if (isNotValidLocation(gpsPosition)) {
            return (/** @type {?} */ (this));
        }
        /** @type {?} */
        const isPreviousPointSameAsNew = (/** @type {?} */ (this)).position
            && gpsPositionsAlmostEqual((/** @type {?} */ (this)).position, gpsPosition, (/** @type {?} */ (this)).config.gpsPositionDuplicatePrecision);
        if (isPreviousPointSameAsNew && !(/** @type {?} */ (this)).config.emitDuplicateGpsPositions) {
            (/** @type {?} */ (this)).positionRecievedSubject.next(gpsPosition);
            return (/** @type {?} */ (this));
        }
        (/** @type {?} */ (this)).log.trace(`Location recieved from '${(/** @type {?} */ (this)).geolocator.name}': ${gpsPosition.latitude}, ${gpsPosition.longitude}`);
        (/** @type {?} */ (this)).adjustCoordinates(gpsPosition);
        (/** @type {?} */ (this)).position = gpsPosition;
        (/** @type {?} */ (this)).isTrackingPosition = true;
        (/** @type {?} */ (this)).positionRecievedTime = new Date((/** @type {?} */ (this)).position.timestamp || Date.now());
        (/** @type {?} */ (this)).positionRecievedSubject.next((/** @type {?} */ (this)).position);
        (/** @type {?} */ (this)).positionChangeSubject.next((/** @type {?} */ (this)).position);
        return (/** @type {?} */ (this));
    }
    /**
     * @protected
     * @template THIS
     * @this {THIS}
     * @param {?} error
     * @return {THIS}
     */
    onLocationError(error) {
        /** @type {?} */
        const errorMessage = errorMsg('Failed to retrieve location position. {error}', error);
        (/** @type {?} */ (this)).positionChangeSubject.error(error);
        (/** @type {?} */ (this)).log.error(errorMessage);
        (/** @type {?} */ (this)).notify.error(errorMessage);
        return (/** @type {?} */ (this));
    }
    /**
     * @private
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @return {THIS}
     */
    adjustCoordinates(position) {
        (/** @type {?} */ (this)).tryAdjustMissingPositionValues(position);
        if ((/** @type {?} */ (this)).config.adjustForGpsAntennaHeight && (/** @type {?} */ (this)).config.gpsAntennaHeight) {
            /** @type {?} */
            let adjustedHeight = position.altitude - (/** @type {?} */ (this)).config.gpsAntennaHeight;
            adjustedHeight = adjustedHeight < 0 ? 0 : adjustedHeight;
            (/** @type {?} */ (this)).log.trace(`Adjusting coordinate altitude from ${position.altitude} to ${adjustedHeight}`);
            Object.assign(position, {
                altitude: adjustedHeight
            });
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @private
     * @param {?} newPosition
     * @return {?}
     */
    tryAdjustMissingPositionValues(newPosition) {
        /** @type {?} */
        const missingSpeed = isNotValue(newPosition.speed);
        /** @type {?} */
        const missingHeading = isNotValue(newPosition.heading);
        /** @type {?} */
        const positionValuesMissing = missingSpeed || missingHeading;
        /** @type {?} */
        const shouldAdjustPositionValues = this.position && positionValuesMissing && this.config.calculateMissingPositionValues;
        if (shouldAdjustPositionValues) {
            /** @type {?} */
            const fromPoint = gpsPositionToPoint(this.position);
            /** @type {?} */
            const toPoint = gpsPositionToPoint(newPosition);
            if (missingSpeed) {
                // meters per second
                /** @type {?} */
                const kilometersTraveled = distance(fromPoint, toPoint, { units: 'kilometers' });
                if (kilometersTraveled) {
                    /** @type {?} */
                    const metersTraveled = convertLengthUnits(kilometersTraveled, LengthUnit.Kilometer, LengthUnit.Meter);
                    /** @type {?} */
                    const secondsDelta = millisecondsToSeconds(Math.abs(newPosition.timestamp - this.position.timestamp));
                    /** @type {?} */
                    const speed = metersTraveled / secondsDelta;
                    Object.assign(newPosition, { speed });
                }
            }
            if (missingHeading) {
                /** @type {?} */
                const heading = bearing(fromPoint, toPoint);
                Object.assign(newPosition, { heading });
            }
        }
    }
    /**
     * @private
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    tryUnsubscribe() {
        if ((/** @type {?} */ (this)).gpsLocatorSubscription) {
            (/** @type {?} */ (this)).log.debug(`Unsubscribing from watching GPS stream from '${(/** @type {?} */ (this)).geolocator.name}'`);
            (/** @type {?} */ (this)).gpsLocatorSubscription.unsubscribe();
        }
        return (/** @type {?} */ (this));
    }
}
GeolocationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
GeolocationService.ctorParameters = () => [
    { type: BaseGeolocator },
    { type: Logger },
    { type: NotifyService },
    { type: GeolocationConfig }
];
/** @nocollapse */ GeolocationService.ngInjectableDef = defineInjectable({ factory: function GeolocationService_Factory() { return new GeolocationService(inject(BaseGeolocator), inject(Logger), inject(NotifyService), inject(GeolocationConfig)); }, token: GeolocationService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeolocatorSourceService {
    /**
     * @param {?} injector
     */
    constructor(injector) {
        this.injector = injector;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getGeolocator(id) {
        /** @type {?} */
        const registry = GEOLOCATOR_REGISTRY.find((/**
         * @param {?} registedSource
         * @return {?}
         */
        registedSource => registedSource.id === id));
        return this.getLocatorFromRegistry(registry);
    }
    /**
     * @return {?}
     */
    getGeolocators() {
        return GEOLOCATOR_REGISTRY
            .map((/**
         * @param {?} registry
         * @return {?}
         */
        registry => this.getLocatorFromRegistry(registry)));
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getGeolocatorSource(id) {
        return this.getGeolocatorSources()
            .pipe(map((/**
         * @param {?} devices
         * @return {?}
         */
        devices => devices.find((/**
         * @param {?} device
         * @return {?}
         */
        device => device.id === id)))));
    }
    /**
     * @return {?}
     */
    getAvailableGeolocatorSources() {
        return this.getGeolocatorSources()
            .pipe(map((/**
         * @param {?} devices
         * @return {?}
         */
        devices => devices.filter((/**
         * @param {?} device
         * @return {?}
         */
        device => device.isAvailable)))));
    }
    /**
     * @return {?}
     */
    getGeolocatorSources() {
        /** @type {?} */
        const availableObservables = GEOLOCATOR_REGISTRY
            .map((/**
         * @param {?} registry
         * @return {?}
         */
        registry => {
            /** @type {?} */
            const locator = this.getLocatorFromRegistry(registry);
            /** @type {?} */
            const source = {
                id: registry.id,
                name: locator.name,
                description: locator.description,
                accuracyUnit: locator.accuracyUnit,
                capabilities: locator.capabilities,
                isAvailable: false,
            };
            return locator.isAvailable()
                .pipe(tap((/**
             * @param {?} available
             * @return {?}
             */
            available => source.isAvailable = available)), map((/**
             * @return {?}
             */
            () => source)));
        }));
        return availableObservables.length === 0
            ? of([])
            : forkJoin(availableObservables);
    }
    /**
     * @private
     * @param {?} registry
     * @return {?}
     */
    getLocatorFromRegistry(registry) {
        /** @type {?} */
        const instance = this.injector.get(registry.constructor);
        return instance;
    }
}
GeolocatorSourceService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
GeolocatorSourceService.ctorParameters = () => [
    { type: Injector }
];
/** @nocollapse */ GeolocatorSourceService.ngInjectableDef = defineInjectable({ factory: function GeolocatorSourceService_Factory() { return new GeolocatorSourceService(inject(INJECTOR)); }, token: GeolocatorSourceService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {...?} positions
 * @return {?}
 */
function gpsPositionsToPoint(...positions) {
    return positions.map((/**
     * @param {?} position
     * @return {?}
     */
    position => gpsPositionToPoint(position)));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} latitude
 * @return {?}
 */
function isNotValidLatitude(latitude) {
    return !isValidLatitude(latitude);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} longitude
 * @return {?}
 */
function isNotValidLongitude(longitude) {
    return !isValidLongitude(longitude);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_EMPTY_Z_VALUE = 0;
/** @type {?} */
const DEFAULT_OPTIONS = {
    units: 'miles',
    hasZValues: true,
    calibrationPositions: []
};
/**
 * @param {?} line
 * @param {?=} options
 * @return {?}
 */
function setMeasuresByGeometricLength(line, options) {
    /** @type {?} */
    const martiPart = toMultiPartPaths(line);
    options = Object.assign({}, DEFAULT_OPTIONS, options);
    /** @type {?} */
    let lastMeasure = 0;
    martiPart.forEach((/**
     * @param {?} linePart
     * @param {?} partIndex
     * @return {?}
     */
    (linePart, partIndex) => {
        setMeasureForLine(linePart, lastMeasure, partIndex, options);
        /** @type {?} */
        const lastCoordinateIndex = linePart.length - 1;
        /** @type {?} */
        const lastCoordinate = linePart[lastCoordinateIndex];
        lastMeasure += getMeasureFromPoint(lastCoordinate);
    }));
}
/**
 * @param {?} line
 * @param {?} startMeasure
 * @param {?} partIndex
 * @param {?} options
 * @return {?}
 */
function setMeasureForLine(line, startMeasure, partIndex, options) {
    /** @type {?} */
    const hasCalibrationPoints = options.calibrationPositions.some((/**
     * @param {?} calibrationPosition
     * @return {?}
     */
    calibrationPosition => calibrationPosition.partIndex === partIndex));
    if (hasCalibrationPoints) {
        calibrateLinePart(line, startMeasure, partIndex, options);
    }
    else {
        setLinePartMeasuresByGeometricLength(line, startMeasure, options);
    }
}
/**
 * @param {?} line
 * @param {?} startMeasure
 * @param {?} partIndex
 * @param {?} options
 * @return {?}
 */
function calibrateLinePart(line, startMeasure, partIndex, options) {
    /** @type {?} */
    const calibrationPositions = options.calibrationPositions.filter((/**
     * @param {?} position
     * @return {?}
     */
    position => position.partIndex === partIndex));
    /** @type {?} */
    let fromVertexIndex = 0;
    sortAscending(calibrationPositions, (/**
     * @param {?} calibration
     * @return {?}
     */
    calibration => calibration.measure));
    calibrationPositions.forEach((/**
     * @param {?} calibration
     * @return {?}
     */
    calibration => {
        /** @type {?} */
        const fromVertex = line[fromVertexIndex];
        /** @type {?} */
        const toVertex = line[calibration.vertexIndex];
        /** @type {?} */
        const numberOfVerticesInBetween = calibration.vertexIndex - fromVertexIndex;
        /** @type {?} */
        const distanceForSection = Math.abs(calibration.measure - startMeasure);
        /** @type {?} */
        const measureDistributionIncrement = distanceForSection / numberOfVerticesInBetween;
        setMeasure(fromVertex, startMeasure, options.hasZValues);
        setMeasure(toVertex, calibration.measure, options.hasZValues);
        /** @type {?} */
        const inBetweenVertices = getVerticesBetween(line, fromVertexIndex, calibration.vertexIndex);
        inBetweenVertices.forEach((/**
         * @param {?} vertice
         * @param {?} index
         * @return {?}
         */
        (vertice, index) => {
            /** @type {?} */
            const partNumber = index + 1;
            /** @type {?} */
            const verticeIncrement = partNumber * measureDistributionIncrement;
            /** @type {?} */
            const measure = startMeasure + verticeIncrement;
            setMeasure(vertice, measure, options.hasZValues);
        }));
        fromVertexIndex = calibration.vertexIndex;
        startMeasure = calibration.measure;
    }));
    /** @type {?} */
    const areMoreVertices = fromVertexIndex < line.length - 1;
    if (areMoreVertices) {
        /** @type {?} */
        const remainingPoints = getVerticesBetween(line, fromVertexIndex - 1, line.length);
        setLinePartMeasuresByGeometricLength(remainingPoints, startMeasure, options);
    }
}
/**
 * @param {?} line
 * @param {?} startRangeIndex
 * @param {?} endRangeIndex
 * @return {?}
 */
function getVerticesBetween(line, startRangeIndex, endRangeIndex) {
    /** @type {?} */
    let index = startRangeIndex + 1;
    /** @type {?} */
    const vertices = [];
    for (; index < endRangeIndex; index++) {
        /** @type {?} */
        const vertice = line[index];
        vertices.push(vertice);
    }
    return vertices;
}
/**
 * @param {?} line
 * @param {?} startMeasure
 * @param {?} options
 * @return {?}
 */
function setLinePartMeasuresByGeometricLength(line, startMeasure, options) {
    /** @type {?} */
    let previousVertex;
    /** @type {?} */
    let vertexMeasure = startMeasure;
    line.forEach((/**
     * @param {?} vertex
     * @param {?} index
     * @return {?}
     */
    (vertex, index) => {
        if (index !== 0) {
            /** @type {?} */
            const distanceBetweenVerticees = distance(previousVertex, vertex, options);
            vertexMeasure += distanceBetweenVerticees;
        }
        setMeasure(vertex, vertexMeasure, options.hasZValues);
        previousVertex = vertex;
    }));
}
/**
 * @param {?} coordinate
 * @param {?} measure
 * @param {?} hasZValues
 * @return {?}
 */
function setMeasure(coordinate, measure, hasZValues) {
    /** @type {?} */
    const accountForZValue = hasZValues || coordinate.length > 3;
    /** @type {?} */
    const measureIndex = accountForZValue ? 3 : 2;
    coordinate[measureIndex] = measure;
    if (accountForZValue) {
        ensureZValue(coordinate);
    }
}
/**
 * @param {?} coordinate
 * @return {?}
 */
function ensureZValue(coordinate) {
    if (isNotNumber(coordinate[2])) {
        coordinate[2] = DEFAULT_EMPTY_Z_VALUE;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const UNPLACED_CALIBRATION_MEASURE_KEY = 'pending';
/** @type {?} */
const DEFAULT_OPTIONS$1 = {
    gpsRequiredAccuracyMeters: 10,
    requireAccuracy: true,
    pointEquivalencyPrecision: 8,
    returnZValues: true,
    returnMValues: true,
    mValueUnit: 'miles',
    storeUnfilteredPath: false,
    calibrationMeasureSnappingDistanceDelta: 2,
    calibrationMeasureSnappingDistanceDeltaUnit: LengthUnit.Foot
};
class PositionPathBuilder {
    /**
     * @return {?}
     */
    get positionCount() {
        /** @type {?} */
        const counts = this.parts.map((/**
         * @param {?} part
         * @return {?}
         */
        part => part.length));
        return sumValues(counts);
    }
    /**
     * @return {?}
     */
    get currentPartIndex() {
        return this.parts.length - 1;
    }
    /**
     * @return {?}
     */
    get currentPart() {
        return this.parts[this.currentPartIndex];
    }
    /**
     * @return {?}
     */
    get lastPosition() {
        return getLastItem(this.currentPart);
    }
    /**
     * @return {?}
     */
    get hasPosition() {
        return Boolean(this.lastPosition);
    }
    /**
     * @return {?}
     */
    get isEmpty() {
        return this.currentPart.length === 0;
    }
    /**
     * @return {?}
     */
    get isValidPath() {
        return this.currentPart.length > 1;
    }
    /**
     * @return {?}
     */
    get isSinglePoint() {
        return this.parts.length === 1 && this.currentPart.length === 1;
    }
    /**
     * @param {?=} options
     */
    constructor(options) {
        this.parts = [[]];
        this.unfilteredPath = [];
        this.calibratedMeasures = new Map();
        this.options = Object.assign({}, DEFAULT_OPTIONS$1, options);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} positionStream
     * @return {THIS}
     */
    trackPosition(positionStream) {
        (/** @type {?} */ (this)).trackSubscription = positionStream.subscribe((/**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
        position => (/** @type {?} */ (this)).addPosition(position)));
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @param {?=} calibrationMeasure
     * @return {THIS}
     */
    addPosition(position, calibrationMeasure) {
        /** @type {?} */
        const accuracyCriteriaMet = !(/** @type {?} */ (this)).options.requireAccuracy
            || isPositionAcceptable(position, (/** @type {?} */ (this)).options.gpsRequiredAccuracyMeters);
        /** @type {?} */
        const positionNotAcceptable = !position || !accuracyCriteriaMet;
        if (positionNotAcceptable) {
            return (/** @type {?} */ (this)).tryStoreUnfilteredPath(position);
        }
        if ((/** @type {?} */ (this)).isEmpty) {
            return (/** @type {?} */ (this)).forceAddPosition(position);
        }
        /** @type {?} */
        const pointsAtSameLocation = (/** @type {?} */ (this)).arePositionsEquivalent((/** @type {?} */ (this)).lastPosition, position);
        /** @type {?} */
        const bothPointsAtStandStill = (/** @type {?} */ (this)).lastPosition.speed === 0 && position.speed === 0 || pointsAtSameLocation;
        if (bothPointsAtStandStill) {
            (/** @type {?} */ (this)).tryStoreUnfilteredPath(position)
                .replaceLastPositionIfBetter(position);
            return (/** @type {?} */ (this));
        }
        (/** @type {?} */ (this)).forceAddPosition(position);
        if (isNumber$1(calibrationMeasure)) {
            (/** @type {?} */ (this)).addCalibrationMeasureToLastPosition(calibrationMeasure);
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    startNewPart() {
        (/** @type {?} */ (this)).parts.push([]);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} vertexIndex
     * @param {?=} partIndex
     * @return {THIS}
     */
    removePositionByIndex(vertexIndex, partIndex = 0) {
        /** @type {?} */
        const part = (/** @type {?} */ (this)).parts[partIndex];
        if (!part) {
            throw new Error(`Invalid part index" ${partIndex}`);
        }
        part.splice(vertexIndex, 1);
        /** @type {?} */
        const key = (/** @type {?} */ (this)).getCalibrationMeasureLookupKey(partIndex, vertexIndex);
        if ((/** @type {?} */ (this)).calibratedMeasures.has(key)) {
            (/** @type {?} */ (this)).calibratedMeasures.delete(key);
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @return {THIS}
     */
    removePosition(position) {
        /** @type {?} */
        let partIndex = -1;
        /** @type {?} */
        let vertexIndex = -1;
        (/** @type {?} */ (this)).parts.forEach((/**
         * @param {?} part
         * @param {?} index
         * @return {?}
         */
        (part, index) => {
            /** @type {?} */
            const foundPositionIndex = part.indexOf(position);
            if (foundPositionIndex > -1) {
                partIndex = index;
                vertexIndex = foundPositionIndex;
            }
        }));
        if (partIndex > -1 && vertexIndex > -1) {
            return (/** @type {?} */ (this)).removePositionByIndex(vertexIndex, partIndex);
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} measure
     * @return {THIS}
     */
    removeCalibrationMeasure(measure) {
        Array.from((/** @type {?} */ (this)).calibratedMeasures.values())
            .filter((/**
         * @param {?} calibration
         * @return {?}
         */
        calibration => calibration.measure === measure))
            .forEach((/**
         * @template THIS
         * @this {THIS}
         * @param {?} calibration
         * @return {THIS}
         */
        calibration => (/** @type {?} */ (this)).removeCalibrationMeasureByIndex(calibration.vertexIndex, calibration.partIndex)));
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} vertexIndex
     * @param {?=} partIndex
     * @return {THIS}
     */
    removeCalibrationMeasureByIndex(vertexIndex, partIndex = 0) {
        /** @type {?} */
        const key = (/** @type {?} */ (this)).getCalibrationMeasureLookupKey(partIndex, vertexIndex);
        if ((/** @type {?} */ (this)).calibratedMeasures.has(key)) {
            (/** @type {?} */ (this)).calibratedMeasures.delete(key);
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} measure
     * @return {THIS}
     */
    addCalibrationMeasure(measure) {
        /** @type {?} */
        const timestamp = new Date().getTime();
        const [lastVertex] = (/** @type {?} */ (this)).currentPart.slice(-1);
        if (lastVertex && lastVertex.timestamp && lastVertex.timestamp === timestamp) {
            return (/** @type {?} */ (this)).addCalibrationMeasureToLastPosition(measure);
        }
        /** @type {?} */
        const partIndex = (/** @type {?} */ (this)).currentPartIndex;
        /** @type {?} */
        const key = UNPLACED_CALIBRATION_MEASURE_KEY;
        (/** @type {?} */ (this)).calibratedMeasures.set(key, {
            measure,
            partIndex,
            vertexIndex: null,
            timestamp
        });
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} measure
     * @return {THIS}
     */
    addCalibrationMeasureToLastPosition(measure) {
        /** @type {?} */
        const partIndex = (/** @type {?} */ (this)).currentPartIndex;
        /** @type {?} */
        const lastVertexIndex = (/** @type {?} */ (this)).currentPart.length - 1;
        return (/** @type {?} */ (this)).addCalibrationMeasureAtIndex(measure, lastVertexIndex, partIndex);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} measure
     * @param {?} vertexIndex
     * @param {?=} partIndex
     * @return {THIS}
     */
    addCalibrationMeasureAtIndex(measure, vertexIndex, partIndex = 0) {
        /** @type {?} */
        const key = (/** @type {?} */ (this)).getCalibrationMeasureLookupKey(partIndex, vertexIndex);
        (/** @type {?} */ (this)).calibratedMeasures.set(key, {
            measure,
            partIndex,
            vertexIndex,
            timestamp: new Date().getTime()
        });
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @return {THIS}
     */
    forceAddPosition(position) {
        (/** @type {?} */ (this)).tryStoreUnfilteredPath(position);
        (/** @type {?} */ (this)).addPositionToPath(position);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toPointFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toPointGeometry(),
            properties
        };
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toLineFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toLineGeometry(),
            properties
        };
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toSingleLineFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toSingleLineGeometry(),
            properties
        };
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toMultiLineFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toMultiLineGeometry(),
            properties
        };
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toPolygonFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toPolygonGeometry(),
            properties
        };
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toMultiPolygonFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toMultiPolygonGeometry(),
            properties
        };
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toSinglePolygonFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toSinglePolygonGeometry(),
            properties
        };
    }
    /**
     * @return {?}
     */
    toFeature() {
        return this.isSinglePoint
            ? (/** @type {?} */ (this.toPointFeature()))
            : this.toLineFeature();
    }
    /**
     * @return {?}
     */
    toGeometry() {
        return this.isSinglePoint
            ? (/** @type {?} */ (this.toPointGeometry()))
            : this.toLineGeometry();
    }
    /**
     * @param {?=} calibrateMeasures
     * @return {?}
     */
    toSingleLineGeometry(calibrateMeasures = true) {
        /** @type {?} */
        const line = this.toLineGeometry(calibrateMeasures);
        if (isMultiPartLine(line.coordinates)) {
            throw new Error('Cannot convert MultiLineString to LineString. Data would be lost');
        }
        return (/** @type {?} */ (line));
    }
    /**
     * @param {?=} calibrateMeasures
     * @return {?}
     */
    toMultiLineGeometry(calibrateMeasures = true) {
        /** @type {?} */
        let line = this.toLineGeometry(calibrateMeasures);
        /** @type {?} */
        const isSinglePartLine = !isMultiPartLine(line.coordinates);
        if (isSinglePartLine) {
            line = {
                type: 'MultiLineString',
                bbox: line.bbox,
                coordinates: [(/** @type {?} */ (line.coordinates))]
            };
        }
        return (/** @type {?} */ (line));
    }
    /**
     * @param {?=} calibrateMeasures
     * @return {?}
     */
    toLineGeometry(calibrateMeasures = true) {
        /** @type {?} */
        const parts = this.toMultiPartArray();
        /** @type {?} */
        const line = parts.length > 1
            ? {
                type: 'MultiLineString',
                coordinates: parts
            }
            : {
                type: 'LineString',
                coordinates: parts[0]
            };
        if (this.options.returnMValues) {
            /** @type {?} */
            const calibrationPositions = calibrateMeasures
                ? Array.from(this.calibratedMeasures.values())
                : [];
            setMeasuresByGeometricLength(line, {
                units: this.options.mValueUnit,
                hasZValues: this.options.returnZValues,
                calibrationPositions
            });
        }
        return line;
    }
    /**
     * @return {?}
     */
    toMultiPolygonGeometry() {
        /** @type {?} */
        let poly = this.toPolygonGeometry();
        /** @type {?} */
        const isSinglePolygon = poly.type === 'Polygon';
        if (isSinglePolygon) {
            poly = {
                type: 'MultiPolygon',
                bbox: poly.bbox,
                coordinates: [(/** @type {?} */ (poly.coordinates))]
            };
        }
        return (/** @type {?} */ (poly));
    }
    /**
     * @return {?}
     */
    toSinglePolygonGeometry() {
        /** @type {?} */
        const poly = this.toPolygonGeometry();
        /** @type {?} */
        const isMultiPart = poly.type === 'MultiPolygon';
        if (isMultiPart) {
            throw new Error('Cannot convert MultiPolygon to Polygon. Data would be lost');
        }
        return (/** @type {?} */ (poly));
    }
    /**
     * @return {?}
     */
    toPolygonGeometry() {
        /** @type {?} */
        const parts = this.toMultiPartArray();
        parts.forEach((/**
         * @param {?} part
         * @return {?}
         */
        part => this.ensurePolygonIsClosed(part)));
        return parts.length > 1
            ? {
                type: 'MultiPolygon',
                coordinates: [parts]
            }
            : {
                type: 'Polygon',
                coordinates: parts
            };
    }
    /**
     * @return {?}
     */
    toPointGeometry() {
        /** @type {?} */
        const parts = this.toMultiPartArray();
        return parts.length > 1
            ? { type: 'MultiPoint', coordinates: parts.map((/**
                 * @param {?} part
                 * @return {?}
                 */
                part => part[0])) }
            : { type: 'Point', coordinates: parts[0][0] };
    }
    /**
     * @param {?} position
     * @return {?}
     */
    replaceLastPositionIfBetter(position) {
        /** @type {?} */
        let wasPositionAdded = true;
        if (this.isEmpty) {
            this.addPositionToPath(position);
            return wasPositionAdded;
        }
        /** @type {?} */
        const newPositionHasBetterAccuracy = this.lastPosition.accuracy > position.accuracy;
        if (newPositionHasBetterAccuracy) {
            this.replaceLastPosition(position);
        }
        else {
            wasPositionAdded = false;
        }
        return wasPositionAdded;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @return {THIS}
     */
    replaceLastPosition(position) {
        (/** @type {?} */ (this)).currentPart[(/** @type {?} */ (this)).currentPart.length - 1] = position;
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getBestPosition() {
        throw new Error('Not implemented yet');
    }
    /**
     * @return {?}
     */
    getUnfilteredPath() {
        return this.unfilteredPath.map((/**
         * @param {?} position
         * @return {?}
         */
        position => {
            /** @type {?} */
            const unfilteredGpsPosition = Object.assign({
                included: this.pathContains(position)
            }, position);
            return unfilteredGpsPosition;
        }));
    }
    /**
     * @return {?}
     */
    getGeometryPathSummary() {
        /** @type {?} */
        const line = this.toMultiLineGeometry(false);
        return line.coordinates.map((/**
         * @param {?} part
         * @param {?} partIndex
         * @return {?}
         */
        (part, partIndex) => this.getGeometryLinePartSummary(part, partIndex)));
    }
    /**
     * @param {?} position
     * @return {?}
     */
    pathContains(position) {
        /** @type {?} */
        const found = this.parts.find((/**
         * @param {?} part
         * @return {?}
         */
        part => part.indexOf(position) > -1));
        return Boolean(found);
    }
    /**
     * @param {?} partIndex
     * @param {?} vertexIndex
     * @return {?}
     */
    getPositionByIndex(partIndex, vertexIndex) {
        return this.parts[partIndex][vertexIndex];
    }
    /**
     * @return {?}
     */
    dispose() {
        if (this.trackSubscription) {
            this.trackSubscription.unsubscribe();
        }
        this.parts.length = 0;
    }
    /**
     * @private
     * @param {?} linePart
     * @param {?} partIndex
     * @return {?}
     */
    getGeometryLinePartSummary(linePart, partIndex) {
        return linePart.map((/**
         * @param {?} vertex
         * @param {?} vertexIndex
         * @return {?}
         */
        (vertex, vertexIndex) => {
            /** @type {?} */
            const position = this.getPositionByIndex(partIndex, vertexIndex);
            /** @type {?} */
            const calibrationKey = this.getCalibrationMeasureLookupKey(partIndex, vertexIndex);
            /** @type {?} */
            const calibrationPointMeasureValue = this.calibratedMeasures.has(calibrationKey)
                ? this.calibratedMeasures.get(calibrationKey).measure
                : PATH_BUILDER_EMPTY_CALIBRATION_MEASURE_VALUE;
            return Object.assign({
                geometricMeasure: getMeasureFromPoint(vertex),
                partIndex,
                vertexIndex,
                calibrationPointMeasureValue
            }, position);
        }));
    }
    /**
     * @private
     * @param {?} partIndex
     * @param {?} vertexIndex
     * @return {?}
     */
    getCalibrationMeasureLookupKey(partIndex, vertexIndex) {
        return `${partIndex}_${vertexIndex}`;
    }
    /**
     * @private
     * @return {?}
     */
    toMultiPartArray() {
        /** @type {?} */
        const parts = [];
        this.parts.forEach((/**
         * @param {?} part
         * @return {?}
         */
        part => {
            /** @type {?} */
            const coordinates = part.map((/**
             * @param {?} position
             * @return {?}
             */
            position => this.options.returnZValues
                ? [position.longitude, position.latitude, position.altitude || 0]
                : [position.longitude, position.latitude]));
            parts.push(coordinates);
        }));
        return parts;
    }
    /**
     * @private
     * @param {?} polygonPoints
     * @return {?}
     */
    ensurePolygonIsClosed(polygonPoints) {
        if (polygonPoints.length > 1) {
            const [first] = polygonPoints;
            /** @type {?} */
            const last = getLastItem(polygonPoints);
            const [firstLng, firstLat, firstZ] = first;
            const [lastLng, lastLat] = last;
            /** @type {?} */
            const doesPolygonNotClose = !this.arePointsEquivalent(firstLng, firstLat, lastLng, lastLat);
            if (doesPolygonNotClose) {
                /** @type {?} */
                const closingPoint = [firstLng, firstLat, firstZ || 0];
                polygonPoints.push(closingPoint);
            }
        }
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    addPositionToPath(position) {
        this.currentPart.push(position);
        if (this.calibratedMeasures.has(UNPLACED_CALIBRATION_MEASURE_KEY)) {
            this.addPendingCalibrationPoint();
        }
    }
    /**
     * @private
     * @return {?}
     */
    addPendingCalibrationPoint() {
        /** @type {?} */
        const calibratonPosition = this.calibratedMeasures.get(UNPLACED_CALIBRATION_MEASURE_KEY);
        /** @type {?} */
        const calibrationTimestamp = calibratonPosition.timestamp;
        const [secondToLastPosition, lastPosition] = this.currentPart.slice(-2);
        /** @type {?} */
        const isTimestampBetweenVertices = calibrationTimestamp > secondToLastPosition.timestamp
            && calibrationTimestamp < lastPosition.timestamp;
        if (isTimestampBetweenVertices) {
            /** @type {?} */
            const totalTimeDelta = Math.abs(lastPosition.timestamp - secondToLastPosition.timestamp);
            /** @type {?} */
            const offsetTimeDelta = Math.abs(calibrationTimestamp - secondToLastPosition.timestamp);
            /** @type {?} */
            const percentOfDistance = offsetTimeDelta / totalTimeDelta;
            /** @type {?} */
            const distanceBetweenVerticesKilometers = getDistanceBetweenLatLng(secondToLastPosition.latitude, secondToLastPosition.longitude, lastPosition.latitude, lastPosition.longitude, LengthUnit.Mile);
            /** @type {?} */
            const distanceToPreviousVertexKilometers = percentOfDistance * distanceBetweenVerticesKilometers;
            /** @type {?} */
            const didSnapCalibrationMeasureToVertes = this.trySnapCalibrationMeasureToVertex(calibratonPosition.measure, distanceBetweenVerticesKilometers, distanceToPreviousVertexKilometers);
            if (didSnapCalibrationMeasureToVertes) {
                return;
            }
            /** @type {?} */
            const heading = bearing([secondToLastPosition.longitude, secondToLastPosition.latitude], [lastPosition.longitude, lastPosition.latitude]);
            /** @type {?} */
            const newPoint = destination([secondToLastPosition.longitude, secondToLastPosition.latitude], distanceToPreviousVertexKilometers, heading, { units: 'kilometers' });
            /** @type {?} */
            const spliceIndexForSecondToLastPosition = this.currentPart.length - 1;
            /** @type {?} */
            const newPosition = Object.assign({}, lastPosition, {
                longitude: newPoint.geometry.coordinates[0],
                latitude: newPoint.geometry.coordinates[1],
                deviceSource: PATH_BUILDER_CALCULATED_M_DEVICE_SOURCE
            });
            this.calibratedMeasures.delete(UNPLACED_CALIBRATION_MEASURE_KEY);
            this.addCalibrationMeasureAtIndex(calibratonPosition.measure, spliceIndexForSecondToLastPosition, this.currentPartIndex);
            this.currentPart.splice(spliceIndexForSecondToLastPosition, 0, newPosition);
        }
        else if (calibrationTimestamp >= lastPosition.timestamp) {
            this.addCalibrationMeasureToLastPosition(calibratonPosition.measure);
        }
        else {
            throw new Error(`Calibration measure timestamp '${calibratonPosition.timestamp}' can not be located between`
                + ` '${secondToLastPosition.timestamp}' and '${lastPosition.timestamp}'`);
        }
    }
    /**
     * @private
     * @param {?} calibrationMeasure
     * @param {?} totalVerticeDistanceKilometers
     * @param {?} distanceToPreviousVertexKilometers
     * @return {?}
     */
    trySnapCalibrationMeasureToVertex(calibrationMeasure, totalVerticeDistanceKilometers, distanceToPreviousVertexKilometers) {
        /** @type {?} */
        const distanceToNextVertexKilometers = totalVerticeDistanceKilometers - distanceToPreviousVertexKilometers;
        /** @type {?} */
        const distanceThresholdKilometers = convertLengthUnits(this.options.calibrationMeasureSnappingDistanceDelta, this.options.calibrationMeasureSnappingDistanceDeltaUnit, LengthUnit.Kilometer);
        /** @type {?} */
        const isPointCloseEnoughToPrevious = distanceToPreviousVertexKilometers < distanceThresholdKilometers;
        /** @type {?} */
        const isPointCloseEnoughToNext = distanceToNextVertexKilometers < distanceThresholdKilometers;
        if (isPointCloseEnoughToPrevious || isPointCloseEnoughToNext) {
            /** @type {?} */
            const previousVertexIndex = this.currentPart.length - 2;
            /** @type {?} */
            const nextVertexIndex = this.currentPart.length - 1;
            /** @type {?} */
            const vertexIndex = distanceToPreviousVertexKilometers < distanceToNextVertexKilometers
                ? previousVertexIndex
                : nextVertexIndex;
            this.addCalibrationMeasureAtIndex(calibrationMeasure, vertexIndex, this.currentPartIndex);
            this.calibratedMeasures.delete(UNPLACED_CALIBRATION_MEASURE_KEY);
            return true;
        }
        return false;
    }
    /**
     * @private
     * @param {?} position1
     * @param {?} position2
     * @return {?}
     */
    arePositionsEquivalent(position1, position2) {
        return this.arePointsEquivalent(position1.longitude, position1.latitude, position2.longitude, position2.latitude);
    }
    /**
     * @private
     * @param {?} longitude1
     * @param {?} latitude1
     * @param {?} longitude2
     * @param {?} latitude2
     * @return {?}
     */
    arePointsEquivalent(longitude1, latitude1, longitude2, latitude2) {
        return pointsAlmostEqual(longitude1, latitude1, longitude2, latitude2, this.options.pointEquivalencyPrecision);
    }
    /**
     * @private
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @return {THIS}
     */
    tryStoreUnfilteredPath(position) {
        if ((/** @type {?} */ (this)).options.storeUnfilteredPath) {
            (/** @type {?} */ (this)).unfilteredPath.push(position);
        }
        return (/** @type {?} */ (this));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} radians
 * @return {?}
 */
function radiansToDegrees(radians) {
    return radians * 180 / Math.PI;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing geometry-related settings.
 */
let GeometryConfig = /**
 * Configuration class for storing geometry-related settings.
 */
class GeometryConfig {
};
GeometryConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ GeometryConfig.ngInjectableDef = defineInjectable({ factory: function GeometryConfig_Factory() { return new GeometryConfig(); }, token: GeometryConfig, providedIn: "root" });
/**
 * Configuration class for storing geometry-related settings.
 */
GeometryConfig = __decorate([
    AutoConfig('GeometryConfig')
], GeometryConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @return {?}
 */
function extractMeasuresFromLine(line) {
    /** @type {?} */
    const measures = [];
    /** @type {?} */
    const paths = toMultiPartPaths(line);
    paths.forEach((/**
     * @param {?} coordinates
     * @return {?}
     */
    (coordinates) => {
        /** @type {?} */
        const pathMeasures = coordinates.map((/**
         * @param {?} coordinate
         * @return {?}
         */
        (coordinate) => getMeasureFromPoint(coordinate)));
        addRange(measures, pathMeasures);
    }));
    return measures;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} x
 * @return {?}
 */
function squareRoot(x) {
    return x * x;
}
/**
 * @param {?} v
 * @param {?} w
 * @return {?}
 */
function squareRootDistance(v, w) {
    return squareRoot(v.x - w.x) + squareRoot(v.y - w.y);
}
/**
 * @param {?} testPoint
 * @param {?} lineStartPoint
 * @param {?} lineEndPoint
 * @return {?}
 */
function distanceToSegmentSquared(testPoint, lineStartPoint, lineEndPoint) {
    /** @type {?} */
    const lengthSquared = squareRootDistance(lineStartPoint, lineEndPoint);
    if (lengthSquared === 0) {
        return squareRootDistance(testPoint, lineStartPoint);
    }
    /** @type {?} */
    const part1 = (testPoint.x - lineStartPoint.x) * (lineEndPoint.x - lineStartPoint.x);
    /** @type {?} */
    const part2 = (testPoint.y - lineStartPoint.y) * (lineEndPoint.y - lineStartPoint.y);
    /** @type {?} */
    const formulaPart1 = part1 + part2;
    /** @type {?} */
    const delta = formulaPart1 / lengthSquared;
    if (delta < 0) {
        return squareRootDistance(testPoint, lineStartPoint);
    }
    if (delta > 1) {
        return squareRootDistance(testPoint, lineEndPoint);
    }
    /** @type {?} */
    const xValue = lineStartPoint.x + delta * (lineEndPoint.x - lineStartPoint.x);
    /** @type {?} */
    const yValue = lineStartPoint.y + delta * (lineEndPoint.y - lineStartPoint.y);
    return squareRootDistance(testPoint, { x: xValue, y: yValue });
}
/**
 * @param {?} testPoint
 * @param {?} lineStartPoint
 * @param {?} lineEndPoint
 * @return {?}
 */
function distToSegment(testPoint, lineStartPoint, lineEndPoint) {
    return Math.sqrt(distanceToSegmentSquared(testPoint, lineStartPoint, lineEndPoint));
}
/**
 * @param {?} testPoint
 * @param {?} lineStartPoint
 * @param {?} lineEndPoint
 * @return {?}
 */
function getDistanceToLine(testPoint, lineStartPoint, lineEndPoint) {
    /** @type {?} */
    const testPointArray = toSinglePartPointArray(testPoint);
    /** @type {?} */
    const lineStartPointArray = toSinglePartPointArray(lineStartPoint);
    /** @type {?} */
    const lineEndPointArray = toSinglePartPointArray(lineEndPoint);
    const [testPointX, testPointY] = testPointArray;
    const [lineStartX, lineStartY] = lineStartPointArray;
    const [lineEndX, lineEndY] = lineEndPointArray;
    return distToSegment({ x: testPointX, y: testPointY }, { x: lineStartX, y: lineStartY }, { x: lineEndX, y: lineEndY });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @param {?} point
 * @param {?=} options
 * @return {?}
 */
function getMeasureFromFlatCoordinateSystem(line, point, options) {
    return getMeasure(line, point, Object.assign({ coordinateSystem: 'flat' }, options));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @param {?} lat
 * @param {?} lng
 * @param {?} options
 * @return {?}
 */
function getMeasureFromLatLng(line, lat, lng, options) {
    return this.getMeasure(line, [lng, lat], options);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @param {?} point
 * @param {?=} isPointDegrees
 * @return {?}
 */
function getVerticeeInfos(line, point, isPointDegrees = true) {
    /** @type {?} */
    const pointComparisonDetails = [];
    /** @type {?} */
    const paths = toMultiPartPaths(line);
    paths.forEach((/**
     * @param {?} coordinates
     * @return {?}
     */
    (coordinates) => {
        /** @type {?} */
        const details = comparePathWithPoint(coordinates, point, isPointDegrees);
        addRange(pointComparisonDetails, details);
    }));
    /** @type {?} */
    let nearestPoint;
    /** @type {?} */
    let furthestPoint;
    /** @type {?} */
    let minPoint;
    /** @type {?} */
    let maxPoint;
    pointComparisonDetails.forEach((/**
     * @param {?} pointCandidate
     * @return {?}
     */
    pointCandidate => {
        if (!nearestPoint || pointCandidate.distance < nearestPoint.distance) {
            nearestPoint = pointCandidate;
        }
        if (!furthestPoint || pointCandidate.distance > furthestPoint.distance) {
            furthestPoint = pointCandidate;
        }
        if (!minPoint || pointCandidate.pointMeasure < minPoint.pointMeasure) {
            minPoint = pointCandidate;
        }
        if (!maxPoint || pointCandidate.pointMeasure > maxPoint.pointMeasure) {
            maxPoint = pointCandidate;
        }
    }));
    // const nearestPoint = pointComparisionDetails
    //   .reduce((accumulator, value) => accumulator.distance > value.distance ? value : accumulator);
    /** @type {?} */
    const pointBefore = pointComparisonDetails[nearestPoint.index - 1];
    /** @type {?} */
    const pointAfter = pointComparisonDetails[nearestPoint.index + 1];
    /** @type {?} */
    let nextPoint = pointAfter;
    /** @type {?} */
    let previousPoint = pointBefore;
    // NOTE: this logic handles the rare case where the distance of the test point matches both the next
    // and previous verticee.
    // 0-----4--------------------------100
    //          5
    if (pointBefore && pointAfter) {
        /** @type {?} */
        const beforDistance = getDistanceToLine(point, nearestPoint.pointCoordinate, pointBefore.pointCoordinate);
        /** @type {?} */
        const afterDistance = getDistanceToLine(point, nearestPoint.pointCoordinate, pointAfter.pointCoordinate);
        if (beforDistance < afterDistance) {
            nextPoint = pointBefore;
            previousPoint = pointComparisonDetails[nextPoint.index - 2];
        }
    }
    return {
        nearestPoint,
        furthestPoint,
        nextPoint,
        previousPoint,
        minPoint,
        maxPoint
    };
}
/**
 * @param {?} line
 * @param {?} point
 * @param {?=} isPointDegrees
 * @return {?}
 */
function getClosestVerticees(line, point, isPointDegrees = true) {
    /** @type {?} */
    const info = getVerticeeInfos(line, point, isPointDegrees);
    return [
        info.nearestPoint ? info.nearestPoint.pointCoordinate : null,
        info.nextPoint ? info.nextPoint.pointCoordinate : null
    ];
}
/**
 * @param {?} line
 * @param {?} point
 * @param {?=} isPointDegrees
 * @return {?}
 */
function getClosestVerticee(line, point, isPointDegrees = true) {
    const [firstClosest] = getClosestVerticees(line, point, isPointDegrees);
    return firstClosest;
}
/**
 * @param {?} coordinates
 * @param {?} pointToCompare
 * @param {?} isPointDegrees
 * @return {?}
 */
function comparePathWithPoint(coordinates, pointToCompare, isPointDegrees) {
    /** @type {?} */
    const pointComparisionDetailsFromPath = coordinates
        .map((/**
     * @param {?} coordinate
     * @param {?} index
     * @return {?}
     */
    (coordinate, index) => compareCoordinateWithPoint(coordinate, pointToCompare, isPointDegrees, index)));
    return pointComparisionDetailsFromPath;
}
/**
 * @param {?} coordinate
 * @param {?} pointToCompare
 * @return {?}
 */
function getDegreeDistance(coordinate, pointToCompare) {
    /** @type {?} */
    const coordinate2 = toSinglePartPointArray(pointToCompare);
    return getMetersBetweenLatLng(coordinate[1], coordinate[0], coordinate2[1], coordinate2[0]);
}
/**
 * @param {?} coordinate
 * @param {?} pointToCompare
 * @param {?} isPointDegrees
 * @param {?} index
 * @return {?}
 */
function compareCoordinateWithPoint(coordinate, pointToCompare, isPointDegrees, index) {
    /** @type {?} */
    const distance$$1 = isPointDegrees
        ? getDegreeDistance(coordinate, pointToCompare)
        : getDistanceBetweenPoints(coordinate, pointToCompare);
    /** @type {?} */
    const pointDetails = {
        pointCoordinate: coordinate,
        distance: distance$$1,
        index
    };
    return pointDetails;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Determines if a point (value) is within a given bounds (line).
 * @param {?} boundStart The start of the restrcting bounds.
 * @param {?} boundEnd The end of the restricting bounds.
 * @param {?} testValue The value to check against the restricting bounds.
 * @return {?}
 */
function isPointWithinBounds(boundStart, boundEnd, testValue) {
    return testValue >= boundStart && testValue <= boundEnd;
}
/**
 * Determines if a point (value) is within a given bounds (line), but will not match the start and end values.
 * @param {?} boundStart The start of the restrcting bounds.
 * @param {?} boundEnd The end of the restricting bounds.
 * @param {?} testValue The value to check against the restricting bounds.
 * @return {?}
 */
function isPointWithinButNotIncludingBounds(boundStart, boundEnd, testValue) {
    return testValue > boundStart && testValue < boundEnd;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Determines if two points (a line) are within a given bounds (line).
 * @param {?} boundStart The start of the restrcting bounds.
 * @param {?} boundEnd The end of the restricting bounds.
 * @param {?} testStartValue The start value of the line to check against the restricting bounds.
 * @param {?} testEndValue The end value of the line to check against the restricting bounds.
 * @return {?}
 */
function isLineWithinBounds(boundStart, boundEnd, testStartValue, testEndValue) {
    /**
     * Runs through:
     * BOUNDS:   10---------15
     * TEST:   8---------------18
     *
     * Starts and runs through:
     * BOUNDS: 0---------15
     * TEST:   0---------------18
     *
     * Ends and runs through:
     * BOUNDS:       5---------18
     * TEST:   0---------------18
     * @type {?}
     */
    const runsThrough = testStartValue < boundStart && testEndValue > boundEnd;
    /** @type {?} */
    const isFullMatch = testStartValue === boundStart && testEndValue === boundEnd;
    /** @type {?} */
    const isStartInBounds = isPointWithinButNotIncludingBounds(boundStart, boundEnd, testStartValue);
    /** @type {?} */
    const isEndInBounds = isPointWithinButNotIncludingBounds(boundStart, boundEnd, testEndValue);
    /** @type {?} */
    const isStartMatch = boundStart === testStartValue;
    /** @type {?} */
    const isEndMatch = boundEnd === testEndValue;
    /** @type {?} */
    const startsAndRunsThrough = isStartMatch && boundStart <= testEndValue;
    /** @type {?} */
    const endsAndRunsThrough = isEndMatch && boundEnd >= testStartValue;
    return runsThrough
        || isFullMatch
        || isStartInBounds
        || isEndInBounds
        || startsAndRunsThrough
        || endsAndRunsThrough;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} line
 * @param {?} point
 * @return {?}
 */
function isPointOnLineString(line, point) {
    return isPointOnLine(line.coordinates[0], getLastItem(line.coordinates), point);
}
/**
 * @param {?} line
 * @param {?} lat
 * @param {?} lng
 * @return {?}
 */
function isLatLngOnLineString(line, lat, lng) {
    const [lineStartLng, lineStartLat] = line.coordinates[0];
    const [lineEndLng, lineEndLat] = getLastItem(line.coordinates);
    return isLatLngOnLine(lineStartLat, lineStartLng, lineEndLat, lineEndLng, lat, lng);
}
/**
 * @param {?} lineStartLat
 * @param {?} lineStartLng
 * @param {?} lineEndLat
 * @param {?} lineEndLng
 * @param {?} testPointLat
 * @param {?} testPointLng
 * @return {?}
 */
function isLatLngOnLine(lineStartLat, lineStartLng, lineEndLat, lineEndLng, testPointLat, testPointLng) {
    throw new Error('AHHH!');
}
/**
 * @param {?} lineStartPoint
 * @param {?} lineEndPoint
 * @param {?} testPoint
 * @param {?=} tolerance
 * @return {?}
 */
function isPointOnLine(lineStartPoint, lineEndPoint, testPoint, tolerance = 0) {
    /** @type {?} */
    const startPoint = toSinglePartPointArray(lineStartPoint);
    /** @type {?} */
    const endPoint = toSinglePartPointArray(lineEndPoint);
    /** @type {?} */
    const point = toSinglePartPointArray(testPoint);
    const [startPointX, startPointY] = startPoint;
    const [endPointX, endPointY] = endPoint;
    const [testPointX, testPointY] = point;
    /** @type {?} */
    const slope = (endPointY - startPointY) / (endPointX - startPointX);
    /** @type {?} */
    const y = slope * testPointX + startPointY;
    if ((y <= testPointY + tolerance && y >= testPointY - tolerance) && (testPointX >= startPointX && testPointX <= endPointX)) {
        return true;
    }
    return false;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} startPoint
 * @param {?} endPoint
 * @param {?} testPoint
 * @return {?}
 */
function calculateCrossProductByPoints(startPoint, endPoint, testPoint) {
    const [x1, y1] = toSinglePartPointArray(startPoint);
    const [x2, y2] = toSinglePartPointArray(endPoint);
    const [testX, testY] = toSinglePartPointArray(testPoint);
    return calculateCrossProduct(x1, y1, x2, y2, testX, testY);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing Gps Gate-related settings.
 */
let GpsGateConfig = /**
 * Configuration class for storing Gps Gate-related settings.
 */
class GpsGateConfig {
    constructor() {
        this.refreshInterval = 1000;
        this.urlTemplate = 'http://localhost:12175/gps/{endpoint}?noCache={cacheBuster}';
        this.getInfoEndpoint = 'getGpsInfo';
        this.getVersionEndpoint = 'getVersion';
        this.jsonpParameterName = 'jsonp';
        this.geolocatorName = 'GpsGate Client';
        this.geolocatorDescription = 'GpsGate client that can connect to a variety of GPS data sources.';
    }
};
GpsGateConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ GpsGateConfig.ngInjectableDef = defineInjectable({ factory: function GpsGateConfig_Factory() { return new GpsGateConfig(); }, token: GpsGateConfig, providedIn: "root" });
/**
 * Configuration class for storing Gps Gate-related settings.
 */
GpsGateConfig = __decorate([
    AutoConfig('GpsGateConfig')
], GpsGateConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
 * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
 */
let GpsGateGeolocator = /**
 * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
 * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
 */
class GpsGateGeolocator extends BaseGeolocator {
    /**
     * @param {?} log
     * @param {?} http
     * @param {?} config
     */
    constructor(log, http, config) {
        super(log);
        this.http = http;
        this.config = config;
        this.capabilities = [
            GeolocatorCapability.Altitude,
            GeolocatorCapability.AltitudeAccuracy,
            GeolocatorCapability.Heading,
            GeolocatorCapability.Speed,
            GeolocatorCapability.HDOP,
        ];
        this.accuracyUnit = GeolocatorAccuracyUnit.Hdop;
    }
    /**
     * @return {?}
     */
    get name() {
        return this.config.geolocatorName;
    }
    /**
     * @return {?}
     */
    get description() {
        return this.config.geolocatorDescription;
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    getCurrentPosition(options) {
        /** @type {?} */
        const url = format(this.config.urlTemplate, {
            endpoint: this.config.getInfoEndpoint,
            cacheBuster: new Date().getTime()
        });
        return this.http.jsonp(url, this.config.jsonpParameterName)
            .pipe(map((/**
         * @param {?} info
         * @return {?}
         */
        (info) => {
            /** @type {?} */
            const timestamp = new Date(info.trackPoint.utc).getTime();
            /** @type {?} */
            const position = Object.assign({
                timestamp,
                // NOTE: We are setting accuracy to HDOP because since this geolocator does not have
                // accuracy capabilities (see capabilities property), accuracy will not be shown within
                // the UI - rather fallback PDOP, HDOP, VDOP, etc will be used. However, we want to set
                // the accuracy because this value is what will be used to do collection
                // accuracy/precision acceptance (acceptable, warning, unaceptable, etc) - RG.
                accuracy: info.trackPoint.precision.hdop,
                altitudeAccuracy: null,
                speed: info.trackPoint.velocity.groundSpeed,
                heading: info.trackPoint.velocity.heading,
                hdop: info.trackPoint.precision.hdop
            }, info.trackPoint.position);
            this.log.trace(`Received current position for ${this.name}`);
            return position;
        })))
            .toPromise();
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    watchPosition(options) {
        /** @type {?} */
        let lastPosition;
        /** @type {?} */
        const subject = new Subject();
        /** @type {?} */
        const interval = setInterval((/**
         * @return {?}
         */
        () => {
            this.getCurrentPosition(options)
                .then((/**
             * @param {?} position
             * @return {?}
             */
            position => {
                if (notEqual(position, lastPosition)) {
                    subject.next(position);
                }
                this.log.trace(`Received watch position for ${this.name}`);
                lastPosition = position;
            }))
                .catch((/**
             * @param {?} error
             * @return {?}
             */
            error => subject.error(error)));
        }), this.config.refreshInterval);
        return subject.pipe(finalize((/**
         * @return {?}
         */
        () => clearInterval(interval))));
    }
    /**
     * @return {?}
     */
    isAvailable() {
        return this.getVersion()
            .pipe(map((/**
         * @param {?} result
         * @return {?}
         */
        result => Boolean(result))), catchError((/**
         * @return {?}
         */
        () => of(false))));
    }
    /**
     * @return {?}
     */
    getVersion() {
        /** @type {?} */
        const url = format(this.config.urlTemplate, {
            endpoint: this.config.getVersionEndpoint,
            cacheBuster: new Date().getTime()
        });
        return this.http.jsonp(url, this.config.jsonpParameterName);
    }
};
GpsGateGeolocator.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
GpsGateGeolocator.ctorParameters = () => [
    { type: Logger },
    { type: HttpClient },
    { type: GpsGateConfig }
];
/** @nocollapse */ GpsGateGeolocator.ngInjectableDef = defineInjectable({ factory: function GpsGateGeolocator_Factory() { return new GpsGateGeolocator(inject(Logger), inject(HttpClient), inject(GpsGateConfig)); }, token: GpsGateGeolocator, providedIn: "root" });
/**
 * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
 * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
 */
GpsGateGeolocator = __decorate([
    Geolocatable('gps-gate'),
    __metadata("design:paramtypes", [Logger, HttpClient, GpsGateConfig])
], GpsGateGeolocator);
/**
 * @param {?} position1
 * @param {?} position2
 * @return {?}
 */
function notEqual(position1, position2) {
    return !equal(position1, position2);
}
/**
 * @param {?} position1
 * @param {?} position2
 * @return {?}
 */
function equal(position1, position2) {
    return position1
        && position2
        && position1.timestamp === position2.timestamp
        && position1.latitude === position2.latitude
        && position1.longitude === position2.longitude
        && position1.accuracy === position2.accuracy
        && position1.speed === position2.speed
        && position1.heading === position2.heading
        && position1.altitude === position2.altitude
        && position1.altitudeAccuracy === position2.altitudeAccuracy
        && position1.pdop === position2.pdop
        && position1.hdop === position2.hdop
        && position1.vdop === position2.vdop
        && position1.tdop === position2.tdop;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssGpsGateModule {
}
TssGpsGateModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TssCoreModule,
                    TssGeolocationModule
                ],
                declarations: [],
                exports: [],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalibrationPointLayer extends FeatureClassLayer {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const CapturePosition = {
    Center: 'center',
    Left: 'left',
    Right: 'right',
    Sld: 'sld',
    Map: 'map',
    Lane: 'lane',
    Shoulder: 'shoulder',
    Curb: 'curb',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CenterlineLayer extends FeatureClassLayer {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LrsDataService {
    /**
     * @param {?} mapService
     * @param {?} dataSourceService
     * @param {?} dataSourceConfig
     */
    constructor(mapService, dataSourceService, dataSourceConfig) {
        this.mapService = mapService;
        this.dataSourceService = dataSourceService;
        this.dataSourceConfig = dataSourceConfig;
    }
    /**
     * @template T
     * @param {?} dataSource
     * @param {?} layer
     * @param {?} field
     * @param {?=} whereClause
     * @return {?}
     */
    getUniqueValues(dataSource, layer, field, whereClause) {
        /** @type {?} */
        const mapServiceParams = { gdbVersion: layer.versionName };
        /** @type {?} */
        let httpParams;
        if (whereClause) {
            mapServiceParams.where = whereClause;
            httpParams = new HttpParams().set('where', whereClause);
        }
        return dataSource.serviceUrl
            ? this.mapService.getUniqueValues(dataSource.serviceUrl, layer, field, mapServiceParams)
            : this.dataSourceService.getUniqueColumnValues(dataSource.id, layer.featureClassName, toFieldName(field), httpParams);
    }
    /**
     * @param {?} dataSource
     * @param {?} layer
     * @param {?} whereClause
     * @return {?}
     */
    getQueryCount(dataSource, layer, whereClause) {
        return dataSource.serviceUrl
            ? this.mapService.getQueryCount(dataSource.serviceUrl, layer, whereClause, { gdbVersion: layer.versionName })
            : this.dataSourceService.getRecordCount(dataSource.id, layer.featureClassName, whereClause, layer.versionName);
    }
    /**
     * @param {?} dataSource
     * @param {?} layer
     * @param {?} routeIds
     * @return {?}
     */
    queryRoutesByIds(dataSource, layer, routeIds) {
        if (!routeIds || !routeIds.length) {
            throw new Error('Failed to query routes. No route IDs supplied.');
        }
        if (!layer.compositeRouteIdFieldName) {
            throw new Error(`Failed to query routes. No 'compositeRouteIdFieldName' property found for layer.`);
        }
        /** @type {?} */
        const whereClause = `${layer.compositeRouteIdFieldName} IN ('${routeIds.join(`','`)}')`;
        return this.queryRoutes(dataSource, layer, whereClause);
    }
    /**
     * @param {?} dataSource
     * @param {?} layer
     * @param {?=} whereClause
     * @return {?}
     */
    queryRoutes(dataSource, layer, whereClause) {
        /** @type {?} */
        const shapeFieldName = getGeometryFieldName(layer.fields);
        return dataSource.serviceUrl
            ? this.mapService.queryRoutes(dataSource.serviceUrl, layer, whereClause, { gdbVersion: layer.versionName })
            : this.dataSourceService.querySpatialData(dataSource.id, layer.featureClassName, whereClause, layer.versionName, null, null, true, shapeFieldName);
    }
    /**
     * @param {?} dataSource
     * @param {?} layer
     * @param {?} searchText
     * @return {?}
     */
    searchRoutesByText(dataSource, layer, searchText) {
        /** @type {?} */
        const useMapService = Boolean(dataSource.serviceUrl);
        /** @type {?} */
        const shapeFieldName = getGeometryFieldName(layer.fields);
        /** @type {?} */
        let whereClause;
        if (!useMapService) {
            whereClause = new WhereClauseBuilder({
                quoteFields: !this.dataSourceConfig.skipColumnQuotes
            })
                .whereLike(layer.displayField, searchText)
                .toWhereClause();
        }
        return useMapService
            ? this.mapService.searchRoutesByText(dataSource.serviceUrl, layer, searchText, { gdbVersion: layer.versionName })
            : this.dataSourceService.querySpatialData(dataSource.id, layer.featureClassName, whereClause, layer.versionName, null, null, true, shapeFieldName);
    }
}
LrsDataService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
LrsDataService.ctorParameters = () => [
    { type: EsriMapServerService },
    { type: DataSourceService },
    { type: DataSourceConfig }
];
/** @nocollapse */ LrsDataService.ngInjectableDef = defineInjectable({ factory: function LrsDataService_Factory() { return new LrsDataService(inject(EsriMapServerService), inject(DataSourceService), inject(DataSourceConfig)); }, token: LrsDataService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing global ESRI-related settings.
 */
let LrsConfig = /**
 * Configuration class for storing global ESRI-related settings.
 */
class LrsConfig extends ResourceConfig {
    constructor() {
        super(...arguments);
        this.dataSourceLrsMetadataEndpoint = 'api/spatial/data/sources/{dataSourceId}/lrs/meta';
        this.cacheInSessionLrsMetadata = true;
    }
};
LrsConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ LrsConfig.ngInjectableDef = defineInjectable({ factory: function LrsConfig_Factory() { return new LrsConfig(); }, token: LrsConfig, providedIn: "root" });
/**
 * Configuration class for storing global ESRI-related settings.
 */
LrsConfig = __decorate([
    AutoConfig('LrsConfig')
], LrsConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataSourceLrsMetadataService extends BaseResourceService {
    /**
     * @param {?} http
     * @param {?} config
     */
    constructor(http, config) {
        super(http, {
            url: join(config.serviceUrl, config.dataSourceLrsMetadataEndpoint),
            idFieldName: 'dataSourceId'
        });
        this.http = http;
    }
    /**
     * @param {?} entity
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    create(entity, routeTokens, params) {
        routeTokens = routeTokens || {};
        routeTokens.id = entity.dataSourceId;
        return super.create(entity, routeTokens, params);
    }
}
DataSourceLrsMetadataService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DataSourceLrsMetadataService.ctorParameters = () => [
    { type: HttpClient },
    { type: LrsConfig }
];
/** @nocollapse */ DataSourceLrsMetadataService.ngInjectableDef = defineInjectable({ factory: function DataSourceLrsMetadataService_Factory() { return new DataSourceLrsMetadataService(inject(HttpClient), inject(LrsConfig)); }, token: DataSourceLrsMetadataService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} layer
 * @param {?=} stripLayerTableName
 * @return {?}
 */
function getLayerTableName(layer, stripLayerTableName = false) {
    /** @type {?} */
    let tableName = layer
        ? layer.featureClassName || layer.datasetName
        : null;
    if (stripLayerTableName) {
        tableName = stripTableName(tableName);
    }
    return tableName;
}
class LrsLayer extends FeatureClassLayer {
    /**
     * @param {...?} sources
     */
    constructor(...sources) {
        super(...sources);
        this.capturePositions = this.capturePositions ? this.capturePositions : [];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getPositionByValue(value) {
        return this.capturePositions.find((/**
         * @param {?} positionDef
         * @return {?}
         */
        positionDef => positionDef.value === value));
    }
    /**
     * @param {?} position
     * @return {?}
     */
    getPositions(position) {
        return this.capturePositions.filter((/**
         * @param {?} positionDef
         * @return {?}
         */
        positionDef => positionDef.position === position));
    }
    /**
     * @param {?} position
     * @return {?}
     */
    hasPosition(position) {
        /** @type {?} */
        const positions = this.getPositions(position);
        return positions.length > 0;
    }
    /**
     * @return {?}
     */
    get hasAnyPositions() {
        return this.capturePositions.length > 0;
    }
    /**
     * @return {?}
     */
    get hasLanePosition() {
        /** @type {?} */
        const positions = this.getPositions(CapturePosition.Lane);
        return positions.length > 0;
    }
    /**
     * @return {?}
     */
    get hasLeftPosition() {
        /** @type {?} */
        const positions = this.getPositions(CapturePosition.Left);
        return positions.length > 0;
    }
    /**
     * @return {?}
     */
    get hasRightPosition() {
        /** @type {?} */
        const positions = this.getPositions(CapturePosition.Right);
        return positions.length > 0;
    }
    /**
     * @return {?}
     */
    get hasCenterPosition() {
        /** @type {?} */
        const positions = this.getPositions(CapturePosition.Center);
        return positions.length > 0;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EventLayer extends LrsLayer {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} layer
 * @return {?}
 */
function generateHierarchyFilters(layer) {
    return layer.routeIdFields.map((/**
     * @param {?} fieldName
     * @param {?} index
     * @return {?}
     */
    (fieldName, index) => {
        /** @type {?} */
        const isFirst = index === 0;
        /** @type {?} */
        const field = layer.fields.find((/**
         * @param {?} f
         * @return {?}
         */
        f => f.name === fieldName));
        if (!field) {
            throw new Error(`Invalid network layer 'routeIdFields' configuration. Field '${fieldName}' not found on layer.`);
        }
        return {
            isRoot: isFirst,
            label: field.alias,
            networkLayerIdFieldName: field.name
        };
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntersectionLayer extends FeatureClassLayer {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} layerId
 * @param {...?} layerList
 * @return {?}
 */
function findLayer(layerId, ...layerList) {
    /** @type {?} */
    let layer;
    layerList.forEach((/**
     * @param {?} layers
     * @return {?}
     */
    layers => {
        layer = layer || (layers || []).find((/**
         * @param {?} l
         * @return {?}
         */
        l => l && l.id === layerId));
    }));
    return layer;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NetworkLayer extends LrsLayer {
    /**
     * @param {...?} sources
     */
    constructor(...sources) {
        super(...sources);
        this.routeIdFields = this.routeIdFields || [];
        this.eventLayers = this.eventLayers || [];
        this.intersectionLayers = this.intersectionLayers || [];
        this.hierarchyFilter = this.hierarchyFilter && this.hierarchyFilter.length
            ? this.hierarchyFilter
            : generateHierarchyFilters(this);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RedlineLayer extends LrsLayer {
    /**
     * @return {?}
     */
    get effectiveDateFieldName() {
        return this.fromDateFieldName;
    }
    /**
     * @param {?} effectiveDateFieldName
     * @return {?}
     */
    set effectiveDateFieldName(effectiveDateFieldName) {
        this.fromDateFieldName = effectiveDateFieldName;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MapServerMetadata {
    /**
     * @param {?} source
     * @return {?}
     */
    assign(source) {
        Object.assign(this, source);
        return this;
    }
    /**
     * @return {?}
     */
    clone() {
        /** @type {?} */
        const copy = clone(this);
        return new MapServerMetadata()
            .assign(copy);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LRS_LAYER_VALIDATIONS = new ValidationCheck(`Layer '{name}'`)
    .add(new ValidationCheck('should have list of fields')
    .pass((/**
 * @param {?} l
 * @return {?}
 */
l => Boolean(l.fields && l.fields.length))), new ValidationCheck('should have an ID field in list of fields')
    .pass((/**
 * @param {?} l
 * @return {?}
 */
l => Boolean(getIdField(l.fields)))));
/** @type {?} */
const LRS_NETWORK_LAYER_VALIDATIONS = new ValidationCheck(`Network layer '{name}' (ID: {id})`)
    .add(new ValidationCheck(`should have a 'Composite Route ID Field Name' value specified`)
    .pass((/**
 * @param {?} l
 * @return {?}
 */
l => Boolean(l.compositeRouteIdFieldName))));
/** @type {?} */
const LRS_EVENT_LAYER_VALIDATIONS = new ValidationCheck(`Event layer '{name}' (ID: {id})`)
    .add(new ValidationCheck(`should have a 'From Measure Field Name' value specified`)
    .pass((/**
 * @param {?} l
 * @return {?}
 */
l => Boolean(l.compositeRouteIdFieldName))));
/** @type {?} */
const LRS_METADATA_VALIDATIONS = new ValidationCheck('LRS Metadata')
    .add(new ValidationCheck('should have network layers')
    .pass((/**
 * @param {?} x
 * @return {?}
 */
x => Boolean(x.networkLayers && x.networkLayers.length))), new ValidationCheck('should have event layers')
    .pass((/**
 * @param {?} x
 * @return {?}
 */
x => Boolean(x.eventLayers && x.eventLayers.length))));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NonLrsLayer extends FeatureClassLayer {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} layerId
 * @param {...?} layerList
 * @return {?}
 */
function find(layerId, ...layerList) {
    return findLayer(layerId, ...layerList);
}
class LrsMetadata extends MapServerMetadata {
    /**
     * @param {?=} dataSource
     */
    constructor(dataSource) {
        super();
        this.networkLayers = [];
        this.eventLayers = [];
        this.redlineLayers = [];
        this.centerlineLayers = [];
        this.calibrationPointLayers = [];
        this.intersectionLayers = [];
        this.nonLRSLayers = [];
        this.lrs = [];
        this.domains = [];
        if (dataSource) {
            this.dataSource = dataSource;
            this.dataSourceId = dataSource.id;
        }
    }
    /**
     * Gets a layer by ID - searching across all types (event layers, network layers, etc).
     * @param {?} layerId
     * @return {?}
     */
    getLayer(layerId) {
        return find(layerId, this.getAllLayers());
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    getLrsLayer(layerId) {
        return (/** @type {?} */ ((find(layerId, this.networkLayers, this.eventLayers, this.redlineLayers))));
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    getLayerDetail(layerId) {
        // TODO: Come up with a better way to check these layer types.
        // NOTE: We are doing all of these boolean checks instead of just simply calling
        // isEventLayer = this.isEventLayer(layerId) because of performance reasons.
        /** @type {?} */
        const isLrsLayer = this.isLrsLayer(layerId);
        /** @type {?} */
        const isEventLayer = this.isEventLayer(layerId);
        /** @type {?} */
        const isNetworkLayer = !isEventLayer && this.isNetworkLayer(layerId);
        /** @type {?} */
        const isCalibrationPointLayer = !isEventLayer && !isNetworkLayer && this.isCalibrationPointLayer(layerId);
        /** @type {?} */
        const isCenterlineLayer = !isEventLayer && !isNetworkLayer && !isCalibrationPointLayer && this.isCenterlineLayer(layerId);
        /** @type {?} */
        const isIntersectionLayer = !isEventLayer && !isNetworkLayer && !isCalibrationPointLayer && !isCenterlineLayer
            && this.isIntersectionLayer(layerId);
        /** @type {?} */
        const isRedlineLayer = !isEventLayer && !isNetworkLayer && !isCalibrationPointLayer && !isCenterlineLayer && !isIntersectionLayer
            && this.isRedlineLayer(layerId);
        /** @type {?} */
        const isTable = !isEventLayer && !isNetworkLayer && !isCalibrationPointLayer && !isCenterlineLayer && !isIntersectionLayer
            && !isRedlineLayer && this.isTable(layerId);
        /** @type {?} */
        const isNonLRSLayer = !isEventLayer && !isNetworkLayer && !isCalibrationPointLayer && !isCenterlineLayer && !isIntersectionLayer
            && !isRedlineLayer && !isTable && this.isNonLRSLayer(layerId);
        /** @type {?} */
        const layer = this.getLayer(layerId);
        /** @type {?} */
        const shapeField = layer ? getGeometryField(layer.fields) : null;
        /** @type {?} */
        const idField = layer ? getIdField(layer.fields) : null;
        return {
            layer,
            layerId,
            isEventLayer,
            isNetworkLayer,
            isCalibrationPointLayer,
            isCenterlineLayer,
            isIntersectionLayer,
            isRedlineLayer,
            isTable,
            isNonLRSLayer,
            isLrsLayer,
            shapeField,
            idField,
        };
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    isLrsLayer(layerId) {
        return Boolean(this.getLrsLayer(layerId));
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    isNetworkLayer(layerId) {
        return Boolean(find(layerId, this.networkLayers));
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    isEventLayer(layerId) {
        return Boolean(find(layerId, this.eventLayers));
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    isIntersectionLayer(layerId) {
        return Boolean(find(layerId, this.intersectionLayers));
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    isRedlineLayer(layerId) {
        return Boolean(find(layerId, this.redlineLayers));
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    isCenterlineLayer(layerId) {
        return Boolean(find(layerId, this.centerlineLayers));
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    isCalibrationPointLayer(layerId) {
        return Boolean(find(layerId, this.calibrationPointLayers));
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    isNonLRSLayer(layerId) {
        return Boolean(find(layerId, this.nonLRSLayers));
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    isTable(layerId) {
        return Boolean(find(layerId, this.tables));
    }
    /**
     * Merges map server general information into this LRS metadata instance.
     * @param {?} mapMetadata
     * @return {?}
     */
    mergeMapMetadata(mapMetadata) {
        mergeMapMetadata(this, mapMetadata);
        return this;
    }
    /**
     * @param {?} mapMetadata
     * @return {?}
     */
    deepMergeMapMetadata(mapMetadata) {
        deepMergeMapMetadata(this, mapMetadata);
        return this;
    }
    /**
     * Merges other LRS metadata into this LRS metdata instance.
     * @param {?} lrsMetadata
     * @return {?}
     */
    mergeLrsMetadata(lrsMetadata) {
        mergeLrsMetadata(this, lrsMetadata);
        return this;
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    getNetworkLayer(layerId) {
        return (/** @type {?} */ (find(layerId, this.networkLayers)));
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    getEventLayer(layerId) {
        return (/** @type {?} */ (find(layerId, this.eventLayers)));
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    getIntersectionLayer(layerId) {
        return (/** @type {?} */ (find(layerId, this.intersectionLayers)));
    }
    /**
     * @return {?}
     */
    getLrsLayers() {
        return ((/** @type {?} */ (this.eventLayers)))
            .concat(this.networkLayers)
            .concat(this.redlineLayers);
    }
    /**
     * @return {?}
     */
    getFeatureClassLayers() {
        return ((/** @type {?} */ (this.eventLayers)))
            .concat(this.networkLayers)
            .concat(this.redlineLayers)
            .concat(this.calibrationPointLayers)
            .concat(this.centerlineLayers)
            .concat(this.nonLRSLayers);
    }
    /**
     * @return {?}
     */
    getAllLayers() {
        return ((/** @type {?} */ (this.getFeatureClassLayers())))
            .concat(this.tables)
            .concat(this.layers);
    }
    /**
     * @param {?} layer
     * @return {?}
     */
    getNetworkIdForLayer(layer) {
        /** @type {?} */
        let networkId = null;
        if (this.isEventLayer(layer.id)) {
            /** @type {?} */
            const eventLayer = (/** @type {?} */ (layer));
            networkId = eventLayer.parentNetwork ? eventLayer.parentNetwork.id : null;
        }
        if (isNotValue(networkId)) {
            this.networkLayers.forEach((/**
             * @param {?} network
             * @return {?}
             */
            network => {
                if (network.eventLayers.find((/**
                 * @param {?} l
                 * @return {?}
                 */
                l => l.id === layer.id))) {
                    networkId = network.id;
                }
            }));
        }
        return networkId;
    }
    /**
     * @param {?} networkLayerId
     * @return {?}
     */
    getEventLayersByNetwork(networkLayerId) {
        /** @type {?} */
        const networkLayer = this.getNetworkLayer(networkLayerId);
        return this.eventLayers.filter((/**
         * @param {?} layer
         * @return {?}
         */
        layer => layer.parentNetwork
            && layer.parentNetwork.id === networkLayerId
            || networkLayer.eventLayers
                && networkLayer.eventLayers.find((/**
                 * @param {?} l
                 * @return {?}
                 */
                l => l.id === layer.id))));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    rebuildLayers() {
        (/** @type {?} */ (this)).eventLayers = (/** @type {?} */ (this)).eventLayers.map((/**
         * @param {?} eventLayer
         * @return {?}
         */
        eventLayer => new EventLayer(find(eventLayer.id, (/** @type {?} */ (this)).layers), eventLayer)));
        (/** @type {?} */ (this)).networkLayers = (/** @type {?} */ (this)).networkLayers.map((/**
         * @param {?} networkLayer
         * @return {?}
         */
        networkLayer => new NetworkLayer(find(networkLayer.id, (/** @type {?} */ (this)).layers), networkLayer)));
        (/** @type {?} */ (this)).redlineLayers = (/** @type {?} */ (this)).redlineLayers.map((/**
         * @param {?} redlineLayer
         * @return {?}
         */
        redlineLayer => new RedlineLayer(find(redlineLayer.id, (/** @type {?} */ (this)).layers), redlineLayer)));
        (/** @type {?} */ (this)).centerlineLayers = (/** @type {?} */ (this)).centerlineLayers.map((/**
         * @param {?} centerlineLayer
         * @return {?}
         */
        centerlineLayer => new CenterlineLayer(centerlineLayer)));
        (/** @type {?} */ (this)).calibrationPointLayers = (/** @type {?} */ (this)).calibrationPointLayers.map((/**
         * @param {?} calibrationPointLayer
         * @return {?}
         */
        calibrationPointLayer => new CalibrationPointLayer(calibrationPointLayer)));
        (/** @type {?} */ (this)).intersectionLayers = (/** @type {?} */ (this)).intersectionLayers.map((/**
         * @param {?} intersectionLayer
         * @return {?}
         */
        intersectionLayer => new IntersectionLayer(intersectionLayer)));
        (/** @type {?} */ (this)).nonLRSLayers = (/** @type {?} */ (this)).nonLRSLayers.map((/**
         * @param {?} nonLrsLayer
         * @return {?}
         */
        nonLrsLayer => new NonLrsLayer(find(nonLrsLayer.id, (/** @type {?} */ (this)).layers), nonLrsLayer)));
        return (/** @type {?} */ (this)).assignCodedValueDomainsToFields();
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    assignCodedValueDomainsToFields() {
        if ((/** @type {?} */ (this)).domains.length) {
            (/** @type {?} */ (this)).getFeatureClassLayers()
                .forEach((/**
             * @param {?} layer
             * @return {?}
             */
            layer => layer.applyFieldDomains((/** @type {?} */ (this)).domains)));
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} source
     * @return {THIS}
     */
    assign(source) {
        Object.assign((/** @type {?} */ (this)), source);
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    clone() {
        /** @type {?} */
        const copy = clone(this);
        return new LrsMetadata()
            .assign(copy)
            .rebuildLayers();
    }
    /**
     * @return {?}
     */
    validate() {
        return LRS_METADATA_VALIDATIONS
            .check(this);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} layerId
 * @param {...?} layerList
 * @return {?}
 */
function find$1(layerId, ...layerList) {
    return findLayer(layerId, ...layerList);
}
/**
 * @param {?} layer
 * @return {?}
 */
function setLayerDefaults(layer) {
    layer.fields = layer.fields || [];
}
/**
 * @param {?} layer
 * @return {?}
 */
function setNetworkLayerDefaults(layer) {
    if (layer) {
        layer.hierarchyFilter = layer.hierarchyFilter || [];
    }
}
/**
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
function mergeFieldDomains(target, source) {
    mergeDeep(target, source, { ignoreArrays: true });
    if (target && target.codedValues && source && source.codedValues) {
        mergeDeepArray(target.codedValues, source.codedValues, { identifier: 'code' });
    }
}
/**
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
function mergeFields(target, source) {
    target = target || [];
    source = source || [];
    mergeDeepArray(target, source, {
        identifier: 'name',
        beforeMerge: (/**
         * @param {?} targetField
         * @param {?} sourceField
         * @return {?}
         */
        (targetField, sourceField) => {
            if (targetField.domain && sourceField.domain && sourceField.domain.codedValues) {
                /** @type {?} */
                const doValuesNeedMerged = sourceField.domain.codedValues.filter((/**
                 * @param {?} c
                 * @return {?}
                 */
                c => isNumber$1(c.order)));
                if (doValuesNeedMerged && doValuesNeedMerged.length) {
                    mergeFieldDomains(targetField.domain, sourceField.domain);
                    return false;
                }
            }
        })
    });
}
/**
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
function mergeLayer(target, source) {
    if (!target || !source) {
        return;
    }
    /** @type {?} */
    const lrsTarget = (/** @type {?} */ (target));
    /** @type {?} */
    const lrsSource = (/** @type {?} */ (source));
    /** @type {?} */
    const targetCapturePositions = lrsTarget.capturePositions || [];
    /** @type {?} */
    const sourceCapturePositions = lrsSource.capturePositions || [];
    /** @type {?} */
    const targetDrawingInfo = (/** @type {?} */ (lrsTarget.drawingInfo));
    /** @type {?} */
    const sourceDrawingInfo = (/** @type {?} */ (lrsSource.drawingInfo));
    /** @type {?} */
    const hasDrawingInfo = Boolean(targetDrawingInfo || sourceDrawingInfo);
    /** @type {?} */
    const drawingInfo = new LayerDrawingInfo((/** @type {?} */ (lrsTarget.drawingInfo)), (/** @type {?} */ (lrsSource.drawingInfo)));
    mergeDeep(target, source, { ignoreArrays: true });
    mergeFields(target.fields, source.fields);
    if (hasDrawingInfo) {
        ((/** @type {?} */ (target))).drawingInfo = drawingInfo;
    }
    if (!targetCapturePositions.length && sourceCapturePositions.length) {
        lrsTarget.capturePositions = sourceCapturePositions;
    }
}
/**
 * @param {?} target
 * @param {?} source
 * @param {?=} sourceMetadata
 * @param {?=} sort
 * @param {?=} onMergeComplete
 * @return {?}
 */
function mergeLayers(target, source, sourceMetadata, sort = true, onMergeComplete = null) {
    target = target || [];
    source = source || [];
    target.forEach((/**
     * @param {?} targetLayer
     * @return {?}
     */
    (targetLayer) => {
        setLayerDefaults(targetLayer);
        mergeLayer(targetLayer, source.find((/**
         * @param {?} sourceLayer
         * @return {?}
         */
        sourceLayer => sourceLayer.id === targetLayer.id)));
    }));
    // There will be occurences where the source has layers that the target doesn't, which
    // means that the merge will not happen above, because the target is the one being looped.
    source
        .filter((/**
     * @param {?} src
     * @return {?}
     */
    src => !target.find((/**
     * @param {?} x
     * @return {?}
     */
    x => src.id === x.id))))
        .forEach((/**
     * @param {?} missing
     * @return {?}
     */
    missing => {
        /** @type {?} */
        let newLayer = missing;
        if (sourceMetadata) {
            /** @type {?} */
            const merger = find$1(missing.id, sourceMetadata.tables, sourceMetadata.layers, sourceMetadata.nonLRSLayers);
            // We want to preseve the original table or layer, so we don't overwrite it here.
            newLayer = Object.assign({}, merger);
            mergeLayer(newLayer, missing);
        }
        setLayerDefaults(newLayer);
        target.push(newLayer);
    }));
    if (sort) {
        target.sort((/**
         * @param {?} layer1
         * @param {?} layer2
         * @return {?}
         */
        (layer1, layer2) => layer1.order - layer2.order));
    }
    if (onMergeComplete) {
        target.forEach((/**
         * @param {?} targetLayer
         * @return {?}
         */
        (targetLayer) => {
            onMergeComplete(targetLayer, source.find((/**
             * @param {?} sourceLayer
             * @return {?}
             */
            sourceLayer => sourceLayer.id === targetLayer.id)));
        }));
    }
}
/**
 * @param {?} target
 * @param {?} source
 * @param {?=} sourceMetadata
 * @return {?}
 */
function mergeNetworkLayers(target, source, sourceMetadata) {
    /** @type {?} */
    const isSorted = true;
    mergeLayers(target, source, sourceMetadata, isSorted, onMergeNetworkLayerComplete);
}
/**
 * @param {?} targetLayer
 * @param {?} sourceLayer
 * @return {?}
 */
function onMergeNetworkLayerComplete(targetLayer, sourceLayer) {
    setNetworkLayerDefaults(targetLayer);
    setNetworkLayerDefaults(sourceLayer);
    if (targetLayer && sourceLayer) {
        mergeDeepArray(targetLayer.hierarchyFilter, sourceLayer.hierarchyFilter, { identifier: 'name' });
    }
}
/**
 * @param {?} target
 * @param {...?} source
 * @return {?}
 */
function mergeLrsMetadata(target, ...source) {
    source.forEach((/**
     * @param {?} srcMeta
     * @return {?}
     */
    srcMeta => {
        /** @type {?} */
        const dataSource = srcMeta.dataSource || target.dataSource;
        mergeDeep(target, srcMeta, { ignoreArrays: true });
        if (dataSource) {
            target.dataSource = dataSource;
        }
        mergeNetworkLayers(target.networkLayers, srcMeta.networkLayers, target);
        mergeLayers(target.eventLayers, srcMeta.eventLayers, target);
        mergeLayers(target.calibrationPointLayers, srcMeta.calibrationPointLayers, target);
        mergeLayers(target.intersectionLayers, srcMeta.intersectionLayers, target);
        mergeLayers(target.centerlineLayers, srcMeta.centerlineLayers, target);
        mergeLayers(target.redlineLayers, srcMeta.redlineLayers, target);
        mergeLayers(target.nonLRSLayers, srcMeta.nonLRSLayers, target);
        mergeLayers(target.layers, srcMeta.layers);
        mergeLayers(target.tables, srcMeta.tables);
    }));
}
/**
 * @param {?} target
 * @param {...?} source
 * @return {?}
 */
function mergeMapMetadata(target, ...source) {
    source.forEach((/**
     * @param {?} meta
     * @return {?}
     */
    meta => {
        Object.assign(target, meta);
    }));
}
/**
 * @param {?} target
 * @param {...?} source
 * @return {?}
 */
function deepMergeMapMetadata(target, ...source) {
    source.forEach((/**
     * @param {?} meta
     * @return {?}
     */
    meta => {
        meta.layers.forEach((/**
         * @param {?} nonLrsLayerInfo
         * @return {?}
         */
        nonLrsLayerInfo => {
            /** @type {?} */
            const targetLayer = target.getLrsLayer(nonLrsLayerInfo.id);
            if (targetLayer) {
                /** @type {?} */
                const baseFields = [...nonLrsLayerInfo.fields];
                mergeFields(baseFields, targetLayer.fields);
                targetLayer.fields = baseFields;
                if (nonLrsLayerInfo.geometryType) {
                    targetLayer.geometryType = nonLrsLayerInfo.geometryType;
                }
                targetLayer.drawingInfo = new LayerDrawingInfo(nonLrsLayerInfo.drawingInfo, targetLayer.drawingInfo);
            }
        }));
    }));
}
/**
 * @param {?} dataSource
 * @param {?} dataSourceLrsMetadata
 * @param {?} mapServerLrsMetadata
 * @param {?} mapServerMetadata
 * @return {?}
 */
function mergeLrsMetadataSources(dataSource, dataSourceLrsMetadata, mapServerLrsMetadata, mapServerMetadata) {
    /** @type {?} */
    const hasMapServerLrsMetadata = Boolean(mapServerLrsMetadata);
    /** @type {?} */
    const fullLrsMeta = mapServerLrsMetadata
        || dataSourceLrsMetadata
        || new LrsMetadata(dataSource);
    fullLrsMeta.mergeMapMetadata(mapServerMetadata);
    fullLrsMeta.dataSource = fullLrsMeta.dataSource || dataSource;
    fullLrsMeta.dataSourceId = fullLrsMeta.dataSourceId || dataSource.id;
    if (hasMapServerLrsMetadata) {
        // If the map service has LRS metadata then we need to merge the
        // data source LRS metadata into the map service lrs metadata
        // because we want the data source metadata to be priority.
        fullLrsMeta.mergeLrsMetadata(dataSourceLrsMetadata);
    }
    else {
        // We only need to do a dep merge when there is no LRS metadata available in the map service because
        // the map service LRS metadata provides all of the same information as the map server metadata (like fields).
        fullLrsMeta.deepMergeMapMetadata(mapServerMetadata);
    }
    fullLrsMeta.rebuildLayers();
    return fullLrsMeta;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LrsMetadataRetriever {
    /**
     * @param {?} http
     * @param {?} mapServer
     * @param {?} dataSourceService
     * @param {?} dataSourceLrsMetadataService
     * @param {?} notify
     * @param {?} log
     */
    constructor(http, mapServer, dataSourceService, dataSourceLrsMetadataService, notify, log) {
        this.http = http;
        this.mapServer = mapServer;
        this.dataSourceService = dataSourceService;
        this.dataSourceLrsMetadataService = dataSourceLrsMetadataService;
        this.notify = notify;
        this.log = log;
    }
    /**
     * @param {?} dataSource
     * @return {?}
     */
    withDataSource(dataSource) {
        if (isString(dataSource)) {
            this.dataSourceId = (/** @type {?} */ (dataSource));
        }
        else {
            this.dataSource = (/** @type {?} */ (dataSource));
            this.dataSourceId = this.dataSource.id;
        }
        return this;
    }
    /**
     * @param {?} lrsMeta
     * @return {?}
     */
    withLrsMetadata(lrsMeta) {
        this.dataSourceLrsMetadata = lrsMeta;
        return this;
    }
    /**
     * @return {?}
     */
    retrieve() {
        if (!this.dataSourceId) {
            throw new Error('A data source ID must be supplied');
        }
        return of(null)
            .pipe(mergeMap(this.getDataSource.bind(this)), mergeMap(this.getDataSourceLrsMetadata.bind(this)), mergeMap(this.getMapServiceLayers.bind(this)), mergeMap(this.getMapServiceLrsMetadata.bind(this)), mergeMap(this.mergeAll.bind(this)));
    }
    /**
     * @private
     * @return {?}
     */
    getDataSource() {
        /** @type {?} */
        const observable = this.dataSource
            ? of(this.dataSource)
            : this.dataSourceService
                .get(this.dataSourceId)
                .pipe(tap((/**
             * @param {?} dataSource
             * @return {?}
             */
            (dataSource) => this.dataSource = dataSource)));
        return this.notify
            .with(observable)
            .error(`Failed to retrieve data source by ID: ${this.dataSourceId}: {error}`)
            .source;
    }
    /**
     * @private
     * @return {?}
     */
    getDataSourceLrsMetadata() {
        /** @type {?} */
        const observable = this.dataSourceLrsMetadata
            ? of(this.dataSourceLrsMetadata)
            : this.dataSourceLrsMetadataService
                .get(this.dataSourceId)
                .pipe(tap((/**
             * @param {?} meta
             * @return {?}
             */
            (meta) => {
                this.dataSourceLrsMetadata = new LrsMetadata(this.dataSource)
                    .assign(meta);
                // NOTE: If we don't recieve any data source LRS metadata back then we assume that
                // the map service has LRS capabiliities - otherwise we have no LRS server data available.
                if (!meta) {
                    this.dataSourceLrsMetadata.serviceHasLrsMeta = true;
                }
            })));
        return this.notify
            .with(observable)
            .error(`Failed to retrieve data source LRS metadata by data source ID: ${this.dataSourceId}: {error}`)
            .source;
    }
    /**
     * @private
     * @return {?}
     */
    getMapServiceLayers() {
        /** @type {?} */
        const observable = this.mapServerMetadata || !this.dataSource.serviceUrl
            ? of(this.mapServerMetadata)
            : this.mapServer
                .getMapLayers(this.dataSource.serviceUrl)
                .pipe(tap((/**
             * @param {?} meta
             * @return {?}
             */
            (meta) => this.mapServerMetadata = new MapServerMetadata().assign(meta))));
        return this.notify
            .with(observable)
            .error(`Failed to retrieve map service metadata from URL: ${this.dataSource.serviceUrl}: {error}`)
            .source;
    }
    /**
     * @private
     * @return {?}
     */
    getMapServiceLrsMetadata() {
        /** @type {?} */
        const observable = !this.dataSource.serviceUrl || !this.dataSourceLrsMetadata.serviceHasLrsMeta
            ? of(this.mapServerLrsMetadata)
            : forkJoin([
                this.mapServer.getLrsServer(this.dataSource.serviceUrl),
                this.mapServer.getLrsLayers(this.dataSource.serviceUrl)
            ])
                .pipe(map((/**
             * @param {?} meta
             * @return {?}
             */
            (meta) => {
                const [lrsServerMeta, lrsLayersMeta] = meta;
                /** @type {?} */
                const lrsMetadata = Object.assign({}, lrsServerMeta, lrsLayersMeta);
                /** @type {?} */
                const mapServerLrsMetadata = new LrsMetadata().assign(lrsMetadata);
                return mapServerLrsMetadata;
            })), tap((/**
             * @param {?} meta
             * @return {?}
             */
            (meta) => this.mapServerLrsMetadata = new LrsMetadata().assign(meta))));
        return this.notify
            .with(observable)
            .error(`Failed to retrieve map service LRS metadata from URL: ${this.dataSource.serviceUrl}: {error}`)
            .source;
    }
    /**
     * @private
     * @return {?}
     */
    mergeAll() {
        /** @type {?} */
        const fullLrsMeta = mergeLrsMetadataSources(this.dataSource, this.dataSourceLrsMetadata, this.mapServerLrsMetadata, this.mapServerMetadata);
        return of(fullLrsMeta);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LrsMetadataService {
    /**
     * @param {?} http
     * @param {?} mapServer
     * @param {?} dataSourceService
     * @param {?} dataSourceLrsMetadataService
     * @param {?} notify
     * @param {?} config
     * @param {?} log
     */
    constructor(http, mapServer, dataSourceService, dataSourceLrsMetadataService, notify, config, log) {
        this.http = http;
        this.mapServer = mapServer;
        this.dataSourceService = dataSourceService;
        this.dataSourceLrsMetadataService = dataSourceLrsMetadataService;
        this.notify = notify;
        this.config = config;
        this.log = log;
        this.lrsCache = [];
    }
    /**
     * @param {?} dataSource
     * @param {?=} lrsMetadata
     * @return {?}
     */
    get(dataSource, lrsMetadata) {
        /** @type {?} */
        const dataSourceId = getDataSourceId(dataSource);
        /** @type {?} */
        const cachedMeta = this.lrsCache.find((/**
         * @param {?} cache
         * @return {?}
         */
        cache => cache.dataSourceId === dataSourceId));
        if (cachedMeta) {
            return of(cachedMeta.metaData);
        }
        return new LrsMetadataRetriever(this.http, this.mapServer, this.dataSourceService, this.dataSourceLrsMetadataService, this.notify, this.log)
            .withDataSource(dataSource)
            .withLrsMetadata(lrsMetadata)
            .retrieve()
            .pipe(tap((/**
         * @param {?} meta
         * @return {?}
         */
        meta => this.tryCacheLrsMetadata(meta))));
    }
    /**
     * @private
     * @param {?} meta
     * @return {?}
     */
    tryCacheLrsMetadata(meta) {
        if (this.config.cacheInSessionLrsMetadata) {
            this.lrsCache.push({
                dataSourceId: meta.dataSourceId,
                metaData: meta
            });
        }
    }
}
LrsMetadataService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
LrsMetadataService.ctorParameters = () => [
    { type: HttpClient },
    { type: EsriMapServerService },
    { type: DataSourceService },
    { type: DataSourceLrsMetadataService },
    { type: NotifyService },
    { type: LrsConfig },
    { type: Logger }
];
/** @nocollapse */ LrsMetadataService.ngInjectableDef = defineInjectable({ factory: function LrsMetadataService_Factory() { return new LrsMetadataService(inject(HttpClient), inject(EsriMapServerService), inject(DataSourceService), inject(DataSourceLrsMetadataService), inject(NotifyService), inject(LrsConfig), inject(Logger)); }, token: LrsMetadataService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RedlineFeature extends LrsFeature {
    /**
     * @param {?} feature
     * @param {?} layer
     */
    constructor(feature, layer) {
        super(feature, layer);
        this.routeId = this.getValue(layer.routeIdFieldName);
        this.fromMeasure = this.getValue(layer.fromMeasureFieldName);
        this.toMeasure = this.getValue(layer.toMeasureFieldName);
        this.isLinear = Boolean(layer.toMeasureFieldName);
    }
    /**
     * @param {?} layer
     * @param {?=} properties
     * @param {?=} geometry
     * @return {?}
     */
    static create(layer, properties = {}, geometry = null) {
        /** @type {?} */
        const feature = toFeature(properties, (/** @type {?} */ (geometry)));
        return new RedlineFeature(feature, layer);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} measure
     * @return {THIS}
     */
    setFromMeasure(measure) {
        (/** @type {?} */ (this)).fromMeasure = measure;
        return (/** @type {?} */ (this)).setValue((/** @type {?} */ (this)).layer.fromMeasureFieldName, measure);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} measure
     * @return {THIS}
     */
    setToMeasure(measure) {
        if (!(/** @type {?} */ (this)).isLinear) {
            throw new Error('Cannot set to measure for a point-based feature');
        }
        (/** @type {?} */ (this)).toMeasure = measure;
        return (/** @type {?} */ (this)).setValue((/** @type {?} */ (this)).layer.toMeasureFieldName, measure);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} fromMeasure
     * @param {?} toMeasure
     * @return {THIS}
     */
    setMeasureExtent(fromMeasure, toMeasure) {
        return (/** @type {?} */ (this)).setFromMeasure(fromMeasure)
            .setToMeasure(toMeasure);
    }
    /**
     * @return {?}
     */
    clone() {
        /** @type {?} */
        const copyFeature = clone(this.toFeature());
        return new RedlineFeature(copyFeature, this.layer);
    }
    /**
     * @protected
     * @return {?}
     */
    isGeometryTypeValid() {
        return isPolygon(this.geometry) || super.isGeometryTypeValid();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SYMBOL_LOCATION_TYPES = [
    { alias: 'Left', locationType: 'left' },
    { alias: 'Right', locationType: 'right' },
    { alias: 'Top', locationType: 'top' },
    { alias: 'Bottom', locationType: 'bottom' },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MapTable {
    constructor() {
        this.fields = [];
        this.indexes = [];
        this.relationships = [];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing mapping-related settings.
 */
let MapsConfig = /**
 * Configuration class for storing mapping-related settings.
 */
class MapsConfig {
};
MapsConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ MapsConfig.ngInjectableDef = defineInjectable({ factory: function MapsConfig_Factory() { return new MapsConfig(); }, token: MapsConfig, providedIn: "root" });
/**
 * Configuration class for storing mapping-related settings.
 */
MapsConfig = __decorate([
    AutoConfig('MapsConfig')
], MapsConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing motion-related settings.
 */
let MotionConfig = /**
 * Configuration class for storing motion-related settings.
 */
class MotionConfig {
    constructor() {
        this.allowMotionMocking = true;
    }
};
MotionConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ MotionConfig.ngInjectableDef = defineInjectable({ factory: function MotionConfig_Factory() { return new MotionConfig(); }, token: MotionConfig, providedIn: "root" });
/**
 * Configuration class for storing motion-related settings.
 */
MotionConfig = __decorate([
    AutoConfig('MotionConfig')
], MotionConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Geolocator service. Provides a single point of motion API.
 */
class DeviceMotionService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this.motionChangeSource = new Subject();
        this.motionChange = this.motionChangeSource.asObservable();
        fromEvent(window, 'ondevicemotion').subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.emitMotionChange(event)));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} motion
     * @return {THIS}
     */
    mockMotion(motion) {
        if (!(/** @type {?} */ (this)).config.allowMotionMocking) {
            throw new Error('Permission denied to mock device motion');
        }
        (/** @type {?} */ (this)).motionChangeSource.next(motion);
        return (/** @type {?} */ (this));
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    emitMotionChange(event) {
        this.motionChangeSource.next({
            x: event.acceleration.x,
            y: event.acceleration.y,
            z: event.acceleration.z,
            withGravityX: event.accelerationIncludingGravity.x,
            withGravityY: event.accelerationIncludingGravity.y,
            withGravityZ: event.accelerationIncludingGravity.z,
            rotationRateAlpha: event.rotationRate.alpha,
            rotationRateBeta: event.rotationRate.beta,
            rotationRateGamma: event.rotationRate.gamma,
        });
    }
}
DeviceMotionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DeviceMotionService.ctorParameters = () => [
    { type: MotionConfig }
];
/** @nocollapse */ DeviceMotionService.ngInjectableDef = defineInjectable({ factory: function DeviceMotionService_Factory() { return new DeviceMotionService(inject(MotionConfig)); }, token: DeviceMotionService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssMotionModule {
}
TssMotionModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [],
                exports: [],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns the heading based on an orientation (alpha, beta, and gamma).
 * Note: this code was sourced from: https://stackoverflow.com/questions/18112729/calculate-compass-heading-from-deviceorientation-event-api
 * @param {?} orientation
 * @return {?}
 */
function getHeadingFromOrientation(orientation) {
    // Convert degrees to radians
    /** @type {?} */
    const alphaRad = degreesToRadians(orientation.alpha);
    /** @type {?} */
    const betaRad = degreesToRadians(orientation.beta);
    /** @type {?} */
    const gammaRad = degreesToRadians(orientation.gamma);
    // Calculate equation components
    /** @type {?} */
    const cA = Math.cos(alphaRad);
    /** @type {?} */
    const sA = Math.sin(alphaRad);
    /** @type {?} */
    const sB = Math.sin(betaRad);
    /** @type {?} */
    const cG = Math.cos(gammaRad);
    /** @type {?} */
    const sG = Math.sin(gammaRad);
    // Calculate A, B, C rotation components
    /** @type {?} */
    const rA = -cA * sG - sA * sB * cG;
    /** @type {?} */
    const rB = -sA * sG + cA * sB * cG;
    // Calculate compass heading
    /** @type {?} */
    let compassHeading = Math.atan(rA / rB);
    // Convert from half unit circle to whole unit circle
    compassHeading = rB < 0
        ? compassHeading += Math.PI
        : compassHeading += 2 * Math.PI;
    // Convert radians to degrees
    compassHeading = radiansToDegrees(compassHeading);
    return compassHeading;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing orientation-related settings.
 */
let OrientationConfig = /**
 * Configuration class for storing orientation-related settings.
 */
class OrientationConfig {
    constructor() {
        this.allowOrientationMocking = true;
        this.allowHeadingMocking = true;
    }
};
OrientationConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ OrientationConfig.ngInjectableDef = defineInjectable({ factory: function OrientationConfig_Factory() { return new OrientationConfig(); }, token: OrientationConfig, providedIn: "root" });
/**
 * Configuration class for storing orientation-related settings.
 */
OrientationConfig = __decorate([
    AutoConfig('OrientationConfig')
], OrientationConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Geolocator service. Provides a single point of GPS interaction.
 */
class DeviceOrientationService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this.internalDeviceNeedsCalibrated = false;
        this.headingChangeSource = new Subject();
        this.orientationChangeSource = new Subject();
        this.orientationChange = this.orientationChangeSource.asObservable();
        this.headingChange = merge(this.headingChangeSource, this.orientationChange.pipe(map((/**
         * @param {?} orientation
         * @return {?}
         */
        orientation => orientation.heading))));
        fromEvent(window, 'deviceorientation').subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.emitOrientationChange(event)));
        fromEvent(window, 'oncompassneedscalibration').subscribe((/**
         * @return {?}
         */
        () => this.internalDeviceNeedsCalibrated = true));
        fromEvent(window, 'compassneedscalibration').subscribe((/**
         * @return {?}
         */
        () => this.internalDeviceNeedsCalibrated = true));
    }
    /**
     * @return {?}
     */
    get deviceNeedsCalibrated() {
        return this.internalDeviceNeedsCalibrated;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} orientation
     * @return {THIS}
     */
    mockOrientation(orientation) {
        if (!(/** @type {?} */ (this)).config.allowOrientationMocking) {
            throw new Error('Permission denied to mock device orientation');
        }
        (/** @type {?} */ (this)).orientationChangeSource.next(orientation);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} heading
     * @return {THIS}
     */
    mockHeading(heading) {
        if (!(/** @type {?} */ (this)).config.allowHeadingMocking) {
            throw new Error('Permission denied to mock heading');
        }
        (/** @type {?} */ (this)).headingChangeSource.next(heading);
        return (/** @type {?} */ (this));
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    emitOrientationChange(event) {
        this.orientationChangeSource.next({
            alpha: event.alpha,
            beta: event.beta,
            gamma: event.gamma,
            heading: getHeadingFromOrientation(event)
        });
    }
}
DeviceOrientationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DeviceOrientationService.ctorParameters = () => [
    { type: OrientationConfig }
];
/** @nocollapse */ DeviceOrientationService.ngInjectableDef = defineInjectable({ factory: function DeviceOrientationService_Factory() { return new DeviceOrientationService(inject(OrientationConfig)); }, token: DeviceOrientationService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TssOrientationModule {
}
TssOrientationModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [],
                exports: [],
                providers: [],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Unique token created for each queue worker
 */
class QueueWorkerToken {
    constructor() {
        this.isWorking = false;
        this.isCanceled = false;
        this.id = Guid.newGuid().value;
    }
    /**
     * @return {?}
     */
    get isComplete() {
        return !this.isWorking;
    }
    /**
     * @return {?}
     */
    get ellapsedSeconds() {
        return getElapsedSeconds(new Date(), this.startTime);
    }
    /**
     * @return {?}
     */
    get totalProcessed() {
        return this.totalComplete + this.totalFailed;
    }
    /**
     * @return {?}
     */
    get recordsProcessedPerSecond() {
        return this.totalComplete / this.ellapsedSeconds;
    }
    /**
     * @return {?}
     */
    get recordsProcessedPerMinute() {
        return this.recordsProcessedPerSecond * 60;
    }
    /**
     * @return {?}
     */
    start() {
        this.reset();
        this.startTime = new Date();
        this.isWorking = true;
        return this;
    }
    /**
     * @return {?}
     */
    reset() {
        this.isWorking = false;
        this.isCanceled = false;
        this.totalComplete = 0;
        this.totalFailed = 0;
        this.startTime = null;
        this.endTime = null;
        return this;
    }
    /**
     * @param {?} remainingCount
     * @return {?}
     */
    calculateRemainingSeconds(remainingCount) {
        return this.isComplete
            ? 0
            : calculateRemainingSeconds(this.totalProcessed, this.ellapsedSeconds, remainingCount);
    }
    /**
     * @return {?}
     */
    complete() {
        this.endTime = new Date();
        this.isWorking = false;
        return this;
    }
    /**
     * @return {?}
     */
    cancel() {
        this.isCanceled = true;
        this.isWorking = false;
        return this;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const WorkQueueStatusEventType = {
    UnitOfWorkStarted: 0,
    UnitOfWorkComplete: 1,
    UnitOfWorkStatusUpdate: 2,
    QueueWorkerStarted: 3,
    QueueWorkerComplete: 4,
    QueueStarted: 5,
    QueueComplete: 6,
};
WorkQueueStatusEventType[WorkQueueStatusEventType.UnitOfWorkStarted] = 'UnitOfWorkStarted';
WorkQueueStatusEventType[WorkQueueStatusEventType.UnitOfWorkComplete] = 'UnitOfWorkComplete';
WorkQueueStatusEventType[WorkQueueStatusEventType.UnitOfWorkStatusUpdate] = 'UnitOfWorkStatusUpdate';
WorkQueueStatusEventType[WorkQueueStatusEventType.QueueWorkerStarted] = 'QueueWorkerStarted';
WorkQueueStatusEventType[WorkQueueStatusEventType.QueueWorkerComplete] = 'QueueWorkerComplete';
WorkQueueStatusEventType[WorkQueueStatusEventType.QueueStarted] = 'QueueStarted';
WorkQueueStatusEventType[WorkQueueStatusEventType.QueueComplete] = 'QueueComplete';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WorkQueueStatusTracker {
    constructor() {
        this.totalQueueSize = 0;
        this.workers = [];
    }
    /**
     * @return {?}
     */
    get workerCount() {
        return this.workers.length;
    }
    /**
     * @return {?}
     */
    get percentComplete() {
        return this.totalQueueSize >= 0
            ? Math.round(this.totalProcessed / this.totalQueueSize * 100) || 0
            : 0;
    }
    /**
     * @return {?}
     */
    get totalComplete() {
        return this.workers.reduce((/**
         * @param {?} accumulator
         * @param {?} current
         * @return {?}
         */
        (accumulator, current) => accumulator + current.totalComplete), 0) || 0;
    }
    /**
     * @return {?}
     */
    get totalFailed() {
        return this.workers.reduce((/**
         * @param {?} accumulator
         * @param {?} current
         * @return {?}
         */
        (accumulator, current) => accumulator + current.totalFailed), 0) || 0;
    }
    /**
     * @return {?}
     */
    get totalProcessed() {
        return this.totalComplete + this.totalFailed;
    }
    /**
     * @return {?}
     */
    get isWorking() {
        return Boolean(this.runningWorkerCount);
    }
    /**
     * @return {?}
     */
    get isComplete() {
        return this.startTime && !this.isWorking;
    }
    /**
     * @return {?}
     */
    get isCanceled() {
        /** @type {?} */
        const canceledWorkersCount = this.workers.filter((/**
         * @param {?} worker
         * @return {?}
         */
        worker => worker.isCanceled)).length;
        return Boolean(canceledWorkersCount && canceledWorkersCount === this.workers.length);
    }
    /**
     * @return {?}
     */
    get runningWorkerCount() {
        return this.workers.filter((/**
         * @param {?} worker
         * @return {?}
         */
        worker => worker.isWorking)).length;
    }
    /**
     * @return {?}
     */
    get startTime() {
        /** @type {?} */
        const startTimes = this.workers
            .filter((/**
         * @param {?} worker
         * @return {?}
         */
        worker => worker.startTime))
            .map((/**
         * @param {?} worker
         * @return {?}
         */
        worker => worker.startTime
            ? worker.startTime.getTime()
            : null));
        return new Date(Math.min(...startTimes));
    }
    /**
     * @return {?}
     */
    get endTime() {
        /** @type {?} */
        const startTimes = this.workers
            .filter((/**
         * @param {?} worker
         * @return {?}
         */
        worker => worker.startTime))
            .map((/**
         * @param {?} worker
         * @return {?}
         */
        worker => worker.startTime
            ? worker.startTime.getTime()
            : null));
        return new Date(Math.max(...startTimes));
    }
    /**
     * @return {?}
     */
    get remainingQueueSize() {
        return this.totalQueueSize - this.totalProcessed;
    }
    /**
     * @return {?}
     */
    get estimatedSecondsLeft() {
        /** @type {?} */
        const remainingCount = this.remainingQueueSize;
        return remainingCount
            ? average(this.workers
                .map((/**
             * @param {?} worker
             * @return {?}
             */
            worker => worker.calculateRemainingSeconds(remainingCount))))
            : 0;
    }
    /**
     * @return {?}
     */
    get averageRecordsProcessedPerMinute() {
        return average(this.workers
            .map((/**
         * @param {?} worker
         * @return {?}
         */
        worker => worker.recordsProcessedPerMinute)));
    }
    /**
     * @param {?} totalQueueSize
     * @return {?}
     */
    setQueueSize(totalQueueSize) {
        this.totalQueueSize = totalQueueSize;
        return this;
    }
    /**
     * @return {?}
     */
    complete() {
        this.workers.splice(0, this.workers.length);
        this.totalQueueSize = 0;
        return this;
    }
    /**
     * @param {...?} workers
     * @return {?}
     */
    addWorker(...workers) {
        workers.forEach((/**
         * @param {?} worker
         * @return {?}
         */
        worker => {
            this.workers.push(worker);
        }));
        return this;
    }
    /**
     * @return {?}
     */
    getStatus() {
        return {
            isWorking: this.isWorking,
            isCanceled: this.isCanceled,
            isComplete: this.isComplete,
            totalProcessed: this.totalProcessed,
            startTime: this.startTime,
            endTime: this.endTime,
            percentComplete: this.percentComplete,
            totalQueueSize: this.totalQueueSize,
            remainingQueueSize: this.remainingQueueSize,
            totalComplete: this.totalComplete,
            totalFailed: this.totalFailed,
            estimatedSecondsLeft: this.estimatedSecondsLeft,
            workerCount: this.workers.length,
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_WORK_QUEUE_OPTIONS = {
    autoStartWorkers: true,
    workerCount: 1,
};
/**
 * Provides the core queueing workflow for basic unit of work queues.
 * High Priority Todos:
 * * Implement worker cancelation into the worker token - RG.
 *
 * Low Priority Todos:
 * * Add queue prioritization - a queue priority flag to pull those items first from the queue - RG.
 * * Change overriding of methods to use metho attributes instead. Example: \@OnWorkComplete.
 * @abstract
 * @template TInput, TOutput
 */
class WorkQueueManager {
    /**
     * @param {?} log
     * @param {?=} options
     */
    constructor(log, options) {
        this.log = log;
        this.workerTokens = [];
        this.tracker = new WorkQueueStatusTracker();
        this.options = Object.assign({}, DEFAULT_WORK_QUEUE_OPTIONS);
        this.setOptions(options);
        this.queueChangeObserver = new Subject();
        this.queueChange = this.queueChangeObserver.pipe();
        this.queueStarted = this.queueChangeObserver.pipe(filter((/**
         * @param {?} change
         * @return {?}
         */
        change => change.event === WorkQueueStatusEventType.QueueStarted)));
        this.queueComplete = this.queueChangeObserver.pipe(filter((/**
         * @param {?} change
         * @return {?}
         */
        change => change.event === WorkQueueStatusEventType.QueueComplete)));
        if (this.options.autoStartWorkers) {
            setTimeout((/**
             * @return {?}
             */
            () => this.startWork()));
        }
    }
    /**
     * @return {?}
     */
    get isWorking() {
        return this.tracker.isWorking;
    }
    /**
     * @return {?}
     */
    get status() {
        return this.tracker.getStatus();
    }
    /**
     * Overrides default options.
     * @param {?} options Options to override the defaults.
     * @return {?}
     */
    setOptions(options) {
        Object.assign(this.options, options);
        return this;
    }
    /**
     * Kicks off the queue workflow with the specified number of workers. If
     * the maximum number of workers are currently running, no additional workers
     * will be created (only the delta of allowed and running will be started).
     * @return {?}
     */
    startWork() {
        // We dont' want to change the queue size if the queue is already working
        // because it will mess up the statistics (percent copmlete, etc).
        /** @type {?} */
        const starterSource = iif((/**
         * @return {?}
         */
        () => !this.isWorking), this.getRemainingQueueCount()
            .pipe(tap((/**
         * @param {?} queueCount
         * @return {?}
         */
        (queueCount) => this.tracker.setQueueSize(queueCount)))));
        this.onReady()
            .pipe(mergeMap((/**
         * @return {?}
         */
        () => starterSource)))
            .subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const workersToStart = this.options.workerCount - this.workerTokens.length;
            if (workersToStart > 0) {
                this.emitQueueChange(null, WorkQueueStatusEventType.QueueStarted);
            }
            for (let i = 0; i < workersToStart; i++) {
                /** @type {?} */
                const token = new QueueWorkerToken().start();
                this.tracker.addWorker(token);
                this.workerTokens.push(token);
                this.emitQueueChange(token, WorkQueueStatusEventType.QueueWorkerStarted);
                this.getNextAndDoWork(token);
            }
        }));
    }
    /**
     * Stops all workers from processing the queue.
     * @return {?}
     */
    stopWork() {
        this.workerTokens.forEach((/**
         * @param {?} token
         * @return {?}
         */
        token => token.cancel()));
    }
    /**
     * Method that determines that the workers are ready to be started. Note, in this implementation it
     * makes use of an empty promise. The main reason for this is to provide a hook for other implementers
     * to setup/initialize the queue before starting the workers. Additionaly, this practices provides a
     * way to run the workers asynchronously.
     * @protected
     * @return {?}
     */
    onReady() {
        return of(null);
    }
    /**
     * @protected
     * @param {?} input
     * @return {?}
     */
    onBeforeWorkStarted(input) {
        return of(input);
    }
    /**
     * @protected
     * @param {?} data
     * @return {?}
     */
    onWorkComplete(data) {
        return of(data);
    }
    /**
     * @protected
     * @param {?} data
     * @param {?} error
     * @return {?}
     */
    onWorkFailed(data, error) {
        return of(data, error);
    }
    /**
     * @protected
     * @return {?}
     */
    getRemainingQueueCount() {
        return of(-1);
    }
    /**
     * @protected
     * @param {?} token
     * @param {?} event
     * @param {?=} input
     * @param {?=} output
     * @return {?}
     */
    emitQueueChange(token, event, input, output) {
        this.queueChangeObserver.next({
            event,
            input,
            output,
            status: this.tracker.getStatus(),
            tokenId: token ? token.id : null,
        });
    }
    /**
     * @private
     * @param {?} token
     * @param {?=} input
     * @param {?=} output
     * @return {?}
     */
    emitWorkStarted(token, input, output) {
        this.emitQueueChange(token, WorkQueueStatusEventType.UnitOfWorkStarted, input, output);
    }
    /**
     * @private
     * @param {?} token
     * @param {?=} input
     * @param {?=} output
     * @return {?}
     */
    emitWorkComplete(token, input, output) {
        this.emitQueueChange(token, WorkQueueStatusEventType.UnitOfWorkComplete, input, output);
    }
    /**
     * @private
     * @param {?} token
     * @return {?}
     */
    onWorkerCompleted(token) {
        if (token.isComplete) {
            return;
        }
        /** @type {?} */
        const index = this.workerTokens.indexOf(token);
        token.complete();
        if (index !== -1) {
            this.workerTokens.splice(index, 1);
        }
        this.emitQueueChange(token, WorkQueueStatusEventType.QueueWorkerComplete);
        if (this.workerTokens.length === 0) {
            this.emitQueueChange(token, WorkQueueStatusEventType.QueueComplete);
            this.tracker.complete();
        }
    }
    /**
     * @private
     * @param {?} token
     * @param {?} next
     * @return {?}
     */
    checkIfWorkerComplete(token, next) {
        if (isNotValue(next)) {
            this.onWorkerCompleted(token);
        }
    }
    /**
     * @private
     * @param {?} token
     * @return {?}
     */
    getNextAndDoWork(token) {
        if (token.isCanceled) {
            this.log.debug(`Canceling worker due to canceled toke: ${token.id}`);
            this.onWorkerCompleted(token);
        }
        this.log.trace('Retrieving next queue item to start processing');
        /** @type {?} */
        const processingData = { input: null, output: null };
        this.getNext()
            .pipe(tap((/**
         * @param {?} input
         * @return {?}
         */
        (input) => processingData.input = input)), tap((/**
         * @param {?} input
         * @return {?}
         */
        (input) => this.checkIfWorkerComplete(token, input))), takeWhile((/**
         * @param {?} input
         * @return {?}
         */
        (input) => isValue(input) && !token.isCanceled)), tap((/**
         * @param {?} input
         * @return {?}
         */
        (input) => this.emitWorkStarted(token, input))), mergeMap((/**
         * @param {?} input
         * @return {?}
         */
        (input) => this.onBeforeWorkStarted(input))), mergeMap((/**
         * @param {?} input
         * @return {?}
         */
        (input) => this.doWork(input))), tap((/**
         * @param {?} output
         * @return {?}
         */
        (output) => processingData.output = output)), map((/**
         * @return {?}
         */
        () => processingData)), mergeMap((/**
         * @param {?} data
         * @return {?}
         */
        (data) => this.onWorkComplete(data))))
            .subscribe((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            this.log.trace('Completed work for item');
            token.totalComplete++;
            this.emitWorkComplete(token, data.input, data.output);
            this.getNextAndDoWork(token);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.log.error(`Failed to process item. {error}`, error);
            token.totalFailed++;
            this.onWorkFailed(processingData, error)
                .toPromise()
                .then((/**
             * @return {?}
             */
            () => this.getNextAndDoWork(token)));
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template TInput, TOutput
 */
class QueuableWorkQueueManager extends WorkQueueManager {
    constructor() {
        super(...arguments);
        this.options = Object.assign({
            autoDequeu: true
        }, DEFAULT_WORK_QUEUE_OPTIONS);
    }
    /**
     * Enqueues multiple items into an array.
     * @param {...?} items Items to enqueue.
     *
     * TODO: We want to change this to use "mergeAll" once we
     *  upgrade to rxjs 6, as that is the desired behavior here.
     *
     * // The following works in rxjs 6, but not in 5:
     * of(...sources)
     * .pipe(
     *   mergeAll(),
     *   // NOTE: in rxjs 5
     *   tap((x: TInput) => x)
     * )
     * @return {?}
     */
    enqueuMany(...items) {
        /** @type {?} */
        const sources = items
            .map((/**
         * @param {?} i
         * @return {?}
         */
        i => this.enqueue(i)));
        return forkJoin(sources)
            .pipe(map((/**
         * @param {?} results
         * @return {?}
         */
        (results) => results.pop())));
    }
    /**
     * Deque many items from the queue.
     * @param {...?} items Items do deque.
     * @return {?}
     */
    dequeuMany(...items) {
        /** @type {?} */
        const sources = items
            .map((/**
         * @param {?} i
         * @return {?}
         */
        i => this.dequeue(i)));
        return forkJoin(sources)
            .pipe(map((/**
         * @param {?} results
         * @return {?}
         */
        (results) => results.pop())));
    }
    /**
     * @protected
     * @param {?} payload
     * @return {?}
     */
    onWorkComplete(payload) {
        return forkJoin(super.onWorkComplete(payload), this.dequeue(payload.input))
            .pipe(map((/**
         * @param {?} result
         * @return {?}
         */
        (result) => result[0])));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const QueueItemStatus = {
    Queued: 0,
    InProgress: 1,
    Complete: 2,
    Canceled: 3,
    Failed: 4,
};
QueueItemStatus[QueueItemStatus.Queued] = 'Queued';
QueueItemStatus[QueueItemStatus.InProgress] = 'InProgress';
QueueItemStatus[QueueItemStatus.Complete] = 'Complete';
QueueItemStatus[QueueItemStatus.Canceled] = 'Canceled';
QueueItemStatus[QueueItemStatus.Failed] = 'Failed';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration class for storing global queue-related settings.
 */
let QueueConfig = /**
 * Configuration class for storing global queue-related settings.
 */
class QueueConfig {
};
QueueConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ QueueConfig.ngInjectableDef = defineInjectable({ factory: function QueueConfig_Factory() { return new QueueConfig(); }, token: QueueConfig, providedIn: "root" });
/**
 * Configuration class for storing global queue-related settings.
 */
QueueConfig = __decorate([
    AutoConfig('QueueConfig')
], QueueConfig);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PrivilegeService extends BaseResourceService {
    /**
     * @param {?} http
     * @param {?} config
     */
    constructor(http, config) {
        super(http, {
            url: join(config.serviceUrl, config.privilegesEndpoint)
        });
        this.http = http;
    }
}
PrivilegeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
PrivilegeService.ctorParameters = () => [
    { type: HttpClient },
    { type: SecurityConfig }
];
/** @nocollapse */ PrivilegeService.ngInjectableDef = defineInjectable({ factory: function PrivilegeService_Factory() { return new PrivilegeService(inject(HttpClient), inject(SecurityConfig)); }, token: PrivilegeService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MISSING_ROLE_PARAM_EXCEPTION_MSG = 'Missing role ID parameter';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MISSING_PRIVILEGE_PARAM_EXCEPTION_MSG = 'Missing privilege identifier parameter';
/**
 * Service to provide all CRUD operations for privilege/role assignment.
 *
 * \@example
 * ## Gets privileges for a given role:
 * service.privilegesByRole('879e27e1-b139-4348-86ca-ec4d5651475f')
 *
 * // Which is just a shortcut for:
 * service.query({ roleId: 'admin' });
 *
 */
class RolePrivilegeService extends BaseResourceService {
    /**
     * @param {?} http
     * @param {?} config
     */
    constructor(http, config) {
        super(http, {
            url: join(config.serviceUrl, config.rolesPrivilegesEndpoint),
            idFieldName: 'roleId'
        });
        this.http = http;
    }
    /**
     * Retrieves a list of privileges for a given role ID.
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    query(routeTokens, params) {
        if (!routeTokens || !routeTokens.roleId) {
            throw new Error(MISSING_ROLE_PARAM_EXCEPTION_MSG);
        }
        return super.query(routeTokens, params);
    }
    /**
     * This method is not supported for this resource. Please use "privilegesByRole".
     * @param {?} id
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    get(id, routeTokens, params) {
        throw new Error(UNSUPPORTED_GET_EXCEPTION_MSG);
    }
    /**
     * This method is not supported for this resource. Please use "addPrivilegeToRole".
     * @param {?} entity
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    create(entity, routeTokens, params) {
        throw new Error(UNSUPPORTED_CREATE_EXCEPTION_MSG);
    }
    /**
     * Updates a privilege assignment (adds a privilege to a role).
     * @param {?} entity
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    update(entity, routeTokens, params) {
        if (!routeTokens || !routeTokens.roleId) {
            throw new Error(MISSING_ROLE_PARAM_EXCEPTION_MSG);
        }
        else if (!routeTokens.privilegeId) {
            throw new Error(MISSING_PRIVILEGE_PARAM_EXCEPTION_MSG);
        }
        return super.update(null, routeTokens, params);
    }
    /**
     * Removes a privilege from a role assignment.
     * @param {?} id
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    delete(id, routeTokens, params) {
        if (!routeTokens || !routeTokens.roleId) {
            throw new Error(MISSING_ROLE_PARAM_EXCEPTION_MSG);
        }
        else if (!routeTokens.privilegeId) {
            throw new Error(MISSING_PRIVILEGE_PARAM_EXCEPTION_MSG);
        }
        return super.delete(id, routeTokens, params);
    }
    /**
     * Retrieves all privileges assigned to the given role ID.
     * @param {?} roleId
     * @param {?=} params
     * @return {?}
     */
    privilegesByRole(roleId, params) {
        return this.query({ roleId }, params);
    }
    /**
     * Adds a privilege to role.
     * @param {?} roleId
     * @param {?} privilegeId
     * @return {?}
     */
    addPrivilegeToRole(roleId, privilegeId) {
        return this.update(null, { roleId, privilegeId });
    }
    /**
     * Removes a privilege from the given role.
     * @param {?} roleId
     * @param {?} privilegeId
     * @return {?}
     */
    removePrivilegeFromRole(roleId, privilegeId) {
        return this.delete(roleId, { roleId, privilegeId });
    }
}
RolePrivilegeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
RolePrivilegeService.ctorParameters = () => [
    { type: HttpClient },
    { type: SecurityConfig }
];
/** @nocollapse */ RolePrivilegeService.ngInjectableDef = defineInjectable({ factory: function RolePrivilegeService_Factory() { return new RolePrivilegeService(inject(HttpClient), inject(SecurityConfig)); }, token: RolePrivilegeService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RoleService extends BaseResourceService {
    /**
     * @param {?} http
     * @param {?} config
     */
    constructor(http, config) {
        super(http, {
            url: join(config.serviceUrl, config.rolesEndpoint)
        });
        this.http = http;
    }
}
RoleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
RoleService.ctorParameters = () => [
    { type: HttpClient },
    { type: SecurityConfig }
];
/** @nocollapse */ RoleService.ngInjectableDef = defineInjectable({ factory: function RoleService_Factory() { return new RoleService(inject(HttpClient), inject(SecurityConfig)); }, token: RoleService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MISSING_USER_PARAM_EXCEPTION_MSG = 'Missing user ID parameter';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service to provide all CRUD operations for user/role assignment.
 *
 * \@example
 * ## Gets roles for a given user:
 * service.rolesByUser('879e27e1-b139-4348-86ca-ec4d5651475f')
 *
 * // Which is just a shortcut for:
 * service.query({ userId: '879e27e1-b139-4348-86ca-ec4d5651475f' });
 *
 */
class UserRoleService extends BaseResourceService {
    /**
     * @param {?} http
     * @param {?} config
     */
    constructor(http, config) {
        super(http, {
            url: join(config.serviceUrl, config.userRolesEndpoint),
            idFieldName: 'userId'
        });
        this.http = http;
    }
    /**
     * Retrieves a list of roles for a given user ID.
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    query(routeTokens, params) {
        if (!routeTokens || !routeTokens.userId) {
            throw new Error(MISSING_USER_PARAM_EXCEPTION_MSG);
        }
        return super.query(routeTokens, params);
    }
    /**
     * This method is not supported for this resource. Please use "rolesByUser".
     * @param {?} id
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    get(id, routeTokens, params) {
        throw new Error(UNSUPPORTED_GET_EXCEPTION_MSG);
    }
    /**
     * This method is not supported for this resource. Please use "addUserToRole".
     * @param {?} entity
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    create(entity, routeTokens, params) {
        throw new Error(UNSUPPORTED_CREATE_EXCEPTION_MSG);
    }
    /**
     * Updates a users role assignment (adds a role to a user).
     * @param {?} entity
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    update(entity, routeTokens, params) {
        if (!routeTokens || !routeTokens.userId) {
            throw new Error(MISSING_USER_PARAM_EXCEPTION_MSG);
        }
        else if (!routeTokens.roleName) {
            throw new Error(MISSING_ROLE_PARAM_EXCEPTION_MSG);
        }
        return super.update(null, routeTokens, params);
    }
    /**
     * Removes a user from a role assignment.
     * @param {?} id
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    delete(id, routeTokens, params) {
        if (!routeTokens || !routeTokens.userId) {
            throw new Error(MISSING_USER_PARAM_EXCEPTION_MSG);
        }
        else if (!routeTokens.roleName) {
            throw new Error(MISSING_ROLE_PARAM_EXCEPTION_MSG);
        }
        return super.delete(id, routeTokens, params);
    }
    /**
     * Retrieves all roles assigned to the given user ID.
     * @param {?} userId
     * @param {?=} params
     * @return {?}
     */
    rolesByUser(userId, params) {
        return this.query({ userId }, params);
    }
    /**
     * Adds a user to role.
     * @param {?} userId
     * @param {?} role
     * @param {?=} params
     * @return {?}
     */
    addUserToRole(userId, role, params) {
        // NOTE: We pass an arbitrary "_" role name because the route requires a role name,
        // however the role's name is going to be pulled from the role entity on the server.
        // The reason we don't pass "role.name" here is because of issues with IIS not
        // handling decoded backslashes (ex: TSS\TSS Users).
        return super.update(role, { userId, roleName: '_' }, params);
    }
    /**
     * Adds a user to role.
     * @param {?} userId
     * @param {?} roleName
     * @param {?=} params
     * @return {?}
     */
    addUserToRoleByName(userId, roleName, params) {
        roleName = decodeURIComponent(roleName);
        return this.update(null, { userId, roleName }, params);
    }
    /**
     * Removes a user from the given role.
     * @param {?} userId
     * @param {?} role
     * @param {?=} params
     * @return {?}
     */
    removeUserFromRole(userId, role, params) {
        return this.removeUserFromRoleByName(userId, role.name, params);
    }
    /**
     * Removes a user from the given role.
     * @param {?} userId
     * @param {?} roleName
     * @param {?=} params
     * @return {?}
     */
    removeUserFromRoleByName(userId, roleName, params) {
        roleName = decodeURIComponent(roleName);
        return this.delete(userId, { userId, roleName }, params);
    }
}
UserRoleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
UserRoleService.ctorParameters = () => [
    { type: HttpClient },
    { type: SecurityConfig }
];
/** @nocollapse */ UserRoleService.ngInjectableDef = defineInjectable({ factory: function UserRoleService_Factory() { return new UserRoleService(inject(HttpClient), inject(SecurityConfig)); }, token: UserRoleService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@example
 * ## Get Users that belong to a given role (by ID).
 * service.usersByRoleId('1428a342-8a95-4b6c-b3e9-da135e3ced04')
 *
 * // ...which is just a shortcut for:
 * service.query({}, new HttpParams().set('filterByRoleId', roleName));
 *
 * ## Get Users that belong to a given role (by name).
 * service.usersByRoleName('Admin')
 *
 * // ...which is just a shortcut for:
 * service.query({}, new HttpParams().set('filterByRoleName', roleName));
 */
class UserService extends BaseResourceService {
    /**
     * @param {?} http
     * @param {?} config
     */
    constructor(http, config) {
        super(http, {
            url: join(config.serviceUrl, config.usersEndpoint)
        });
        this.http = http;
    }
    /**
     * @param {?} roleId
     * @param {?=} params
     * @return {?}
     */
    usersByRoleId(roleId, params) {
        params = (params || new HttpParams()).set('filterByRoleId', roleId);
        return this.query({}, params);
    }
    /**
     * @param {?} roleName
     * @param {?=} params
     * @return {?}
     */
    usersByRoleName(roleName, params) {
        params = (params || new HttpParams()).set('filterByRoleName', roleName);
        return this.query({}, params);
    }
    /**
     * @param {?} searchText
     * @param {?=} params
     * @return {?}
     */
    search(searchText, params) {
        params = (params || new HttpParams()).set('search', searchText);
        return this.query({}, params);
    }
}
UserService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
UserService.ctorParameters = () => [
    { type: HttpClient },
    { type: SecurityConfig }
];
/** @nocollapse */ UserService.ngInjectableDef = defineInjectable({ factory: function UserService_Factory() { return new UserService(inject(HttpClient), inject(SecurityConfig)); }, token: UserService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ApiService, AppInitializerFactory, AppInitializerService, AppProfileService, ALL_APPS_QUERY_ID, TssAppSpatialModule, DEFAULT_APP_ID, DEFAULT_PROFILE_ID, AppConfig, TssAppModule, AppSettingService, ALL_APP_SETTINGS_QUERY_ID, CachePersistence, CacheStrategy, CacheConfig, CACHE_ONLY_NO_DATA_EXC_MSG, CacheInterceptor, TssCacheModule, CacheService, CACHE_STORAGE_KEY_PREFIX, PersistentCacheStorage, addIfNotExist, addRangeToBeginning, addRange, getLastItem, removeDuplicates, removeItem, removeWhere, AutoConfig, clone, hexToRgb, isHexColor, rgbToHex, transparencyToOpacity, getCookie, CoreConfig, TssCoreModule, addDays, addHours, addMilliseconds, addMinutes, addSeconds, millisecondsToDays, millisecondsToHours, millisecondsToMinutes, millisecondsToSeconds, toMilliseconds, toStandardizedQueryDateFormat, toUtcDate, toUtcEpochDate, STANDARDIZED_QUERY_DATE_FORMAT, ORACLE_DATE_FORMAT, DEFAULT_DATE_FORMAT, HOURS_PER_DAY, MINUTES_PER_HOUR, SECONDS_PER_MINUTE, MILLISECONDS_PER_SECOND, MILLISECONDS_PER_MINUTE, MILLISECONDS_PER_HOUR, MILLISECONDS_PER_DAY, READABLE_TIME_SUFFIX_MAP, formatDateForQuery, formatDate, SqlDateFormat, getCurrentDateAsUtc, getCurrentDateEpochAsUtc, getElapsedMilliseconds, getElapsedSeconds, ReadableTimePipe, secondsToReadableTime, toReadableTime, setDateToBeginningOfDay, setDateToEndOfDay, subtractDays, subtractMinutes, subtractSeconds, subtractHours, subtractMilliseconds, hasLocalStorage, hasWindow, OnlineOfflineService, almostEqual, DEFAULT_POINT_EQUALITY_PRECISION, pointsAlmostEqual, errorMsg, DEFAULT_ERROR_MSG, formatNumber, format, FIRST_LETTER_SEPERATED_BY_SPACE_MATCH_REGEX, PASCAL_CASE_FIRST_LETTER_MATCH_REGEX, LEADING_AND_TRAILING_UNDERSCORE_MATCH_REGEX, LEADING_AND_TRAILING_HYPHEN_MATCH_REGEX, UNDERSCORE_MATCH_REGEX, HYPHEN_MATCH_REGEX, humanize, lowerCaseFirst, trimEnd, trim, trimStart, upperCaseEachWord, upperCaseFirstLetter, groupBy, KeysPipe, typeToLevel, levelToType, LogLevel, Logger, base64MimeType, base64toBlob, base64toByteArray, BASE_64_METADATA_REGEX, JSON_MIME_TYPE, TEXT_MIME_TYPE, TEXT_FILE_EXTENSION, AUDIO_WEBM_MIME_TYPE, AUDIO_MP3_MIME_TYPE, AUDIO_MP3_FILE_EXTENSION, VIDEO_WEBM_MIME_TYPE, VIDEO_MP4_MIME_TYPE, VIDEO_MP4_FILE_EXTENSION, IMAGE_PNG_FILE_EXTENSION, IMAGE_PNG_MIME_TYPE, IMAGE_JPEG_FILE_EXTENSION, IMAGE_JPEG_MIME_TYPE, stripBase64Metadata, mergeDeepArray, mergeDeep, BaseNotificationTracker, NotificationPromiseTracker, NotificationSubscriptionTracker, NotifyType, NotifyService, assignValidValues, getValue, setValue, getRandomInteger, getRandomNumber, BaseEmptyResourceService, BaseResourceService, NO_URL_ERROR_MSG, UNSUPPORTED_GET_EXCEPTION_MSG, UNSUPPORTED_CREATE_EXCEPTION_MSG, EMPTY_PARAM_VALUE, ResourceConfig, round, SafeUrlPipe, sortAndReorder, sortByOrder, SortDirection, sortAscending, sortDescending, sort, average, calculateCrossProduct, calculatePercentComplete, calculateRemainingSeconds, isNumberBetweenOrEqual, isNumberBetween, StatsTracker, sumProperty, sumValues, sum, BaseStorage, FileSizePipe, formatByteSize, getByteSize, InMemoryStorage, PersistentStorage, STORAGE_FORMAT_UNITS, NO_BYTES_FORMATTED, extractTokenExpressions, extractTokenValuesFromTemplate, extractTokens, hasTokens, replaceToken, replaceTokens, standardizeTokens, stripTokenBraces, TOKEN_EXPRESSION, FULL_TOKEN_EXPRESSION, WILDCARD_EXPRESSION_VALUE, canBeNumber, canNotBeNumber, isArray, isBoolean, isDate$1 as isDate, isDefined, isFunction, isNotArray, isNotBoolean, isNotDate, isNotDefined, isNotFunction, isNotNumber, isNotObject, isNotPrimitive, isNotString, isNotType, isNotValue, isNumber$1 as isNumber, isObject, isPrimitive, isString, isType, isValue, toPrimitiveType, AreaUnit, convertAreaUnits, convertLengthUnits, fromMeters, LengthUnit, MeasurementUnit, metersPerSecondToKilometersPerHour, metersPerSecondToMilesPerHour, toMeters, LENGTH_UNIT_METER_CONVERSION_FACTOR, clean, ensureProtocol, getBaseUrl, getFirstHashRoutePath, getFullUrl, getPostHashRoutePaths, getQueryParams, joinAndFomat, join, parametersToString, removeEmptyParams, stripTrailingSlash, EMPTY_PARAMS_REGEX, using, INVALID_GUID_ERROR_MSG, Guid, uuidValueReplacer, uuid, ValidationCheck, ValidationResult, CsvConfig, CSV_NEW_LINE, CSV_SEPARATOR, TssCsvModule, geometryToCsv, toCsv, APPLY_EDITS_SEED_POD_FILE_EXTENSION, DataSourceEditService, AttachmentType, AttachmentService, ATTACHMENT_FILE_FORM_KEY, ATTACHMENT_DATA_FORM_KEY, DataSourceConfig, DataSourceProviderType, SELECT_ALL_WHERE_CLAUSE, DATA_SOURCE_PROVIDERS, DATA_SOURCE_EXAMPLES, TssDataSourceModule, DataSourceService, stripTableName, getDataSourceId, getDateFormatForProvider, isEnterpriseProvider, isOracleProvider, SEED_POD_FILE_EXTENSION, BaseEsriService, EsriConfig, EsriMapServerService, getEsriMapServiceHttOptions, addParamsToHttpOptions, MAP_SERVER_SERVICE_MATCH_IDENTIFIER, MAP_SERVER_SERVICE_IDENTIFIER, FEATURE_SERVER_SERVICE_IDENTIFIER, IMAGE_SERVER_SERVICE_IDENTIFIER, FEATURE_SERVER_LAYER_SERVICE_IDENTIFIER, MAP_SERVER_LAYER_SERVICE_MATCH_IDENTIFIER, MAP_SERVER_LAYER_SERVICE_IDENTIFIER, LRS_SERVER_SERVICE_IDENTIFIER, LRS_SERVER_LAYERS_SERVICE_IDENTIFIER, MAP_LAYERS_SERVICE_ENDPOINT, MAP_LAYER_SERVICE_ENDPOINT, MAP_LAYER_QUERY_SERVICE_ENDPOINT, MAP_LAYER_QUERY_RELATED_RECORDS_SERVICE_ENDPOINT, LRS_SERVER_META_ENDPOINT, LRS_LAYERS_SERVICE_ENDPOINT, LRS_SERVER_APPLY_EDITS_ENDPOINT, LRS_GEOMETRY_TO_MEASURE, PORTAL_SHARING_ENDPOINT, PORTAL_OAUTH_AUTHORIZE_ENDPOINT, PORTAL_OAUTH_TOKEN_ENDPOINT, PORTAL_GENERATE_TOKEN_ENDPOINT, PORTAL_REDIRECT_URL_PARAMS_BREAK_CHARACTER, DEFAULT_PORTAL_OAUTH_REDIRECT_OPTIONS, TssEsriModule, isFeatureServerLayerUrl, isFeatureServerServiceUrl, DEFAULT_GEOMETRY_TO_MEASURE_OPTIONS, getGeometryToMeasureOptions, isCacheableEsriServiceRoute, joinAndFomatWithLayer, isLrsServerLayersServiceUrl, isLrsServerServiceUrl, extractMapServerLayerId, extractMapServerUrl, isMapServerLayerUrl, isMapServerServiceUrl, doesPathIncludePortalAccessCode, doesPathIncludePortalAccessToken, EsriPortalService, extractPortalAccessToken, getPortalOAuthRedirectUrl, getPortalSharingUrl, getPortalUrl, removePortalAccessTokenFromHash, toEsriPortalAccessToken, DEFAULT_MAP_QUERY_OPTIONS, getMapQueryOptions, toHttpQueryParams, toEsriServerToken, tryStripGdbVersion, ExportConfig, DEFAULT_EXPORT_GEOJSON_FILE_NAME, TssExportModule, ExportService, GeolocationConfig, PATH_BUILDER_EMPTY_CALIBRATION_MEASURE_VALUE, PATH_BUILDER_CALCULATED_M_DEVICE_SOURCE, GEOLOCATOR_REGISTRY, GEOLOCATION_GEOLOCATOR_ID, TssGeolocationModule, GeolocationService, BaseGeolocator, Geolocatable, GeolocationGeolocator, GeolocatorAccuracyUnit, GeolocatorCapability, GeolocatorSourceService, gpsPositionToPoint, gpsPositionsAlmostEqual, gpsPositionsToPoint, isNotValidLatitude, isNotValidLocation, isNotValidLongitude, isPositionError, isValidLatitude, isValidLocation, isValidLongitude, positionToGpsPosition, isPositionAcceptable, PositionPathBuilder, degreesToRadians, getMeasureExtent, isLine, isPoint, isPolygon, radiansToDegrees, setMeasuresByGeometricLength, GeometryConfig, SORTED_BY_MEASURE_PROPERTY_FLAG, EARTH_RADIUS_IN_KILOMETERS, EARTH_RADIUS_IN_METERS, WGS_84_SRID, TssGeometryModule, extractMeasuresFromLine, flattenLine, getDistanceToLine, getMeasureExtentFromLine, getMeasureFromFlatCoordinateSystem, getMeasureFromLatLng, getMeasure, getVerticeeInfos, getClosestVerticees, getClosestVerticee, getPoint, hasMeasureValues, singleLineHasMeasureValues, multiLineHasMeasureValues, isLineWithinBounds, isMultiPartLine, isPointOnLineString, isLatLngOnLineString, isLatLngOnLine, isPointOnLine, multiLineToCoordinates, singleLineToCoordinates, sortLineByMeasure, toLineOrMultiLineString, toLineString, toMultiLineString, toMultiPartPaths, isPointWithinBounds, isPointWithinButNotIncludingBounds, calculateCrossProductByPoints, getDistanceBetweenPoints, getDistanceBetweenPointValues, getKilometersBetweenLatLng, getMetersBetweenLatLng, getFeetBetweenLatLng, getMilesBetweenLatLng, getDistanceBetweenLatLng, getMeasureExtentFromPoint, getMeasureFromPoint, isMultiPartPoint, getSortResultForPoints, sortPointsByMeasure, toMultiPartPoint, toSinglePartPointArray, GpsGateGeolocator, GpsGateConfig, TssGpsGateModule, HttpParamInterceptor, HttpConfig, TssHttpModule, isRouteMatch, toFormDataString, toFormData, CalibrationPointLayer, CapturePosition, CenterlineLayer, evaluteFeatureDataExpression, extractFeatureDataByLayer, extractFeatureData, ALL_FIELD_CRITERIA, isDynamicDataExpression, DYNAMIC_DATA_REGEX, LrsDataService, DataSourceLrsMetadataService, EventFeatureCollection, EventFeature, EventLayer, toLrsFeature, toFeature, generateHierarchyFilters, IntersectionLayer, findLayer, LrsFeatureCollection, LrsFeature, getLayerTableName, LrsLayer, mergeFieldDomains, mergeFields, mergeLayer, mergeLayers, mergeNetworkLayers, onMergeNetworkLayerComplete, mergeLrsMetadata, mergeMapMetadata, deepMergeMapMetadata, mergeLrsMetadataSources, LrsMetadataRetriever, LRS_LAYER_VALIDATIONS, LRS_NETWORK_LAYER_VALIDATIONS, LRS_EVENT_LAYER_VALIDATIONS, LRS_METADATA_VALIDATIONS, LrsMetadataService, LrsMetadata, getLrsViewDateWhereStatement, NO_TEMPORAL_LAYER_SUPPLIED_ERROR_MSG, NO_REFERENCE_LAYER_SUPPLIED_ERROR_MSG, LRS_DATE_WHERE_CLAUSE_TEMPLATE, LRS_POINT_EVENT_WHERE_CLAUSE_TEMPLATE, LRS_LINEAR_EVENT_WHERE_CLAUSE_TEMPLATE, LrsWhereClauseBuilder, LrsConfig, TssLrsModule, NetworkFeatureCollection, NetworkFeature, NetworkLayer, NonLrsLayer, RedlineFeature, RedlineLayer, isClassBreakInfoEmpty, isRendererSymbolDefault, DEFAULT_UNIQUE_VALUE_INFO, DEFAULT_CLASS_BREAK_VALUE_INFO, DEFAULT_RENDERER_SYMBOL, LayerDrawingInfoRenderer, LayerDrawingInfo, LAYER_RENDER_TYPES, LayerRendererTypePipe, SYMBOL_LOCATION_TYPES, isUniqueValueInfoEmpty, isPointGeometryType, isLinearGeometryType, isPolygonGeometryType, POINT_GEOMETRY_TYPES, LINEAR_GEOMETRY_TYPES, POLYGON_GEOMETRY_TYPES, FeatureClassLayer, getCodedValue, getCodedValueNameOrDefault, getCodedValueName, isFieldGeometryType, isObjectIdType, getGeometryField, getGeometryFieldName, getIdField, getIdFieldFieldName, isFieldExpression, toFieldType, toFieldName, getField, getFieldAlias, isFieldNumeric, isFieldValueNumeric, FIELD_TYPE_OID, FIELD_TYPE_OID_STRING, FIELD_TYPE_STRING, FIELD_TYPE_NUMBER, FIELD_TYPE_XML, FIELD_TYPE_BLOB, FIELD_TYPE_DATE, FIELD_TYPE_DOUBLE, FIELD_TYPE_GUID, FIELD_TYPE_GEOMETRY, FIELD_TYPE_GLOBALID, FIELD_TYPE_INTEGER, FIELD_TYPE_RASTER, FIELD_TYPE_SINGLE, FIELD_TYPE_SMALL_INTEGER, ESRI_FIELD_TYPE_OID, ESRI_FIELD_TYPE_STRING, ESRI_FIELD_TYPE_NUMBER, ESRI_FIELD_TYPE_XML, ESRI_FIELD_TYPE_BLOB, ESRI_FIELD_TYPE_DATE, ESRI_FIELD_TYPE_DOUBLE, ESRI_FIELD_TYPE_GUID, ESRI_FIELD_TYPE_GEOMETRY, ESRI_FIELD_TYPE_GLOBALID, ESRI_FIELD_TYPE_INTEGER, ESRI_FIELD_TYPE_RASTER, ESRI_FIELD_TYPE_SINGLE, ESRI_FIELD_TYPE_SMALL_INTEGER, FIELD_METADATA, MapFeature, MapServerMetadata, MapTable, TssMapsModule, MapsConfig, toLayerId, FIELD_QUOTE, CriteriaOperator, TargetOperator, ValueOperator, GroupingOperator, CombiningOperator, DefaultWhereClauseBuilderOptions, WhereClauseBuilder, DeviceMotionService, MotionConfig, TssMotionModule, DeviceOrientationService, getHeadingFromOrientation, OrientationConfig, TssOrientationModule, TssPolyfillModule, PreventDefaultLinkDirective, QueuableWorkQueueManager, QueueItemStatus, QueueWorkerToken, QueueConfig, TssQueueModule, DEFAULT_WORK_QUEUE_OPTIONS, WorkQueueManager, WorkQueueStatusEventType, WorkQueueStatusTracker, SignInState, AuthService, HasRolesDirective, PrivilegeService, RoleManagerService, MISSING_PRIVILEGE_PARAM_EXCEPTION_MSG, RolePrivilegeService, RoleService, MISSING_ROLE_PARAM_EXCEPTION_MSG, UserRoleService, SecurityConfig, MISSING_USER_PARAM_EXCEPTION_MSG, TssSecurityModule, TokenInterceptor, UserService };

//# sourceMappingURL=tss-sdk.js.map