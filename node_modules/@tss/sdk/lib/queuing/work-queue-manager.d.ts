import { Observable } from 'rxjs';
import { WorkerQueueOptions } from './worker-queue-options';
import { QueueWorkerToken } from './queue-worker-token';
import { WorkQueueStatusEvent } from './work-queue-status-event';
import { WorkQueueStatusEventType } from './work-queue-status-event-type';
import { WorkQueueStatusTracker } from './work-queue-status-tracker';
import { Logger } from '../core/logging/logger.service';
import { WorkQueueStatus } from './work-queue-status';
import { QueuePayload } from './queue-payload';
export declare const DEFAULT_WORK_QUEUE_OPTIONS: {
    autoStartWorkers: boolean;
    workerCount: number;
};
/**
 * Provides the core queueing workflow for basic unit of work queues.
 * High Priority Todos:
 * * Implement worker cancelation into the worker token - RG.
 *
 * Low Priority Todos:
 * * Add queue prioritization - a queue priority flag to pull those items first from the queue - RG.
 * * Change overriding of methods to use metho attributes instead. Example: @OnWorkComplete.
 */
export declare abstract class WorkQueueManager<TInput, TOutput> {
    protected log: Logger;
    private queueChangeObserver;
    protected readonly workerTokens: QueueWorkerToken[];
    protected readonly tracker: WorkQueueStatusTracker;
    readonly queueChange: Observable<WorkQueueStatusEvent<TInput, TOutput>>;
    readonly queueStarted: Observable<WorkQueueStatusEvent<TInput, TOutput>>;
    readonly queueComplete: Observable<WorkQueueStatusEvent<TInput, TOutput>>;
    readonly options: WorkerQueueOptions;
    readonly isWorking: boolean;
    readonly status: WorkQueueStatus;
    constructor(log: Logger, options?: WorkerQueueOptions);
    /**
     * Overrides default options.
     * @param options Options to override the defaults.
     */
    setOptions(options: WorkerQueueOptions): WorkQueueManager<TInput, TOutput>;
    /**
     * Kicks off the queue workflow with the specified number of workers. If
     * the maximum number of workers are currently running, no additional workers
     * will be created (only the delta of allowed and running will be started).
     */
    startWork(): void;
    /**
     * Stops all workers from processing the queue.
     */
    stopWork(): void;
    /**
     * Implementation method to do the actual unit of work.
     * @param item The input paramater needed to process the unit of work and return an output result.
     */
    protected abstract doWork(item: TInput): Observable<TOutput>;
    /**
     * Implementation method to retrieve the next value in the queue. Note, there are no further checks
     * to verify duplicate items are not processed - it is the responsibility of the implementer of this
     * base class to never return the same item from this method. Typically the item in the queue is either
     * dequeued or marked as "processing" to prevent this potential issue.
     */
    protected abstract getNext(): Observable<TInput>;
    /**
     * Method that determines that the workers are ready to be started. Note, in this implementation it
     * makes use of an empty promise. The main reason for this is to provide a hook for other implementers
     * to setup/initialize the queue before starting the workers. Additionaly, this practices provides a
     * way to run the workers asynchronously.
     */
    protected onReady(): Observable<any>;
    protected onBeforeWorkStarted(input: TInput): Observable<TInput>;
    protected onWorkComplete(data: QueuePayload<TInput, TOutput>): Observable<QueuePayload<TInput, TOutput>>;
    protected onWorkFailed(data: QueuePayload<TInput, TOutput>, error: any): Observable<any>;
    protected getRemainingQueueCount(): Observable<number>;
    protected emitQueueChange(token: QueueWorkerToken, event: WorkQueueStatusEventType, input?: TInput, output?: TOutput): void;
    private emitWorkStarted;
    private emitWorkComplete;
    private onWorkerCompleted;
    private checkIfWorkerComplete;
    private getNextAndDoWork;
}
