import { FeatureClassLayer } from '../maps/feature-class-layer';
import { LayerDateFormat, MapLayerType, MapLayer } from '../maps/map-layer';
import { SpatialReferenceInfo } from '../maps/spatial-reference';
import { CapturePositionDefinition } from './capture-position-definition';
import { LaneMetadata } from './lane-metadata';
import { CapturePosition } from './capture-position';
export declare function getLayerTableName(layer: LrsLayer, stripLayerTableName?: boolean): string;
export interface TemporalLayer {
    fromDateFieldName?: string;
    toDateFieldName?: string;
}
export interface DataLayer {
    featureClassName: string;
}
export interface NetworkLayerMappingInfo {
    id: number;
    name?: string;
    type?: MapLayerType;
}
export interface LrsReferenceLayer extends TemporalLayer {
    routeIdFieldName: string;
    fromMeasureFieldName: string;
    toMeasureFieldName: string;
}
export interface LrsDataReferenceLayer extends LrsReferenceLayer, DataLayer {
}
export interface ChildLrsLayer {
    parentNetwork: NetworkLayerMappingInfo;
}
export interface EditableLayer {
    targetFeatureClassName?: string;
    modifiedDateFieldName?: string;
    modifiedByFieldName?: string;
}
export declare class LrsLayer extends FeatureClassLayer implements LaneMetadata, EditableLayer {
    featureClassName: string;
    lrsNetworkId?: number;
    datasetName?: string;
    unitsOfMeasure?: string;
    measurePrecision?: number;
    temporalViewDate?: Date;
    timeZoneOffset?: number;
    versionName?: string;
    isRouteEventSource?: boolean;
    isStaged?: boolean;
    dateFormat?: LayerDateFormat;
    spatialReferenceInfo?: SpatialReferenceInfo;
    fromDateFieldName?: string;
    toDateFieldName?: string;
    lrs?: NetworkLayerMappingInfo;
    targetFeatureClassName?: string;
    modifiedDateFieldName?: string;
    modifiedByFieldName?: string;
    preventOverlaps?: boolean;
    autoStopCaptureOnRecordBreak?: boolean;
    forwardLaneCountFieldName?: string;
    reverseLaneCountFieldName?: string;
    positionIdentifierFieldName?: string;
    capturePositions: CapturePositionDefinition[];
    laneDrawValueOrder?: string[];
    laneIdentifierReverseValues?: string[];
    constructor(...sources: MapLayer[]);
    getPositionByValue(value: any): CapturePositionDefinition;
    getPositions(position: CapturePosition): CapturePositionDefinition[];
    hasPosition(position: CapturePosition): boolean;
    readonly hasAnyPositions: boolean;
    readonly hasLanePosition: boolean;
    readonly hasLeftPosition: boolean;
    readonly hasRightPosition: boolean;
    readonly hasCenterPosition: boolean;
}
