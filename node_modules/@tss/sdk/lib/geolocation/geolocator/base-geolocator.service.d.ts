import { Observable } from 'rxjs';
import { GeolocatorAccuracyUnit } from './geolocator-accuracy-unit';
import { GpsPosition } from '../gps-position/gps-position';
import { GeolocatorCapability } from './geolocator-capability';
import { Logger } from '../../core/logging/logger.service';
import { Geolocator } from './geolocator';
/**
 * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
 * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
 */
import * as ɵngcc0 from '@angular/core';
export declare abstract class BaseGeolocator implements Geolocator {
    protected readonly log: Logger;
    capabilities: GeolocatorCapability[];
    accuracyUnit: GeolocatorAccuracyUnit;
    abstract readonly name: string;
    abstract readonly description: string;
    constructor(log: Logger);
    /**
     * Get the device's current position.
     */
    abstract getCurrentPosition(options?: PositionOptions): Promise<GpsPosition>;
    /**
     * Watch the current device's position.  Clear the watch by unsubscribing from
     * Observable changes.
     *
     * ```typescript
     * const subscription = this.geolocation.watchPosition()
     *                               .filter(p => Boolean(p.coords)) //Filter Out Errors
     *                               .subscribe(position =>
     *   console.log(position.coords.longitude + ' ' + position.coords.latitude)
     * );
     *
     * // To stop notifications
     * subscription.unsubscribe();
     * ```
     */
    abstract watchPosition(options?: PositionOptions): Observable<GpsPosition>;
    abstract isAvailable(): Observable<boolean>;
    hasCapability(capability: GeolocatorCapability): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<BaseGeolocator, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<BaseGeolocator>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1nZW9sb2NhdG9yLnNlcnZpY2UuZC50cyIsInNvdXJjZXMiOlsiYmFzZS1nZW9sb2NhdG9yLnNlcnZpY2UuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEdlb2xvY2F0b3JBY2N1cmFjeVVuaXQgfSBmcm9tICcuL2dlb2xvY2F0b3ItYWNjdXJhY3ktdW5pdCc7XG5pbXBvcnQgeyBHcHNQb3NpdGlvbiB9IGZyb20gJy4uL2dwcy1wb3NpdGlvbi9ncHMtcG9zaXRpb24nO1xuaW1wb3J0IHsgR2VvbG9jYXRvckNhcGFiaWxpdHkgfSBmcm9tICcuL2dlb2xvY2F0b3ItY2FwYWJpbGl0eSc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi8uLi9jb3JlL2xvZ2dpbmcvbG9nZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgR2VvbG9jYXRvciB9IGZyb20gJy4vZ2VvbG9jYXRvcic7XG4vKipcbiAqIFdyYXBwZXIgZm9yIGdlb2xvY2F0aW9uIHNlcnZpY2UuIFRoZSB3cmFwcGVyIHByaW1hcmlseSBleGlzdHMgdG8gYWJzdHJhY3QgdGhlIGRpcmVjdCBpbnRlcmFjdGlvbiB3aXRoXG4gKiB0aGUgXCJuYXZpZ2F0b3JcIiBvYmplY3QgYW5kIHRvIGFsbG93IGZvciBpbmplY3Rpbmcgb3RoZXIgaW1wbGVtZW50YXRpb25zIG9mIGdlb2xvY2F0aW9uIGZ1bmN0aW9uYWxpdHkuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIEJhc2VHZW9sb2NhdG9yIGltcGxlbWVudHMgR2VvbG9jYXRvciB7XG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGxvZzogTG9nZ2VyO1xuICAgIGNhcGFiaWxpdGllczogR2VvbG9jYXRvckNhcGFiaWxpdHlbXTtcbiAgICBhY2N1cmFjeVVuaXQ6IEdlb2xvY2F0b3JBY2N1cmFjeVVuaXQ7XG4gICAgYWJzdHJhY3QgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICAgIGFic3RyYWN0IHJlYWRvbmx5IGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgY29uc3RydWN0b3IobG9nOiBMb2dnZXIpO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGV2aWNlJ3MgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRDdXJyZW50UG9zaXRpb24ob3B0aW9ucz86IFBvc2l0aW9uT3B0aW9ucyk6IFByb21pc2U8R3BzUG9zaXRpb24+O1xuICAgIC8qKlxuICAgICAqIFdhdGNoIHRoZSBjdXJyZW50IGRldmljZSdzIHBvc2l0aW9uLiAgQ2xlYXIgdGhlIHdhdGNoIGJ5IHVuc3Vic2NyaWJpbmcgZnJvbVxuICAgICAqIE9ic2VydmFibGUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24oKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIocCA9PiBCb29sZWFuKHAuY29vcmRzKSkgLy9GaWx0ZXIgT3V0IEVycm9yc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUocG9zaXRpb24gPT5cbiAgICAgKiAgIGNvbnNvbGUubG9nKHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUgKyAnICcgKyBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUpXG4gICAgICogKTtcbiAgICAgKlxuICAgICAqIC8vIFRvIHN0b3Agbm90aWZpY2F0aW9uc1xuICAgICAqIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFic3RyYWN0IHdhdGNoUG9zaXRpb24ob3B0aW9ucz86IFBvc2l0aW9uT3B0aW9ucyk6IE9ic2VydmFibGU8R3BzUG9zaXRpb24+O1xuICAgIGFic3RyYWN0IGlzQXZhaWxhYmxlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj47XG4gICAgaGFzQ2FwYWJpbGl0eShjYXBhYmlsaXR5OiBHZW9sb2NhdG9yQ2FwYWJpbGl0eSk6IGJvb2xlYW47XG59XG4iXX0=