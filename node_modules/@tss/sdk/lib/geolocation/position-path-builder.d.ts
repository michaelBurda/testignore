import { LineString, Feature, MultiPoint, Point, Polygon, MultiLineString, MultiPolygon } from 'geojson';
import { Observable } from 'rxjs';
import { PositionPathBuilderOptions } from './position-path-builder-options';
import { Disposable } from '../core/disposable';
import { GpsPosition } from './gps-position/gps-position';
import { PositionPathUnfilteredGpsPosition } from './position-path-unfiltered-gps-position';
import { PositionPathCalibrationPosition } from './position-path-calibration-position';
import { PositionPathBuilderSummaryPosition } from './positon-path-builder-position-summary';
export declare class PositionPathBuilder implements Disposable {
    readonly parts: GpsPosition[][];
    readonly unfilteredPath: GpsPosition[];
    readonly pathBreaks: {}[];
    readonly calibratedMeasures: Map<string, PositionPathCalibrationPosition>;
    private readonly options;
    private trackSubscription;
    readonly positionCount: number;
    readonly currentPartIndex: number;
    readonly currentPart: GpsPosition[];
    readonly lastPosition: GpsPosition;
    readonly hasPosition: boolean;
    readonly isEmpty: boolean;
    readonly isValidPath: boolean;
    readonly isSinglePoint: boolean;
    constructor(options?: PositionPathBuilderOptions);
    trackPosition(positionStream: Observable<GpsPosition>): this;
    addPosition(position: GpsPosition, calibrationMeasure?: number): this;
    startNewPart(): this;
    removePositionByIndex(vertexIndex: number, partIndex?: number): this;
    removePosition(position: GpsPosition): this;
    removeCalibrationMeasure(measure: number): this;
    removeCalibrationMeasureByIndex(vertexIndex: number, partIndex?: number): this;
    addCalibrationMeasure(measure: number): this;
    addCalibrationMeasureToLastPosition(measure: number): this;
    addCalibrationMeasureAtIndex(measure: number, vertexIndex: number, partIndex?: number): this;
    forceAddPosition(position: GpsPosition): this;
    toPointFeature(properties?: {}): Feature<Point | MultiPoint>;
    toLineFeature(properties?: {}): Feature<LineString | MultiLineString>;
    toSingleLineFeature(properties?: {}): Feature<LineString>;
    toMultiLineFeature(properties?: {}): Feature<MultiLineString>;
    toPolygonFeature(properties?: {}): Feature<Polygon | MultiPolygon>;
    toMultiPolygonFeature(properties?: {}): Feature<MultiPolygon>;
    toSinglePolygonFeature(properties?: {}): Feature<Polygon>;
    toFeature(): Feature<LineString | MultiLineString | Point | MultiPoint>;
    toGeometry(): LineString | MultiLineString | Point;
    toSingleLineGeometry(calibrateMeasures?: boolean): LineString;
    toMultiLineGeometry(calibrateMeasures?: boolean): MultiLineString;
    toLineGeometry(calibrateMeasures?: boolean): LineString | MultiLineString;
    toMultiPolygonGeometry(): MultiPolygon;
    toSinglePolygonGeometry(): Polygon;
    toPolygonGeometry(): Polygon | MultiPolygon;
    toPointGeometry(): Point | MultiPoint;
    replaceLastPositionIfBetter(position: GpsPosition): boolean;
    replaceLastPosition(position: GpsPosition): this;
    getBestPosition(): GpsPosition;
    getUnfilteredPath(): PositionPathUnfilteredGpsPosition[];
    getGeometryPathSummary(): PositionPathBuilderSummaryPosition[][];
    pathContains(position: GpsPosition): boolean;
    getPositionByIndex(partIndex: number, vertexIndex: number): GpsPosition;
    dispose(): void;
    private getGeometryLinePartSummary;
    private getCalibrationMeasureLookupKey;
    private toMultiPartArray;
    private ensurePolygonIsClosed;
    private addPositionToPath;
    private addPendingCalibrationPoint;
    private trySnapCalibrationMeasureToVertex;
    private arePositionsEquivalent;
    private arePointsEquivalent;
    private tryStoreUnfilteredPath;
}
