/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import destination from '@turf/destination';
import bearing from '@turf/bearing';
import { isPositionAcceptable } from './is-position-acceptable.function';
import { setMeasuresByGeometricLength } from '../geometry/geometry/set-measures-by-geometric-length.function';
import { isMultiPartLine } from '../geometry/line/is-multi-part.function';
import { getMeasureFromPoint } from '../geometry/point/get-measure-from-point.function';
import { PATH_BUILDER_EMPTY_CALIBRATION_MEASURE_VALUE, PATH_BUILDER_CALCULATED_M_DEVICE_SOURCE } from './geolocation.constants';
import { getDistanceBetweenLatLng } from '../geometry/point/get-distance-between-points.function';
import { convertLengthUnits } from '../core/units/convert-length-units.function';
import { LengthUnit } from '../core/units/length-unit';
import { sumValues } from '../core/stats/sum-values.function';
import { getLastItem } from '../core/array/get-last-item.function';
import { isNumber } from '../core/type-check/is-number.function';
import { pointsAlmostEqual } from '../core/equality/points-almost-equal.function';
/** @type {?} */
const UNPLACED_CALIBRATION_MEASURE_KEY = 'pending';
/** @type {?} */
const DEFAULT_OPTIONS = {
    gpsRequiredAccuracyMeters: 10,
    requireAccuracy: true,
    pointEquivalencyPrecision: 8,
    returnZValues: true,
    returnMValues: true,
    mValueUnit: 'miles',
    storeUnfilteredPath: false,
    calibrationMeasureSnappingDistanceDelta: 2,
    calibrationMeasureSnappingDistanceDeltaUnit: LengthUnit.Foot
};
export class PositionPathBuilder {
    /**
     * @return {?}
     */
    get positionCount() {
        /** @type {?} */
        const counts = this.parts.map((/**
         * @param {?} part
         * @return {?}
         */
        part => part.length));
        return sumValues(counts);
    }
    /**
     * @return {?}
     */
    get currentPartIndex() {
        return this.parts.length - 1;
    }
    /**
     * @return {?}
     */
    get currentPart() {
        return this.parts[this.currentPartIndex];
    }
    /**
     * @return {?}
     */
    get lastPosition() {
        return getLastItem(this.currentPart);
    }
    /**
     * @return {?}
     */
    get hasPosition() {
        return Boolean(this.lastPosition);
    }
    /**
     * @return {?}
     */
    get isEmpty() {
        return this.currentPart.length === 0;
    }
    /**
     * @return {?}
     */
    get isValidPath() {
        return this.currentPart.length > 1;
    }
    /**
     * @return {?}
     */
    get isSinglePoint() {
        return this.parts.length === 1 && this.currentPart.length === 1;
    }
    /**
     * @param {?=} options
     */
    constructor(options) {
        this.parts = [[]];
        this.unfilteredPath = [];
        this.calibratedMeasures = new Map();
        this.options = Object.assign({}, DEFAULT_OPTIONS, options);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} positionStream
     * @return {THIS}
     */
    trackPosition(positionStream) {
        (/** @type {?} */ (this)).trackSubscription = positionStream.subscribe((/**
         * @template THIS
         * @this {THIS}
         * @param {?} position
         * @return {THIS}
         */
        position => (/** @type {?} */ (this)).addPosition(position)));
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @param {?=} calibrationMeasure
     * @return {THIS}
     */
    addPosition(position, calibrationMeasure) {
        /** @type {?} */
        const accuracyCriteriaMet = !(/** @type {?} */ (this)).options.requireAccuracy
            || isPositionAcceptable(position, (/** @type {?} */ (this)).options.gpsRequiredAccuracyMeters);
        /** @type {?} */
        const positionNotAcceptable = !position || !accuracyCriteriaMet;
        if (positionNotAcceptable) {
            return (/** @type {?} */ (this)).tryStoreUnfilteredPath(position);
        }
        if ((/** @type {?} */ (this)).isEmpty) {
            return (/** @type {?} */ (this)).forceAddPosition(position);
        }
        /** @type {?} */
        const pointsAtSameLocation = (/** @type {?} */ (this)).arePositionsEquivalent((/** @type {?} */ (this)).lastPosition, position);
        /** @type {?} */
        const bothPointsAtStandStill = (/** @type {?} */ (this)).lastPosition.speed === 0 && position.speed === 0 || pointsAtSameLocation;
        if (bothPointsAtStandStill) {
            (/** @type {?} */ (this)).tryStoreUnfilteredPath(position)
                .replaceLastPositionIfBetter(position);
            return (/** @type {?} */ (this));
        }
        (/** @type {?} */ (this)).forceAddPosition(position);
        if (isNumber(calibrationMeasure)) {
            (/** @type {?} */ (this)).addCalibrationMeasureToLastPosition(calibrationMeasure);
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    startNewPart() {
        (/** @type {?} */ (this)).parts.push([]);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} vertexIndex
     * @param {?=} partIndex
     * @return {THIS}
     */
    removePositionByIndex(vertexIndex, partIndex = 0) {
        /** @type {?} */
        const part = (/** @type {?} */ (this)).parts[partIndex];
        if (!part) {
            throw new Error(`Invalid part index" ${partIndex}`);
        }
        part.splice(vertexIndex, 1);
        /** @type {?} */
        const key = (/** @type {?} */ (this)).getCalibrationMeasureLookupKey(partIndex, vertexIndex);
        if ((/** @type {?} */ (this)).calibratedMeasures.has(key)) {
            (/** @type {?} */ (this)).calibratedMeasures.delete(key);
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @return {THIS}
     */
    removePosition(position) {
        /** @type {?} */
        let partIndex = -1;
        /** @type {?} */
        let vertexIndex = -1;
        (/** @type {?} */ (this)).parts.forEach((/**
         * @param {?} part
         * @param {?} index
         * @return {?}
         */
        (part, index) => {
            /** @type {?} */
            const foundPositionIndex = part.indexOf(position);
            if (foundPositionIndex > -1) {
                partIndex = index;
                vertexIndex = foundPositionIndex;
            }
        }));
        if (partIndex > -1 && vertexIndex > -1) {
            return (/** @type {?} */ (this)).removePositionByIndex(vertexIndex, partIndex);
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} measure
     * @return {THIS}
     */
    removeCalibrationMeasure(measure) {
        Array.from((/** @type {?} */ (this)).calibratedMeasures.values())
            .filter((/**
         * @param {?} calibration
         * @return {?}
         */
        calibration => calibration.measure === measure))
            .forEach((/**
         * @template THIS
         * @this {THIS}
         * @param {?} calibration
         * @return {THIS}
         */
        calibration => (/** @type {?} */ (this)).removeCalibrationMeasureByIndex(calibration.vertexIndex, calibration.partIndex)));
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} vertexIndex
     * @param {?=} partIndex
     * @return {THIS}
     */
    removeCalibrationMeasureByIndex(vertexIndex, partIndex = 0) {
        /** @type {?} */
        const key = (/** @type {?} */ (this)).getCalibrationMeasureLookupKey(partIndex, vertexIndex);
        if ((/** @type {?} */ (this)).calibratedMeasures.has(key)) {
            (/** @type {?} */ (this)).calibratedMeasures.delete(key);
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} measure
     * @return {THIS}
     */
    addCalibrationMeasure(measure) {
        /** @type {?} */
        const timestamp = new Date().getTime();
        const [lastVertex] = (/** @type {?} */ (this)).currentPart.slice(-1);
        if (lastVertex && lastVertex.timestamp && lastVertex.timestamp === timestamp) {
            return (/** @type {?} */ (this)).addCalibrationMeasureToLastPosition(measure);
        }
        /** @type {?} */
        const partIndex = (/** @type {?} */ (this)).currentPartIndex;
        /** @type {?} */
        const key = UNPLACED_CALIBRATION_MEASURE_KEY;
        (/** @type {?} */ (this)).calibratedMeasures.set(key, {
            measure,
            partIndex,
            vertexIndex: null,
            timestamp
        });
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} measure
     * @return {THIS}
     */
    addCalibrationMeasureToLastPosition(measure) {
        /** @type {?} */
        const partIndex = (/** @type {?} */ (this)).currentPartIndex;
        /** @type {?} */
        const lastVertexIndex = (/** @type {?} */ (this)).currentPart.length - 1;
        return (/** @type {?} */ (this)).addCalibrationMeasureAtIndex(measure, lastVertexIndex, partIndex);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} measure
     * @param {?} vertexIndex
     * @param {?=} partIndex
     * @return {THIS}
     */
    addCalibrationMeasureAtIndex(measure, vertexIndex, partIndex = 0) {
        /** @type {?} */
        const key = (/** @type {?} */ (this)).getCalibrationMeasureLookupKey(partIndex, vertexIndex);
        (/** @type {?} */ (this)).calibratedMeasures.set(key, {
            measure,
            partIndex,
            vertexIndex,
            timestamp: new Date().getTime()
        });
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @return {THIS}
     */
    forceAddPosition(position) {
        (/** @type {?} */ (this)).tryStoreUnfilteredPath(position);
        (/** @type {?} */ (this)).addPositionToPath(position);
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toPointFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toPointGeometry(),
            properties
        };
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toLineFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toLineGeometry(),
            properties
        };
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toSingleLineFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toSingleLineGeometry(),
            properties
        };
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toMultiLineFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toMultiLineGeometry(),
            properties
        };
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toPolygonFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toPolygonGeometry(),
            properties
        };
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toMultiPolygonFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toMultiPolygonGeometry(),
            properties
        };
    }
    /**
     * @param {?=} properties
     * @return {?}
     */
    toSinglePolygonFeature(properties = {}) {
        return {
            type: 'Feature',
            geometry: this.toSinglePolygonGeometry(),
            properties
        };
    }
    /**
     * @return {?}
     */
    toFeature() {
        return this.isSinglePoint
            ? (/** @type {?} */ (this.toPointFeature()))
            : this.toLineFeature();
    }
    /**
     * @return {?}
     */
    toGeometry() {
        return this.isSinglePoint
            ? (/** @type {?} */ (this.toPointGeometry()))
            : this.toLineGeometry();
    }
    /**
     * @param {?=} calibrateMeasures
     * @return {?}
     */
    toSingleLineGeometry(calibrateMeasures = true) {
        /** @type {?} */
        const line = this.toLineGeometry(calibrateMeasures);
        if (isMultiPartLine(line.coordinates)) {
            throw new Error('Cannot convert MultiLineString to LineString. Data would be lost');
        }
        return (/** @type {?} */ (line));
    }
    /**
     * @param {?=} calibrateMeasures
     * @return {?}
     */
    toMultiLineGeometry(calibrateMeasures = true) {
        /** @type {?} */
        let line = this.toLineGeometry(calibrateMeasures);
        /** @type {?} */
        const isSinglePartLine = !isMultiPartLine(line.coordinates);
        if (isSinglePartLine) {
            line = {
                type: 'MultiLineString',
                bbox: line.bbox,
                coordinates: [(/** @type {?} */ (line.coordinates))]
            };
        }
        return (/** @type {?} */ (line));
    }
    /**
     * @param {?=} calibrateMeasures
     * @return {?}
     */
    toLineGeometry(calibrateMeasures = true) {
        /** @type {?} */
        const parts = this.toMultiPartArray();
        /** @type {?} */
        const line = parts.length > 1
            ? {
                type: 'MultiLineString',
                coordinates: parts
            }
            : {
                type: 'LineString',
                coordinates: parts[0]
            };
        if (this.options.returnMValues) {
            /** @type {?} */
            const calibrationPositions = calibrateMeasures
                ? Array.from(this.calibratedMeasures.values())
                : [];
            setMeasuresByGeometricLength(line, {
                units: this.options.mValueUnit,
                hasZValues: this.options.returnZValues,
                calibrationPositions
            });
        }
        return line;
    }
    /**
     * @return {?}
     */
    toMultiPolygonGeometry() {
        /** @type {?} */
        let poly = this.toPolygonGeometry();
        /** @type {?} */
        const isSinglePolygon = poly.type === 'Polygon';
        if (isSinglePolygon) {
            poly = {
                type: 'MultiPolygon',
                bbox: poly.bbox,
                coordinates: [(/** @type {?} */ (poly.coordinates))]
            };
        }
        return (/** @type {?} */ (poly));
    }
    /**
     * @return {?}
     */
    toSinglePolygonGeometry() {
        /** @type {?} */
        const poly = this.toPolygonGeometry();
        /** @type {?} */
        const isMultiPart = poly.type === 'MultiPolygon';
        if (isMultiPart) {
            throw new Error('Cannot convert MultiPolygon to Polygon. Data would be lost');
        }
        return (/** @type {?} */ (poly));
    }
    /**
     * @return {?}
     */
    toPolygonGeometry() {
        /** @type {?} */
        const parts = this.toMultiPartArray();
        parts.forEach((/**
         * @param {?} part
         * @return {?}
         */
        part => this.ensurePolygonIsClosed(part)));
        return parts.length > 1
            ? {
                type: 'MultiPolygon',
                coordinates: [parts]
            }
            : {
                type: 'Polygon',
                coordinates: parts
            };
    }
    /**
     * @return {?}
     */
    toPointGeometry() {
        /** @type {?} */
        const parts = this.toMultiPartArray();
        return parts.length > 1
            ? { type: 'MultiPoint', coordinates: parts.map((/**
                 * @param {?} part
                 * @return {?}
                 */
                part => part[0])) }
            : { type: 'Point', coordinates: parts[0][0] };
    }
    /**
     * @param {?} position
     * @return {?}
     */
    replaceLastPositionIfBetter(position) {
        /** @type {?} */
        let wasPositionAdded = true;
        if (this.isEmpty) {
            this.addPositionToPath(position);
            return wasPositionAdded;
        }
        /** @type {?} */
        const newPositionHasBetterAccuracy = this.lastPosition.accuracy > position.accuracy;
        if (newPositionHasBetterAccuracy) {
            this.replaceLastPosition(position);
        }
        else {
            wasPositionAdded = false;
        }
        return wasPositionAdded;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @return {THIS}
     */
    replaceLastPosition(position) {
        (/** @type {?} */ (this)).currentPart[(/** @type {?} */ (this)).currentPart.length - 1] = position;
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    getBestPosition() {
        throw new Error('Not implemented yet');
    }
    /**
     * @return {?}
     */
    getUnfilteredPath() {
        return this.unfilteredPath.map((/**
         * @param {?} position
         * @return {?}
         */
        position => {
            /** @type {?} */
            const unfilteredGpsPosition = Object.assign({
                included: this.pathContains(position)
            }, position);
            return unfilteredGpsPosition;
        }));
    }
    /**
     * @return {?}
     */
    getGeometryPathSummary() {
        /** @type {?} */
        const line = this.toMultiLineGeometry(false);
        return line.coordinates.map((/**
         * @param {?} part
         * @param {?} partIndex
         * @return {?}
         */
        (part, partIndex) => this.getGeometryLinePartSummary(part, partIndex)));
    }
    /**
     * @param {?} position
     * @return {?}
     */
    pathContains(position) {
        /** @type {?} */
        const found = this.parts.find((/**
         * @param {?} part
         * @return {?}
         */
        part => part.indexOf(position) > -1));
        return Boolean(found);
    }
    /**
     * @param {?} partIndex
     * @param {?} vertexIndex
     * @return {?}
     */
    getPositionByIndex(partIndex, vertexIndex) {
        return this.parts[partIndex][vertexIndex];
    }
    /**
     * @return {?}
     */
    dispose() {
        if (this.trackSubscription) {
            this.trackSubscription.unsubscribe();
        }
        this.parts.length = 0;
    }
    /**
     * @private
     * @param {?} linePart
     * @param {?} partIndex
     * @return {?}
     */
    getGeometryLinePartSummary(linePart, partIndex) {
        return linePart.map((/**
         * @param {?} vertex
         * @param {?} vertexIndex
         * @return {?}
         */
        (vertex, vertexIndex) => {
            /** @type {?} */
            const position = this.getPositionByIndex(partIndex, vertexIndex);
            /** @type {?} */
            const calibrationKey = this.getCalibrationMeasureLookupKey(partIndex, vertexIndex);
            /** @type {?} */
            const calibrationPointMeasureValue = this.calibratedMeasures.has(calibrationKey)
                ? this.calibratedMeasures.get(calibrationKey).measure
                : PATH_BUILDER_EMPTY_CALIBRATION_MEASURE_VALUE;
            return Object.assign({
                geometricMeasure: getMeasureFromPoint(vertex),
                partIndex,
                vertexIndex,
                calibrationPointMeasureValue
            }, position);
        }));
    }
    /**
     * @private
     * @param {?} partIndex
     * @param {?} vertexIndex
     * @return {?}
     */
    getCalibrationMeasureLookupKey(partIndex, vertexIndex) {
        return `${partIndex}_${vertexIndex}`;
    }
    /**
     * @private
     * @return {?}
     */
    toMultiPartArray() {
        /** @type {?} */
        const parts = [];
        this.parts.forEach((/**
         * @param {?} part
         * @return {?}
         */
        part => {
            /** @type {?} */
            const coordinates = part.map((/**
             * @param {?} position
             * @return {?}
             */
            position => this.options.returnZValues
                ? [position.longitude, position.latitude, position.altitude || 0]
                : [position.longitude, position.latitude]));
            parts.push(coordinates);
        }));
        return parts;
    }
    /**
     * @private
     * @param {?} polygonPoints
     * @return {?}
     */
    ensurePolygonIsClosed(polygonPoints) {
        if (polygonPoints.length > 1) {
            const [first] = polygonPoints;
            /** @type {?} */
            const last = getLastItem(polygonPoints);
            const [firstLng, firstLat, firstZ] = first;
            const [lastLng, lastLat] = last;
            /** @type {?} */
            const doesPolygonNotClose = !this.arePointsEquivalent(firstLng, firstLat, lastLng, lastLat);
            if (doesPolygonNotClose) {
                /** @type {?} */
                const closingPoint = [firstLng, firstLat, firstZ || 0];
                polygonPoints.push(closingPoint);
            }
        }
    }
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    addPositionToPath(position) {
        this.currentPart.push(position);
        if (this.calibratedMeasures.has(UNPLACED_CALIBRATION_MEASURE_KEY)) {
            this.addPendingCalibrationPoint();
        }
    }
    /**
     * @private
     * @return {?}
     */
    addPendingCalibrationPoint() {
        /** @type {?} */
        const calibratonPosition = this.calibratedMeasures.get(UNPLACED_CALIBRATION_MEASURE_KEY);
        /** @type {?} */
        const calibrationTimestamp = calibratonPosition.timestamp;
        const [secondToLastPosition, lastPosition] = this.currentPart.slice(-2);
        /** @type {?} */
        const isTimestampBetweenVertices = calibrationTimestamp > secondToLastPosition.timestamp
            && calibrationTimestamp < lastPosition.timestamp;
        if (isTimestampBetweenVertices) {
            /** @type {?} */
            const totalTimeDelta = Math.abs(lastPosition.timestamp - secondToLastPosition.timestamp);
            /** @type {?} */
            const offsetTimeDelta = Math.abs(calibrationTimestamp - secondToLastPosition.timestamp);
            /** @type {?} */
            const percentOfDistance = offsetTimeDelta / totalTimeDelta;
            /** @type {?} */
            const distanceBetweenVerticesKilometers = getDistanceBetweenLatLng(secondToLastPosition.latitude, secondToLastPosition.longitude, lastPosition.latitude, lastPosition.longitude, LengthUnit.Mile);
            /** @type {?} */
            const distanceToPreviousVertexKilometers = percentOfDistance * distanceBetweenVerticesKilometers;
            /** @type {?} */
            const didSnapCalibrationMeasureToVertes = this.trySnapCalibrationMeasureToVertex(calibratonPosition.measure, distanceBetweenVerticesKilometers, distanceToPreviousVertexKilometers);
            if (didSnapCalibrationMeasureToVertes) {
                return;
            }
            /** @type {?} */
            const heading = bearing([secondToLastPosition.longitude, secondToLastPosition.latitude], [lastPosition.longitude, lastPosition.latitude]);
            /** @type {?} */
            const newPoint = destination([secondToLastPosition.longitude, secondToLastPosition.latitude], distanceToPreviousVertexKilometers, heading, { units: 'kilometers' });
            /** @type {?} */
            const spliceIndexForSecondToLastPosition = this.currentPart.length - 1;
            /** @type {?} */
            const newPosition = Object.assign({}, lastPosition, {
                longitude: newPoint.geometry.coordinates[0],
                latitude: newPoint.geometry.coordinates[1],
                deviceSource: PATH_BUILDER_CALCULATED_M_DEVICE_SOURCE
            });
            this.calibratedMeasures.delete(UNPLACED_CALIBRATION_MEASURE_KEY);
            this.addCalibrationMeasureAtIndex(calibratonPosition.measure, spliceIndexForSecondToLastPosition, this.currentPartIndex);
            this.currentPart.splice(spliceIndexForSecondToLastPosition, 0, newPosition);
        }
        else if (calibrationTimestamp >= lastPosition.timestamp) {
            this.addCalibrationMeasureToLastPosition(calibratonPosition.measure);
        }
        else {
            throw new Error(`Calibration measure timestamp '${calibratonPosition.timestamp}' can not be located between`
                + ` '${secondToLastPosition.timestamp}' and '${lastPosition.timestamp}'`);
        }
    }
    /**
     * @private
     * @param {?} calibrationMeasure
     * @param {?} totalVerticeDistanceKilometers
     * @param {?} distanceToPreviousVertexKilometers
     * @return {?}
     */
    trySnapCalibrationMeasureToVertex(calibrationMeasure, totalVerticeDistanceKilometers, distanceToPreviousVertexKilometers) {
        /** @type {?} */
        const distanceToNextVertexKilometers = totalVerticeDistanceKilometers - distanceToPreviousVertexKilometers;
        /** @type {?} */
        const distanceThresholdKilometers = convertLengthUnits(this.options.calibrationMeasureSnappingDistanceDelta, this.options.calibrationMeasureSnappingDistanceDeltaUnit, LengthUnit.Kilometer);
        /** @type {?} */
        const isPointCloseEnoughToPrevious = distanceToPreviousVertexKilometers < distanceThresholdKilometers;
        /** @type {?} */
        const isPointCloseEnoughToNext = distanceToNextVertexKilometers < distanceThresholdKilometers;
        if (isPointCloseEnoughToPrevious || isPointCloseEnoughToNext) {
            /** @type {?} */
            const previousVertexIndex = this.currentPart.length - 2;
            /** @type {?} */
            const nextVertexIndex = this.currentPart.length - 1;
            /** @type {?} */
            const vertexIndex = distanceToPreviousVertexKilometers < distanceToNextVertexKilometers
                ? previousVertexIndex
                : nextVertexIndex;
            this.addCalibrationMeasureAtIndex(calibrationMeasure, vertexIndex, this.currentPartIndex);
            this.calibratedMeasures.delete(UNPLACED_CALIBRATION_MEASURE_KEY);
            return true;
        }
        return false;
    }
    /**
     * @private
     * @param {?} position1
     * @param {?} position2
     * @return {?}
     */
    arePositionsEquivalent(position1, position2) {
        return this.arePointsEquivalent(position1.longitude, position1.latitude, position2.longitude, position2.latitude);
    }
    /**
     * @private
     * @param {?} longitude1
     * @param {?} latitude1
     * @param {?} longitude2
     * @param {?} latitude2
     * @return {?}
     */
    arePointsEquivalent(longitude1, latitude1, longitude2, latitude2) {
        return pointsAlmostEqual(longitude1, latitude1, longitude2, latitude2, this.options.pointEquivalencyPrecision);
    }
    /**
     * @private
     * @template THIS
     * @this {THIS}
     * @param {?} position
     * @return {THIS}
     */
    tryStoreUnfilteredPath(position) {
        if ((/** @type {?} */ (this)).options.storeUnfilteredPath) {
            (/** @type {?} */ (this)).unfilteredPath.push(position);
        }
        return (/** @type {?} */ (this));
    }
}
if (false) {
    /** @type {?} */
    PositionPathBuilder.prototype.parts;
    /** @type {?} */
    PositionPathBuilder.prototype.unfilteredPath;
    /** @type {?} */
    PositionPathBuilder.prototype.pathBreaks;
    /** @type {?} */
    PositionPathBuilder.prototype.calibratedMeasures;
    /**
     * @type {?}
     * @private
     */
    PositionPathBuilder.prototype.options;
    /**
     * @type {?}
     * @private
     */
    PositionPathBuilder.prototype.trackSubscription;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zaXRpb24tcGF0aC1idWlsZGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRzcy9zZGsvIiwic291cmNlcyI6WyJsaWIvZ2VvbG9jYXRpb24vcG9zaXRpb24tcGF0aC1idWlsZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFHQSxPQUFPLFdBQVcsTUFBTSxtQkFBbUIsQ0FBQztBQUM1QyxPQUFPLE9BQU8sTUFBTSxlQUFlLENBQUM7QUFLcEMsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFHekUsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sZ0VBQWdFLENBQUM7QUFDOUcsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBSTFFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG1EQUFtRCxDQUFDO0FBQ3hGLE9BQU8sRUFBRSw0Q0FBNEMsRUFBRSx1Q0FBdUMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ2hJLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHdEQUF3RCxDQUFDO0FBQ2xHLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBQ2pGLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDOUQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQ25FLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUNqRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSwrQ0FBK0MsQ0FBQzs7TUFHNUUsZ0NBQWdDLEdBQUcsU0FBUzs7TUFFNUMsZUFBZSxHQUErQjtJQUNsRCx5QkFBeUIsRUFBRSxFQUFFO0lBQzdCLGVBQWUsRUFBRSxJQUFJO0lBQ3JCLHlCQUF5QixFQUFFLENBQUM7SUFDNUIsYUFBYSxFQUFFLElBQUk7SUFDbkIsYUFBYSxFQUFFLElBQUk7SUFDbkIsVUFBVSxFQUFFLE9BQU87SUFDbkIsbUJBQW1CLEVBQUUsS0FBSztJQUMxQix1Q0FBdUMsRUFBRSxDQUFDO0lBQzFDLDJDQUEyQyxFQUFFLFVBQVUsQ0FBQyxJQUFJO0NBQzdEO0FBR0QsTUFBTSxPQUFPLG1CQUFtQjs7OztJQVE5QixJQUFJLGFBQWE7O2NBQ1QsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRzs7OztRQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBQztRQUNsRCxPQUFPLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMzQixDQUFDOzs7O0lBRUQsSUFBSSxnQkFBZ0I7UUFDbEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDL0IsQ0FBQzs7OztJQUVELElBQUksV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUMzQyxDQUFDOzs7O0lBRUQsSUFBSSxZQUFZO1FBQ2QsT0FBTyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7Ozs7SUFFRCxJQUFJLFdBQVc7UUFDYixPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDcEMsQ0FBQzs7OztJQUVELElBQUksT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7Ozs7SUFFRCxJQUFJLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNyQyxDQUFDOzs7O0lBRUQsSUFBSSxhQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0lBQ2xFLENBQUM7Ozs7SUFFRCxZQUFZLE9BQW9DO1FBQzlDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsY0FBYyxHQUFHLEVBQUUsQ0FBQztRQUN6QixJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxHQUFHLEVBQTJDLENBQUM7UUFDN0UsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxlQUFlLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDN0QsQ0FBQzs7Ozs7OztJQUVELGFBQWEsQ0FBQyxjQUF1QztRQUNuRCxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxpQkFBaUIsR0FBRyxjQUFjLENBQUMsU0FBUzs7Ozs7O1FBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEVBQUMsQ0FBQztRQUMxRixPQUFPLG1CQUFBLElBQUksRUFBQSxDQUFDO0lBQ2QsQ0FBQzs7Ozs7Ozs7SUFFRCxXQUFXLENBQUMsUUFBcUIsRUFBRSxrQkFBMkI7O2NBQ3RELG1CQUFtQixHQUFHLENBQUMsbUJBQUEsSUFBSSxFQUFBLENBQUMsT0FBTyxDQUFDLGVBQWU7ZUFDcEQsb0JBQW9CLENBQUMsUUFBUSxFQUFFLG1CQUFBLElBQUksRUFBQSxDQUFDLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQzs7Y0FDckUscUJBQXFCLEdBQUcsQ0FBQyxRQUFRLElBQUksQ0FBQyxtQkFBbUI7UUFFL0QsSUFBSSxxQkFBcUIsRUFBRTtZQUN6QixPQUFPLG1CQUFBLElBQUksRUFBQSxDQUFDLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzlDO1FBRUQsSUFBSSxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxPQUFPLEVBQUU7WUFDaEIsT0FBTyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN4Qzs7Y0FFSyxvQkFBb0IsR0FBRyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxzQkFBc0IsQ0FBQyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDOztjQUMvRSxzQkFBc0IsR0FBRyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxZQUFZLENBQUMsS0FBSyxLQUFLLENBQUMsSUFBSSxRQUFRLENBQUMsS0FBSyxLQUFLLENBQUMsSUFBSSxvQkFBb0I7UUFDNUcsSUFBSSxzQkFBc0IsRUFBRTtZQUMxQixtQkFBQSxJQUFJLEVBQUEsQ0FDRCxzQkFBc0IsQ0FBQyxRQUFRLENBQUM7aUJBQ2hDLDJCQUEyQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXpDLE9BQU8sbUJBQUEsSUFBSSxFQUFBLENBQUM7U0FDYjtRQUVELG1CQUFBLElBQUksRUFBQSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2hDLElBQUksUUFBUSxDQUFDLGtCQUFrQixDQUFDLEVBQUU7WUFDaEMsbUJBQUEsSUFBSSxFQUFBLENBQUMsbUNBQW1DLENBQUMsa0JBQWtCLENBQUMsQ0FBQztTQUM5RDtRQUVELE9BQU8sbUJBQUEsSUFBSSxFQUFBLENBQUM7SUFDZCxDQUFDOzs7Ozs7SUFFRCxZQUFZO1FBQ1YsbUJBQUEsSUFBSSxFQUFBLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNwQixPQUFPLG1CQUFBLElBQUksRUFBQSxDQUFDO0lBQ2QsQ0FBQzs7Ozs7Ozs7SUFFRCxxQkFBcUIsQ0FBQyxXQUFtQixFQUFFLFlBQW9CLENBQUM7O2NBQ3hELElBQUksR0FBRyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxNQUFNLElBQUksS0FBSyxDQUFDLHVCQUF1QixTQUFTLEVBQUUsQ0FBQyxDQUFDO1NBQ3JEO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUM7O2NBRXRCLEdBQUcsR0FBRyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyw4QkFBOEIsQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDO1FBQ3ZFLElBQUksbUJBQUEsSUFBSSxFQUFBLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3BDLG1CQUFBLElBQUksRUFBQSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNyQztRQUVELE9BQU8sbUJBQUEsSUFBSSxFQUFBLENBQUM7SUFDZCxDQUFDOzs7Ozs7O0lBRUQsY0FBYyxDQUFDLFFBQXFCOztZQUM5QixTQUFTLEdBQUcsQ0FBQyxDQUFDOztZQUNkLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFFcEIsbUJBQUEsSUFBSSxFQUFBLENBQUMsS0FBSyxDQUFDLE9BQU87Ozs7O1FBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUU7O2tCQUMzQixrQkFBa0IsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQztZQUNqRCxJQUFJLGtCQUFrQixHQUFHLENBQUMsQ0FBQyxFQUFFO2dCQUMzQixTQUFTLEdBQUcsS0FBSyxDQUFDO2dCQUNsQixXQUFXLEdBQUcsa0JBQWtCLENBQUM7YUFDbEM7UUFDSCxDQUFDLEVBQUMsQ0FBQztRQUVILElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQyxJQUFJLFdBQVcsR0FBRyxDQUFDLENBQUMsRUFBRTtZQUN0QyxPQUFPLG1CQUFBLElBQUksRUFBQSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQztTQUMzRDtRQUVELE9BQU8sbUJBQUEsSUFBSSxFQUFBLENBQUM7SUFDZCxDQUFDOzs7Ozs7O0lBRUQsd0JBQXdCLENBQUMsT0FBZTtRQUN0QyxLQUFLLENBQUMsSUFBSSxDQUFDLG1CQUFBLElBQUksRUFBQSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxDQUFDO2FBQ3pDLE1BQU07Ozs7UUFBQyxXQUFXLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEtBQUssT0FBTyxFQUFDO2FBQ3RELE9BQU87Ozs7OztRQUFDLFdBQVcsQ0FBQyxFQUFFLENBQ3JCLG1CQUFBLElBQUksRUFBQSxDQUFDLCtCQUErQixDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLFNBQVMsQ0FBQyxFQUNyRixDQUFDO1FBRUosT0FBTyxtQkFBQSxJQUFJLEVBQUEsQ0FBQztJQUNkLENBQUM7Ozs7Ozs7O0lBRUQsK0JBQStCLENBQUMsV0FBbUIsRUFBRSxZQUFvQixDQUFDOztjQUNsRSxHQUFHLEdBQUcsbUJBQUEsSUFBSSxFQUFBLENBQUMsOEJBQThCLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQztRQUN2RSxJQUFJLG1CQUFBLElBQUksRUFBQSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNwQyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDckM7UUFFRCxPQUFPLG1CQUFBLElBQUksRUFBQSxDQUFDO0lBQ2QsQ0FBQzs7Ozs7OztJQUVELHFCQUFxQixDQUFDLE9BQWU7O2NBQzdCLFNBQVMsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRTtjQUNoQyxDQUFDLFVBQVUsQ0FBQyxHQUFHLG1CQUFBLElBQUksRUFBQSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0MsSUFBSSxVQUFVLElBQUksVUFBVSxDQUFDLFNBQVMsSUFBSSxVQUFVLENBQUMsU0FBUyxLQUFLLFNBQVMsRUFBRTtZQUM1RSxPQUFPLG1CQUFBLElBQUksRUFBQSxDQUFDLG1DQUFtQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQzFEOztjQUVLLFNBQVMsR0FBRyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxnQkFBZ0I7O2NBQ2pDLEdBQUcsR0FBRyxnQ0FBZ0M7UUFDNUMsbUJBQUEsSUFBSSxFQUFBLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTtZQUMvQixPQUFPO1lBQ1AsU0FBUztZQUNULFdBQVcsRUFBRSxJQUFJO1lBQ2pCLFNBQVM7U0FDVixDQUFDLENBQUM7UUFFSCxPQUFPLG1CQUFBLElBQUksRUFBQSxDQUFDO0lBQ2QsQ0FBQzs7Ozs7OztJQUVELG1DQUFtQyxDQUFDLE9BQWU7O2NBQzNDLFNBQVMsR0FBRyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxnQkFBZ0I7O2NBQ2pDLGVBQWUsR0FBRyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUM7UUFDbkQsT0FBTyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyw0QkFBNEIsQ0FBQyxPQUFPLEVBQUUsZUFBZSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ2hGLENBQUM7Ozs7Ozs7OztJQUVELDRCQUE0QixDQUFDLE9BQWUsRUFBRSxXQUFtQixFQUFFLFNBQVMsR0FBRyxDQUFDOztjQUN4RSxHQUFHLEdBQUcsbUJBQUEsSUFBSSxFQUFBLENBQUMsOEJBQThCLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQztRQUN2RSxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFO1lBQy9CLE9BQU87WUFDUCxTQUFTO1lBQ1QsV0FBVztZQUNYLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRTtTQUNoQyxDQUFDLENBQUM7UUFFSCxPQUFPLG1CQUFBLElBQUksRUFBQSxDQUFDO0lBQ2QsQ0FBQzs7Ozs7OztJQUVELGdCQUFnQixDQUFDLFFBQXFCO1FBQ3BDLG1CQUFBLElBQUksRUFBQSxDQUFDLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3RDLG1CQUFBLElBQUksRUFBQSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2pDLE9BQU8sbUJBQUEsSUFBSSxFQUFBLENBQUM7SUFDZCxDQUFDOzs7OztJQUVELGNBQWMsQ0FBQyxVQUFVLEdBQUcsRUFBRTtRQUM1QixPQUFPO1lBQ0wsSUFBSSxFQUFFLFNBQVM7WUFDZixRQUFRLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUNoQyxVQUFVO1NBQ1gsQ0FBQztJQUNKLENBQUM7Ozs7O0lBRUQsYUFBYSxDQUFDLFVBQVUsR0FBRyxFQUFFO1FBQzNCLE9BQU87WUFDTCxJQUFJLEVBQUUsU0FBUztZQUNmLFFBQVEsRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQy9CLFVBQVU7U0FDWCxDQUFDO0lBQ0osQ0FBQzs7Ozs7SUFFRCxtQkFBbUIsQ0FBQyxVQUFVLEdBQUcsRUFBRTtRQUNqQyxPQUFPO1lBQ0wsSUFBSSxFQUFFLFNBQVM7WUFDZixRQUFRLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixFQUFFO1lBQ3JDLFVBQVU7U0FDWCxDQUFDO0lBQ0osQ0FBQzs7Ozs7SUFFRCxrQkFBa0IsQ0FBQyxVQUFVLEdBQUcsRUFBRTtRQUNoQyxPQUFPO1lBQ0wsSUFBSSxFQUFFLFNBQVM7WUFDZixRQUFRLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixFQUFFO1lBQ3BDLFVBQVU7U0FDWCxDQUFDO0lBQ0osQ0FBQzs7Ozs7SUFFRCxnQkFBZ0IsQ0FBQyxVQUFVLEdBQUcsRUFBRTtRQUM5QixPQUFPO1lBQ0wsSUFBSSxFQUFFLFNBQVM7WUFDZixRQUFRLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQ2xDLFVBQVU7U0FDWCxDQUFDO0lBQ0osQ0FBQzs7Ozs7SUFFRCxxQkFBcUIsQ0FBQyxVQUFVLEdBQUcsRUFBRTtRQUNuQyxPQUFPO1lBQ0wsSUFBSSxFQUFFLFNBQVM7WUFDZixRQUFRLEVBQUUsSUFBSSxDQUFDLHNCQUFzQixFQUFFO1lBQ3ZDLFVBQVU7U0FDWCxDQUFDO0lBQ0osQ0FBQzs7Ozs7SUFFRCxzQkFBc0IsQ0FBQyxVQUFVLEdBQUcsRUFBRTtRQUNwQyxPQUFPO1lBQ0wsSUFBSSxFQUFFLFNBQVM7WUFDZixRQUFRLEVBQUUsSUFBSSxDQUFDLHVCQUF1QixFQUFFO1lBQ3hDLFVBQVU7U0FDWCxDQUFDO0lBQ0osQ0FBQzs7OztJQUVELFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQyxhQUFhO1lBQ3ZCLENBQUMsQ0FBQyxtQkFBQSxJQUFJLENBQUMsY0FBYyxFQUFFLEVBQWtCO1lBQ3pDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDM0IsQ0FBQzs7OztJQUVELFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQyxhQUFhO1lBQ3ZCLENBQUMsQ0FBQyxtQkFBQSxJQUFJLENBQUMsZUFBZSxFQUFFLEVBQVM7WUFDakMsQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUM1QixDQUFDOzs7OztJQUVELG9CQUFvQixDQUFDLGlCQUFpQixHQUFHLElBQUk7O2NBQ3JDLElBQUksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGlCQUFpQixDQUFDO1FBQ25ELElBQUksZUFBZSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUNyQyxNQUFNLElBQUksS0FBSyxDQUFDLGtFQUFrRSxDQUFDLENBQUM7U0FDckY7UUFFRCxPQUFPLG1CQUFBLElBQUksRUFBYyxDQUFDO0lBQzVCLENBQUM7Ozs7O0lBRUQsbUJBQW1CLENBQUMsaUJBQWlCLEdBQUcsSUFBSTs7WUFDdEMsSUFBSSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsaUJBQWlCLENBQUM7O2NBQzNDLGdCQUFnQixHQUFHLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDM0QsSUFBSSxnQkFBZ0IsRUFBRTtZQUNwQixJQUFJLEdBQUc7Z0JBQ0wsSUFBSSxFQUFFLGlCQUFpQjtnQkFDdkIsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2dCQUNmLFdBQVcsRUFBRSxDQUFDLG1CQUFBLElBQUksQ0FBQyxXQUFXLEVBQWMsQ0FBQzthQUM5QyxDQUFDO1NBQ0g7UUFFRCxPQUFPLG1CQUFBLElBQUksRUFBbUIsQ0FBQztJQUNqQyxDQUFDOzs7OztJQUVELGNBQWMsQ0FBQyxpQkFBaUIsR0FBRyxJQUFJOztjQUMvQixLQUFLLEdBQWlCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTs7Y0FDN0MsSUFBSSxHQUFpQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUM7WUFDekQsQ0FBQyxDQUFDO2dCQUNBLElBQUksRUFBRSxpQkFBaUI7Z0JBQ3ZCLFdBQVcsRUFBRSxLQUFLO2FBQ25CO1lBQ0QsQ0FBQyxDQUFDO2dCQUNBLElBQUksRUFBRSxZQUFZO2dCQUNsQixXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQzthQUN0QjtRQUVILElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUU7O2tCQUN4QixvQkFBb0IsR0FBMEIsaUJBQWlCO2dCQUNuRSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FDVixJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLENBQ2pDO2dCQUNELENBQUMsQ0FBQyxFQUFFO1lBRU4sNEJBQTRCLENBQUMsSUFBSSxFQUFFO2dCQUNqQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVO2dCQUM5QixVQUFVLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhO2dCQUN0QyxvQkFBb0I7YUFDckIsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7Ozs7SUFFRCxzQkFBc0I7O1lBQ2hCLElBQUksR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUU7O2NBQzdCLGVBQWUsR0FBRyxJQUFJLENBQUMsSUFBSSxLQUFLLFNBQVM7UUFFL0MsSUFBSSxlQUFlLEVBQUU7WUFDbkIsSUFBSSxHQUFHO2dCQUNMLElBQUksRUFBRSxjQUFjO2dCQUNwQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7Z0JBQ2YsV0FBVyxFQUFFLENBQUMsbUJBQUEsSUFBSSxDQUFDLFdBQVcsRUFBZ0IsQ0FBQzthQUNoRCxDQUFDO1NBQ0g7UUFFRCxPQUFPLG1CQUFBLElBQUksRUFBZ0IsQ0FBQztJQUM5QixDQUFDOzs7O0lBRUQsdUJBQXVCOztjQUNmLElBQUksR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUU7O2NBQy9CLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxLQUFLLGNBQWM7UUFFaEQsSUFBSSxXQUFXLEVBQUU7WUFDZixNQUFNLElBQUksS0FBSyxDQUFDLDREQUE0RCxDQUFDLENBQUM7U0FDL0U7UUFFRCxPQUFPLG1CQUFBLElBQUksRUFBVyxDQUFDO0lBQ3pCLENBQUM7Ozs7SUFFRCxpQkFBaUI7O2NBQ1QsS0FBSyxHQUFpQixJQUFJLENBQUMsZ0JBQWdCLEVBQUU7UUFDbkQsS0FBSyxDQUFDLE9BQU87Ozs7UUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsRUFBQyxDQUFDO1FBRXhELE9BQU8sS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDO1lBQ3JCLENBQUMsQ0FBQztnQkFDQSxJQUFJLEVBQUUsY0FBYztnQkFDcEIsV0FBVyxFQUFFLENBQUMsS0FBSyxDQUFDO2FBQ3JCO1lBQ0QsQ0FBQyxDQUFDO2dCQUNBLElBQUksRUFBRSxTQUFTO2dCQUNmLFdBQVcsRUFBRSxLQUFLO2FBQ25CLENBQUM7SUFDTixDQUFDOzs7O0lBRUQsZUFBZTs7Y0FDUCxLQUFLLEdBQWlCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtRQUVuRCxPQUFPLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQztZQUNyQixDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsR0FBRzs7OztnQkFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBQyxFQUFFO1lBQ2pFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ2xELENBQUM7Ozs7O0lBRUQsMkJBQTJCLENBQUMsUUFBcUI7O1lBQzNDLGdCQUFnQixHQUFHLElBQUk7UUFDM0IsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNqQyxPQUFPLGdCQUFnQixDQUFDO1NBQ3pCOztjQUVLLDRCQUE0QixHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxRQUFRO1FBQ25GLElBQUksNEJBQTRCLEVBQUU7WUFDaEMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3BDO2FBQU07WUFDTCxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7U0FDMUI7UUFFRCxPQUFPLGdCQUFnQixDQUFDO0lBQzFCLENBQUM7Ozs7Ozs7SUFFRCxtQkFBbUIsQ0FBQyxRQUFxQjtRQUN2QyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxXQUFXLENBQUMsbUJBQUEsSUFBSSxFQUFBLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUM7UUFFekQsT0FBTyxtQkFBQSxJQUFJLEVBQUEsQ0FBQztJQUNkLENBQUM7Ozs7SUFFRCxlQUFlO1FBQ2IsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7Ozs7SUFFRCxpQkFBaUI7UUFDZixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRzs7OztRQUFDLFFBQVEsQ0FBQyxFQUFFOztrQkFDbEMscUJBQXFCLEdBQXNDLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQzdFLFFBQVEsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQzthQUN0QyxFQUFFLFFBQVEsQ0FBQztZQUVaLE9BQU8scUJBQXFCLENBQUM7UUFDL0IsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDOzs7O0lBRUQsc0JBQXNCOztjQUNkLElBQUksR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDO1FBRTVDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHOzs7OztRQUN6QixDQUFDLElBQWdCLEVBQUUsU0FBaUIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsRUFDMUYsQ0FBQztJQUNKLENBQUM7Ozs7O0lBRUQsWUFBWSxDQUFDLFFBQXFCOztjQUMxQixLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJOzs7O1FBQUMsSUFBSSxDQUFDLEVBQUUsQ0FDbkMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDNUI7UUFFRCxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QixDQUFDOzs7Ozs7SUFFRCxrQkFBa0IsQ0FBQyxTQUFpQixFQUFFLFdBQW1CO1FBQ3ZELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUM1QyxDQUFDOzs7O0lBRUQsT0FBTztRQUNMLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQzFCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUN0QztRQUVELElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUN4QixDQUFDOzs7Ozs7O0lBRU8sMEJBQTBCLENBQUMsUUFBb0IsRUFBRSxTQUFpQjtRQUN4RSxPQUFPLFFBQVEsQ0FBQyxHQUFHOzs7OztRQUFDLENBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxFQUFFOztrQkFDcEMsUUFBUSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDOztrQkFDMUQsY0FBYyxHQUFHLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDOztrQkFDNUUsNEJBQTRCLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUM7Z0JBQzlFLENBQUMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDLE9BQU87Z0JBQ3JELENBQUMsQ0FBQyw0Q0FBNEM7WUFFaEQsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDO2dCQUNuQixnQkFBZ0IsRUFBRSxtQkFBbUIsQ0FBQyxNQUFNLENBQUM7Z0JBQzdDLFNBQVM7Z0JBQ1QsV0FBVztnQkFDWCw0QkFBNEI7YUFDN0IsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNmLENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQzs7Ozs7OztJQUVPLDhCQUE4QixDQUFDLFNBQWlCLEVBQUUsV0FBbUI7UUFDM0UsT0FBTyxHQUFHLFNBQVMsSUFBSSxXQUFXLEVBQUUsQ0FBQztJQUN2QyxDQUFDOzs7OztJQUVPLGdCQUFnQjs7Y0FDaEIsS0FBSyxHQUFpQixFQUFFO1FBQzlCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTzs7OztRQUFDLElBQUksQ0FBQyxFQUFFOztrQkFDbEIsV0FBVyxHQUFlLElBQUksQ0FBQyxHQUFHOzs7O1lBQ3RDLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhO2dCQUNwQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUM7Z0JBQ2pFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUM1QztZQUVELEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDMUIsQ0FBQyxFQUFDLENBQUM7UUFFSCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7Ozs7OztJQUVPLHFCQUFxQixDQUFDLGFBQXlCO1FBQ3JELElBQUksYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7a0JBQ3RCLENBQUMsS0FBSyxDQUFDLEdBQUcsYUFBYTs7a0JBQ3ZCLElBQUksR0FBYSxXQUFXLENBQUMsYUFBYSxDQUFDO2tCQUMzQyxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLEdBQUcsS0FBSztrQkFDcEMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLEdBQUcsSUFBSTs7a0JBQ3pCLG1CQUFtQixHQUFHLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQztZQUUzRixJQUFJLG1CQUFtQixFQUFFOztzQkFDakIsWUFBWSxHQUFHLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLElBQUksQ0FBQyxDQUFDO2dCQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQ2xDO1NBQ0Y7SUFDSCxDQUFDOzs7Ozs7SUFFTyxpQkFBaUIsQ0FBQyxRQUFxQjtRQUM3QyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUVoQyxJQUFJLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsZ0NBQWdDLENBQUMsRUFBRTtZQUNqRSxJQUFJLENBQUMsMEJBQTBCLEVBQUUsQ0FBQztTQUNuQztJQUNILENBQUM7Ozs7O0lBRU8sMEJBQTBCOztjQUMxQixrQkFBa0IsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLGdDQUFnQyxDQUFDOztjQUNsRixvQkFBb0IsR0FBRyxrQkFBa0IsQ0FBQyxTQUFTO2NBQ25ELENBQUMsb0JBQW9CLEVBQUUsWUFBWSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7O2NBQ2pFLDBCQUEwQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixDQUFDLFNBQVM7ZUFDbkYsb0JBQW9CLEdBQUcsWUFBWSxDQUFDLFNBQVM7UUFFbEQsSUFBSSwwQkFBMEIsRUFBRTs7a0JBQ3hCLGNBQWMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsb0JBQW9CLENBQUMsU0FBUyxDQUFDOztrQkFDbEYsZUFBZSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsb0JBQW9CLEdBQUcsb0JBQW9CLENBQUMsU0FBUyxDQUFDOztrQkFDakYsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLGNBQWM7O2tCQUNwRCxpQ0FBaUMsR0FBRyx3QkFBd0IsQ0FDaEUsb0JBQW9CLENBQUMsUUFBUSxFQUM3QixvQkFBb0IsQ0FBQyxTQUFTLEVBQzlCLFlBQVksQ0FBQyxRQUFRLEVBQ3JCLFlBQVksQ0FBQyxTQUFTLEVBQ3RCLFVBQVUsQ0FBQyxJQUFJLENBQ2hCOztrQkFFSyxrQ0FBa0MsR0FBRyxpQkFBaUIsR0FBRyxpQ0FBaUM7O2tCQUMxRixpQ0FBaUMsR0FBRyxJQUFJLENBQUMsaUNBQWlDLENBQzlFLGtCQUFrQixDQUFDLE9BQU8sRUFDMUIsaUNBQWlDLEVBQ2pDLGtDQUFrQyxDQUFDO1lBRXJDLElBQUksaUNBQWlDLEVBQUU7Z0JBQ3JDLE9BQU87YUFDUjs7a0JBRUssT0FBTyxHQUFHLE9BQU8sQ0FDckIsQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLEVBQUUsb0JBQW9CLENBQUMsUUFBUSxDQUFDLEVBQy9ELENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUMsUUFBUSxDQUFDLENBQ2hEOztrQkFFSyxRQUFRLEdBQW1CLFdBQVcsQ0FDMUMsQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLEVBQUUsb0JBQW9CLENBQUMsUUFBUSxDQUFDLEVBQy9ELGtDQUFrQyxFQUNsQyxPQUFPLEVBQUUsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLENBQ2pDOztrQkFFSyxrQ0FBa0MsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDOztrQkFDaEUsV0FBVyxHQUFnQixNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxZQUFZLEVBQUU7Z0JBQy9ELFNBQVMsRUFBRSxRQUFRLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7Z0JBQzNDLFFBQVEsRUFBRSxRQUFRLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7Z0JBQzFDLFlBQVksRUFBRSx1Q0FBdUM7YUFDdEQsQ0FBQztZQUVGLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztZQUNqRSxJQUFJLENBQUMsNEJBQTRCLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLGtDQUFrQyxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ3pILElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLGtDQUFrQyxFQUFFLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQztTQUM3RTthQUFNLElBQUksb0JBQW9CLElBQUksWUFBWSxDQUFDLFNBQVMsRUFBRTtZQUN6RCxJQUFJLENBQUMsbUNBQW1DLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDdEU7YUFBTTtZQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLGtCQUFrQixDQUFDLFNBQVMsOEJBQThCO2tCQUN4RyxLQUFLLG9CQUFvQixDQUFDLFNBQVMsVUFBVSxZQUFZLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztTQUM3RTtJQUNILENBQUM7Ozs7Ozs7O0lBRU8saUNBQWlDLENBQ3ZDLGtCQUEwQixFQUMxQiw4QkFBc0MsRUFDdEMsa0NBQTBDOztjQUVwQyw4QkFBOEIsR0FBRyw4QkFBOEIsR0FBRyxrQ0FBa0M7O2NBQ3BHLDJCQUEyQixHQUFHLGtCQUFrQixDQUNwRCxJQUFJLENBQUMsT0FBTyxDQUFDLHVDQUF1QyxFQUNwRCxJQUFJLENBQUMsT0FBTyxDQUFDLDJDQUEyQyxFQUN4RCxVQUFVLENBQUMsU0FBUyxDQUNyQjs7Y0FFSyw0QkFBNEIsR0FBRyxrQ0FBa0MsR0FBRywyQkFBMkI7O2NBQy9GLHdCQUF3QixHQUFHLDhCQUE4QixHQUFHLDJCQUEyQjtRQUU3RixJQUFJLDRCQUE0QixJQUFJLHdCQUF3QixFQUFFOztrQkFDdEQsbUJBQW1CLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQzs7a0JBQ2pELGVBQWUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDOztrQkFDN0MsV0FBVyxHQUFHLGtDQUFrQyxHQUFHLDhCQUE4QjtnQkFDckYsQ0FBQyxDQUFDLG1CQUFtQjtnQkFDckIsQ0FBQyxDQUFDLGVBQWU7WUFFbkIsSUFBSSxDQUFDLDRCQUE0QixDQUFDLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUMxRixJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLGdDQUFnQyxDQUFDLENBQUM7WUFDakUsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQzs7Ozs7OztJQUVPLHNCQUFzQixDQUFDLFNBQXNCLEVBQUUsU0FBc0I7UUFDM0UsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQzdCLFNBQVMsQ0FBQyxTQUFTLEVBQ25CLFNBQVMsQ0FBQyxRQUFRLEVBQ2xCLFNBQVMsQ0FBQyxTQUFTLEVBQ25CLFNBQVMsQ0FBQyxRQUFRLENBQ25CLENBQUM7SUFDSixDQUFDOzs7Ozs7Ozs7SUFFTyxtQkFBbUIsQ0FBQyxVQUFrQixFQUFFLFNBQWlCLEVBQUUsVUFBa0IsRUFBRSxTQUFpQjtRQUN0RyxPQUFPLGlCQUFpQixDQUN0QixVQUFVLEVBQ1YsU0FBUyxFQUNULFVBQVUsRUFDVixTQUFTLEVBQ1QsSUFBSSxDQUFDLE9BQU8sQ0FBQyx5QkFBeUIsQ0FDdkMsQ0FBQztJQUNKLENBQUM7Ozs7Ozs7O0lBRU8sc0JBQXNCLENBQUMsUUFBcUI7UUFDbEQsSUFBSSxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxPQUFPLENBQUMsbUJBQW1CLEVBQUU7WUFDcEMsbUJBQUEsSUFBSSxFQUFBLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNwQztRQUVELE9BQU8sbUJBQUEsSUFBSSxFQUFBLENBQUM7SUFDZCxDQUFDO0NBQ0Y7OztJQWhsQkMsb0NBQWdDOztJQUNoQyw2Q0FBdUM7O0lBQ3ZDLHlDQUEwQjs7SUFDMUIsaURBQTBFOzs7OztJQUMxRSxzQ0FBcUQ7Ozs7O0lBQ3JELGdEQUF3QyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDNyZCBQYXJ0eS5cbmltcG9ydCB7IExpbmVTdHJpbmcsIEZlYXR1cmUsIE11bHRpUG9pbnQsIFBvaW50LCBQb2x5Z29uLCBNdWx0aUxpbmVTdHJpbmcsIE11bHRpUG9seWdvbiB9IGZyb20gJ2dlb2pzb24nO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgZGVzdGluYXRpb24gZnJvbSAnQHR1cmYvZGVzdGluYXRpb24nO1xuaW1wb3J0IGJlYXJpbmcgZnJvbSAnQHR1cmYvYmVhcmluZyc7XG5cbi8vIFRTUy5cbmltcG9ydCB7IFBvc2l0aW9uUGF0aEJ1aWxkZXJPcHRpb25zIH0gZnJvbSAnLi9wb3NpdGlvbi1wYXRoLWJ1aWxkZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnLi4vY29yZS9kaXNwb3NhYmxlJztcbmltcG9ydCB7IGlzUG9zaXRpb25BY2NlcHRhYmxlIH0gZnJvbSAnLi9pcy1wb3NpdGlvbi1hY2NlcHRhYmxlLmZ1bmN0aW9uJztcbmltcG9ydCB7IEdwc1Bvc2l0aW9uIH0gZnJvbSAnLi9ncHMtcG9zaXRpb24vZ3BzLXBvc2l0aW9uJztcbmltcG9ydCB7IFBvc2l0aW9uUGF0aFVuZmlsdGVyZWRHcHNQb3NpdGlvbiB9IGZyb20gJy4vcG9zaXRpb24tcGF0aC11bmZpbHRlcmVkLWdwcy1wb3NpdGlvbic7XG5pbXBvcnQgeyBzZXRNZWFzdXJlc0J5R2VvbWV0cmljTGVuZ3RoIH0gZnJvbSAnLi4vZ2VvbWV0cnkvZ2VvbWV0cnkvc2V0LW1lYXN1cmVzLWJ5LWdlb21ldHJpYy1sZW5ndGguZnVuY3Rpb24nO1xuaW1wb3J0IHsgaXNNdWx0aVBhcnRMaW5lIH0gZnJvbSAnLi4vZ2VvbWV0cnkvbGluZS9pcy1tdWx0aS1wYXJ0LmZ1bmN0aW9uJztcbmltcG9ydCB7IFBvc2l0aW9uUGF0aENhbGlicmF0aW9uUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLXBhdGgtY2FsaWJyYXRpb24tcG9zaXRpb24nO1xuaW1wb3J0IHsgQ2FsaWJyYXRpb25Qb3NpdGlvbiB9IGZyb20gJy4uL2dlb21ldHJ5L2xpbmUvY2FsaWJyYXRpb24vY2FsaWJyYXRpb24tcG9pbnQnO1xuaW1wb3J0IHsgUG9zaXRpb25QYXRoQnVpbGRlclN1bW1hcnlQb3NpdGlvbiB9IGZyb20gJy4vcG9zaXRvbi1wYXRoLWJ1aWxkZXItcG9zaXRpb24tc3VtbWFyeSc7XG5pbXBvcnQgeyBnZXRNZWFzdXJlRnJvbVBvaW50IH0gZnJvbSAnLi4vZ2VvbWV0cnkvcG9pbnQvZ2V0LW1lYXN1cmUtZnJvbS1wb2ludC5mdW5jdGlvbic7XG5pbXBvcnQgeyBQQVRIX0JVSUxERVJfRU1QVFlfQ0FMSUJSQVRJT05fTUVBU1VSRV9WQUxVRSwgUEFUSF9CVUlMREVSX0NBTENVTEFURURfTV9ERVZJQ0VfU09VUkNFIH0gZnJvbSAnLi9nZW9sb2NhdGlvbi5jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0RGlzdGFuY2VCZXR3ZWVuTGF0TG5nIH0gZnJvbSAnLi4vZ2VvbWV0cnkvcG9pbnQvZ2V0LWRpc3RhbmNlLWJldHdlZW4tcG9pbnRzLmZ1bmN0aW9uJztcbmltcG9ydCB7IGNvbnZlcnRMZW5ndGhVbml0cyB9IGZyb20gJy4uL2NvcmUvdW5pdHMvY29udmVydC1sZW5ndGgtdW5pdHMuZnVuY3Rpb24nO1xuaW1wb3J0IHsgTGVuZ3RoVW5pdCB9IGZyb20gJy4uL2NvcmUvdW5pdHMvbGVuZ3RoLXVuaXQnO1xuaW1wb3J0IHsgc3VtVmFsdWVzIH0gZnJvbSAnLi4vY29yZS9zdGF0cy9zdW0tdmFsdWVzLmZ1bmN0aW9uJztcbmltcG9ydCB7IGdldExhc3RJdGVtIH0gZnJvbSAnLi4vY29yZS9hcnJheS9nZXQtbGFzdC1pdGVtLmZ1bmN0aW9uJztcbmltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSAnLi4vY29yZS90eXBlLWNoZWNrL2lzLW51bWJlci5mdW5jdGlvbic7XG5pbXBvcnQgeyBwb2ludHNBbG1vc3RFcXVhbCB9IGZyb20gJy4uL2NvcmUvZXF1YWxpdHkvcG9pbnRzLWFsbW9zdC1lcXVhbC5mdW5jdGlvbic7XG5cblxuY29uc3QgVU5QTEFDRURfQ0FMSUJSQVRJT05fTUVBU1VSRV9LRVkgPSAncGVuZGluZyc7XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUzogUG9zaXRpb25QYXRoQnVpbGRlck9wdGlvbnMgPSB7XG4gIGdwc1JlcXVpcmVkQWNjdXJhY3lNZXRlcnM6IDEwLFxuICByZXF1aXJlQWNjdXJhY3k6IHRydWUsXG4gIHBvaW50RXF1aXZhbGVuY3lQcmVjaXNpb246IDgsXG4gIHJldHVyblpWYWx1ZXM6IHRydWUsXG4gIHJldHVybk1WYWx1ZXM6IHRydWUsXG4gIG1WYWx1ZVVuaXQ6ICdtaWxlcycsXG4gIHN0b3JlVW5maWx0ZXJlZFBhdGg6IGZhbHNlLFxuICBjYWxpYnJhdGlvbk1lYXN1cmVTbmFwcGluZ0Rpc3RhbmNlRGVsdGE6IDIsXG4gIGNhbGlicmF0aW9uTWVhc3VyZVNuYXBwaW5nRGlzdGFuY2VEZWx0YVVuaXQ6IExlbmd0aFVuaXQuRm9vdFxufTtcblxuXG5leHBvcnQgY2xhc3MgUG9zaXRpb25QYXRoQnVpbGRlciBpbXBsZW1lbnRzIERpc3Bvc2FibGUge1xuICByZWFkb25seSBwYXJ0czogR3BzUG9zaXRpb25bXVtdO1xuICByZWFkb25seSB1bmZpbHRlcmVkUGF0aDogR3BzUG9zaXRpb25bXTtcbiAgcmVhZG9ubHkgcGF0aEJyZWFrczoge31bXTtcbiAgcmVhZG9ubHkgY2FsaWJyYXRlZE1lYXN1cmVzOiBNYXA8c3RyaW5nLCBQb3NpdGlvblBhdGhDYWxpYnJhdGlvblBvc2l0aW9uPjtcbiAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBQb3NpdGlvblBhdGhCdWlsZGVyT3B0aW9ucztcbiAgcHJpdmF0ZSB0cmFja1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGdldCBwb3NpdGlvbkNvdW50KCk6IG51bWJlciB7XG4gICAgY29uc3QgY291bnRzID0gdGhpcy5wYXJ0cy5tYXAocGFydCA9PiBwYXJ0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHN1bVZhbHVlcyhjb3VudHMpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQYXJ0SW5kZXgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0cy5sZW5ndGggLSAxO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQYXJ0KCk6IEdwc1Bvc2l0aW9uW10ge1xuICAgIHJldHVybiB0aGlzLnBhcnRzW3RoaXMuY3VycmVudFBhcnRJbmRleF07XG4gIH1cblxuICBnZXQgbGFzdFBvc2l0aW9uKCk6IEdwc1Bvc2l0aW9uIHtcbiAgICByZXR1cm4gZ2V0TGFzdEl0ZW0odGhpcy5jdXJyZW50UGFydCk7XG4gIH1cblxuICBnZXQgaGFzUG9zaXRpb24oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5sYXN0UG9zaXRpb24pO1xuICB9XG5cbiAgZ2V0IGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFBhcnQubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgZ2V0IGlzVmFsaWRQYXRoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRQYXJ0Lmxlbmd0aCA+IDE7XG4gIH1cblxuICBnZXQgaXNTaW5nbGVQb2ludCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0cy5sZW5ndGggPT09IDEgJiYgdGhpcy5jdXJyZW50UGFydC5sZW5ndGggPT09IDE7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRpb25zPzogUG9zaXRpb25QYXRoQnVpbGRlck9wdGlvbnMpIHtcbiAgICB0aGlzLnBhcnRzID0gW1tdXTtcbiAgICB0aGlzLnVuZmlsdGVyZWRQYXRoID0gW107XG4gICAgdGhpcy5jYWxpYnJhdGVkTWVhc3VyZXMgPSBuZXcgTWFwPHN0cmluZywgUG9zaXRpb25QYXRoQ2FsaWJyYXRpb25Qb3NpdGlvbj4oKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdHJhY2tQb3NpdGlvbihwb3NpdGlvblN0cmVhbTogT2JzZXJ2YWJsZTxHcHNQb3NpdGlvbj4pOiB0aGlzIHtcbiAgICB0aGlzLnRyYWNrU3Vic2NyaXB0aW9uID0gcG9zaXRpb25TdHJlYW0uc3Vic2NyaWJlKHBvc2l0aW9uID0+IHRoaXMuYWRkUG9zaXRpb24ocG9zaXRpb24pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZFBvc2l0aW9uKHBvc2l0aW9uOiBHcHNQb3NpdGlvbiwgY2FsaWJyYXRpb25NZWFzdXJlPzogbnVtYmVyKTogdGhpcyB7XG4gICAgY29uc3QgYWNjdXJhY3lDcml0ZXJpYU1ldCA9ICF0aGlzLm9wdGlvbnMucmVxdWlyZUFjY3VyYWN5XG4gICAgICB8fCBpc1Bvc2l0aW9uQWNjZXB0YWJsZShwb3NpdGlvbiwgdGhpcy5vcHRpb25zLmdwc1JlcXVpcmVkQWNjdXJhY3lNZXRlcnMpO1xuICAgIGNvbnN0IHBvc2l0aW9uTm90QWNjZXB0YWJsZSA9ICFwb3NpdGlvbiB8fCAhYWNjdXJhY3lDcml0ZXJpYU1ldDtcblxuICAgIGlmIChwb3NpdGlvbk5vdEFjY2VwdGFibGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyeVN0b3JlVW5maWx0ZXJlZFBhdGgocG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcmNlQWRkUG9zaXRpb24ocG9zaXRpb24pO1xuICAgIH1cblxuICAgIGNvbnN0IHBvaW50c0F0U2FtZUxvY2F0aW9uID0gdGhpcy5hcmVQb3NpdGlvbnNFcXVpdmFsZW50KHRoaXMubGFzdFBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgY29uc3QgYm90aFBvaW50c0F0U3RhbmRTdGlsbCA9IHRoaXMubGFzdFBvc2l0aW9uLnNwZWVkID09PSAwICYmIHBvc2l0aW9uLnNwZWVkID09PSAwIHx8IHBvaW50c0F0U2FtZUxvY2F0aW9uO1xuICAgIGlmIChib3RoUG9pbnRzQXRTdGFuZFN0aWxsKSB7XG4gICAgICB0aGlzXG4gICAgICAgIC50cnlTdG9yZVVuZmlsdGVyZWRQYXRoKHBvc2l0aW9uKVxuICAgICAgICAucmVwbGFjZUxhc3RQb3NpdGlvbklmQmV0dGVyKHBvc2l0aW9uKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5mb3JjZUFkZFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICBpZiAoaXNOdW1iZXIoY2FsaWJyYXRpb25NZWFzdXJlKSkge1xuICAgICAgdGhpcy5hZGRDYWxpYnJhdGlvbk1lYXN1cmVUb0xhc3RQb3NpdGlvbihjYWxpYnJhdGlvbk1lYXN1cmUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhcnROZXdQYXJ0KCk6IHRoaXMge1xuICAgIHRoaXMucGFydHMucHVzaChbXSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmVQb3NpdGlvbkJ5SW5kZXgodmVydGV4SW5kZXg6IG51bWJlciwgcGFydEluZGV4OiBudW1iZXIgPSAwKTogdGhpcyB7XG4gICAgY29uc3QgcGFydCA9IHRoaXMucGFydHNbcGFydEluZGV4XTtcbiAgICBpZiAoIXBhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJ0IGluZGV4XCIgJHtwYXJ0SW5kZXh9YCk7XG4gICAgfVxuXG4gICAgcGFydC5zcGxpY2UodmVydGV4SW5kZXgsIDEpO1xuXG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRDYWxpYnJhdGlvbk1lYXN1cmVMb29rdXBLZXkocGFydEluZGV4LCB2ZXJ0ZXhJbmRleCk7XG4gICAgaWYgKHRoaXMuY2FsaWJyYXRlZE1lYXN1cmVzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLmNhbGlicmF0ZWRNZWFzdXJlcy5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbW92ZVBvc2l0aW9uKHBvc2l0aW9uOiBHcHNQb3NpdGlvbik6IHRoaXMge1xuICAgIGxldCBwYXJ0SW5kZXggPSAtMTtcbiAgICBsZXQgdmVydGV4SW5kZXggPSAtMTtcblxuICAgIHRoaXMucGFydHMuZm9yRWFjaCgocGFydCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGZvdW5kUG9zaXRpb25JbmRleCA9IHBhcnQuaW5kZXhPZihwb3NpdGlvbik7XG4gICAgICBpZiAoZm91bmRQb3NpdGlvbkluZGV4ID4gLTEpIHtcbiAgICAgICAgcGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgIHZlcnRleEluZGV4ID0gZm91bmRQb3NpdGlvbkluZGV4O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHBhcnRJbmRleCA+IC0xICYmIHZlcnRleEluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZVBvc2l0aW9uQnlJbmRleCh2ZXJ0ZXhJbmRleCwgcGFydEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbW92ZUNhbGlicmF0aW9uTWVhc3VyZShtZWFzdXJlOiBudW1iZXIpOiB0aGlzIHtcbiAgICBBcnJheS5mcm9tKHRoaXMuY2FsaWJyYXRlZE1lYXN1cmVzLnZhbHVlcygpKVxuICAgICAgLmZpbHRlcihjYWxpYnJhdGlvbiA9PiBjYWxpYnJhdGlvbi5tZWFzdXJlID09PSBtZWFzdXJlKVxuICAgICAgLmZvckVhY2goY2FsaWJyYXRpb24gPT5cbiAgICAgICAgdGhpcy5yZW1vdmVDYWxpYnJhdGlvbk1lYXN1cmVCeUluZGV4KGNhbGlicmF0aW9uLnZlcnRleEluZGV4LCBjYWxpYnJhdGlvbi5wYXJ0SW5kZXgpXG4gICAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmVDYWxpYnJhdGlvbk1lYXN1cmVCeUluZGV4KHZlcnRleEluZGV4OiBudW1iZXIsIHBhcnRJbmRleDogbnVtYmVyID0gMCk6IHRoaXMge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0Q2FsaWJyYXRpb25NZWFzdXJlTG9va3VwS2V5KHBhcnRJbmRleCwgdmVydGV4SW5kZXgpO1xuICAgIGlmICh0aGlzLmNhbGlicmF0ZWRNZWFzdXJlcy5oYXMoa2V5KSkge1xuICAgICAgdGhpcy5jYWxpYnJhdGVkTWVhc3VyZXMuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRDYWxpYnJhdGlvbk1lYXN1cmUobWVhc3VyZTogbnVtYmVyKTogdGhpcyB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgW2xhc3RWZXJ0ZXhdID0gdGhpcy5jdXJyZW50UGFydC5zbGljZSgtMSk7XG4gICAgaWYgKGxhc3RWZXJ0ZXggJiYgbGFzdFZlcnRleC50aW1lc3RhbXAgJiYgbGFzdFZlcnRleC50aW1lc3RhbXAgPT09IHRpbWVzdGFtcCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkQ2FsaWJyYXRpb25NZWFzdXJlVG9MYXN0UG9zaXRpb24obWVhc3VyZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFydEluZGV4ID0gdGhpcy5jdXJyZW50UGFydEluZGV4O1xuICAgIGNvbnN0IGtleSA9IFVOUExBQ0VEX0NBTElCUkFUSU9OX01FQVNVUkVfS0VZO1xuICAgIHRoaXMuY2FsaWJyYXRlZE1lYXN1cmVzLnNldChrZXksIHtcbiAgICAgIG1lYXN1cmUsXG4gICAgICBwYXJ0SW5kZXgsXG4gICAgICB2ZXJ0ZXhJbmRleDogbnVsbCxcbiAgICAgIHRpbWVzdGFtcFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRDYWxpYnJhdGlvbk1lYXN1cmVUb0xhc3RQb3NpdGlvbihtZWFzdXJlOiBudW1iZXIpOiB0aGlzIHtcbiAgICBjb25zdCBwYXJ0SW5kZXggPSB0aGlzLmN1cnJlbnRQYXJ0SW5kZXg7XG4gICAgY29uc3QgbGFzdFZlcnRleEluZGV4ID0gdGhpcy5jdXJyZW50UGFydC5sZW5ndGggLSAxO1xuICAgIHJldHVybiB0aGlzLmFkZENhbGlicmF0aW9uTWVhc3VyZUF0SW5kZXgobWVhc3VyZSwgbGFzdFZlcnRleEluZGV4LCBwYXJ0SW5kZXgpO1xuICB9XG5cbiAgYWRkQ2FsaWJyYXRpb25NZWFzdXJlQXRJbmRleChtZWFzdXJlOiBudW1iZXIsIHZlcnRleEluZGV4OiBudW1iZXIsIHBhcnRJbmRleCA9IDApOiB0aGlzIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmdldENhbGlicmF0aW9uTWVhc3VyZUxvb2t1cEtleShwYXJ0SW5kZXgsIHZlcnRleEluZGV4KTtcbiAgICB0aGlzLmNhbGlicmF0ZWRNZWFzdXJlcy5zZXQoa2V5LCB7XG4gICAgICBtZWFzdXJlLFxuICAgICAgcGFydEluZGV4LFxuICAgICAgdmVydGV4SW5kZXgsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZvcmNlQWRkUG9zaXRpb24ocG9zaXRpb246IEdwc1Bvc2l0aW9uKTogdGhpcyB7XG4gICAgdGhpcy50cnlTdG9yZVVuZmlsdGVyZWRQYXRoKHBvc2l0aW9uKTtcbiAgICB0aGlzLmFkZFBvc2l0aW9uVG9QYXRoKHBvc2l0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRvUG9pbnRGZWF0dXJlKHByb3BlcnRpZXMgPSB7fSk6IEZlYXR1cmU8UG9pbnQgfCBNdWx0aVBvaW50PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgIGdlb21ldHJ5OiB0aGlzLnRvUG9pbnRHZW9tZXRyeSgpLFxuICAgICAgcHJvcGVydGllc1xuICAgIH07XG4gIH1cblxuICB0b0xpbmVGZWF0dXJlKHByb3BlcnRpZXMgPSB7fSk6IEZlYXR1cmU8TGluZVN0cmluZyB8IE11bHRpTGluZVN0cmluZz4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICBnZW9tZXRyeTogdGhpcy50b0xpbmVHZW9tZXRyeSgpLFxuICAgICAgcHJvcGVydGllc1xuICAgIH07XG4gIH1cblxuICB0b1NpbmdsZUxpbmVGZWF0dXJlKHByb3BlcnRpZXMgPSB7fSk6IEZlYXR1cmU8TGluZVN0cmluZz4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICBnZW9tZXRyeTogdGhpcy50b1NpbmdsZUxpbmVHZW9tZXRyeSgpLFxuICAgICAgcHJvcGVydGllc1xuICAgIH07XG4gIH1cblxuICB0b011bHRpTGluZUZlYXR1cmUocHJvcGVydGllcyA9IHt9KTogRmVhdHVyZTxNdWx0aUxpbmVTdHJpbmc+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgZ2VvbWV0cnk6IHRoaXMudG9NdWx0aUxpbmVHZW9tZXRyeSgpLFxuICAgICAgcHJvcGVydGllc1xuICAgIH07XG4gIH1cblxuICB0b1BvbHlnb25GZWF0dXJlKHByb3BlcnRpZXMgPSB7fSk6IEZlYXR1cmU8UG9seWdvbiB8IE11bHRpUG9seWdvbj4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICBnZW9tZXRyeTogdGhpcy50b1BvbHlnb25HZW9tZXRyeSgpLFxuICAgICAgcHJvcGVydGllc1xuICAgIH07XG4gIH1cblxuICB0b011bHRpUG9seWdvbkZlYXR1cmUocHJvcGVydGllcyA9IHt9KTogRmVhdHVyZTxNdWx0aVBvbHlnb24+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgZ2VvbWV0cnk6IHRoaXMudG9NdWx0aVBvbHlnb25HZW9tZXRyeSgpLFxuICAgICAgcHJvcGVydGllc1xuICAgIH07XG4gIH1cblxuICB0b1NpbmdsZVBvbHlnb25GZWF0dXJlKHByb3BlcnRpZXMgPSB7fSk6IEZlYXR1cmU8UG9seWdvbj4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICBnZW9tZXRyeTogdGhpcy50b1NpbmdsZVBvbHlnb25HZW9tZXRyeSgpLFxuICAgICAgcHJvcGVydGllc1xuICAgIH07XG4gIH1cblxuICB0b0ZlYXR1cmUoKTogRmVhdHVyZTxMaW5lU3RyaW5nIHwgTXVsdGlMaW5lU3RyaW5nIHwgUG9pbnQgfCBNdWx0aVBvaW50PiB7XG4gICAgcmV0dXJuIHRoaXMuaXNTaW5nbGVQb2ludFxuICAgICAgPyB0aGlzLnRvUG9pbnRGZWF0dXJlKCkgYXMgRmVhdHVyZTxQb2ludD5cbiAgICAgIDogdGhpcy50b0xpbmVGZWF0dXJlKCk7XG4gIH1cblxuICB0b0dlb21ldHJ5KCk6IExpbmVTdHJpbmcgfCBNdWx0aUxpbmVTdHJpbmcgfCBQb2ludCB7XG4gICAgcmV0dXJuIHRoaXMuaXNTaW5nbGVQb2ludFxuICAgICAgPyB0aGlzLnRvUG9pbnRHZW9tZXRyeSgpIGFzIFBvaW50XG4gICAgICA6IHRoaXMudG9MaW5lR2VvbWV0cnkoKTtcbiAgfVxuXG4gIHRvU2luZ2xlTGluZUdlb21ldHJ5KGNhbGlicmF0ZU1lYXN1cmVzID0gdHJ1ZSk6IExpbmVTdHJpbmcge1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLnRvTGluZUdlb21ldHJ5KGNhbGlicmF0ZU1lYXN1cmVzKTtcbiAgICBpZiAoaXNNdWx0aVBhcnRMaW5lKGxpbmUuY29vcmRpbmF0ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IE11bHRpTGluZVN0cmluZyB0byBMaW5lU3RyaW5nLiBEYXRhIHdvdWxkIGJlIGxvc3QnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZSBhcyBMaW5lU3RyaW5nO1xuICB9XG5cbiAgdG9NdWx0aUxpbmVHZW9tZXRyeShjYWxpYnJhdGVNZWFzdXJlcyA9IHRydWUpOiBNdWx0aUxpbmVTdHJpbmcge1xuICAgIGxldCBsaW5lID0gdGhpcy50b0xpbmVHZW9tZXRyeShjYWxpYnJhdGVNZWFzdXJlcyk7XG4gICAgY29uc3QgaXNTaW5nbGVQYXJ0TGluZSA9ICFpc011bHRpUGFydExpbmUobGluZS5jb29yZGluYXRlcyk7XG4gICAgaWYgKGlzU2luZ2xlUGFydExpbmUpIHtcbiAgICAgIGxpbmUgPSB7XG4gICAgICAgIHR5cGU6ICdNdWx0aUxpbmVTdHJpbmcnLFxuICAgICAgICBiYm94OiBsaW5lLmJib3gsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbbGluZS5jb29yZGluYXRlcyBhcyBudW1iZXJbXVtdXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZSBhcyBNdWx0aUxpbmVTdHJpbmc7XG4gIH1cblxuICB0b0xpbmVHZW9tZXRyeShjYWxpYnJhdGVNZWFzdXJlcyA9IHRydWUpOiBMaW5lU3RyaW5nIHwgTXVsdGlMaW5lU3RyaW5nIHtcbiAgICBjb25zdCBwYXJ0czogbnVtYmVyW11bXVtdID0gdGhpcy50b011bHRpUGFydEFycmF5KCk7XG4gICAgY29uc3QgbGluZTogTGluZVN0cmluZyB8IE11bHRpTGluZVN0cmluZyA9IHBhcnRzLmxlbmd0aCA+IDFcbiAgICAgID8ge1xuICAgICAgICB0eXBlOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IHBhcnRzXG4gICAgICB9XG4gICAgICA6IHtcbiAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICBjb29yZGluYXRlczogcGFydHNbMF1cbiAgICAgIH07XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJldHVybk1WYWx1ZXMpIHtcbiAgICAgIGNvbnN0IGNhbGlicmF0aW9uUG9zaXRpb25zOiBDYWxpYnJhdGlvblBvc2l0aW9uW10gPSBjYWxpYnJhdGVNZWFzdXJlc1xuICAgICAgICA/IEFycmF5LmZyb20oXG4gICAgICAgICAgdGhpcy5jYWxpYnJhdGVkTWVhc3VyZXMudmFsdWVzKClcbiAgICAgICAgKVxuICAgICAgICA6IFtdO1xuXG4gICAgICBzZXRNZWFzdXJlc0J5R2VvbWV0cmljTGVuZ3RoKGxpbmUsIHtcbiAgICAgICAgdW5pdHM6IHRoaXMub3B0aW9ucy5tVmFsdWVVbml0LFxuICAgICAgICBoYXNaVmFsdWVzOiB0aGlzLm9wdGlvbnMucmV0dXJuWlZhbHVlcyxcbiAgICAgICAgY2FsaWJyYXRpb25Qb3NpdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lO1xuICB9XG5cbiAgdG9NdWx0aVBvbHlnb25HZW9tZXRyeSgpOiBNdWx0aVBvbHlnb24ge1xuICAgIGxldCBwb2x5ID0gdGhpcy50b1BvbHlnb25HZW9tZXRyeSgpO1xuICAgIGNvbnN0IGlzU2luZ2xlUG9seWdvbiA9IHBvbHkudHlwZSA9PT0gJ1BvbHlnb24nO1xuXG4gICAgaWYgKGlzU2luZ2xlUG9seWdvbikge1xuICAgICAgcG9seSA9IHtcbiAgICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICAgIGJib3g6IHBvbHkuYmJveCxcbiAgICAgICAgY29vcmRpbmF0ZXM6IFtwb2x5LmNvb3JkaW5hdGVzIGFzIG51bWJlcltdW11bXV1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHkgYXMgTXVsdGlQb2x5Z29uO1xuICB9XG5cbiAgdG9TaW5nbGVQb2x5Z29uR2VvbWV0cnkoKTogUG9seWdvbiB7XG4gICAgY29uc3QgcG9seSA9IHRoaXMudG9Qb2x5Z29uR2VvbWV0cnkoKTtcbiAgICBjb25zdCBpc011bHRpUGFydCA9IHBvbHkudHlwZSA9PT0gJ011bHRpUG9seWdvbic7XG5cbiAgICBpZiAoaXNNdWx0aVBhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgTXVsdGlQb2x5Z29uIHRvIFBvbHlnb24uIERhdGEgd291bGQgYmUgbG9zdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2x5IGFzIFBvbHlnb247XG4gIH1cblxuICB0b1BvbHlnb25HZW9tZXRyeSgpOiBQb2x5Z29uIHwgTXVsdGlQb2x5Z29uIHtcbiAgICBjb25zdCBwYXJ0czogbnVtYmVyW11bXVtdID0gdGhpcy50b011bHRpUGFydEFycmF5KCk7XG4gICAgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHRoaXMuZW5zdXJlUG9seWdvbklzQ2xvc2VkKHBhcnQpKTtcblxuICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPiAxXG4gICAgICA/IHtcbiAgICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbcGFydHNdXG4gICAgICB9XG4gICAgICA6IHtcbiAgICAgICAgdHlwZTogJ1BvbHlnb24nLFxuICAgICAgICBjb29yZGluYXRlczogcGFydHNcbiAgICAgIH07XG4gIH1cblxuICB0b1BvaW50R2VvbWV0cnkoKTogUG9pbnQgfCBNdWx0aVBvaW50IHtcbiAgICBjb25zdCBwYXJ0czogbnVtYmVyW11bXVtdID0gdGhpcy50b011bHRpUGFydEFycmF5KCk7XG5cbiAgICByZXR1cm4gcGFydHMubGVuZ3RoID4gMVxuICAgICAgPyB7IHR5cGU6ICdNdWx0aVBvaW50JywgY29vcmRpbmF0ZXM6IHBhcnRzLm1hcChwYXJ0ID0+IHBhcnRbMF0pIH1cbiAgICAgIDogeyB0eXBlOiAnUG9pbnQnLCBjb29yZGluYXRlczogcGFydHNbMF1bMF0gfTtcbiAgfVxuXG4gIHJlcGxhY2VMYXN0UG9zaXRpb25JZkJldHRlcihwb3NpdGlvbjogR3BzUG9zaXRpb24pOiBib29sZWFuIHtcbiAgICBsZXQgd2FzUG9zaXRpb25BZGRlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgdGhpcy5hZGRQb3NpdGlvblRvUGF0aChwb3NpdGlvbik7XG4gICAgICByZXR1cm4gd2FzUG9zaXRpb25BZGRlZDtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdQb3NpdGlvbkhhc0JldHRlckFjY3VyYWN5ID0gdGhpcy5sYXN0UG9zaXRpb24uYWNjdXJhY3kgPiBwb3NpdGlvbi5hY2N1cmFjeTtcbiAgICBpZiAobmV3UG9zaXRpb25IYXNCZXR0ZXJBY2N1cmFjeSkge1xuICAgICAgdGhpcy5yZXBsYWNlTGFzdFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FzUG9zaXRpb25BZGRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB3YXNQb3NpdGlvbkFkZGVkO1xuICB9XG5cbiAgcmVwbGFjZUxhc3RQb3NpdGlvbihwb3NpdGlvbjogR3BzUG9zaXRpb24pOiB0aGlzIHtcbiAgICB0aGlzLmN1cnJlbnRQYXJ0W3RoaXMuY3VycmVudFBhcnQubGVuZ3RoIC0gMV0gPSBwb3NpdGlvbjtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0QmVzdFBvc2l0aW9uKCk6IEdwc1Bvc2l0aW9uIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgfVxuXG4gIGdldFVuZmlsdGVyZWRQYXRoKCk6IFBvc2l0aW9uUGF0aFVuZmlsdGVyZWRHcHNQb3NpdGlvbltdIHtcbiAgICByZXR1cm4gdGhpcy51bmZpbHRlcmVkUGF0aC5tYXAocG9zaXRpb24gPT4ge1xuICAgICAgY29uc3QgdW5maWx0ZXJlZEdwc1Bvc2l0aW9uOiBQb3NpdGlvblBhdGhVbmZpbHRlcmVkR3BzUG9zaXRpb24gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgaW5jbHVkZWQ6IHRoaXMucGF0aENvbnRhaW5zKHBvc2l0aW9uKVxuICAgICAgfSwgcG9zaXRpb24pO1xuXG4gICAgICByZXR1cm4gdW5maWx0ZXJlZEdwc1Bvc2l0aW9uO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0R2VvbWV0cnlQYXRoU3VtbWFyeSgpOiBQb3NpdGlvblBhdGhCdWlsZGVyU3VtbWFyeVBvc2l0aW9uW11bXSB7XG4gICAgY29uc3QgbGluZSA9IHRoaXMudG9NdWx0aUxpbmVHZW9tZXRyeShmYWxzZSk7XG5cbiAgICByZXR1cm4gbGluZS5jb29yZGluYXRlcy5tYXAoXG4gICAgICAocGFydDogbnVtYmVyW11bXSwgcGFydEluZGV4OiBudW1iZXIpID0+IHRoaXMuZ2V0R2VvbWV0cnlMaW5lUGFydFN1bW1hcnkocGFydCwgcGFydEluZGV4KVxuICAgICk7XG4gIH1cblxuICBwYXRoQ29udGFpbnMocG9zaXRpb246IEdwc1Bvc2l0aW9uKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZm91bmQgPSB0aGlzLnBhcnRzLmZpbmQocGFydCA9PlxuICAgICAgcGFydC5pbmRleE9mKHBvc2l0aW9uKSA+IC0xXG4gICAgKTtcblxuICAgIHJldHVybiBCb29sZWFuKGZvdW5kKTtcbiAgfVxuXG4gIGdldFBvc2l0aW9uQnlJbmRleChwYXJ0SW5kZXg6IG51bWJlciwgdmVydGV4SW5kZXg6IG51bWJlcik6IEdwc1Bvc2l0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0c1twYXJ0SW5kZXhdW3ZlcnRleEluZGV4XTtcbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudHJhY2tTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMudHJhY2tTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcnRzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBwcml2YXRlIGdldEdlb21ldHJ5TGluZVBhcnRTdW1tYXJ5KGxpbmVQYXJ0OiBudW1iZXJbXVtdLCBwYXJ0SW5kZXg6IG51bWJlcik6IFBvc2l0aW9uUGF0aEJ1aWxkZXJTdW1tYXJ5UG9zaXRpb25bXSB7XG4gICAgcmV0dXJuIGxpbmVQYXJ0Lm1hcCgodmVydGV4LCB2ZXJ0ZXhJbmRleCkgPT4ge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uQnlJbmRleChwYXJ0SW5kZXgsIHZlcnRleEluZGV4KTtcbiAgICAgIGNvbnN0IGNhbGlicmF0aW9uS2V5ID0gdGhpcy5nZXRDYWxpYnJhdGlvbk1lYXN1cmVMb29rdXBLZXkocGFydEluZGV4LCB2ZXJ0ZXhJbmRleCk7XG4gICAgICBjb25zdCBjYWxpYnJhdGlvblBvaW50TWVhc3VyZVZhbHVlID0gdGhpcy5jYWxpYnJhdGVkTWVhc3VyZXMuaGFzKGNhbGlicmF0aW9uS2V5KVxuICAgICAgICA/IHRoaXMuY2FsaWJyYXRlZE1lYXN1cmVzLmdldChjYWxpYnJhdGlvbktleSkubWVhc3VyZVxuICAgICAgICA6IFBBVEhfQlVJTERFUl9FTVBUWV9DQUxJQlJBVElPTl9NRUFTVVJFX1ZBTFVFO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGdlb21ldHJpY01lYXN1cmU6IGdldE1lYXN1cmVGcm9tUG9pbnQodmVydGV4KSxcbiAgICAgICAgcGFydEluZGV4LFxuICAgICAgICB2ZXJ0ZXhJbmRleCxcbiAgICAgICAgY2FsaWJyYXRpb25Qb2ludE1lYXN1cmVWYWx1ZVxuICAgICAgfSwgcG9zaXRpb24pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDYWxpYnJhdGlvbk1lYXN1cmVMb29rdXBLZXkocGFydEluZGV4OiBudW1iZXIsIHZlcnRleEluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHtwYXJ0SW5kZXh9XyR7dmVydGV4SW5kZXh9YDtcbiAgfVxuXG4gIHByaXZhdGUgdG9NdWx0aVBhcnRBcnJheSgpOiBudW1iZXJbXVtdW10ge1xuICAgIGNvbnN0IHBhcnRzOiBudW1iZXJbXVtdW10gPSBbXTtcbiAgICB0aGlzLnBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICBjb25zdCBjb29yZGluYXRlczogbnVtYmVyW11bXSA9IHBhcnQubWFwKFxuICAgICAgICBwb3NpdGlvbiA9PiB0aGlzLm9wdGlvbnMucmV0dXJuWlZhbHVlc1xuICAgICAgICAgID8gW3Bvc2l0aW9uLmxvbmdpdHVkZSwgcG9zaXRpb24ubGF0aXR1ZGUsIHBvc2l0aW9uLmFsdGl0dWRlIHx8IDBdXG4gICAgICAgICAgOiBbcG9zaXRpb24ubG9uZ2l0dWRlLCBwb3NpdGlvbi5sYXRpdHVkZV1cbiAgICAgICk7XG5cbiAgICAgIHBhcnRzLnB1c2goY29vcmRpbmF0ZXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgcHJpdmF0ZSBlbnN1cmVQb2x5Z29uSXNDbG9zZWQocG9seWdvblBvaW50czogbnVtYmVyW11bXSk6IHZvaWQge1xuICAgIGlmIChwb2x5Z29uUG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IFtmaXJzdF0gPSBwb2x5Z29uUG9pbnRzO1xuICAgICAgY29uc3QgbGFzdDogbnVtYmVyW10gPSBnZXRMYXN0SXRlbShwb2x5Z29uUG9pbnRzKTtcbiAgICAgIGNvbnN0IFtmaXJzdExuZywgZmlyc3RMYXQsIGZpcnN0Wl0gPSBmaXJzdDtcbiAgICAgIGNvbnN0IFtsYXN0TG5nLCBsYXN0TGF0XSA9IGxhc3Q7XG4gICAgICBjb25zdCBkb2VzUG9seWdvbk5vdENsb3NlID0gIXRoaXMuYXJlUG9pbnRzRXF1aXZhbGVudChmaXJzdExuZywgZmlyc3RMYXQsIGxhc3RMbmcsIGxhc3RMYXQpO1xuXG4gICAgICBpZiAoZG9lc1BvbHlnb25Ob3RDbG9zZSkge1xuICAgICAgICBjb25zdCBjbG9zaW5nUG9pbnQgPSBbZmlyc3RMbmcsIGZpcnN0TGF0LCBmaXJzdFogfHwgMF07XG4gICAgICAgIHBvbHlnb25Qb2ludHMucHVzaChjbG9zaW5nUG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYWRkUG9zaXRpb25Ub1BhdGgocG9zaXRpb246IEdwc1Bvc2l0aW9uKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50UGFydC5wdXNoKHBvc2l0aW9uKTtcblxuICAgIGlmICh0aGlzLmNhbGlicmF0ZWRNZWFzdXJlcy5oYXMoVU5QTEFDRURfQ0FMSUJSQVRJT05fTUVBU1VSRV9LRVkpKSB7XG4gICAgICB0aGlzLmFkZFBlbmRpbmdDYWxpYnJhdGlvblBvaW50KCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhZGRQZW5kaW5nQ2FsaWJyYXRpb25Qb2ludCgpOiB2b2lkIHtcbiAgICBjb25zdCBjYWxpYnJhdG9uUG9zaXRpb24gPSB0aGlzLmNhbGlicmF0ZWRNZWFzdXJlcy5nZXQoVU5QTEFDRURfQ0FMSUJSQVRJT05fTUVBU1VSRV9LRVkpO1xuICAgIGNvbnN0IGNhbGlicmF0aW9uVGltZXN0YW1wID0gY2FsaWJyYXRvblBvc2l0aW9uLnRpbWVzdGFtcDtcbiAgICBjb25zdCBbc2Vjb25kVG9MYXN0UG9zaXRpb24sIGxhc3RQb3NpdGlvbl0gPSB0aGlzLmN1cnJlbnRQYXJ0LnNsaWNlKC0yKTtcbiAgICBjb25zdCBpc1RpbWVzdGFtcEJldHdlZW5WZXJ0aWNlcyA9IGNhbGlicmF0aW9uVGltZXN0YW1wID4gc2Vjb25kVG9MYXN0UG9zaXRpb24udGltZXN0YW1wXG4gICAgICAmJiBjYWxpYnJhdGlvblRpbWVzdGFtcCA8IGxhc3RQb3NpdGlvbi50aW1lc3RhbXA7XG5cbiAgICBpZiAoaXNUaW1lc3RhbXBCZXR3ZWVuVmVydGljZXMpIHtcbiAgICAgIGNvbnN0IHRvdGFsVGltZURlbHRhID0gTWF0aC5hYnMobGFzdFBvc2l0aW9uLnRpbWVzdGFtcCAtIHNlY29uZFRvTGFzdFBvc2l0aW9uLnRpbWVzdGFtcCk7XG4gICAgICBjb25zdCBvZmZzZXRUaW1lRGVsdGEgPSBNYXRoLmFicyhjYWxpYnJhdGlvblRpbWVzdGFtcCAtIHNlY29uZFRvTGFzdFBvc2l0aW9uLnRpbWVzdGFtcCk7XG4gICAgICBjb25zdCBwZXJjZW50T2ZEaXN0YW5jZSA9IG9mZnNldFRpbWVEZWx0YSAvIHRvdGFsVGltZURlbHRhO1xuICAgICAgY29uc3QgZGlzdGFuY2VCZXR3ZWVuVmVydGljZXNLaWxvbWV0ZXJzID0gZ2V0RGlzdGFuY2VCZXR3ZWVuTGF0TG5nKFxuICAgICAgICBzZWNvbmRUb0xhc3RQb3NpdGlvbi5sYXRpdHVkZSxcbiAgICAgICAgc2Vjb25kVG9MYXN0UG9zaXRpb24ubG9uZ2l0dWRlLFxuICAgICAgICBsYXN0UG9zaXRpb24ubGF0aXR1ZGUsXG4gICAgICAgIGxhc3RQb3NpdGlvbi5sb25naXR1ZGUsXG4gICAgICAgIExlbmd0aFVuaXQuTWlsZVxuICAgICAgKTtcblxuICAgICAgY29uc3QgZGlzdGFuY2VUb1ByZXZpb3VzVmVydGV4S2lsb21ldGVycyA9IHBlcmNlbnRPZkRpc3RhbmNlICogZGlzdGFuY2VCZXR3ZWVuVmVydGljZXNLaWxvbWV0ZXJzO1xuICAgICAgY29uc3QgZGlkU25hcENhbGlicmF0aW9uTWVhc3VyZVRvVmVydGVzID0gdGhpcy50cnlTbmFwQ2FsaWJyYXRpb25NZWFzdXJlVG9WZXJ0ZXgoXG4gICAgICAgIGNhbGlicmF0b25Qb3NpdGlvbi5tZWFzdXJlLFxuICAgICAgICBkaXN0YW5jZUJldHdlZW5WZXJ0aWNlc0tpbG9tZXRlcnMsXG4gICAgICAgIGRpc3RhbmNlVG9QcmV2aW91c1ZlcnRleEtpbG9tZXRlcnMpO1xuXG4gICAgICBpZiAoZGlkU25hcENhbGlicmF0aW9uTWVhc3VyZVRvVmVydGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGVhZGluZyA9IGJlYXJpbmcoXG4gICAgICAgIFtzZWNvbmRUb0xhc3RQb3NpdGlvbi5sb25naXR1ZGUsIHNlY29uZFRvTGFzdFBvc2l0aW9uLmxhdGl0dWRlXSxcbiAgICAgICAgW2xhc3RQb3NpdGlvbi5sb25naXR1ZGUsIGxhc3RQb3NpdGlvbi5sYXRpdHVkZV1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG5ld1BvaW50OiBGZWF0dXJlPFBvaW50PiA9IGRlc3RpbmF0aW9uKFxuICAgICAgICBbc2Vjb25kVG9MYXN0UG9zaXRpb24ubG9uZ2l0dWRlLCBzZWNvbmRUb0xhc3RQb3NpdGlvbi5sYXRpdHVkZV0sXG4gICAgICAgIGRpc3RhbmNlVG9QcmV2aW91c1ZlcnRleEtpbG9tZXRlcnMsXG4gICAgICAgIGhlYWRpbmcsIHsgdW5pdHM6ICdraWxvbWV0ZXJzJyB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCBzcGxpY2VJbmRleEZvclNlY29uZFRvTGFzdFBvc2l0aW9uID0gdGhpcy5jdXJyZW50UGFydC5sZW5ndGggLSAxO1xuICAgICAgY29uc3QgbmV3UG9zaXRpb246IEdwc1Bvc2l0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgbGFzdFBvc2l0aW9uLCB7XG4gICAgICAgIGxvbmdpdHVkZTogbmV3UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgIGxhdGl0dWRlOiBuZXdQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSxcbiAgICAgICAgZGV2aWNlU291cmNlOiBQQVRIX0JVSUxERVJfQ0FMQ1VMQVRFRF9NX0RFVklDRV9TT1VSQ0VcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmNhbGlicmF0ZWRNZWFzdXJlcy5kZWxldGUoVU5QTEFDRURfQ0FMSUJSQVRJT05fTUVBU1VSRV9LRVkpO1xuICAgICAgdGhpcy5hZGRDYWxpYnJhdGlvbk1lYXN1cmVBdEluZGV4KGNhbGlicmF0b25Qb3NpdGlvbi5tZWFzdXJlLCBzcGxpY2VJbmRleEZvclNlY29uZFRvTGFzdFBvc2l0aW9uLCB0aGlzLmN1cnJlbnRQYXJ0SW5kZXgpO1xuICAgICAgdGhpcy5jdXJyZW50UGFydC5zcGxpY2Uoc3BsaWNlSW5kZXhGb3JTZWNvbmRUb0xhc3RQb3NpdGlvbiwgMCwgbmV3UG9zaXRpb24pO1xuICAgIH0gZWxzZSBpZiAoY2FsaWJyYXRpb25UaW1lc3RhbXAgPj0gbGFzdFBvc2l0aW9uLnRpbWVzdGFtcCkge1xuICAgICAgdGhpcy5hZGRDYWxpYnJhdGlvbk1lYXN1cmVUb0xhc3RQb3NpdGlvbihjYWxpYnJhdG9uUG9zaXRpb24ubWVhc3VyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsaWJyYXRpb24gbWVhc3VyZSB0aW1lc3RhbXAgJyR7Y2FsaWJyYXRvblBvc2l0aW9uLnRpbWVzdGFtcH0nIGNhbiBub3QgYmUgbG9jYXRlZCBiZXR3ZWVuYFxuICAgICAgICArIGAgJyR7c2Vjb25kVG9MYXN0UG9zaXRpb24udGltZXN0YW1wfScgYW5kICcke2xhc3RQb3NpdGlvbi50aW1lc3RhbXB9J2ApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJ5U25hcENhbGlicmF0aW9uTWVhc3VyZVRvVmVydGV4KFxuICAgIGNhbGlicmF0aW9uTWVhc3VyZTogbnVtYmVyLFxuICAgIHRvdGFsVmVydGljZURpc3RhbmNlS2lsb21ldGVyczogbnVtYmVyLFxuICAgIGRpc3RhbmNlVG9QcmV2aW91c1ZlcnRleEtpbG9tZXRlcnM6IG51bWJlclxuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBkaXN0YW5jZVRvTmV4dFZlcnRleEtpbG9tZXRlcnMgPSB0b3RhbFZlcnRpY2VEaXN0YW5jZUtpbG9tZXRlcnMgLSBkaXN0YW5jZVRvUHJldmlvdXNWZXJ0ZXhLaWxvbWV0ZXJzO1xuICAgIGNvbnN0IGRpc3RhbmNlVGhyZXNob2xkS2lsb21ldGVycyA9IGNvbnZlcnRMZW5ndGhVbml0cyhcbiAgICAgIHRoaXMub3B0aW9ucy5jYWxpYnJhdGlvbk1lYXN1cmVTbmFwcGluZ0Rpc3RhbmNlRGVsdGEsXG4gICAgICB0aGlzLm9wdGlvbnMuY2FsaWJyYXRpb25NZWFzdXJlU25hcHBpbmdEaXN0YW5jZURlbHRhVW5pdCxcbiAgICAgIExlbmd0aFVuaXQuS2lsb21ldGVyXG4gICAgKTtcblxuICAgIGNvbnN0IGlzUG9pbnRDbG9zZUVub3VnaFRvUHJldmlvdXMgPSBkaXN0YW5jZVRvUHJldmlvdXNWZXJ0ZXhLaWxvbWV0ZXJzIDwgZGlzdGFuY2VUaHJlc2hvbGRLaWxvbWV0ZXJzO1xuICAgIGNvbnN0IGlzUG9pbnRDbG9zZUVub3VnaFRvTmV4dCA9IGRpc3RhbmNlVG9OZXh0VmVydGV4S2lsb21ldGVycyA8IGRpc3RhbmNlVGhyZXNob2xkS2lsb21ldGVycztcblxuICAgIGlmIChpc1BvaW50Q2xvc2VFbm91Z2hUb1ByZXZpb3VzIHx8IGlzUG9pbnRDbG9zZUVub3VnaFRvTmV4dCkge1xuICAgICAgY29uc3QgcHJldmlvdXNWZXJ0ZXhJbmRleCA9IHRoaXMuY3VycmVudFBhcnQubGVuZ3RoIC0gMjtcbiAgICAgIGNvbnN0IG5leHRWZXJ0ZXhJbmRleCA9IHRoaXMuY3VycmVudFBhcnQubGVuZ3RoIC0gMTtcbiAgICAgIGNvbnN0IHZlcnRleEluZGV4ID0gZGlzdGFuY2VUb1ByZXZpb3VzVmVydGV4S2lsb21ldGVycyA8IGRpc3RhbmNlVG9OZXh0VmVydGV4S2lsb21ldGVyc1xuICAgICAgICA/IHByZXZpb3VzVmVydGV4SW5kZXhcbiAgICAgICAgOiBuZXh0VmVydGV4SW5kZXg7XG5cbiAgICAgIHRoaXMuYWRkQ2FsaWJyYXRpb25NZWFzdXJlQXRJbmRleChjYWxpYnJhdGlvbk1lYXN1cmUsIHZlcnRleEluZGV4LCB0aGlzLmN1cnJlbnRQYXJ0SW5kZXgpO1xuICAgICAgdGhpcy5jYWxpYnJhdGVkTWVhc3VyZXMuZGVsZXRlKFVOUExBQ0VEX0NBTElCUkFUSU9OX01FQVNVUkVfS0VZKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgYXJlUG9zaXRpb25zRXF1aXZhbGVudChwb3NpdGlvbjE6IEdwc1Bvc2l0aW9uLCBwb3NpdGlvbjI6IEdwc1Bvc2l0aW9uKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXJlUG9pbnRzRXF1aXZhbGVudChcbiAgICAgIHBvc2l0aW9uMS5sb25naXR1ZGUsXG4gICAgICBwb3NpdGlvbjEubGF0aXR1ZGUsXG4gICAgICBwb3NpdGlvbjIubG9uZ2l0dWRlLFxuICAgICAgcG9zaXRpb24yLmxhdGl0dWRlXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgYXJlUG9pbnRzRXF1aXZhbGVudChsb25naXR1ZGUxOiBudW1iZXIsIGxhdGl0dWRlMTogbnVtYmVyLCBsb25naXR1ZGUyOiBudW1iZXIsIGxhdGl0dWRlMjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHBvaW50c0FsbW9zdEVxdWFsKFxuICAgICAgbG9uZ2l0dWRlMSxcbiAgICAgIGxhdGl0dWRlMSxcbiAgICAgIGxvbmdpdHVkZTIsXG4gICAgICBsYXRpdHVkZTIsXG4gICAgICB0aGlzLm9wdGlvbnMucG9pbnRFcXVpdmFsZW5jeVByZWNpc2lvblxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHRyeVN0b3JlVW5maWx0ZXJlZFBhdGgocG9zaXRpb246IEdwc1Bvc2l0aW9uKTogdGhpcyB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdG9yZVVuZmlsdGVyZWRQYXRoKSB7XG4gICAgICB0aGlzLnVuZmlsdGVyZWRQYXRoLnB1c2gocG9zaXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iXX0=