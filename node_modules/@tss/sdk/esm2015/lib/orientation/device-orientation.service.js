/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Angular.
import { Injectable } from '@angular/core';
// 3rd Party.
import { Subject, fromEvent, merge } from 'rxjs';
import { getHeadingFromOrientation } from './heading/get-heading-from-orientation.function';
import { OrientationConfig } from './orientation.config';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./orientation.config";
/**
 * Geolocator service. Provides a single point of GPS interaction.
 */
export class DeviceOrientationService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this.internalDeviceNeedsCalibrated = false;
        this.headingChangeSource = new Subject();
        this.orientationChangeSource = new Subject();
        this.orientationChange = this.orientationChangeSource.asObservable();
        this.headingChange = merge(this.headingChangeSource, this.orientationChange.pipe(map((/**
         * @param {?} orientation
         * @return {?}
         */
        orientation => orientation.heading))));
        fromEvent(window, 'deviceorientation').subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.emitOrientationChange(event)));
        fromEvent(window, 'oncompassneedscalibration').subscribe((/**
         * @return {?}
         */
        () => this.internalDeviceNeedsCalibrated = true));
        fromEvent(window, 'compassneedscalibration').subscribe((/**
         * @return {?}
         */
        () => this.internalDeviceNeedsCalibrated = true));
    }
    /**
     * @return {?}
     */
    get deviceNeedsCalibrated() {
        return this.internalDeviceNeedsCalibrated;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} orientation
     * @return {THIS}
     */
    mockOrientation(orientation) {
        if (!(/** @type {?} */ (this)).config.allowOrientationMocking) {
            throw new Error('Permission denied to mock device orientation');
        }
        (/** @type {?} */ (this)).orientationChangeSource.next(orientation);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} heading
     * @return {THIS}
     */
    mockHeading(heading) {
        if (!(/** @type {?} */ (this)).config.allowHeadingMocking) {
            throw new Error('Permission denied to mock heading');
        }
        (/** @type {?} */ (this)).headingChangeSource.next(heading);
        return (/** @type {?} */ (this));
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    emitOrientationChange(event) {
        this.orientationChangeSource.next({
            alpha: event.alpha,
            beta: event.beta,
            gamma: event.gamma,
            heading: getHeadingFromOrientation(event)
        });
    }
}
DeviceOrientationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DeviceOrientationService.ctorParameters = () => [
    { type: OrientationConfig }
];
/** @nocollapse */ DeviceOrientationService.ngInjectableDef = i0.defineInjectable({ factory: function DeviceOrientationService_Factory() { return new DeviceOrientationService(i0.inject(i1.OrientationConfig)); }, token: DeviceOrientationService, providedIn: "root" });
if (false) {
    /** @type {?} */
    DeviceOrientationService.prototype.orientationChange;
    /** @type {?} */
    DeviceOrientationService.prototype.headingChange;
    /** @type {?} */
    DeviceOrientationService.prototype.orientationChangeSource;
    /** @type {?} */
    DeviceOrientationService.prototype.headingChangeSource;
    /**
     * @type {?}
     * @private
     */
    DeviceOrientationService.prototype.internalDeviceNeedsCalibrated;
    /**
     * @type {?}
     * @private
     */
    DeviceOrientationService.prototype.config;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGV2aWNlLW9yaWVudGF0aW9uLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdHNzL3Nkay8iLCJzb3VyY2VzIjpbImxpYi9vcmllbnRhdGlvbi9kZXZpY2Utb3JpZW50YXRpb24uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBRzNDLE9BQU8sRUFBYyxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUk3RCxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxpREFBaUQsQ0FBQztBQUM1RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUN6RCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7OztBQVNyQyxNQUFNLE9BQU8sd0JBQXdCOzs7O0lBWW5DLFlBQTZCLE1BQXlCO1FBQXpCLFdBQU0sR0FBTixNQUFNLENBQW1CO1FBTjlDLGtDQUE2QixHQUFHLEtBQUssQ0FBQztRQU81QyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUN6QyxJQUFJLENBQUMsdUJBQXVCLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUM3QyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3JFLElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUN4QixJQUFJLENBQUMsbUJBQW1CLEVBQ3hCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQ3pCLEdBQUc7Ozs7UUFBQyxXQUFXLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUMsQ0FDeEMsQ0FDRixDQUFDO1FBRUYsU0FBUyxDQUFDLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDLFNBQVM7Ozs7UUFBQyxDQUFDLEtBQTZCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsRUFBQyxDQUFDO1FBQ3ZILFNBQVMsQ0FBQyxNQUFNLEVBQUUsMkJBQTJCLENBQUMsQ0FBQyxTQUFTOzs7UUFBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsNkJBQTZCLEdBQUcsSUFBSSxFQUFDLENBQUM7UUFDMUcsU0FBUyxDQUFDLE1BQU0sRUFBRSx5QkFBeUIsQ0FBQyxDQUFDLFNBQVM7OztRQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyw2QkFBNkIsR0FBRyxJQUFJLEVBQUMsQ0FBQztJQUMxRyxDQUFDOzs7O0lBbEJELElBQUkscUJBQXFCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLDZCQUE2QixDQUFDO0lBQzVDLENBQUM7Ozs7Ozs7SUFrQkQsZUFBZSxDQUFDLFdBQXdCO1FBQ3RDLElBQUksQ0FBQyxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxNQUFNLENBQUMsdUJBQXVCLEVBQUU7WUFDeEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDO1NBQ2pFO1FBRUQsbUJBQUEsSUFBSSxFQUFBLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQy9DLE9BQU8sbUJBQUEsSUFBSSxFQUFBLENBQUM7SUFDZCxDQUFDOzs7Ozs7O0lBRUQsV0FBVyxDQUFDLE9BQWU7UUFDekIsSUFBSSxDQUFDLG1CQUFBLElBQUksRUFBQSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRTtZQUNwQyxNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7U0FDdEQ7UUFFRCxtQkFBQSxJQUFJLEVBQUEsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkMsT0FBTyxtQkFBQSxJQUFJLEVBQUEsQ0FBQztJQUNkLENBQUM7Ozs7OztJQUVPLHFCQUFxQixDQUFDLEtBQTZCO1FBQ3pELElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUM7WUFDaEMsS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLO1lBQ2xCLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSTtZQUNoQixLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUs7WUFDbEIsT0FBTyxFQUFFLHlCQUF5QixDQUFDLEtBQUssQ0FBQztTQUMxQyxDQUFDLENBQUM7SUFDTCxDQUFDOzs7WUF4REYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7O1lBVFEsaUJBQWlCOzs7OztJQVd4QixxREFBb0Q7O0lBQ3BELGlEQUEyQzs7SUFDM0MsMkRBQXVEOztJQUN2RCx1REFBOEM7Ozs7O0lBRTlDLGlFQUE4Qzs7Ozs7SUFNbEMsMENBQTBDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQW5ndWxhci5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLy8gM3JkIFBhcnR5LlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgZnJvbUV2ZW50LCBtZXJnZSB9IGZyb20gJ3J4anMnO1xuXG4vLyBBcHAuXG5pbXBvcnQgeyBPcmllbnRhdGlvbiB9IGZyb20gJy4vb3JpZW50YXRpb24nO1xuaW1wb3J0IHsgZ2V0SGVhZGluZ0Zyb21PcmllbnRhdGlvbiB9IGZyb20gJy4vaGVhZGluZy9nZXQtaGVhZGluZy1mcm9tLW9yaWVudGF0aW9uLmZ1bmN0aW9uJztcbmltcG9ydCB7IE9yaWVudGF0aW9uQ29uZmlnIH0gZnJvbSAnLi9vcmllbnRhdGlvbi5jb25maWcnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5cbi8qKlxuICogR2VvbG9jYXRvciBzZXJ2aWNlLiBQcm92aWRlcyBhIHNpbmdsZSBwb2ludCBvZiBHUFMgaW50ZXJhY3Rpb24uXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIERldmljZU9yaWVudGF0aW9uU2VydmljZSB7XG4gIHJlYWRvbmx5IG9yaWVudGF0aW9uQ2hhbmdlOiBPYnNlcnZhYmxlPE9yaWVudGF0aW9uPjtcbiAgcmVhZG9ubHkgaGVhZGluZ0NoYW5nZTogT2JzZXJ2YWJsZTxudW1iZXI+O1xuICByZWFkb25seSBvcmllbnRhdGlvbkNoYW5nZVNvdXJjZTogU3ViamVjdDxPcmllbnRhdGlvbj47XG4gIHJlYWRvbmx5IGhlYWRpbmdDaGFuZ2VTb3VyY2U6IFN1YmplY3Q8bnVtYmVyPjtcblxuICBwcml2YXRlIGludGVybmFsRGV2aWNlTmVlZHNDYWxpYnJhdGVkID0gZmFsc2U7XG5cbiAgZ2V0IGRldmljZU5lZWRzQ2FsaWJyYXRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbERldmljZU5lZWRzQ2FsaWJyYXRlZDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBPcmllbnRhdGlvbkNvbmZpZykge1xuICAgIHRoaXMuaGVhZGluZ0NoYW5nZVNvdXJjZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgdGhpcy5vcmllbnRhdGlvbkNoYW5nZVNvdXJjZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgdGhpcy5vcmllbnRhdGlvbkNoYW5nZSA9IHRoaXMub3JpZW50YXRpb25DaGFuZ2VTb3VyY2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5oZWFkaW5nQ2hhbmdlID0gbWVyZ2UoXG4gICAgICB0aGlzLmhlYWRpbmdDaGFuZ2VTb3VyY2UsXG4gICAgICB0aGlzLm9yaWVudGF0aW9uQ2hhbmdlLnBpcGUoXG4gICAgICAgIG1hcChvcmllbnRhdGlvbiA9PiBvcmllbnRhdGlvbi5oZWFkaW5nKVxuICAgICAgKVxuICAgICk7XG5cbiAgICBmcm9tRXZlbnQod2luZG93LCAnZGV2aWNlb3JpZW50YXRpb24nKS5zdWJzY3JpYmUoKGV2ZW50OiBEZXZpY2VPcmllbnRhdGlvbkV2ZW50KSA9PiB0aGlzLmVtaXRPcmllbnRhdGlvbkNoYW5nZShldmVudCkpO1xuICAgIGZyb21FdmVudCh3aW5kb3csICdvbmNvbXBhc3NuZWVkc2NhbGlicmF0aW9uJykuc3Vic2NyaWJlKCgpID0+IHRoaXMuaW50ZXJuYWxEZXZpY2VOZWVkc0NhbGlicmF0ZWQgPSB0cnVlKTtcbiAgICBmcm9tRXZlbnQod2luZG93LCAnY29tcGFzc25lZWRzY2FsaWJyYXRpb24nKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5pbnRlcm5hbERldmljZU5lZWRzQ2FsaWJyYXRlZCA9IHRydWUpO1xuICB9XG5cbiAgbW9ja09yaWVudGF0aW9uKG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbik6IHRoaXMge1xuICAgIGlmICghdGhpcy5jb25maWcuYWxsb3dPcmllbnRhdGlvbk1vY2tpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGVybWlzc2lvbiBkZW5pZWQgdG8gbW9jayBkZXZpY2Ugb3JpZW50YXRpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLm9yaWVudGF0aW9uQ2hhbmdlU291cmNlLm5leHQob3JpZW50YXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbW9ja0hlYWRpbmcoaGVhZGluZzogbnVtYmVyKTogdGhpcyB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5hbGxvd0hlYWRpbmdNb2NraW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Blcm1pc3Npb24gZGVuaWVkIHRvIG1vY2sgaGVhZGluZycpO1xuICAgIH1cblxuICAgIHRoaXMuaGVhZGluZ0NoYW5nZVNvdXJjZS5uZXh0KGhlYWRpbmcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0T3JpZW50YXRpb25DaGFuZ2UoZXZlbnQ6IERldmljZU9yaWVudGF0aW9uRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLm9yaWVudGF0aW9uQ2hhbmdlU291cmNlLm5leHQoe1xuICAgICAgYWxwaGE6IGV2ZW50LmFscGhhLFxuICAgICAgYmV0YTogZXZlbnQuYmV0YSxcbiAgICAgIGdhbW1hOiBldmVudC5nYW1tYSxcbiAgICAgIGhlYWRpbmc6IGdldEhlYWRpbmdGcm9tT3JpZW50YXRpb24oZXZlbnQpXG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==