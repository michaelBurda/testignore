/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { LrsWhereClauseBuilder } from '../lrs/lrs-where-clause-builder';
/**
 * @abstract
 */
export class BaseEsriService {
    /**
     * @param {?} http
     * @param {?} config
     * @param {?} dataConfig
     * @param {?} log
     */
    constructor(http, config, dataConfig, log) {
        this.http = http;
        this.config = config;
        this.dataConfig = dataConfig;
        this.log = log;
    }
    /**
     * @protected
     * @param {?} payload
     * @return {?}
     */
    shouldUsePostMethod(payload) {
        return this.config.arcgisQueryMethodStrategy === 'force-post'
            || JSON.stringify(payload || '').length > this.config.arcgisMaxWhereLengthGetThreshold;
    }
    /**
     * @protected
     * @template T
     * @param {?} response
     * @param {?} url
     * @return {?}
     */
    handleEsriResponseError(response, url) {
        /** @type {?} */
        const error = (/** @type {?} */ (response));
        if (error && error.error) {
            /** @type {?} */
            const returnError = new Error(`Failed to query map service: ${error.error.message}`);
            this.log.error(`Failed to execute map service request: ${url}`, returnError);
            throw returnError;
        }
    }
    /**
     * @protected
     * @return {?}
     */
    getWhereBuilder() {
        return new LrsWhereClauseBuilder({ quoteFields: !this.dataConfig.skipColumnQuotes });
    }
}
if (false) {
    /**
     * @type {?}
     * @protected
     */
    BaseEsriService.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    BaseEsriService.prototype.config;
    /**
     * @type {?}
     * @protected
     */
    BaseEsriService.prototype.dataConfig;
    /**
     * @type {?}
     * @protected
     */
    BaseEsriService.prototype.log;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1lc3JpLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdHNzL3Nkay8iLCJzb3VyY2VzIjpbImxpYi9lc3JpL2Jhc2UtZXNyaS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFLQSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQzs7OztBQU14RSxNQUFNLE9BQWdCLGVBQWU7Ozs7Ozs7SUFDbkMsWUFBc0IsSUFBZ0IsRUFBWSxNQUFrQixFQUFZLFVBQTRCLEVBQVksR0FBVztRQUE3RyxTQUFJLEdBQUosSUFBSSxDQUFZO1FBQVksV0FBTSxHQUFOLE1BQU0sQ0FBWTtRQUFZLGVBQVUsR0FBVixVQUFVLENBQWtCO1FBQVksUUFBRyxHQUFILEdBQUcsQ0FBUTtJQUNuSSxDQUFDOzs7Ozs7SUFFUyxtQkFBbUIsQ0FBQyxPQUFvQjtRQUNoRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMseUJBQXlCLEtBQUssWUFBWTtlQUN4RCxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQztJQUMzRixDQUFDOzs7Ozs7OztJQUVTLHVCQUF1QixDQUFJLFFBQXlDLEVBQUUsR0FBVzs7Y0FDbkYsS0FBSyxHQUFHLG1CQUFBLFFBQVEsRUFBK0I7UUFDckQsSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDLEtBQUssRUFBRTs7a0JBQ2xCLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNwRixJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQywwQ0FBMEMsR0FBRyxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDN0UsTUFBTSxXQUFXLENBQUM7U0FDbkI7SUFDSCxDQUFDOzs7OztJQUVTLGVBQWU7UUFDdkIsT0FBTyxJQUFJLHFCQUFxQixDQUFDLEVBQUUsV0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7SUFDdkYsQ0FBQztDQUNGOzs7Ozs7SUFwQmEsK0JBQTBCOzs7OztJQUFFLGlDQUE0Qjs7Ozs7SUFBRSxxQ0FBc0M7Ozs7O0lBQUUsOEJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQW5ndWxhci5cbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5cbi8vIFRTUy5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2NvcmUvbG9nZ2luZy9sb2dnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBMcnNXaGVyZUNsYXVzZUJ1aWxkZXIgfSBmcm9tICcuLi9scnMvbHJzLXdoZXJlLWNsYXVzZS1idWlsZGVyJztcbmltcG9ydCB7IEVzcmlDb25maWcgfSBmcm9tICcuL2VzcmktY29uZmlnJztcbmltcG9ydCB7IEVzcmlNYXBTZXJ2aWNlRXJyb3JSZXNwb25zZSB9IGZyb20gJy4vZXNyaS1tYXAtc2VydmVyLWVycm9yLXJlc3BvbnNlJztcbmltcG9ydCB7IERhdGFTb3VyY2VDb25maWcgfSBmcm9tICcuLi9kYXRhLXNvdXJjZS9kYXRhLXNvdXJjZS1jb25maWcnO1xuXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlRXNyaVNlcnZpY2Uge1xuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgaHR0cDogSHR0cENsaWVudCwgcHJvdGVjdGVkIGNvbmZpZzogRXNyaUNvbmZpZywgcHJvdGVjdGVkIGRhdGFDb25maWc6IERhdGFTb3VyY2VDb25maWcsIHByb3RlY3RlZCBsb2c6IExvZ2dlcikge1xuICB9XG5cbiAgcHJvdGVjdGVkIHNob3VsZFVzZVBvc3RNZXRob2QocGF5bG9hZDogc3RyaW5nIHwge30pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuYXJjZ2lzUXVlcnlNZXRob2RTdHJhdGVneSA9PT0gJ2ZvcmNlLXBvc3QnXG4gICAgICB8fCBKU09OLnN0cmluZ2lmeShwYXlsb2FkIHx8ICcnKS5sZW5ndGggPiB0aGlzLmNvbmZpZy5hcmNnaXNNYXhXaGVyZUxlbmd0aEdldFRocmVzaG9sZDtcbiAgfVxuXG4gIHByb3RlY3RlZCBoYW5kbGVFc3JpUmVzcG9uc2VFcnJvcjxUPihyZXNwb25zZTogVCB8IEVzcmlNYXBTZXJ2aWNlRXJyb3JSZXNwb25zZSwgdXJsOiBzdHJpbmcpIHtcbiAgICBjb25zdCBlcnJvciA9IHJlc3BvbnNlIGFzIEVzcmlNYXBTZXJ2aWNlRXJyb3JSZXNwb25zZTtcbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IuZXJyb3IpIHtcbiAgICAgIGNvbnN0IHJldHVybkVycm9yID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gcXVlcnkgbWFwIHNlcnZpY2U6ICR7ZXJyb3IuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRoaXMubG9nLmVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSBtYXAgc2VydmljZSByZXF1ZXN0OiAke3VybH1gLCByZXR1cm5FcnJvcik7XG4gICAgICB0aHJvdyByZXR1cm5FcnJvcjtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0V2hlcmVCdWlsZGVyKCk6IExyc1doZXJlQ2xhdXNlQnVpbGRlciB7XG4gICAgcmV0dXJuIG5ldyBMcnNXaGVyZUNsYXVzZUJ1aWxkZXIoeyBxdW90ZUZpZWxkczogIXRoaXMuZGF0YUNvbmZpZy5za2lwQ29sdW1uUXVvdGVzIH0pO1xuICB9XG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiJdfQ==