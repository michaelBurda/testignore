/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// 3rd Party.
import { Subject, of, iif } from 'rxjs';
import { takeWhile, tap, filter, mergeMap, map } from 'rxjs/operators';
import { QueueWorkerToken } from './queue-worker-token';
import { WorkQueueStatusEventType } from './work-queue-status-event-type';
import { WorkQueueStatusTracker } from './work-queue-status-tracker';
import { isValue } from '../core/type-check/is-value.function';
import { isNotValue } from '../core/type-check/is-not-value.function';
/** @type {?} */
export const DEFAULT_WORK_QUEUE_OPTIONS = {
    autoStartWorkers: true,
    workerCount: 1,
};
/**
 * Provides the core queueing workflow for basic unit of work queues.
 * High Priority Todos:
 * * Implement worker cancelation into the worker token - RG.
 *
 * Low Priority Todos:
 * * Add queue prioritization - a queue priority flag to pull those items first from the queue - RG.
 * * Change overriding of methods to use metho attributes instead. Example: \@OnWorkComplete.
 * @abstract
 * @template TInput, TOutput
 */
export class WorkQueueManager {
    /**
     * @param {?} log
     * @param {?=} options
     */
    constructor(log, options) {
        this.log = log;
        this.workerTokens = [];
        this.tracker = new WorkQueueStatusTracker();
        this.options = Object.assign({}, DEFAULT_WORK_QUEUE_OPTIONS);
        this.setOptions(options);
        this.queueChangeObserver = new Subject();
        this.queueChange = this.queueChangeObserver.pipe();
        this.queueStarted = this.queueChangeObserver.pipe(filter((/**
         * @param {?} change
         * @return {?}
         */
        change => change.event === WorkQueueStatusEventType.QueueStarted)));
        this.queueComplete = this.queueChangeObserver.pipe(filter((/**
         * @param {?} change
         * @return {?}
         */
        change => change.event === WorkQueueStatusEventType.QueueComplete)));
        if (this.options.autoStartWorkers) {
            setTimeout((/**
             * @return {?}
             */
            () => this.startWork()));
        }
    }
    /**
     * @return {?}
     */
    get isWorking() {
        return this.tracker.isWorking;
    }
    /**
     * @return {?}
     */
    get status() {
        return this.tracker.getStatus();
    }
    /**
     * Overrides default options.
     * @param {?} options Options to override the defaults.
     * @return {?}
     */
    setOptions(options) {
        Object.assign(this.options, options);
        return this;
    }
    /**
     * Kicks off the queue workflow with the specified number of workers. If
     * the maximum number of workers are currently running, no additional workers
     * will be created (only the delta of allowed and running will be started).
     * @return {?}
     */
    startWork() {
        // We dont' want to change the queue size if the queue is already working
        // because it will mess up the statistics (percent copmlete, etc).
        /** @type {?} */
        const starterSource = iif((/**
         * @return {?}
         */
        () => !this.isWorking), this.getRemainingQueueCount()
            .pipe(tap((/**
         * @param {?} queueCount
         * @return {?}
         */
        (queueCount) => this.tracker.setQueueSize(queueCount)))));
        this.onReady()
            .pipe(mergeMap((/**
         * @return {?}
         */
        () => starterSource)))
            .subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const workersToStart = this.options.workerCount - this.workerTokens.length;
            if (workersToStart > 0) {
                this.emitQueueChange(null, WorkQueueStatusEventType.QueueStarted);
            }
            for (let i = 0; i < workersToStart; i++) {
                /** @type {?} */
                const token = new QueueWorkerToken().start();
                this.tracker.addWorker(token);
                this.workerTokens.push(token);
                this.emitQueueChange(token, WorkQueueStatusEventType.QueueWorkerStarted);
                this.getNextAndDoWork(token);
            }
        }));
    }
    /**
     * Stops all workers from processing the queue.
     * @return {?}
     */
    stopWork() {
        this.workerTokens.forEach((/**
         * @param {?} token
         * @return {?}
         */
        token => token.cancel()));
    }
    /**
     * Method that determines that the workers are ready to be started. Note, in this implementation it
     * makes use of an empty promise. The main reason for this is to provide a hook for other implementers
     * to setup/initialize the queue before starting the workers. Additionaly, this practices provides a
     * way to run the workers asynchronously.
     * @protected
     * @return {?}
     */
    onReady() {
        return of(null);
    }
    /**
     * @protected
     * @param {?} input
     * @return {?}
     */
    onBeforeWorkStarted(input) {
        return of(input);
    }
    /**
     * @protected
     * @param {?} data
     * @return {?}
     */
    onWorkComplete(data) {
        return of(data);
    }
    /**
     * @protected
     * @param {?} data
     * @param {?} error
     * @return {?}
     */
    onWorkFailed(data, error) {
        return of(data, error);
    }
    /**
     * @protected
     * @return {?}
     */
    getRemainingQueueCount() {
        return of(-1);
    }
    /**
     * @protected
     * @param {?} token
     * @param {?} event
     * @param {?=} input
     * @param {?=} output
     * @return {?}
     */
    emitQueueChange(token, event, input, output) {
        this.queueChangeObserver.next({
            event,
            input,
            output,
            status: this.tracker.getStatus(),
            tokenId: token ? token.id : null,
        });
    }
    /**
     * @private
     * @param {?} token
     * @param {?=} input
     * @param {?=} output
     * @return {?}
     */
    emitWorkStarted(token, input, output) {
        this.emitQueueChange(token, WorkQueueStatusEventType.UnitOfWorkStarted, input, output);
    }
    /**
     * @private
     * @param {?} token
     * @param {?=} input
     * @param {?=} output
     * @return {?}
     */
    emitWorkComplete(token, input, output) {
        this.emitQueueChange(token, WorkQueueStatusEventType.UnitOfWorkComplete, input, output);
    }
    /**
     * @private
     * @param {?} token
     * @return {?}
     */
    onWorkerCompleted(token) {
        if (token.isComplete) {
            return;
        }
        /** @type {?} */
        const index = this.workerTokens.indexOf(token);
        token.complete();
        if (index !== -1) {
            this.workerTokens.splice(index, 1);
        }
        this.emitQueueChange(token, WorkQueueStatusEventType.QueueWorkerComplete);
        if (this.workerTokens.length === 0) {
            this.emitQueueChange(token, WorkQueueStatusEventType.QueueComplete);
            this.tracker.complete();
        }
    }
    /**
     * @private
     * @param {?} token
     * @param {?} next
     * @return {?}
     */
    checkIfWorkerComplete(token, next) {
        if (isNotValue(next)) {
            this.onWorkerCompleted(token);
        }
    }
    /**
     * @private
     * @param {?} token
     * @return {?}
     */
    getNextAndDoWork(token) {
        if (token.isCanceled) {
            this.log.debug(`Canceling worker due to canceled toke: ${token.id}`);
            this.onWorkerCompleted(token);
        }
        this.log.trace('Retrieving next queue item to start processing');
        /** @type {?} */
        const processingData = { input: null, output: null };
        this.getNext()
            .pipe(tap((/**
         * @param {?} input
         * @return {?}
         */
        (input) => processingData.input = input)), tap((/**
         * @param {?} input
         * @return {?}
         */
        (input) => this.checkIfWorkerComplete(token, input))), takeWhile((/**
         * @param {?} input
         * @return {?}
         */
        (input) => isValue(input) && !token.isCanceled)), tap((/**
         * @param {?} input
         * @return {?}
         */
        (input) => this.emitWorkStarted(token, input))), mergeMap((/**
         * @param {?} input
         * @return {?}
         */
        (input) => this.onBeforeWorkStarted(input))), mergeMap((/**
         * @param {?} input
         * @return {?}
         */
        (input) => this.doWork(input))), tap((/**
         * @param {?} output
         * @return {?}
         */
        (output) => processingData.output = output)), map((/**
         * @return {?}
         */
        () => processingData)), mergeMap((/**
         * @param {?} data
         * @return {?}
         */
        (data) => this.onWorkComplete(data))))
            .subscribe((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            this.log.trace('Completed work for item');
            token.totalComplete++;
            this.emitWorkComplete(token, data.input, data.output);
            this.getNextAndDoWork(token);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            this.log.error(`Failed to process item. {error}`, error);
            token.totalFailed++;
            this.onWorkFailed(processingData, error)
                .toPromise()
                .then((/**
             * @return {?}
             */
            () => this.getNextAndDoWork(token)));
        }));
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    WorkQueueManager.prototype.queueChangeObserver;
    /**
     * @type {?}
     * @protected
     */
    WorkQueueManager.prototype.workerTokens;
    /**
     * @type {?}
     * @protected
     */
    WorkQueueManager.prototype.tracker;
    /** @type {?} */
    WorkQueueManager.prototype.queueChange;
    /** @type {?} */
    WorkQueueManager.prototype.queueStarted;
    /** @type {?} */
    WorkQueueManager.prototype.queueComplete;
    /** @type {?} */
    WorkQueueManager.prototype.options;
    /**
     * @type {?}
     * @protected
     */
    WorkQueueManager.prototype.log;
    /**
     * Implementation method to do the actual unit of work.
     * @abstract
     * @protected
     * @param {?} item The input paramater needed to process the unit of work and return an output result.
     * @return {?}
     */
    WorkQueueManager.prototype.doWork = function (item) { };
    /**
     * Implementation method to retrieve the next value in the queue. Note, there are no further checks
     * to verify duplicate items are not processed - it is the responsibility of the implementer of this
     * base class to never return the same item from this method. Typically the item in the queue is either
     * dequeued or marked as "processing" to prevent this potential issue.
     * @abstract
     * @protected
     * @return {?}
     */
    WorkQueueManager.prototype.getNext = function () { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29yay1xdWV1ZS1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRzcy9zZGsvIiwic291cmNlcyI6WyJsaWIvcXVldWluZy93b3JrLXF1ZXVlLW1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxPQUFPLEVBQWMsT0FBTyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDcEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUl2RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUV4RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUMxRSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUlyRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDL0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLDBDQUEwQyxDQUFDOztBQUd0RSxNQUFNLE9BQU8sMEJBQTBCLEdBQUc7SUFDeEMsZ0JBQWdCLEVBQUUsSUFBSTtJQUN0QixXQUFXLEVBQUUsQ0FBQztDQUNmOzs7Ozs7Ozs7Ozs7QUFZRCxNQUFNLE9BQWdCLGdCQUFnQjs7Ozs7SUFtQnBDLFlBQXNCLEdBQVcsRUFBRSxPQUE0QjtRQUF6QyxRQUFHLEdBQUgsR0FBRyxDQUFRO1FBaEJkLGlCQUFZLEdBQXVCLEVBQUUsQ0FBQztRQUN0QyxZQUFPLEdBQTJCLElBQUksc0JBQXNCLEVBQUUsQ0FBQztRQUt6RSxZQUFPLEdBQXVCLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLDBCQUEwQixDQUFDLENBQUM7UUFXbkYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxPQUFPLEVBQUUs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RSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUN0RCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDL0IsQ0FBQzs7OztRQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDWCxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxpQ0FBaUMsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUN6RCxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDcEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLEVBQUUsS0FBSyxDQUFDO2lCQUNyQyxTQUFTLEVBQUU7aUJBQ1gsSUFBSTs7O1lBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxFQUFDLENBQUM7UUFDOUMsQ0FBQyxFQUFDLENBQUM7SUFDUCxDQUFDO0NBQ0Y7Ozs7OztJQTVNQywrQ0FBNEU7Ozs7O0lBRTVFLHdDQUF5RDs7Ozs7SUFDekQsbUNBQWtGOztJQUVsRix1Q0FBd0U7O0lBQ3hFLHdDQUF5RTs7SUFDekUseUNBQTBFOztJQUMxRSxtQ0FBcUY7Ozs7O0lBVXpFLCtCQUFxQjs7Ozs7Ozs7SUEwRWpDLHdEQUE2RDs7Ozs7Ozs7OztJQVE3RCxxREFBaUQiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAzcmQgUGFydHkuXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBvZiwgaWlmIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlV2hpbGUsIHRhcCwgZmlsdGVyLCBtZXJnZU1hcCwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vLyBUU1MuXG5pbXBvcnQgeyBXb3JrZXJRdWV1ZU9wdGlvbnMgfSBmcm9tICcuL3dvcmtlci1xdWV1ZS1vcHRpb25zJztcbmltcG9ydCB7IFF1ZXVlV29ya2VyVG9rZW4gfSBmcm9tICcuL3F1ZXVlLXdvcmtlci10b2tlbic7XG5pbXBvcnQgeyBXb3JrUXVldWVTdGF0dXNFdmVudCB9IGZyb20gJy4vd29yay1xdWV1ZS1zdGF0dXMtZXZlbnQnO1xuaW1wb3J0IHsgV29ya1F1ZXVlU3RhdHVzRXZlbnRUeXBlIH0gZnJvbSAnLi93b3JrLXF1ZXVlLXN0YXR1cy1ldmVudC10eXBlJztcbmltcG9ydCB7IFdvcmtRdWV1ZVN0YXR1c1RyYWNrZXIgfSBmcm9tICcuL3dvcmstcXVldWUtc3RhdHVzLXRyYWNrZXInO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vY29yZS9sb2dnaW5nL2xvZ2dlci5zZXJ2aWNlJztcbmltcG9ydCB7IFdvcmtRdWV1ZVN0YXR1cyB9IGZyb20gJy4vd29yay1xdWV1ZS1zdGF0dXMnO1xuaW1wb3J0IHsgUXVldWVQYXlsb2FkIH0gZnJvbSAnLi9xdWV1ZS1wYXlsb2FkJztcbmltcG9ydCB7IGlzVmFsdWUgfSBmcm9tICcuLi9jb3JlL3R5cGUtY2hlY2svaXMtdmFsdWUuZnVuY3Rpb24nO1xuaW1wb3J0IHsgaXNOb3RWYWx1ZSB9IGZyb20gJy4uL2NvcmUvdHlwZS1jaGVjay9pcy1ub3QtdmFsdWUuZnVuY3Rpb24nO1xuXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1dPUktfUVVFVUVfT1BUSU9OUyA9IHtcbiAgYXV0b1N0YXJ0V29ya2VyczogdHJ1ZSxcbiAgd29ya2VyQ291bnQ6IDEsXG59O1xuXG5cbi8qKlxuICogUHJvdmlkZXMgdGhlIGNvcmUgcXVldWVpbmcgd29ya2Zsb3cgZm9yIGJhc2ljIHVuaXQgb2Ygd29yayBxdWV1ZXMuXG4gKiBIaWdoIFByaW9yaXR5IFRvZG9zOlxuICogKiBJbXBsZW1lbnQgd29ya2VyIGNhbmNlbGF0aW9uIGludG8gdGhlIHdvcmtlciB0b2tlbiAtIFJHLlxuICpcbiAqIExvdyBQcmlvcml0eSBUb2RvczpcbiAqICogQWRkIHF1ZXVlIHByaW9yaXRpemF0aW9uIC0gYSBxdWV1ZSBwcmlvcml0eSBmbGFnIHRvIHB1bGwgdGhvc2UgaXRlbXMgZmlyc3QgZnJvbSB0aGUgcXVldWUgLSBSRy5cbiAqICogQ2hhbmdlIG92ZXJyaWRpbmcgb2YgbWV0aG9kcyB0byB1c2UgbWV0aG8gYXR0cmlidXRlcyBpbnN0ZWFkLiBFeGFtcGxlOiBAT25Xb3JrQ29tcGxldGUuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBXb3JrUXVldWVNYW5hZ2VyPFRJbnB1dCwgVE91dHB1dD4ge1xuICBwcml2YXRlIHF1ZXVlQ2hhbmdlT2JzZXJ2ZXI6IFN1YmplY3Q8V29ya1F1ZXVlU3RhdHVzRXZlbnQ8VElucHV0LCBUT3V0cHV0Pj47XG5cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHdvcmtlclRva2VuczogUXVldWVXb3JrZXJUb2tlbltdID0gW107XG4gIHByb3RlY3RlZCByZWFkb25seSB0cmFja2VyOiBXb3JrUXVldWVTdGF0dXNUcmFja2VyID0gbmV3IFdvcmtRdWV1ZVN0YXR1c1RyYWNrZXIoKTtcblxuICByZWFkb25seSBxdWV1ZUNoYW5nZTogT2JzZXJ2YWJsZTxXb3JrUXVldWVTdGF0dXNFdmVudDxUSW5wdXQsIFRPdXRwdXQ+PjtcbiAgcmVhZG9ubHkgcXVldWVTdGFydGVkOiBPYnNlcnZhYmxlPFdvcmtRdWV1ZVN0YXR1c0V2ZW50PFRJbnB1dCwgVE91dHB1dD4+O1xuICByZWFkb25seSBxdWV1ZUNvbXBsZXRlOiBPYnNlcnZhYmxlPFdvcmtRdWV1ZVN0YXR1c0V2ZW50PFRJbnB1dCwgVE91dHB1dD4+O1xuICByZWFkb25seSBvcHRpb25zOiBXb3JrZXJRdWV1ZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1dPUktfUVVFVUVfT1BUSU9OUyk7XG5cbiAgZ2V0IGlzV29ya2luZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy50cmFja2VyLmlzV29ya2luZztcbiAgfVxuXG4gIGdldCBzdGF0dXMoKTogV29ya1F1ZXVlU3RhdHVzIHtcbiAgICByZXR1cm4gdGhpcy50cmFja2VyLmdldFN0YXR1cygpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGxvZzogTG9nZ2VyLCBvcHRpb25zPzogV29ya2VyUXVldWVPcHRpb25zKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMucXVldWVDaGFuZ2VPYnNlcnZlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgdGhpcy5xdWV1ZUNoYW5nZSA9IHRoaXMucXVldWVDaGFuZ2VPYnNlcnZlci5waXBlKCk7XG5cbiAgICB0aGlzLnF1ZXVlU3RhcnRlZCA9IHRoaXMucXVldWVDaGFuZ2VPYnNlcnZlci5waXBlKFxuICAgICAgZmlsdGVyKGNoYW5nZSA9PiBjaGFuZ2UuZXZlbnQgPT09IFdvcmtRdWV1ZVN0YXR1c0V2ZW50VHlwZS5RdWV1ZVN0YXJ0ZWQpXG4gICAgKTtcblxuICAgIHRoaXMucXVldWVDb21wbGV0ZSA9IHRoaXMucXVldWVDaGFuZ2VPYnNlcnZlci5waXBlKFxuICAgICAgZmlsdGVyKGNoYW5nZSA9PiBjaGFuZ2UuZXZlbnQgPT09IFdvcmtRdWV1ZVN0YXR1c0V2ZW50VHlwZS5RdWV1ZUNvbXBsZXRlKVxuICAgICk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9TdGFydFdvcmtlcnMpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydFdvcmsoKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBkZWZhdWx0IG9wdGlvbnMuXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgKi9cbiAgc2V0T3B0aW9ucyhvcHRpb25zOiBXb3JrZXJRdWV1ZU9wdGlvbnMpOiBXb3JrUXVldWVNYW5hZ2VyPFRJbnB1dCwgVE91dHB1dD4ge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBLaWNrcyBvZmYgdGhlIHF1ZXVlIHdvcmtmbG93IHdpdGggdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygd29ya2Vycy4gSWZcbiAgICogdGhlIG1heGltdW0gbnVtYmVyIG9mIHdvcmtlcnMgYXJlIGN1cnJlbnRseSBydW5uaW5nLCBubyBhZGRpdGlvbmFsIHdvcmtlcnNcbiAgICogd2lsbCBiZSBjcmVhdGVkIChvbmx5IHRoZSBkZWx0YSBvZiBhbGxvd2VkIGFuZCBydW5uaW5nIHdpbGwgYmUgc3RhcnRlZCkuXG4gICAqL1xuICBzdGFydFdvcmsoKTogdm9pZCB7XG4gICAgLy8gV2UgZG9udCcgd2FudCB0byBjaGFuZ2UgdGhlIHF1ZXVlIHNpemUgaWYgdGhlIHF1ZXVlIGlzIGFscmVhZHkgd29ya2luZ1xuICAgIC8vIGJlY2F1c2UgaXQgd2lsbCBtZXNzIHVwIHRoZSBzdGF0aXN0aWNzIChwZXJjZW50IGNvcG1sZXRlLCBldGMpLlxuICAgIGNvbnN0IHN0YXJ0ZXJTb3VyY2UgPSBpaWYoKCkgPT4gIXRoaXMuaXNXb3JraW5nLFxuICAgICAgdGhpcy5nZXRSZW1haW5pbmdRdWV1ZUNvdW50KClcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgdGFwKChxdWV1ZUNvdW50OiBudW1iZXIpID0+IHRoaXMudHJhY2tlci5zZXRRdWV1ZVNpemUocXVldWVDb3VudCkpXG4gICAgICAgIClcbiAgICApO1xuXG4gICAgdGhpcy5vblJlYWR5KClcbiAgICAgIC5waXBlKFxuICAgICAgICBtZXJnZU1hcCgoKSA9PiBzdGFydGVyU291cmNlKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdvcmtlcnNUb1N0YXJ0ID0gdGhpcy5vcHRpb25zLndvcmtlckNvdW50IC0gdGhpcy53b3JrZXJUb2tlbnMubGVuZ3RoO1xuXG4gICAgICAgIGlmICh3b3JrZXJzVG9TdGFydCA+IDApIHtcbiAgICAgICAgICB0aGlzLmVtaXRRdWV1ZUNoYW5nZShudWxsLCBXb3JrUXVldWVTdGF0dXNFdmVudFR5cGUuUXVldWVTdGFydGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29ya2Vyc1RvU3RhcnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHRva2VuID0gbmV3IFF1ZXVlV29ya2VyVG9rZW4oKS5zdGFydCgpO1xuICAgICAgICAgIHRoaXMudHJhY2tlci5hZGRXb3JrZXIodG9rZW4pO1xuICAgICAgICAgIHRoaXMud29ya2VyVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIHRoaXMuZW1pdFF1ZXVlQ2hhbmdlKHRva2VuLCBXb3JrUXVldWVTdGF0dXNFdmVudFR5cGUuUXVldWVXb3JrZXJTdGFydGVkKTtcbiAgICAgICAgICB0aGlzLmdldE5leHRBbmREb1dvcmsodG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBhbGwgd29ya2VycyBmcm9tIHByb2Nlc3NpbmcgdGhlIHF1ZXVlLlxuICAgKi9cbiAgc3RvcFdvcmsoKTogdm9pZCB7XG4gICAgdGhpcy53b3JrZXJUb2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB0b2tlbi5jYW5jZWwoKSk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gbWV0aG9kIHRvIGRvIHRoZSBhY3R1YWwgdW5pdCBvZiB3b3JrLlxuICAgKiBAcGFyYW0gaXRlbSBUaGUgaW5wdXQgcGFyYW1hdGVyIG5lZWRlZCB0byBwcm9jZXNzIHRoZSB1bml0IG9mIHdvcmsgYW5kIHJldHVybiBhbiBvdXRwdXQgcmVzdWx0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGRvV29yayhpdGVtOiBUSW5wdXQpOiBPYnNlcnZhYmxlPFRPdXRwdXQ+O1xuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBtZXRob2QgdG8gcmV0cmlldmUgdGhlIG5leHQgdmFsdWUgaW4gdGhlIHF1ZXVlLiBOb3RlLCB0aGVyZSBhcmUgbm8gZnVydGhlciBjaGVja3NcbiAgICogdG8gdmVyaWZ5IGR1cGxpY2F0ZSBpdGVtcyBhcmUgbm90IHByb2Nlc3NlZCAtIGl0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgaW1wbGVtZW50ZXIgb2YgdGhpc1xuICAgKiBiYXNlIGNsYXNzIHRvIG5ldmVyIHJldHVybiB0aGUgc2FtZSBpdGVtIGZyb20gdGhpcyBtZXRob2QuIFR5cGljYWxseSB0aGUgaXRlbSBpbiB0aGUgcXVldWUgaXMgZWl0aGVyXG4gICAqIGRlcXVldWVkIG9yIG1hcmtlZCBhcyBcInByb2Nlc3NpbmdcIiB0byBwcmV2ZW50IHRoaXMgcG90ZW50aWFsIGlzc3VlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldE5leHQoKTogT2JzZXJ2YWJsZTxUSW5wdXQ+O1xuXG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBkZXRlcm1pbmVzIHRoYXQgdGhlIHdvcmtlcnMgYXJlIHJlYWR5IHRvIGJlIHN0YXJ0ZWQuIE5vdGUsIGluIHRoaXMgaW1wbGVtZW50YXRpb24gaXRcbiAgICogbWFrZXMgdXNlIG9mIGFuIGVtcHR5IHByb21pc2UuIFRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBpcyB0byBwcm92aWRlIGEgaG9vayBmb3Igb3RoZXIgaW1wbGVtZW50ZXJzXG4gICAqIHRvIHNldHVwL2luaXRpYWxpemUgdGhlIHF1ZXVlIGJlZm9yZSBzdGFydGluZyB0aGUgd29ya2Vycy4gQWRkaXRpb25hbHksIHRoaXMgcHJhY3RpY2VzIHByb3ZpZGVzIGFcbiAgICogd2F5IHRvIHJ1biB0aGUgd29ya2VycyBhc3luY2hyb25vdXNseS5cbiAgICovXG4gIHByb3RlY3RlZCBvblJlYWR5KCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIG9mKG51bGwpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQmVmb3JlV29ya1N0YXJ0ZWQoaW5wdXQ6IFRJbnB1dCk6IE9ic2VydmFibGU8VElucHV0PiB7XG4gICAgcmV0dXJuIG9mKGlucHV0KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbldvcmtDb21wbGV0ZShkYXRhOiBRdWV1ZVBheWxvYWQ8VElucHV0LCBUT3V0cHV0Pik6IE9ic2VydmFibGU8UXVldWVQYXlsb2FkPFRJbnB1dCwgVE91dHB1dD4+IHtcbiAgICByZXR1cm4gb2YoZGF0YSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25Xb3JrRmFpbGVkKGRhdGE6IFF1ZXVlUGF5bG9hZDxUSW5wdXQsIFRPdXRwdXQ+LCBlcnJvcjogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gb2YoZGF0YSwgZXJyb3IpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldFJlbWFpbmluZ1F1ZXVlQ291bnQoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICByZXR1cm4gb2YoLTEpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGVtaXRRdWV1ZUNoYW5nZSh0b2tlbjogUXVldWVXb3JrZXJUb2tlbiwgZXZlbnQ6IFdvcmtRdWV1ZVN0YXR1c0V2ZW50VHlwZSwgaW5wdXQ/OiBUSW5wdXQsIG91dHB1dD86IFRPdXRwdXQpOiB2b2lkIHtcbiAgICB0aGlzLnF1ZXVlQ2hhbmdlT2JzZXJ2ZXIubmV4dCh7XG4gICAgICBldmVudCxcbiAgICAgIGlucHV0LFxuICAgICAgb3V0cHV0LFxuICAgICAgc3RhdHVzOiB0aGlzLnRyYWNrZXIuZ2V0U3RhdHVzKCksXG4gICAgICB0b2tlbklkOiB0b2tlbiA/IHRva2VuLmlkIDogbnVsbCxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdFdvcmtTdGFydGVkKHRva2VuOiBRdWV1ZVdvcmtlclRva2VuLCBpbnB1dD86IFRJbnB1dCwgb3V0cHV0PzogVE91dHB1dCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdFF1ZXVlQ2hhbmdlKHRva2VuLCBXb3JrUXVldWVTdGF0dXNFdmVudFR5cGUuVW5pdE9mV29ya1N0YXJ0ZWQsIGlucHV0LCBvdXRwdXQpO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0V29ya0NvbXBsZXRlKHRva2VuOiBRdWV1ZVdvcmtlclRva2VuLCBpbnB1dD86IFRJbnB1dCwgb3V0cHV0PzogVE91dHB1dCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdFF1ZXVlQ2hhbmdlKHRva2VuLCBXb3JrUXVldWVTdGF0dXNFdmVudFR5cGUuVW5pdE9mV29ya0NvbXBsZXRlLCBpbnB1dCwgb3V0cHV0KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Xb3JrZXJDb21wbGV0ZWQodG9rZW46IFF1ZXVlV29ya2VyVG9rZW4pIHtcbiAgICBpZiAodG9rZW4uaXNDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy53b3JrZXJUb2tlbnMuaW5kZXhPZih0b2tlbik7XG4gICAgdG9rZW4uY29tcGxldGUoKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMud29ya2VyVG9rZW5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0UXVldWVDaGFuZ2UodG9rZW4sIFdvcmtRdWV1ZVN0YXR1c0V2ZW50VHlwZS5RdWV1ZVdvcmtlckNvbXBsZXRlKTtcbiAgICBpZiAodGhpcy53b3JrZXJUb2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmVtaXRRdWV1ZUNoYW5nZSh0b2tlbiwgV29ya1F1ZXVlU3RhdHVzRXZlbnRUeXBlLlF1ZXVlQ29tcGxldGUpO1xuICAgICAgdGhpcy50cmFja2VyLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0lmV29ya2VyQ29tcGxldGUodG9rZW46IFF1ZXVlV29ya2VyVG9rZW4sIG5leHQ6IFRJbnB1dCkge1xuICAgIGlmIChpc05vdFZhbHVlKG5leHQpKSB7XG4gICAgICB0aGlzLm9uV29ya2VyQ29tcGxldGVkKHRva2VuKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldE5leHRBbmREb1dvcmsodG9rZW46IFF1ZXVlV29ya2VyVG9rZW4pOiB2b2lkIHtcbiAgICBpZiAodG9rZW4uaXNDYW5jZWxlZCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoYENhbmNlbGluZyB3b3JrZXIgZHVlIHRvIGNhbmNlbGVkIHRva2U6ICR7dG9rZW4uaWR9YCk7XG4gICAgICB0aGlzLm9uV29ya2VyQ29tcGxldGVkKHRva2VuKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZy50cmFjZSgnUmV0cmlldmluZyBuZXh0IHF1ZXVlIGl0ZW0gdG8gc3RhcnQgcHJvY2Vzc2luZycpO1xuICAgIGNvbnN0IHByb2Nlc3NpbmdEYXRhOiBRdWV1ZVBheWxvYWQ8VElucHV0LCBUT3V0cHV0PiA9IHsgaW5wdXQ6IG51bGwsIG91dHB1dDogbnVsbCB9O1xuICAgIHRoaXMuZ2V0TmV4dCgpXG4gICAgICAucGlwZShcbiAgICAgICAgdGFwKChpbnB1dDogVElucHV0KSA9PiBwcm9jZXNzaW5nRGF0YS5pbnB1dCA9IGlucHV0KSxcbiAgICAgICAgdGFwKChpbnB1dDogVElucHV0KSA9PiB0aGlzLmNoZWNrSWZXb3JrZXJDb21wbGV0ZSh0b2tlbiwgaW5wdXQpKSxcbiAgICAgICAgdGFrZVdoaWxlKChpbnB1dDogVElucHV0KSA9PiBpc1ZhbHVlKGlucHV0KSAmJiAhdG9rZW4uaXNDYW5jZWxlZCksXG4gICAgICAgIHRhcCgoaW5wdXQ6IFRJbnB1dCkgPT4gdGhpcy5lbWl0V29ya1N0YXJ0ZWQodG9rZW4sIGlucHV0KSksXG4gICAgICAgIG1lcmdlTWFwKChpbnB1dDogVElucHV0KSA9PiB0aGlzLm9uQmVmb3JlV29ya1N0YXJ0ZWQoaW5wdXQpKSxcbiAgICAgICAgbWVyZ2VNYXAoKGlucHV0OiBUSW5wdXQpID0+IHRoaXMuZG9Xb3JrKGlucHV0KSksXG4gICAgICAgIHRhcCgob3V0cHV0OiBUT3V0cHV0KSA9PiBwcm9jZXNzaW5nRGF0YS5vdXRwdXQgPSBvdXRwdXQpLFxuICAgICAgICBtYXAoKCkgPT4gcHJvY2Vzc2luZ0RhdGEpLFxuICAgICAgICBtZXJnZU1hcCgoZGF0YTogUXVldWVQYXlsb2FkPFRJbnB1dCwgVE91dHB1dD4pID0+IHRoaXMub25Xb3JrQ29tcGxldGUoZGF0YSkpLFxuICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKGRhdGE6IFF1ZXVlUGF5bG9hZDxUSW5wdXQsIFRPdXRwdXQ+KSA9PiB7XG4gICAgICAgIHRoaXMubG9nLnRyYWNlKCdDb21wbGV0ZWQgd29yayBmb3IgaXRlbScpO1xuICAgICAgICB0b2tlbi50b3RhbENvbXBsZXRlKys7XG4gICAgICAgIHRoaXMuZW1pdFdvcmtDb21wbGV0ZSh0b2tlbiwgZGF0YS5pbnB1dCwgZGF0YS5vdXRwdXQpO1xuICAgICAgICB0aGlzLmdldE5leHRBbmREb1dvcmsodG9rZW4pO1xuICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyBpdGVtLiB7ZXJyb3J9YCwgZXJyb3IpO1xuICAgICAgICB0b2tlbi50b3RhbEZhaWxlZCsrO1xuICAgICAgICB0aGlzLm9uV29ya0ZhaWxlZChwcm9jZXNzaW5nRGF0YSwgZXJyb3IpXG4gICAgICAgICAgLnRvUHJvbWlzZSgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5nZXROZXh0QW5kRG9Xb3JrKHRva2VuKSk7XG4gICAgICB9KTtcbiAgfVxufVxuIl19