/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
// Angular.
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
// 3rd Party.
import { Subject, of } from 'rxjs';
import { finalize, map, catchError } from 'rxjs/operators';
// TSS.
import { GeolocatorCapability } from '../geolocation/geolocator/geolocator-capability';
import { BaseGeolocator } from '../geolocation/geolocator/base-geolocator.service';
import { GeolocatorAccuracyUnit } from '../geolocation/geolocator/geolocator-accuracy-unit';
import { Logger } from '../core/logging/logger.service';
import { GpsGateConfig } from './gps-gate.config';
import { format } from '../core/formatting/format.function';
import { Geolocatable } from '../geolocation/geolocator/geolocatable.decorator';
import * as i0 from "@angular/core";
import * as i1 from "../core/logging/logger.service";
import * as i2 from "@angular/common/http";
import * as i3 from "./gps-gate.config";
/**
 * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
 * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
 */
let GpsGateGeolocator = /**
 * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
 * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
 */
class GpsGateGeolocator extends BaseGeolocator {
    /**
     * @param {?} log
     * @param {?} http
     * @param {?} config
     */
    constructor(log, http, config) {
        super(log);
        this.http = http;
        this.config = config;
        this.capabilities = [
            GeolocatorCapability.Altitude,
            GeolocatorCapability.AltitudeAccuracy,
            GeolocatorCapability.Heading,
            GeolocatorCapability.Speed,
            GeolocatorCapability.HDOP,
        ];
        this.accuracyUnit = GeolocatorAccuracyUnit.Hdop;
    }
    /**
     * @return {?}
     */
    get name() {
        return this.config.geolocatorName;
    }
    /**
     * @return {?}
     */
    get description() {
        return this.config.geolocatorDescription;
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    getCurrentPosition(options) {
        /** @type {?} */
        const url = format(this.config.urlTemplate, {
            endpoint: this.config.getInfoEndpoint,
            cacheBuster: new Date().getTime()
        });
        return this.http.jsonp(url, this.config.jsonpParameterName)
            .pipe(map((/**
         * @param {?} info
         * @return {?}
         */
        (info) => {
            /** @type {?} */
            const timestamp = new Date(info.trackPoint.utc).getTime();
            /** @type {?} */
            const position = Object.assign({
                timestamp,
                // NOTE: We are setting accuracy to HDOP because since this geolocator does not have
                // accuracy capabilities (see capabilities property), accuracy will not be shown within
                // the UI - rather fallback PDOP, HDOP, VDOP, etc will be used. However, we want to set
                // the accuracy because this value is what will be used to do collection
                // accuracy/precision acceptance (acceptable, warning, unaceptable, etc) - RG.
                accuracy: info.trackPoint.precision.hdop,
                altitudeAccuracy: null,
                speed: info.trackPoint.velocity.groundSpeed,
                heading: info.trackPoint.velocity.heading,
                hdop: info.trackPoint.precision.hdop
            }, info.trackPoint.position);
            this.log.trace(`Received current position for ${this.name}`);
            return position;
        })))
            .toPromise();
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    watchPosition(options) {
        /** @type {?} */
        let lastPosition;
        /** @type {?} */
        const subject = new Subject();
        /** @type {?} */
        const interval = setInterval((/**
         * @return {?}
         */
        () => {
            this.getCurrentPosition(options)
                .then((/**
             * @param {?} position
             * @return {?}
             */
            position => {
                if (notEqual(position, lastPosition)) {
                    subject.next(position);
                }
                this.log.trace(`Received watch position for ${this.name}`);
                lastPosition = position;
            }))
                .catch((/**
             * @param {?} error
             * @return {?}
             */
            error => subject.error(error)));
        }), this.config.refreshInterval);
        return subject.pipe(finalize((/**
         * @return {?}
         */
        () => clearInterval(interval))));
    }
    /**
     * @return {?}
     */
    isAvailable() {
        return this.getVersion()
            .pipe(map((/**
         * @param {?} result
         * @return {?}
         */
        result => Boolean(result))), catchError((/**
         * @return {?}
         */
        () => of(false))));
    }
    /**
     * @return {?}
     */
    getVersion() {
        /** @type {?} */
        const url = format(this.config.urlTemplate, {
            endpoint: this.config.getVersionEndpoint,
            cacheBuster: new Date().getTime()
        });
        return this.http.jsonp(url, this.config.jsonpParameterName);
    }
};
GpsGateGeolocator.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
GpsGateGeolocator.ctorParameters = () => [
    { type: Logger },
    { type: HttpClient },
    { type: GpsGateConfig }
];
/** @nocollapse */ GpsGateGeolocator.ngInjectableDef = i0.defineInjectable({ factory: function GpsGateGeolocator_Factory() { return new GpsGateGeolocator(i0.inject(i1.Logger), i0.inject(i2.HttpClient), i0.inject(i3.GpsGateConfig)); }, token: GpsGateGeolocator, providedIn: "root" });
/**
 * Wrapper for geolocation service. The wrapper primarily exists to abstract the direct interaction with
 * the "navigator" object and to allow for injecting other implementations of geolocation functionality.
 */
GpsGateGeolocator = tslib_1.__decorate([
    Geolocatable('gps-gate'),
    tslib_1.__metadata("design:paramtypes", [Logger, HttpClient, GpsGateConfig])
], GpsGateGeolocator);
export { GpsGateGeolocator };
if (false) {
    /** @type {?} */
    GpsGateGeolocator.prototype.capabilities;
    /**
     * @type {?}
     * @private
     */
    GpsGateGeolocator.prototype.http;
    /**
     * @type {?}
     * @private
     */
    GpsGateGeolocator.prototype.config;
}
/**
 * @param {?} position1
 * @param {?} position2
 * @return {?}
 */
function notEqual(position1, position2) {
    return !equal(position1, position2);
}
/**
 * @param {?} position1
 * @param {?} position2
 * @return {?}
 */
function equal(position1, position2) {
    return position1
        && position2
        && position1.timestamp === position2.timestamp
        && position1.latitude === position2.latitude
        && position1.longitude === position2.longitude
        && position1.accuracy === position2.accuracy
        && position1.speed === position2.speed
        && position1.heading === position2.heading
        && position1.altitude === position2.altitude
        && position1.altitudeAccuracy === position2.altitudeAccuracy
        && position1.pdop === position2.pdop
        && position1.hdop === position2.hdop
        && position1.vdop === position2.vdop
        && position1.tdop === position2.tdop;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3BzLWdhdGUtZ2VvbG9jYXRvci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRzcy9zZGsvIiwic291cmNlcyI6WyJsaWIvZ3BzLWdhdGUvZ3BzLWdhdGUtZ2VvbG9jYXRvci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDOztBQUdsRCxPQUFPLEVBQWMsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQyxPQUFPLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7QUFHM0QsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0saURBQWlELENBQUM7QUFDdkYsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1EQUFtRCxDQUFDO0FBQ25GLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLG9EQUFvRCxDQUFDO0FBQzVGLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUN4RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFJbEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQzVELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxrREFBa0QsQ0FBQzs7Ozs7Ozs7O0lBU25FLGlCQUFpQjs7OztNQUFqQixpQkFBa0IsU0FBUSxjQUFjOzs7Ozs7SUFpQm5ELFlBQVksR0FBVyxFQUFtQixJQUFnQixFQUFtQixNQUFxQjtRQUNoRyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFENkIsU0FBSSxHQUFKLElBQUksQ0FBWTtRQUFtQixXQUFNLEdBQU4sTUFBTSxDQUFlO1FBaEJsRyxpQkFBWSxHQUFHO1lBQ2Isb0JBQW9CLENBQUMsUUFBUTtZQUM3QixvQkFB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QyxTQUFTO1dBQzNDLFNBQVMsQ0FBQyxRQUFRLEtBQUssU0FBUyxDQUFDLFFBQVE7V0FDekMsU0FBUyxDQUFDLFNBQVMsS0FBSyxTQUFTLENBQUMsU0FBUztXQUMzQyxTQUFTLENBQUMsUUFBUSxLQUFLLFNBQVMsQ0FBQyxRQUFRO1dBQ3pDLFNBQVMsQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDLEtBQUs7V0FDbkMsU0FBUyxDQUFDLE9BQU8sS0FBSyxTQUFTLENBQUMsT0FBTztXQUN2QyxTQUFTLENBQUMsUUFBUSxLQUFLLFNBQVMsQ0FBQyxRQUFRO1dBQ3pDLFNBQVMsQ0FBQyxnQkFBZ0IsS0FBSyxTQUFTLENBQUMsZ0JBQWdCO1dBQ3pELFNBQVMsQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLElBQUk7V0FDakMsU0FBUyxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsSUFBSTtXQUNqQyxTQUFTLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxJQUFJO1dBQ2pDLFNBQVMsQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQztBQUN6QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQW5ndWxhci5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5cbi8vIDNyZCBQYXJ0eS5cbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaW5hbGl6ZSwgbWFwLCBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vLyBUU1MuXG5pbXBvcnQgeyBHZW9sb2NhdG9yQ2FwYWJpbGl0eSB9IGZyb20gJy4uL2dlb2xvY2F0aW9uL2dlb2xvY2F0b3IvZ2VvbG9jYXRvci1jYXBhYmlsaXR5JztcbmltcG9ydCB7IEJhc2VHZW9sb2NhdG9yIH0gZnJvbSAnLi4vZ2VvbG9jYXRpb24vZ2VvbG9jYXRvci9iYXNlLWdlb2xvY2F0b3Iuc2VydmljZSc7XG5pbXBvcnQgeyBHZW9sb2NhdG9yQWNjdXJhY3lVbml0IH0gZnJvbSAnLi4vZ2VvbG9jYXRpb24vZ2VvbG9jYXRvci9nZW9sb2NhdG9yLWFjY3VyYWN5LXVuaXQnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vY29yZS9sb2dnaW5nL2xvZ2dlci5zZXJ2aWNlJztcbmltcG9ydCB7IEdwc0dhdGVDb25maWcgfSBmcm9tICcuL2dwcy1nYXRlLmNvbmZpZyc7XG5pbXBvcnQgeyBHcHNHYXRlVmVyc2lvbkluZm8gfSBmcm9tICcuL2dwcy1nYXRlLXZlcnNpb24taW5mbyc7XG5pbXBvcnQgeyBHcHNQb3NpdGlvbiB9IGZyb20gJy4uL2dlb2xvY2F0aW9uL2dwcy1wb3NpdGlvbi9ncHMtcG9zaXRpb24nO1xuaW1wb3J0IHsgR3BzR2F0ZUdwc0luZm8gfSBmcm9tICcuL2dwcy1nYXRlLWdwcy1pbmZvJztcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJy4uL2NvcmUvZm9ybWF0dGluZy9mb3JtYXQuZnVuY3Rpb24nO1xuaW1wb3J0IHsgR2VvbG9jYXRhYmxlIH0gZnJvbSAnLi4vZ2VvbG9jYXRpb24vZ2VvbG9jYXRvci9nZW9sb2NhdGFibGUuZGVjb3JhdG9yJztcblxuXG4vKipcbiAqIFdyYXBwZXIgZm9yIGdlb2xvY2F0aW9uIHNlcnZpY2UuIFRoZSB3cmFwcGVyIHByaW1hcmlseSBleGlzdHMgdG8gYWJzdHJhY3QgdGhlIGRpcmVjdCBpbnRlcmFjdGlvbiB3aXRoXG4gKiB0aGUgXCJuYXZpZ2F0b3JcIiBvYmplY3QgYW5kIHRvIGFsbG93IGZvciBpbmplY3Rpbmcgb3RoZXIgaW1wbGVtZW50YXRpb25zIG9mIGdlb2xvY2F0aW9uIGZ1bmN0aW9uYWxpdHkuXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5AR2VvbG9jYXRhYmxlKCdncHMtZ2F0ZScpXG5leHBvcnQgY2xhc3MgR3BzR2F0ZUdlb2xvY2F0b3IgZXh0ZW5kcyBCYXNlR2VvbG9jYXRvciB7XG4gIGNhcGFiaWxpdGllcyA9IFtcbiAgICBHZW9sb2NhdG9yQ2FwYWJpbGl0eS5BbHRpdHVkZSxcbiAgICBHZW9sb2NhdG9yQ2FwYWJpbGl0eS5BbHRpdHVkZUFjY3VyYWN5LFxuICAgIEdlb2xvY2F0b3JDYXBhYmlsaXR5LkhlYWRpbmcsXG4gICAgR2VvbG9jYXRvckNhcGFiaWxpdHkuU3BlZWQsXG4gICAgR2VvbG9jYXRvckNhcGFiaWxpdHkuSERPUCxcbiAgXTtcblxuICBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5nZW9sb2NhdG9yTmFtZTtcbiAgfVxuXG4gIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5nZW9sb2NhdG9yRGVzY3JpcHRpb247XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2c6IExvZ2dlciwgcHJpdmF0ZSByZWFkb25seSBodHRwOiBIdHRwQ2xpZW50LCBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogR3BzR2F0ZUNvbmZpZykge1xuICAgIHN1cGVyKGxvZyk7XG4gICAgdGhpcy5hY2N1cmFjeVVuaXQgPSBHZW9sb2NhdG9yQWNjdXJhY3lVbml0Lkhkb3A7XG4gIH1cblxuICBnZXRDdXJyZW50UG9zaXRpb24ob3B0aW9ucz86IFBvc2l0aW9uT3B0aW9ucyk6IFByb21pc2U8R3BzUG9zaXRpb24+IHtcbiAgICBjb25zdCB1cmwgPSBmb3JtYXQodGhpcy5jb25maWcudXJsVGVtcGxhdGUsIHtcbiAgICAgIGVuZHBvaW50OiB0aGlzLmNvbmZpZy5nZXRJbmZvRW5kcG9pbnQsXG4gICAgICBjYWNoZUJ1c3RlcjogbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmh0dHAuanNvbnA8R3BzR2F0ZUdwc0luZm8+KHVybCwgdGhpcy5jb25maWcuanNvbnBQYXJhbWV0ZXJOYW1lKVxuICAgICAgLnBpcGUoXG4gICAgICAgIG1hcCgoaW5mbzogR3BzR2F0ZUdwc0luZm8pID0+IHtcbiAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZShpbmZvLnRyYWNrUG9pbnQudXRjKS5nZXRUaW1lKCk7XG4gICAgICAgICAgY29uc3QgcG9zaXRpb246IEdwc1Bvc2l0aW9uID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICAvLyBOT1RFOiBXZSBhcmUgc2V0dGluZyBhY2N1cmFjeSB0byBIRE9QIGJlY2F1c2Ugc2luY2UgdGhpcyBnZW9sb2NhdG9yIGRvZXMgbm90IGhhdmVcbiAgICAgICAgICAgIC8vIGFjY3VyYWN5IGNhcGFiaWxpdGllcyAoc2VlIGNhcGFiaWxpdGllcyBwcm9wZXJ0eSksIGFjY3VyYWN5IHdpbGwgbm90IGJlIHNob3duIHdpdGhpblxuICAgICAgICAgICAgLy8gdGhlIFVJIC0gcmF0aGVyIGZhbGxiYWNrIFBET1AsIEhET1AsIFZET1AsIGV0YyB3aWxsIGJlIHVzZWQuIEhvd2V2ZXIsIHdlIHdhbnQgdG8gc2V0XG4gICAgICAgICAgICAvLyB0aGUgYWNjdXJhY3kgYmVjYXVzZSB0aGlzIHZhbHVlIGlzIHdoYXQgd2lsbCBiZSB1c2VkIHRvIGRvIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIC8vIGFjY3VyYWN5L3ByZWNpc2lvbiBhY2NlcHRhbmNlIChhY2NlcHRhYmxlLCB3YXJuaW5nLCB1bmFjZXB0YWJsZSwgZXRjKSAtIFJHLlxuICAgICAgICAgICAgYWNjdXJhY3k6IGluZm8udHJhY2tQb2ludC5wcmVjaXNpb24uaGRvcCxcbiAgICAgICAgICAgIGFsdGl0dWRlQWNjdXJhY3k6IG51bGwsXG4gICAgICAgICAgICBzcGVlZDogaW5mby50cmFja1BvaW50LnZlbG9jaXR5Lmdyb3VuZFNwZWVkLFxuICAgICAgICAgICAgaGVhZGluZzogaW5mby50cmFja1BvaW50LnZlbG9jaXR5LmhlYWRpbmcsXG4gICAgICAgICAgICBoZG9wOiBpbmZvLnRyYWNrUG9pbnQucHJlY2lzaW9uLmhkb3BcbiAgICAgICAgICB9LCBpbmZvLnRyYWNrUG9pbnQucG9zaXRpb24pO1xuXG4gICAgICAgICAgdGhpcy5sb2cudHJhY2UoYFJlY2VpdmVkIGN1cnJlbnQgcG9zaXRpb24gZm9yICR7dGhpcy5uYW1lfWApO1xuICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICAgIC50b1Byb21pc2UoKTtcbiAgfVxuXG4gIHdhdGNoUG9zaXRpb24ob3B0aW9ucz86IFBvc2l0aW9uT3B0aW9ucyk6IE9ic2VydmFibGU8R3BzUG9zaXRpb24+IHtcbiAgICBsZXQgbGFzdFBvc2l0aW9uOiBHcHNQb3NpdGlvbjtcbiAgICBjb25zdCBzdWJqZWN0ID0gbmV3IFN1YmplY3Q8R3BzUG9zaXRpb24+KCk7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLmdldEN1cnJlbnRQb3NpdGlvbihvcHRpb25zKVxuICAgICAgICAudGhlbihwb3NpdGlvbiA9PiB7XG4gICAgICAgICAgaWYgKG5vdEVxdWFsKHBvc2l0aW9uLCBsYXN0UG9zaXRpb24pKSB7XG4gICAgICAgICAgICBzdWJqZWN0Lm5leHQocG9zaXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubG9nLnRyYWNlKGBSZWNlaXZlZCB3YXRjaCBwb3NpdGlvbiBmb3IgJHt0aGlzLm5hbWV9YCk7XG4gICAgICAgICAgbGFzdFBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiBzdWJqZWN0LmVycm9yKGVycm9yKSk7XG4gICAgfSwgdGhpcy5jb25maWcucmVmcmVzaEludGVydmFsKTtcblxuICAgIHJldHVybiBzdWJqZWN0LnBpcGUoXG4gICAgICBmaW5hbGl6ZSgoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKSlcbiAgICApO1xuICB9XG5cbiAgaXNBdmFpbGFibGUoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmVyc2lvbigpXG4gICAgICAucGlwZShcbiAgICAgICAgbWFwKHJlc3VsdCA9PiBCb29sZWFuKHJlc3VsdCkpLFxuICAgICAgICBjYXRjaEVycm9yKCgpID0+IG9mKGZhbHNlKSlcbiAgICAgICk7XG4gIH1cblxuICBnZXRWZXJzaW9uKCk6IE9ic2VydmFibGU8R3BzR2F0ZVZlcnNpb25JbmZvPiB7XG4gICAgY29uc3QgdXJsID0gZm9ybWF0KHRoaXMuY29uZmlnLnVybFRlbXBsYXRlLCB7XG4gICAgICBlbmRwb2ludDogdGhpcy5jb25maWcuZ2V0VmVyc2lvbkVuZHBvaW50LFxuICAgICAgY2FjaGVCdXN0ZXI6IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5odHRwLmpzb25wPEdwc0dhdGVWZXJzaW9uSW5mbz4odXJsLCB0aGlzLmNvbmZpZy5qc29ucFBhcmFtZXRlck5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vdEVxdWFsKHBvc2l0aW9uMTogR3BzUG9zaXRpb24sIHBvc2l0aW9uMjogR3BzUG9zaXRpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuICFlcXVhbChwb3NpdGlvbjEsIHBvc2l0aW9uMik7XG59XG5cbmZ1bmN0aW9uIGVxdWFsKHBvc2l0aW9uMTogR3BzUG9zaXRpb24sIHBvc2l0aW9uMjogR3BzUG9zaXRpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHBvc2l0aW9uMVxuICAgICYmIHBvc2l0aW9uMlxuICAgICYmIHBvc2l0aW9uMS50aW1lc3RhbXAgPT09IHBvc2l0aW9uMi50aW1lc3RhbXBcbiAgICAmJiBwb3NpdGlvbjEubGF0aXR1ZGUgPT09IHBvc2l0aW9uMi5sYXRpdHVkZVxuICAgICYmIHBvc2l0aW9uMS5sb25naXR1ZGUgPT09IHBvc2l0aW9uMi5sb25naXR1ZGVcbiAgICAmJiBwb3NpdGlvbjEuYWNjdXJhY3kgPT09IHBvc2l0aW9uMi5hY2N1cmFjeVxuICAgICYmIHBvc2l0aW9uMS5zcGVlZCA9PT0gcG9zaXRpb24yLnNwZWVkXG4gICAgJiYgcG9zaXRpb24xLmhlYWRpbmcgPT09IHBvc2l0aW9uMi5oZWFkaW5nXG4gICAgJiYgcG9zaXRpb24xLmFsdGl0dWRlID09PSBwb3NpdGlvbjIuYWx0aXR1ZGVcbiAgICAmJiBwb3NpdGlvbjEuYWx0aXR1ZGVBY2N1cmFjeSA9PT0gcG9zaXRpb24yLmFsdGl0dWRlQWNjdXJhY3lcbiAgICAmJiBwb3NpdGlvbjEucGRvcCA9PT0gcG9zaXRpb24yLnBkb3BcbiAgICAmJiBwb3NpdGlvbjEuaGRvcCA9PT0gcG9zaXRpb24yLmhkb3BcbiAgICAmJiBwb3NpdGlvbjEudmRvcCA9PT0gcG9zaXRpb24yLnZkb3BcbiAgICAmJiBwb3NpdGlvbjEudGRvcCA9PT0gcG9zaXRpb24yLnRkb3A7XG59XG4iXX0=