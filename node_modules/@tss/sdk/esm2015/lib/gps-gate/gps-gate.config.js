/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
// Angular.
import { Injectable } from '@angular/core';
// TSS.
import { AutoConfig } from '../core/auto-config.decorator';
import * as i0 from "@angular/core";
/**
 * Configuration class for storing Gps Gate-related settings.
 */
let GpsGateConfig = /**
 * Configuration class for storing Gps Gate-related settings.
 */
class GpsGateConfig {
    constructor() {
        this.refreshInterval = 1000;
        this.urlTemplate = 'http://localhost:12175/gps/{endpoint}?noCache={cacheBuster}';
        this.getInfoEndpoint = 'getGpsInfo';
        this.getVersionEndpoint = 'getVersion';
        this.jsonpParameterName = 'jsonp';
        this.geolocatorName = 'GpsGate Client';
        this.geolocatorDescription = 'GpsGate client that can connect to a variety of GPS data sources.';
    }
};
GpsGateConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ GpsGateConfig.ngInjectableDef = i0.defineInjectable({ factory: function GpsGateConfig_Factory() { return new GpsGateConfig(); }, token: GpsGateConfig, providedIn: "root" });
/**
 * Configuration class for storing Gps Gate-related settings.
 */
GpsGateConfig = tslib_1.__decorate([
    AutoConfig('GpsGateConfig')
], GpsGateConfig);
export { GpsGateConfig };
if (false) {
    /** @type {?} */
    GpsGateConfig.prototype.refreshInterval;
    /** @type {?} */
    GpsGateConfig.prototype.urlTemplate;
    /** @type {?} */
    GpsGateConfig.prototype.getInfoEndpoint;
    /** @type {?} */
    GpsGateConfig.prototype.getVersionEndpoint;
    /** @type {?} */
    GpsGateConfig.prototype.jsonpParameterName;
    /** @type {?} */
    GpsGateConfig.prototype.geolocatorName;
    /** @type {?} */
    GpsGateConfig.prototype.geolocatorDescription;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3BzLWdhdGUuY29uZmlnLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRzcy9zZGsvIiwic291cmNlcyI6WyJsaWIvZ3BzLWdhdGUvZ3BzLWdhdGUuY29uZmlnLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBRzNDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQzs7Ozs7SUFVOUMsYUFBYTs7O01BQWIsYUFBYTtJQUoxQjtRQUtFLG9CQUFlLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLGdCQUFXLEdBQUcsNkRBQTZELENBQUM7UUFDNUUsb0JBQWUsR0FBRyxZQUFZLENBQUM7UUFDL0IsdUJBQWtCLEdBQUcsWUFBWSxDQUFDO1FBQ2xDLHVCQUFrQixHQUFHLE9BQU8sQ0FBQztRQUM3QixtQkFBYyxHQUFHLGdCQUFnQixDQUFDO1FBQ2xDLDBCQUFxQixHQUFHLG1FQUFtRSxDQUFDO0tBQzdGO0NBQUEsQ0FBQTs7WUFaQSxVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkI7Ozs7OztBQUVZLGFBQWE7SUFEekIsVUFBVSxDQUFDLGVBQWUsQ0FBQztHQUNmLGFBQWEsQ0FRekI7U0FSWSxhQUFhOzs7SUFDeEIsd0NBQXVCOztJQUN2QixvQ0FBNEU7O0lBQzVFLHdDQUErQjs7SUFDL0IsMkNBQWtDOztJQUNsQywyQ0FBNkI7O0lBQzdCLHVDQUFrQzs7SUFDbEMsOENBQTRGIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQW5ndWxhci5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLy8gVFNTLlxuaW1wb3J0IHsgQXV0b0NvbmZpZyB9IGZyb20gJy4uL2NvcmUvYXV0by1jb25maWcuZGVjb3JhdG9yJztcblxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gY2xhc3MgZm9yIHN0b3JpbmcgR3BzIEdhdGUtcmVsYXRlZCBzZXR0aW5ncy5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5AQXV0b0NvbmZpZygnR3BzR2F0ZUNvbmZpZycpXG5leHBvcnQgY2xhc3MgR3BzR2F0ZUNvbmZpZyB7XG4gIHJlZnJlc2hJbnRlcnZhbCA9IDEwMDA7XG4gIHVybFRlbXBsYXRlID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6MTIxNzUvZ3BzL3tlbmRwb2ludH0/bm9DYWNoZT17Y2FjaGVCdXN0ZXJ9JztcbiAgZ2V0SW5mb0VuZHBvaW50ID0gJ2dldEdwc0luZm8nO1xuICBnZXRWZXJzaW9uRW5kcG9pbnQgPSAnZ2V0VmVyc2lvbic7XG4gIGpzb25wUGFyYW1ldGVyTmFtZSA9ICdqc29ucCc7XG4gIGdlb2xvY2F0b3JOYW1lID0gJ0dwc0dhdGUgQ2xpZW50JztcbiAgZ2VvbG9jYXRvckRlc2NyaXB0aW9uID0gJ0dwc0dhdGUgY2xpZW50IHRoYXQgY2FuIGNvbm5lY3QgdG8gYSB2YXJpZXR5IG9mIEdQUyBkYXRhIHNvdXJjZXMuJztcbn1cbiJdfQ==