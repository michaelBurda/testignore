/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Angualr.
import { Injectable } from '@angular/core';
import { HttpResponse } from '@angular/common/http';
// 3rd Party.
import { of, throwError } from 'rxjs';
import { tap, catchError } from 'rxjs/operators';
// TSS.
import { CacheService } from './cache.service';
import { CacheConfig } from './cache.config';
import { Logger } from '../core/logging/logger.service';
import { CacheStrategy } from './cache-strategy';
import { hasTokens } from '../core/tokens/has-tokens.function';
import { isString } from '../core/type-check/is-string.function';
import { extractTokenValuesFromTemplate } from '../core/tokens/extract-token-values-from-template.function';
import { format } from '../core/formatting/format.function';
import { CACHE_ONLY_NO_DATA_EXC_MSG } from './cache.constants';
import * as i0 from "@angular/core";
import * as i1 from "./cache.config";
import * as i2 from "./cache.service";
import * as i3 from "../core/logging/logger.service";
/**
 * @param {?} strategy
 * @return {?}
 */
function shouldCheckCacheFirst(strategy) {
    return strategy === CacheStrategy.CacheFirst
        || strategy === CacheStrategy.Fastest
        || strategy === CacheStrategy.CacheOnly;
}
/**
 * @param {?} definition
 * @param {?} requestUrl
 * @return {?}
 */
function getCacheKey(definition, requestUrl) {
    /** @type {?} */
    let cacheKey = definition.cacheId || requestUrl;
    if (hasTokens(cacheKey) && isString(definition.route)) {
        /** @type {?} */
        const tokenValues = extractTokenValuesFromTemplate((/** @type {?} */ (definition.route)), requestUrl);
        cacheKey = format(cacheKey, tokenValues, true);
    }
    return cacheKey;
}
export class CacheInterceptor {
    /**
     * @param {?} config
     * @param {?} cache
     * @param {?} log
     */
    constructor(config, cache, log) {
        this.config = config;
        this.cache = cache;
        this.log = log;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        /** @type {?} */
        const allowCaching = request.method === 'GET' && this.config.cacheEnabled;
        /** @type {?} */
        let matchingCacheDefinition;
        // TODO: Handle request method type.
        // TDOO: Handle global use cache only.
        if (allowCaching) {
            matchingCacheDefinition = this.config.getCacheDefinition(request.urlWithParams);
            /** @type {?} */
            const strategy = matchingCacheDefinition
                ? this.config.forcedGlobalCacheStrategy || matchingCacheDefinition.strategy
                : null;
            if (matchingCacheDefinition && shouldCheckCacheFirst(strategy)) {
                /** @type {?} */
                const cacheKey = getCacheKey(matchingCacheDefinition, request.url);
                /** @type {?} */
                const isCacheOnly = strategy === CacheStrategy.CacheOnly;
                /** @type {?} */
                const cachedResponse = this.cache.get(cacheKey);
                if (cachedResponse) {
                    this.log.debug(`Resolving HTTP request from cache: '${request.url}'`);
                    return of(cachedResponse);
                }
                else if (isCacheOnly) {
                    return throwError(new Error(CACHE_ONLY_NO_DATA_EXC_MSG));
                }
            }
        }
        this.log.trace(`Making HTTP request: '${request.url}'`);
        /** @type {?} */
        let continuedResponse = next.handle(request);
        // If a matched cache definition is found, then we need to handle caching when the request when it is complete.
        if (allowCaching && matchingCacheDefinition) {
            continuedResponse = this.cacheResponse(continuedResponse, request, matchingCacheDefinition);
        }
        return continuedResponse;
    }
    /**
     * @private
     * @param {?} source
     * @param {?} request
     * @param {?} cacheDefinition
     * @return {?}
     */
    cacheResponse(source, request, cacheDefinition) {
        /** @type {?} */
        const cacheKey = getCacheKey(cacheDefinition, request.url);
        return source.pipe(tap((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            if (cacheDefinition && event instanceof HttpResponse) {
                this.log.debug(`Caching HTTP request: '${request.url}'`);
                this.cache.set(cacheKey, event, cacheDefinition.expires);
            }
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            /** @type {?} */
            const cachedData = this.cache.get(cacheKey);
            if (cachedData) {
                this.log.debug(`Failed to resolve cacheable HTTP request from URL '${request.url}', fallingback to cache`);
                return of(cachedData);
            }
            else {
                this.log.debug(`Failed to resolve cacheable HTTP request from URL '${request.url}' and no cached data available`);
                throw error;
            }
        })));
    }
}
CacheInterceptor.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CacheInterceptor.ctorParameters = () => [
    { type: CacheConfig },
    { type: CacheService },
    { type: Logger }
];
/** @nocollapse */ CacheInterceptor.ngInjectableDef = i0.defineInjectable({ factory: function CacheInterceptor_Factory() { return new CacheInterceptor(i0.inject(i1.CacheConfig), i0.inject(i2.CacheService), i0.inject(i3.Logger)); }, token: CacheInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    CacheInterceptor.prototype.config;
    /**
     * @type {?}
     * @private
     */
    CacheInterceptor.prototype.cache;
    /**
     * @type {?}
     * @private
     */
    CacheInterceptor.prototype.log;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGUuaW50ZXJjZXB0b3IuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdHNzL3Nkay8iLCJzb3VyY2VzIjpbImxpYi9jYWNoZS9jYWNoZS5pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUF3RCxZQUFZLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQzs7QUFHMUcsT0FBTyxFQUFjLEVBQUUsRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEQsT0FBTyxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7QUFHakQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDeEQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRWpELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUMvRCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sdUNBQXVDLENBQUM7QUFDakUsT0FBTyxFQUFFLDhCQUE4QixFQUFFLE1BQU0sNERBQTRELENBQUM7QUFDNUcsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQzVELE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLG1CQUFtQixDQUFDOzs7Ozs7Ozs7QUFHL0QsU0FBUyxxQkFBcUIsQ0FBQyxRQUF1QjtJQUNwRCxPQUFPLFFBQVEsS0FBSyxhQUFhLENBQUMsVUFBVTtXQUN2QyxRQUFRLEtBQUssYUFBYSxDQUFDLE9BQU87V0FDbEMsUUFBUSxLQUFLLGFBQWEsQ0FBQyxTQUFTLENBQUM7QUFDNUMsQ0FBQzs7Ozs7O0FBRUQsU0FBUyxXQUFXLENB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QUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDekQsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDMUQ7UUFDSCxDQUFDLEVBQUMsRUFDRixVQUFVOzs7O1FBQUMsQ0FBQyxLQUFVLEVBQUUsRUFBRTs7a0JBQ2xCLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUM7WUFDM0MsSUFBSSxVQUFVLEVBQUU7Z0JBQ2QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsc0RBQXNELE9BQU8sQ0FBQyxHQUFHLHlCQUF5QixDQUFDLENBQUM7Z0JBQzNHLE9BQU8sRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQ3ZCO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLHNEQUFzRCxPQUFPLENBQUMsR0FBRyxnQ0FBZ0MsQ0FBQyxDQUFDO2dCQUNsSCxNQUFNLEtBQUssQ0FBQzthQUNiO1FBQ0gsQ0FBQyxFQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7OztZQXJFRixVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkI7Ozs7WUE5QlEsV0FBVztZQURYLFlBQVk7WUFFWixNQUFNOzs7Ozs7OztJQStCRCxrQ0FBMkI7Ozs7O0lBQUUsaUNBQTJCOzs7OztJQUFFLCtCQUFtQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIEFuZ3VhbHIuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIdHRwUmVxdWVzdCwgSHR0cEhhbmRsZXIsIEh0dHBFdmVudCwgSHR0cEludGVyY2VwdG9yLCBIdHRwUmVzcG9uc2UgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5cbi8vIDNyZCBQYXJ0eS5cbmltcG9ydCB7IE9ic2VydmFibGUsIG9mLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YXAsIGNhdGNoRXJyb3IgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8vIFRTUy5cbmltcG9ydCB7IENhY2hlU2VydmljZSB9IGZyb20gJy4vY2FjaGUuc2VydmljZSc7XG5pbXBvcnQgeyBDYWNoZUNvbmZpZyB9IGZyb20gJy4vY2FjaGUuY29uZmlnJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2NvcmUvbG9nZ2luZy9sb2dnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDYWNoZVN0cmF0ZWd5IH0gZnJvbSAnLi9jYWNoZS1zdHJhdGVneSc7XG5pbXBvcnQgeyBDYWNoZURlZmluaXRpb24gfSBmcm9tICcuL2NhY2hlLWRlZmluaXRpb24nO1xuaW1wb3J0IHsgaGFzVG9rZW5zIH0gZnJvbSAnLi4vY29yZS90b2tlbnMvaGFzLXRva2Vucy5mdW5jdGlvbic7XG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4uL2NvcmUvdHlwZS1jaGVjay9pcy1zdHJpbmcuZnVuY3Rpb24nO1xuaW1wb3J0IHsgZXh0cmFjdFRva2VuVmFsdWVzRnJvbVRlbXBsYXRlIH0gZnJvbSAnLi4vY29yZS90b2tlbnMvZXh0cmFjdC10b2tlbi12YWx1ZXMtZnJvbS10ZW1wbGF0ZS5mdW5jdGlvbic7XG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tICcuLi9jb3JlL2Zvcm1hdHRpbmcvZm9ybWF0LmZ1bmN0aW9uJztcbmltcG9ydCB7IENBQ0hFX09OTFlfTk9fREFUQV9FWENfTVNHIH0gZnJvbSAnLi9jYWNoZS5jb25zdGFudHMnO1xuXG5cbmZ1bmN0aW9uIHNob3VsZENoZWNrQ2FjaGVGaXJzdChzdHJhdGVneTogQ2FjaGVTdHJhdGVneSkge1xuICByZXR1cm4gc3RyYXRlZ3kgPT09IENhY2hlU3RyYXRlZ3kuQ2FjaGVGaXJzdFxuICAgIHx8IHN0cmF0ZWd5ID09PSBDYWNoZVN0cmF0ZWd5LkZhc3Rlc3RcbiAgICB8fCBzdHJhdGVneSA9PT0gQ2FjaGVTdHJhdGVneS5DYWNoZU9ubHk7XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlS2V5KGRlZmluaXRpb246IENhY2hlRGVmaW5pdGlvbiwgcmVxdWVzdFVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IGNhY2hlS2V5ID0gZGVmaW5pdGlvbi5jYWNoZUlkIHx8IHJlcXVlc3RVcmw7XG4gIGlmIChoYXNUb2tlbnMoY2FjaGVLZXkpICYmIGlzU3RyaW5nKGRlZmluaXRpb24ucm91dGUpKSB7XG4gICAgY29uc3QgdG9rZW5WYWx1ZXMgPSBleHRyYWN0VG9rZW5WYWx1ZXNGcm9tVGVtcGxhdGUoZGVmaW5pdGlvbi5yb3V0ZSBhcyBzdHJpbmcsIHJlcXVlc3RVcmwpO1xuICAgIGNhY2hlS2V5ID0gZm9ybWF0KGNhY2hlS2V5LCB0b2tlblZhbHVlcywgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gY2FjaGVLZXk7XG59XG5cblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgQ2FjaGVJbnRlcmNlcHRvciBpbXBsZW1lbnRzIEh0dHBJbnRlcmNlcHRvciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29uZmlnOiBDYWNoZUNvbmZpZywgcHJpdmF0ZSBjYWNoZTogQ2FjaGVTZXJ2aWNlLCBwcml2YXRlIGxvZzogTG9nZ2VyKSB7XG4gIH1cblxuICBpbnRlcmNlcHQocmVxdWVzdDogSHR0cFJlcXVlc3Q8YW55PiwgbmV4dDogSHR0cEhhbmRsZXIpOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PiB7XG4gICAgY29uc3QgYWxsb3dDYWNoaW5nID0gcmVxdWVzdC5tZXRob2QgPT09ICdHRVQnICYmIHRoaXMuY29uZmlnLmNhY2hlRW5hYmxlZDtcbiAgICBsZXQgbWF0Y2hpbmdDYWNoZURlZmluaXRpb246IENhY2hlRGVmaW5pdGlvbjtcblxuICAgIC8vIFRPRE86IEhhbmRsZSByZXF1ZXN0IG1ldGhvZCB0eXBlLlxuICAgIC8vIFRET086IEhhbmRsZSBnbG9iYWwgdXNlIGNhY2hlIG9ubHkuXG5cbiAgICBpZiAoYWxsb3dDYWNoaW5nKSB7XG4gICAgICBtYXRjaGluZ0NhY2hlRGVmaW5pdGlvbiA9IHRoaXMuY29uZmlnLmdldENhY2hlRGVmaW5pdGlvbihyZXF1ZXN0LnVybFdpdGhQYXJhbXMpO1xuICAgICAgY29uc3Qgc3RyYXRlZ3k6IENhY2hlU3RyYXRlZ3kgPSBtYXRjaGluZ0NhY2hlRGVmaW5pdGlvblxuICAgICAgICA/IHRoaXMuY29uZmlnLmZvcmNlZEdsb2JhbENhY2hlU3RyYXRlZ3kgfHwgbWF0Y2hpbmdDYWNoZURlZmluaXRpb24uc3RyYXRlZ3lcbiAgICAgICAgOiBudWxsO1xuXG4gICAgICBpZiAobWF0Y2hpbmdDYWNoZURlZmluaXRpb24gJiYgc2hvdWxkQ2hlY2tDYWNoZUZpcnN0KHN0cmF0ZWd5KSkge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KG1hdGNoaW5nQ2FjaGVEZWZpbml0aW9uLCByZXF1ZXN0LnVybCk7XG4gICAgICAgIGNvbnN0IGlzQ2FjaGVPbmx5ID0gc3RyYXRlZ3kgPT09IENhY2hlU3RyYXRlZ3kuQ2FjaGVPbmx5O1xuICAgICAgICBjb25zdCBjYWNoZWRSZXNwb25zZTogSHR0cFJlc3BvbnNlPGFueT4gPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG5cbiAgICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoYFJlc29sdmluZyBIVFRQIHJlcXVlc3QgZnJvbSBjYWNoZTogJyR7cmVxdWVzdC51cmx9J2ApO1xuICAgICAgICAgIHJldHVybiBvZihjYWNoZWRSZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDYWNoZU9ubHkpIHtcbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoQ0FDSEVfT05MWV9OT19EQVRBX0VYQ19NU0cpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubG9nLnRyYWNlKGBNYWtpbmcgSFRUUCByZXF1ZXN0OiAnJHtyZXF1ZXN0LnVybH0nYCk7XG4gICAgbGV0IGNvbnRpbnVlZFJlc3BvbnNlOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PiA9IG5leHQuaGFuZGxlKHJlcXVlc3QpO1xuXG4gICAgLy8gSWYgYSBtYXRjaGVkIGNhY2hlIGRlZmluaXRpb24gaXMgZm91bmQsIHRoZW4gd2UgbmVlZCB0byBoYW5kbGUgY2FjaGluZyB3aGVuIHRoZSByZXF1ZXN0IHdoZW4gaXQgaXMgY29tcGxldGUuXG4gICAgaWYgKGFsbG93Q2FjaGluZyAmJiBtYXRjaGluZ0NhY2hlRGVmaW5pdGlvbikge1xuICAgICAgY29udGludWVkUmVzcG9uc2UgPSB0aGlzLmNhY2hlUmVzcG9uc2UoY29udGludWVkUmVzcG9uc2UsIHJlcXVlc3QsIG1hdGNoaW5nQ2FjaGVEZWZpbml0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGludWVkUmVzcG9uc2U7XG4gIH1cblxuICBwcml2YXRlIGNhY2hlUmVzcG9uc2UoXG4gICAgc291cmNlOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PixcbiAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+LFxuICAgIGNhY2hlRGVmaW5pdGlvbjogQ2FjaGVEZWZpbml0aW9uXG4gICk6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGNhY2hlRGVmaW5pdGlvbiwgcmVxdWVzdC51cmwpO1xuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIHRhcChldmVudCA9PiB7XG4gICAgICAgIGlmIChjYWNoZURlZmluaXRpb24gJiYgZXZlbnQgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2UpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhgQ2FjaGluZyBIVFRQIHJlcXVlc3Q6ICcke3JlcXVlc3QudXJsfSdgKTtcbiAgICAgICAgICB0aGlzLmNhY2hlLnNldChjYWNoZUtleSwgZXZlbnQsIGNhY2hlRGVmaW5pdGlvbi5leHBpcmVzKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBjYXRjaEVycm9yKChlcnJvcjogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgIGlmIChjYWNoZWREYXRhKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoYEZhaWxlZCB0byByZXNvbHZlIGNhY2hlYWJsZSBIVFRQIHJlcXVlc3QgZnJvbSBVUkwgJyR7cmVxdWVzdC51cmx9JywgZmFsbGluZ2JhY2sgdG8gY2FjaGVgKTtcbiAgICAgICAgICByZXR1cm4gb2YoY2FjaGVkRGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoYEZhaWxlZCB0byByZXNvbHZlIGNhY2hlYWJsZSBIVFRQIHJlcXVlc3QgZnJvbSBVUkwgJyR7cmVxdWVzdC51cmx9JyBhbmQgbm8gY2FjaGVkIGRhdGEgYXZhaWxhYmxlYCk7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIl19