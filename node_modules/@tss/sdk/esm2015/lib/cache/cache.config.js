import * as tslib_1 from "tslib";
var CacheConfig_1;
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Angular.
import { Injectable } from '@angular/core';
// TSS.
import { AutoConfig } from '../core/auto-config.decorator';
import { isRouteMatch } from '../http/is-route-match.function';
import * as i0 from "@angular/core";
/**
 * Configuration class for storing global data caching settings.
 */
let CacheConfig = CacheConfig_1 = /**
 * Configuration class for storing global data caching settings.
 */
class CacheConfig {
    constructor() {
        /**
         * Determines whether caching should be used or not. When disabled, all
         * caching-related functionality is ignored (not used).
         */
        this.cacheEnabled = false;
        /**
         * List of configurations that describe what to cache and how to cache it.
         * The main parts of this configuration include the "route" (how to match what
         * to cache) and the "strategy" (whether to look for content in the cache first
         * or try to make the HTTP request first).
         */
        this.cacheDefitions = [];
        /**
         * When set, this strategy will trump all strategies defined in the "Cache Defintions".
         * WARNING: This is a global setting and can have adverse affects when used improperly.
         * The main use case for this setting is to allow for the global cache strategy of
         * 'cacheOnly', which will allow an application to force an "offline" state (forcing
         * requests to pull from cache only).
         */
        this.forcedGlobalCacheStrategy = null;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    static create(config) {
        return Object.assign(new CacheConfig_1(), config);
    }
    /**
     * @param {...?} defs
     * @return {?}
     */
    static enable(...defs) {
        return CacheConfig_1.create({
            cacheEnabled: true,
            cacheDefitions: defs,
        });
    }
    /**
     * @param {?} route
     * @return {?}
     */
    getCacheDefinition(route) {
        return this.cacheDefitions.find((/**
         * @param {?} def
         * @return {?}
         */
        def => isRouteMatch(route, def.route)));
    }
};
CacheConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ CacheConfig.ngInjectableDef = i0.defineInjectable({ factory: function CacheConfig_Factory() { return new CacheConfig(); }, token: CacheConfig, providedIn: "root" });
/**
 * Configuration class for storing global data caching settings.
 */
CacheConfig = CacheConfig_1 = tslib_1.__decorate([
    AutoConfig('CacheConfig')
], CacheConfig);
export { CacheConfig };
if (false) {
    /**
     * Determines whether caching should be used or not. When disabled, all
     * caching-related functionality is ignored (not used).
     * @type {?}
     */
    CacheConfig.prototype.cacheEnabled;
    /**
     * List of configurations that describe what to cache and how to cache it.
     * The main parts of this configuration include the "route" (how to match what
     * to cache) and the "strategy" (whether to look for content in the cache first
     * or try to make the HTTP request first).
     * @type {?}
     */
    CacheConfig.prototype.cacheDefitions;
    /**
     * When set, this strategy will trump all strategies defined in the "Cache Defintions".
     * WARNING: This is a global setting and can have adverse affects when used improperly.
     * The main use case for this setting is to allow for the global cache strategy of
     * 'cacheOnly', which will allow an application to force an "offline" state (forcing
     * requests to pull from cache only).
     * @type {?}
     */
    CacheConfig.prototype.forcedGlobalCacheStrategy;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGUuY29uZmlnLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRzcy9zZGsvIiwic291cmNlcyI6WyJsaWIvY2FjaGUvY2FjaGUuY29uZmlnLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDOztBQUczQyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDM0QsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlDQUFpQyxDQUFDOzs7OztJQWFsRCxXQUFXOzs7TUFBWCxXQUFXO0lBSnhCOzs7OztRQVNFLGlCQUFZLEdBQUcsS0FBSyxDQUFDOzs7Ozs7O1FBUXJCLG1CQUFjLEdBQXNCLEVBQUUsQ0FBQzs7Ozs7Ozs7UUFTdkMsOEJBQXlCLEdBQWtCLElBQUksQ0FBQztLQWdCakQ7Ozs7O0lBZEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUEwQjtRQUN0QyxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxhQUFXLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNsRCxDQUFDOzs7OztJQUVELE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUF1QjtRQUN0QyxPQUFPLGFBQVcsQ0FBQyxNQUFNLENBQUM7WUFDeEIsWUFBWSxFQUFFLElBQUk7WUFDbEIsY0FBYyxFQUFFLElBQUk7U0FDckIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7Ozs7SUFFRCxrQkFBa0IsQ0FBQyxLQUFhO1FBQzlCLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJOzs7O1FBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBQyxDQUFDO0lBQ3pFLENBQUM7Q0FDRixDQUFBOztZQTFDQSxVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkI7Ozs7OztBQUVZLFdBQVc7SUFEdkIsVUFBVSxDQUFDLGFBQWEsQ0FBQztHQUNiLFdBQVcsQ0FzQ3ZCO1NBdENZLFdBQVc7Ozs7Ozs7SUFLdEIsbUNBQXFCOzs7Ozs7OztJQVFyQixxQ0FBdUM7Ozs7Ozs7OztJQVN2QyxnREFBZ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBbmd1bGFyLlxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vLyBUU1MuXG5pbXBvcnQgeyBBdXRvQ29uZmlnIH0gZnJvbSAnLi4vY29yZS9hdXRvLWNvbmZpZy5kZWNvcmF0b3InO1xuaW1wb3J0IHsgaXNSb3V0ZU1hdGNoIH0gZnJvbSAnLi4vaHR0cC9pcy1yb3V0ZS1tYXRjaC5mdW5jdGlvbic7XG5pbXBvcnQgeyBDYWNoZURlZmluaXRpb24gfSBmcm9tICcuL2NhY2hlLWRlZmluaXRpb24nO1xuaW1wb3J0IHsgQ2FjaGVTdHJhdGVneSB9IGZyb20gJy4vY2FjaGUtc3RyYXRlZ3knO1xuaW1wb3J0IHsgQ2FjaGVDb25maWdPcHRpb25zIH0gZnJvbSAnLi9jYWNoZS1jb25maWctb3B0aW9ucyc7XG5cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGNsYXNzIGZvciBzdG9yaW5nIGdsb2JhbCBkYXRhIGNhY2hpbmcgc2V0dGluZ3MuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuQEF1dG9Db25maWcoJ0NhY2hlQ29uZmlnJylcbmV4cG9ydCBjbGFzcyBDYWNoZUNvbmZpZyB7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgY2FjaGluZyBzaG91bGQgYmUgdXNlZCBvciBub3QuIFdoZW4gZGlzYWJsZWQsIGFsbFxuICAgKiBjYWNoaW5nLXJlbGF0ZWQgZnVuY3Rpb25hbGl0eSBpcyBpZ25vcmVkIChub3QgdXNlZCkuXG4gICAqL1xuICBjYWNoZUVuYWJsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogTGlzdCBvZiBjb25maWd1cmF0aW9ucyB0aGF0IGRlc2NyaWJlIHdoYXQgdG8gY2FjaGUgYW5kIGhvdyB0byBjYWNoZSBpdC5cbiAgICogVGhlIG1haW4gcGFydHMgb2YgdGhpcyBjb25maWd1cmF0aW9uIGluY2x1ZGUgdGhlIFwicm91dGVcIiAoaG93IHRvIG1hdGNoIHdoYXRcbiAgICogdG8gY2FjaGUpIGFuZCB0aGUgXCJzdHJhdGVneVwiICh3aGV0aGVyIHRvIGxvb2sgZm9yIGNvbnRlbnQgaW4gdGhlIGNhY2hlIGZpcnN0XG4gICAqIG9yIHRyeSB0byBtYWtlIHRoZSBIVFRQIHJlcXVlc3QgZmlyc3QpLlxuICAgKi9cbiAgY2FjaGVEZWZpdGlvbnM6IENhY2hlRGVmaW5pdGlvbltdID0gW107XG5cbiAgLyoqXG4gICAqIFdoZW4gc2V0LCB0aGlzIHN0cmF0ZWd5IHdpbGwgdHJ1bXAgYWxsIHN0cmF0ZWdpZXMgZGVmaW5lZCBpbiB0aGUgXCJDYWNoZSBEZWZpbnRpb25zXCIuXG4gICAqIFdBUk5JTkc6IFRoaXMgaXMgYSBnbG9iYWwgc2V0dGluZyBhbmQgY2FuIGhhdmUgYWR2ZXJzZSBhZmZlY3RzIHdoZW4gdXNlZCBpbXByb3Blcmx5LlxuICAgKiBUaGUgbWFpbiB1c2UgY2FzZSBmb3IgdGhpcyBzZXR0aW5nIGlzIHRvIGFsbG93IGZvciB0aGUgZ2xvYmFsIGNhY2hlIHN0cmF0ZWd5IG9mXG4gICAqICdjYWNoZU9ubHknLCB3aGljaCB3aWxsIGFsbG93IGFuIGFwcGxpY2F0aW9uIHRvIGZvcmNlIGFuIFwib2ZmbGluZVwiIHN0YXRlIChmb3JjaW5nXG4gICAqIHJlcXVlc3RzIHRvIHB1bGwgZnJvbSBjYWNoZSBvbmx5KS5cbiAgICovXG4gIGZvcmNlZEdsb2JhbENhY2hlU3RyYXRlZ3k6IENhY2hlU3RyYXRlZ3kgPSBudWxsO1xuXG4gIHN0YXRpYyBjcmVhdGUoY29uZmlnOiBDYWNoZUNvbmZpZ09wdGlvbnMpOiBDYWNoZUNvbmZpZyB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IENhY2hlQ29uZmlnKCksIGNvbmZpZyk7XG4gIH1cblxuICBzdGF0aWMgZW5hYmxlKC4uLmRlZnM6IENhY2hlRGVmaW5pdGlvbltdKTogQ2FjaGVDb25maWcge1xuICAgIHJldHVybiBDYWNoZUNvbmZpZy5jcmVhdGUoe1xuICAgICAgY2FjaGVFbmFibGVkOiB0cnVlLFxuICAgICAgY2FjaGVEZWZpdGlvbnM6IGRlZnMsXG4gICAgfSk7XG4gIH1cblxuICBnZXRDYWNoZURlZmluaXRpb24ocm91dGU6IHN0cmluZyk6IENhY2hlRGVmaW5pdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVEZWZpdGlvbnMuZmluZChkZWYgPT4gaXNSb3V0ZU1hdGNoKHJvdXRlLCBkZWYucm91dGUpKTtcbiAgfVxufVxuIl19