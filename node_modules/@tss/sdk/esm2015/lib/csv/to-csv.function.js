/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TSS.
import { CSV_NEW_LINE, CSV_SEPARATOR } from './csv.constants';
import { clone } from '../core/clone/clone.function';
import { isDefined } from '../core/type-check/is-defined.function';
/**
 * @param {?} data
 * @param {...?} properties
 * @return {?}
 */
export function toCsv(data, ...properties) {
    const [firstItem] = data;
    /** @type {?} */
    let csv = '';
    if (firstItem) {
        // NOTE: We need to clone the object here because we can't trust on Object.keys working
        // on every object type. For example, a true "coordinate", object.keys doesn't work - RG.
        properties = properties && properties.length
            ? properties
            : Object.keys(clone(firstItem));
        /** @type {?} */
        const header = `${properties.join(CSV_SEPARATOR)}`;
        /** @type {?} */
        const csvLines = data.map((/**
         * @param {?} point
         * @return {?}
         */
        point => {
            /** @type {?} */
            const fields = properties.map((/**
             * @param {?} property
             * @return {?}
             */
            property => {
                /** @type {?} */
                const value = point[property];
                /** @type {?} */
                const hasPropertyValue = isDefined(value);
                return hasPropertyValue ? value : '';
            }));
            return fields.join(CSV_SEPARATOR);
        }));
        csv = `${header}${CSV_NEW_LINE}${csvLines.join(CSV_NEW_LINE)}`;
    }
    return csv;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG8tY3N2LmZ1bmN0aW9uLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRzcy9zZGsvIiwic291cmNlcyI6WyJsaWIvY3N2L3RvLWNzdi5mdW5jdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDOUQsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ3JELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQzs7Ozs7O0FBR25FLE1BQU0sVUFBVSxLQUFLLENBQUMsSUFBVyxFQUFFLEdBQUcsVUFBb0I7VUFDbEQsQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJOztRQUNwQixHQUFHLEdBQUcsRUFBRTtJQUVaLElBQUksU0FBUyxFQUFFO1FBQ2IsdUZBQXVGO1FBQ3ZGLHlGQUF5RjtRQUN6RixVQUFVLEdBQUcsVUFBVSxJQUFJLFVBQVUsQ0FBQyxNQUFNO1lBQzFDLENBQUMsQ0FBQyxVQUFVO1lBQ1osQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7O2NBRTVCLE1BQU0sR0FBRyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUU7O2NBQzVDLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRzs7OztRQUFDLEtBQUssQ0FBQyxFQUFFOztrQkFDMUIsTUFBTSxHQUFHLFVBQVUsQ0FBQyxHQUFHOzs7O1lBQUMsUUFBUSxDQUFDLEVBQUU7O3NCQUNqQyxLQUFLLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQzs7c0JBQ3ZCLGdCQUFnQixHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUM7Z0JBQ3pDLE9BQU8sZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ3ZDLENBQUMsRUFBQztZQUVGLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNwQyxDQUFDLEVBQUM7UUFFRixHQUFHLEdBQUcsR0FBRyxNQUFNLEdBQUcsWUFBWSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQztLQUNoRTtJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRTUy5cbmltcG9ydCB7IENTVl9ORVdfTElORSwgQ1NWX1NFUEFSQVRPUiB9IGZyb20gJy4vY3N2LmNvbnN0YW50cyc7XG5pbXBvcnQgeyBjbG9uZSB9IGZyb20gJy4uL2NvcmUvY2xvbmUvY2xvbmUuZnVuY3Rpb24nO1xuaW1wb3J0IHsgaXNEZWZpbmVkIH0gZnJvbSAnLi4vY29yZS90eXBlLWNoZWNrL2lzLWRlZmluZWQuZnVuY3Rpb24nO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiB0b0NzdihkYXRhOiBhbnlbXSwgLi4ucHJvcGVydGllczogc3RyaW5nW10pOiBzdHJpbmcge1xuICBjb25zdCBbZmlyc3RJdGVtXSA9IGRhdGE7XG4gIGxldCBjc3YgPSAnJztcblxuICBpZiAoZmlyc3RJdGVtKSB7XG4gICAgLy8gTk9URTogV2UgbmVlZCB0byBjbG9uZSB0aGUgb2JqZWN0IGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCB0cnVzdCBvbiBPYmplY3Qua2V5cyB3b3JraW5nXG4gICAgLy8gb24gZXZlcnkgb2JqZWN0IHR5cGUuIEZvciBleGFtcGxlLCBhIHRydWUgXCJjb29yZGluYXRlXCIsIG9iamVjdC5rZXlzIGRvZXNuJ3Qgd29yayAtIFJHLlxuICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzICYmIHByb3BlcnRpZXMubGVuZ3RoXG4gICAgICA/IHByb3BlcnRpZXNcbiAgICAgIDogT2JqZWN0LmtleXMoY2xvbmUoZmlyc3RJdGVtKSk7XG5cbiAgICBjb25zdCBoZWFkZXIgPSBgJHtwcm9wZXJ0aWVzLmpvaW4oQ1NWX1NFUEFSQVRPUil9YDtcbiAgICBjb25zdCBjc3ZMaW5lcyA9IGRhdGEubWFwKHBvaW50ID0+IHtcbiAgICAgIGNvbnN0IGZpZWxkcyA9IHByb3BlcnRpZXMubWFwKHByb3BlcnR5ID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgICAgIGNvbnN0IGhhc1Byb3BlcnR5VmFsdWUgPSBpc0RlZmluZWQodmFsdWUpO1xuICAgICAgICByZXR1cm4gaGFzUHJvcGVydHlWYWx1ZSA/IHZhbHVlIDogJyc7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGZpZWxkcy5qb2luKENTVl9TRVBBUkFUT1IpO1xuICAgIH0pO1xuXG4gICAgY3N2ID0gYCR7aGVhZGVyfSR7Q1NWX05FV19MSU5FfSR7Y3N2TGluZXMuam9pbihDU1ZfTkVXX0xJTkUpfWA7XG4gIH1cblxuICByZXR1cm4gY3N2O1xufVxuIl19