/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { toMultiPartPaths } from './to-multi-part-paths.function';
import { SORTED_BY_MEASURE_PROPERTY_FLAG } from '../geometry.constants';
import { sortPointsByMeasure, getSortResultForPoints } from '../point/sort-points.function';
import { multiLineHasMeasureValues } from './has-measure-values.function';
/**
 * @param {?} line
 * @return {?}
 */
export function sortLineByMeasure(line) {
    if (line[SORTED_BY_MEASURE_PROPERTY_FLAG]) {
        // There's no need to waste time sorting this geometry if it's already been done.
        return;
    }
    /** @type {?} */
    const paths = toMultiPartPaths(line);
    if (!multiLineHasMeasureValues(paths)) {
        // We can not continue sorting if the coordinates do not have measure values in them.
        return;
    }
    // We need to sort all of the inner coordinates first, and then the outer paths
    // because we don't know the min/max of the inner coordinates until this is done.
    paths.forEach((/**
     * @param {?} coordinates
     * @return {?}
     */
    (coordinates) => sortPointsByMeasure(coordinates)));
    paths.sort((/**
     * @param {?} firstCoordinate
     * @param {?} secondCoordinate
     * @return {?}
     */
    (firstCoordinate, secondCoordinate) => {
        /** @type {?} */
        const firstCoordinateFirstPoint = firstCoordinate[0];
        /** @type {?} */
        const secondCoordinateFirstPoint = secondCoordinate[0];
        return getSortResultForPoints(firstCoordinateFirstPoint, secondCoordinateFirstPoint);
    }));
    line[SORTED_BY_MEASURE_PROPERTY_FLAG] = true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC1saW5lLWJ5LW1lYXN1cmUuZnVuY3Rpb24uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdHNzL3Nkay8iLCJzb3VyY2VzIjpbImxpYi9nZW9tZXRyeS9saW5lL3NvcnQtbGluZS1ieS1tZWFzdXJlLmZ1bmN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUVsRSxPQUFPLEVBQUUsK0JBQStCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN4RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUM1RixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQzs7Ozs7QUFHMUUsTUFBTSxVQUFVLGlCQUFpQixDQUFDLElBQWtCO0lBQ2xELElBQUksSUFBSSxDQUFDLCtCQUErQixDQUFDLEVBQUU7UUFDekMsaUZBQWlGO1FBQ2pGLE9BQU87S0FDUjs7VUFFSyxLQUFLLEdBQWlCLGdCQUFnQixDQUFDLElBQUksQ0FBQztJQUNsRCxJQUFJLENBQUMseUJBQXlCLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDckMscUZBQXFGO1FBQ3JGLE9BQU87S0FDUjtJQUVELCtFQUErRTtJQUMvRSxpRkFBaUY7SUFDakYsS0FBSyxDQUFDLE9BQU87Ozs7SUFBQyxDQUFDLFdBQXVCLEVBQUUsRUFBRSxDQUFDLG1CQUFtQixDQUFDLFdBQVcsQ0FBQyxFQUFDLENBQUM7SUFFN0UsS0FBSyxDQUFDLElBQUk7Ozs7O0lBQUMsQ0FBQyxlQUEyQixFQUFFLGdCQUE0QixFQUFFLEVBQUU7O2NBQ2pFLHlCQUF5QixHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUM7O2NBQzlDLDBCQUEwQixHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQztRQUV0RCxPQUFPLHNCQUFzQixDQUFDLHlCQUF5QixFQUFFLDBCQUEwQixDQUFDLENBQUM7SUFDdkYsQ0FBQyxFQUFDLENBQUM7SUFFSCxJQUFJLENBQUMsK0JBQStCLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDL0MsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvTXVsdGlQYXJ0UGF0aHMgfSBmcm9tICcuL3RvLW11bHRpLXBhcnQtcGF0aHMuZnVuY3Rpb24nO1xuaW1wb3J0IHsgTGluZUdlb21ldHJ5IH0gZnJvbSAnLi9saW5lLWdlb21ldHJ5JztcbmltcG9ydCB7IFNPUlRFRF9CWV9NRUFTVVJFX1BST1BFUlRZX0ZMQUcgfSBmcm9tICcuLi9nZW9tZXRyeS5jb25zdGFudHMnO1xuaW1wb3J0IHsgc29ydFBvaW50c0J5TWVhc3VyZSwgZ2V0U29ydFJlc3VsdEZvclBvaW50cyB9IGZyb20gJy4uL3BvaW50L3NvcnQtcG9pbnRzLmZ1bmN0aW9uJztcbmltcG9ydCB7IG11bHRpTGluZUhhc01lYXN1cmVWYWx1ZXMgfSBmcm9tICcuL2hhcy1tZWFzdXJlLXZhbHVlcy5mdW5jdGlvbic7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRMaW5lQnlNZWFzdXJlKGxpbmU6IExpbmVHZW9tZXRyeSk6IHZvaWQge1xuICBpZiAobGluZVtTT1JURURfQllfTUVBU1VSRV9QUk9QRVJUWV9GTEFHXSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byB3YXN0ZSB0aW1lIHNvcnRpbmcgdGhpcyBnZW9tZXRyeSBpZiBpdCdzIGFscmVhZHkgYmVlbiBkb25lLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBhdGhzOiBudW1iZXJbXVtdW10gPSB0b011bHRpUGFydFBhdGhzKGxpbmUpO1xuICBpZiAoIW11bHRpTGluZUhhc01lYXN1cmVWYWx1ZXMocGF0aHMpKSB7XG4gICAgLy8gV2UgY2FuIG5vdCBjb250aW51ZSBzb3J0aW5nIGlmIHRoZSBjb29yZGluYXRlcyBkbyBub3QgaGF2ZSBtZWFzdXJlIHZhbHVlcyBpbiB0aGVtLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdG8gc29ydCBhbGwgb2YgdGhlIGlubmVyIGNvb3JkaW5hdGVzIGZpcnN0LCBhbmQgdGhlbiB0aGUgb3V0ZXIgcGF0aHNcbiAgLy8gYmVjYXVzZSB3ZSBkb24ndCBrbm93IHRoZSBtaW4vbWF4IG9mIHRoZSBpbm5lciBjb29yZGluYXRlcyB1bnRpbCB0aGlzIGlzIGRvbmUuXG4gIHBhdGhzLmZvckVhY2goKGNvb3JkaW5hdGVzOiBudW1iZXJbXVtdKSA9PiBzb3J0UG9pbnRzQnlNZWFzdXJlKGNvb3JkaW5hdGVzKSk7XG5cbiAgcGF0aHMuc29ydCgoZmlyc3RDb29yZGluYXRlOiBudW1iZXJbXVtdLCBzZWNvbmRDb29yZGluYXRlOiBudW1iZXJbXVtdKSA9PiB7XG4gICAgY29uc3QgZmlyc3RDb29yZGluYXRlRmlyc3RQb2ludCA9IGZpcnN0Q29vcmRpbmF0ZVswXTtcbiAgICBjb25zdCBzZWNvbmRDb29yZGluYXRlRmlyc3RQb2ludCA9IHNlY29uZENvb3JkaW5hdGVbMF07XG5cbiAgICByZXR1cm4gZ2V0U29ydFJlc3VsdEZvclBvaW50cyhmaXJzdENvb3JkaW5hdGVGaXJzdFBvaW50LCBzZWNvbmRDb29yZGluYXRlRmlyc3RQb2ludCk7XG4gIH0pO1xuXG4gIGxpbmVbU09SVEVEX0JZX01FQVNVUkVfUFJPUEVSVFlfRkxBR10gPSB0cnVlO1xufVxuIl19