/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { toMultiPartPaths } from './to-multi-part-paths.function';
import { addRange } from '../../core/array/add-range.function';
import { getMeasureFromPoint } from '../point/get-measure-from-point.function';
/**
 * @param {?} line
 * @param {?} measure
 * @return {?}
 */
export function getPoint(line, measure) {
    /** @type {?} */
    const pointComparisionDetails = [];
    /** @type {?} */
    const paths = toMultiPartPaths(line);
    paths.forEach((/**
     * @param {?} coordinates
     * @return {?}
     */
    (coordinates) => {
        /** @type {?} */
        const details = comparePathWithMeasure(coordinates, measure);
        addRange(pointComparisionDetails, details);
    }));
    /** @type {?} */
    const minPoint = pointComparisionDetails.reduce((/**
     * @param {?} accumulator
     * @param {?} value
     * @return {?}
     */
    (accumulator, value) => minPointCloserToMeasure(accumulator, value, measure)));
    /** @type {?} */
    const maxPoint = pointComparisionDetails.reduce((/**
     * @param {?} accumulator
     * @param {?} value
     * @return {?}
     */
    (accumulator, value) => maxPointCloserToMeasure(accumulator, value, measure)));
    /** @type {?} */
    const measureDeltaPercent = calculateMeasureDelta(minPoint.pointMeasure, maxPoint.pointMeasure, measure);
    /** @type {?} */
    const x = interpolateX(minPoint.pointCoordinate, maxPoint.pointCoordinate, measureDeltaPercent);
    /** @type {?} */
    const y = interpolateY(minPoint.pointCoordinate, maxPoint.pointCoordinate, measureDeltaPercent);
    return [x, y, 0, measure];
}
/**
 * @param {?} __0
 * @param {?} __1
 * @param {?} delta
 * @return {?}
 */
function interpolateX([minX], [maxX], delta) {
    return minX + delta * (maxX - minX);
}
/**
 * @param {?} __0
 * @param {?} __1
 * @param {?} delta
 * @return {?}
 */
function interpolateY([, minY], [, maxY], delta) {
    return minY + delta * (maxY - minY);
}
/**
 * @param {?} minMeasure
 * @param {?} maxMeasure
 * @param {?} measure
 * @return {?}
 */
function calculateMeasureDelta(minMeasure, maxMeasure, measure) {
    if (maxMeasure === minMeasure) {
        return 0;
    }
    return (measure - minMeasure) / (maxMeasure - minMeasure);
}
/**
 * @param {?} coordinates
 * @param {?} measureToCompare
 * @return {?}
 */
function comparePathWithMeasure(coordinates, measureToCompare) {
    /** @type {?} */
    const pointComparisionDetailsFromPath = coordinates
        .map((/**
     * @param {?} coordinate
     * @param {?} index
     * @return {?}
     */
    (coordinate, index) => compareCoordinateWithMeasure(coordinate, measureToCompare, index)));
    return pointComparisionDetailsFromPath;
}
/**
 * @param {?} coordinate
 * @param {?} measureToCompare
 * @param {?} index
 * @return {?}
 */
function compareCoordinateWithMeasure(coordinate, measureToCompare, index) {
    /** @type {?} */
    const measureFromCoordinate = getMeasureFromPoint(coordinate);
    /** @type {?} */
    const pointDetails = {
        pointCoordinate: coordinate,
        distance: Math.abs(measureFromCoordinate - measureToCompare),
        pointMeasure: measureFromCoordinate,
        index
    };
    return pointDetails;
}
/**
 * @param {?} accumulator
 * @param {?} value
 * @param {?} measureToCompare
 * @return {?}
 */
function minPointCloserToMeasure(accumulator, value, measureToCompare) {
    /** @type {?} */
    const isPointCloserToMeasure = value.distance <= accumulator.distance;
    /** @type {?} */
    const isPointLessThanMeasure = value.pointMeasure <= measureToCompare;
    return isPointCloserToMeasure && isPointLessThanMeasure
        ? value
        : accumulator;
}
/**
 * @param {?} point1
 * @param {?} point2
 * @param {?} measureToCompare
 * @return {?}
 */
function maxPointCloserToMeasure(point1, point2, measureToCompare) {
    /** @type {?} */
    const isPointCloserToMeasure = point1.distance <= point2.distance;
    /** @type {?} */
    const isPointGreaterThanMeasure = point1.pointMeasure >= measureToCompare;
    return isPointCloserToMeasure && isPointGreaterThanMeasure
        ? point1
        : point2;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0LXBvaW50LmZ1bmN0aW9uLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRzcy9zZGsvIiwic291cmNlcyI6WyJsaWIvZ2VvbWV0cnkvbGluZS9nZXQtcG9pbnQuZnVuY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRWxFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUUvRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQzs7Ozs7O0FBRy9FLE1BQU0sVUFBVSxRQUFRLENBQUMsSUFBa0IsRUFBRSxPQUFlOztVQUNwRCx1QkFBdUIsR0FBNkIsRUFBRTs7VUFDdEQsS0FBSyxHQUFpQixnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7SUFFbEQsS0FBSyxDQUFDLE9BQU87Ozs7SUFBQyxDQUFDLFdBQXVCLEVBQUUsRUFBRTs7Y0FDbEMsT0FBTyxHQUFHLHNCQUFzQixDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUM7UUFDNUQsUUFBUSxDQUFDLHVCQUF1QixFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzdDLENBQUMsRUFBQyxDQUFDOztVQUVHLFFBQVEsR0FBRyx1QkFBdUIsQ0FBQyxNQUFNOzs7OztJQUFDLENBQUMsV0FBVyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsdUJBQXVCLENBQUMsV0FBVyxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsRUFBQzs7VUFDdkgsUUFBUSxHQUFHLHVCQUF1QixDQUFDLE1BQU07Ozs7O0lBQUMsQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxFQUFDOztVQUN2SCxtQkFBbUIsR0FBRyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLFFBQVEsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDOztVQUNsRyxDQUFDLEdBQUcsWUFBWSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsUUFBUSxDQUFDLGVBQWUsRUFBRSxtQkFBbUIsQ0FBQzs7VUFDekYsQ0FBQyxHQUFHLFlBQVksQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFFLFFBQVEsQ0FBQyxlQUFlLEVBQUUsbUJBQW1CLENBQUM7SUFFL0YsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQzVCLENBQUM7Ozs7Ozs7QUFFRCxTQUFTLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBVyxFQUFFLENBQUMsSUFBSSxDQUFXLEVBQUUsS0FBYTtJQUNyRSxPQUFPLElBQUksR0FBRyxLQUFLLEdBQUcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDdEMsQ0FBQzs7Ozs7OztBQUVELFNBQVMsWUFBWSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQVcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFXLEVBQUUsS0FBYTtJQUN6RSxPQUFPLElBQUksR0FBRyxLQUFLLEdBQUcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDdEMsQ0FBQzs7Ozs7OztBQUVELFNBQVMscUJBQXFCLENBQUMsVUFBa0IsRUFBRSxVQUFrQixFQUFFLE9BQWU7SUFDcEYsSUFBSSxVQUFVLEtBQUssVUFBVSxFQUFFO1FBQzdCLE9BQU8sQ0FBQyxDQUFDO0tBQ1Y7SUFFRCxPQUFPLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQyxDQUFDO0FBQzVELENBQUM7Ozs7OztBQUVELFNBQVMsc0JBQXNCLENBQUMsV0FBdUIsRUFBRSxnQkFBd0I7O1VBQ3pFLCtCQUErQixHQUE2QixXQUFXO1NBQzFFLEdBQUc7Ozs7O0lBQ0YsQ0FBQyxVQUFvQixFQUFFLEtBQWEsRUFBRSxFQUFFLENBQUMsNEJBQTRCLENBQUMsVUFBVSxFQUFFLGdCQUFnQixFQUFFLEtBQUssQ0FBQyxFQUMzRztJQUVILE9BQU8sK0JBQStCLENBQUM7QUFDekMsQ0FBQzs7Ozs7OztBQUVELFNBQVMsNEJBQTRCLENBQUMsVUFBb0IsRUFBRSxnQkFBd0IsRUFBRSxLQUFhOztVQUMzRixxQkFBcUIsR0FBRyxtQkFBbUIsQ0FBQyxVQUFVLENBQUM7O1VBQ3ZELFlBQVksR0FBMkI7UUFDM0MsZUFBZSxFQUFFLFVBQVU7UUFDM0IsUUFBUSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMscUJBQXFCLEdBQUcsZ0JBQWdCLENBQUM7UUFDNUQsWUFBWSxFQUFFLHFCQUFxQjtRQUNuQyxLQUFLO0tBQ047SUFFRCxPQUFPLFlBQVksQ0FBQztBQUN0QixDQUFDOzs7Ozs7O0FBRUQsU0FBUyx1QkFBdUIsQ0FDOUIsV0FBbUMsRUFDbkMsS0FBNkIsRUFDN0IsZ0JBQXdCOztVQUVsQixzQkFBc0IsR0FBRyxLQUFLLENBQUMsUUFBUSxJQUFJLFdBQVcsQ0FBQyxRQUFROztVQUMvRCxzQkFBc0IsR0FBRyxLQUFLLENBQUMsWUFBWSxJQUFJLGdCQUFnQjtJQUVyRSxPQUFPLHNCQUFzQixJQUFJLHNCQUFzQjtRQUNyRCxDQUFDLENBQUMsS0FBSztRQUNQLENBQUMsQ0FBQyxXQUFXLENBQUM7QUFDbEIsQ0FBQzs7Ozs7OztBQUVELFNBQVMsdUJBQXVCLENBQzlCLE1BQThCLEVBQzlCLE1BQThCLEVBQzlCLGdCQUF3Qjs7VUFFbEIsc0JBQXNCLEdBQUcsTUFBTSxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUMsUUFBUTs7VUFDM0QseUJBQXlCLEdBQUcsTUFBTSxDQUFDLFlBQVksSUFBSSxnQkFBZ0I7SUFFekUsT0FBTyxzQkFBc0IsSUFBSSx5QkFBeUI7UUFDeEQsQ0FBQyxDQUFDLE1BQU07UUFDUixDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ2IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvTXVsdGlQYXJ0UGF0aHMgfSBmcm9tICcuL3RvLW11bHRpLXBhcnQtcGF0aHMuZnVuY3Rpb24nO1xuaW1wb3J0IHsgTGluZUdlb21ldHJ5IH0gZnJvbSAnLi9saW5lLWdlb21ldHJ5JztcbmltcG9ydCB7IGFkZFJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS9hcnJheS9hZGQtcmFuZ2UuZnVuY3Rpb24nO1xuaW1wb3J0IHsgUG9pbnRDb21wYXJpc29uRGV0YWlscyB9IGZyb20gJy4uL3BvaW50L3BvaW50LWNvbXBhcmlzb24tZGV0YWlscyc7XG5pbXBvcnQgeyBnZXRNZWFzdXJlRnJvbVBvaW50IH0gZnJvbSAnLi4vcG9pbnQvZ2V0LW1lYXN1cmUtZnJvbS1wb2ludC5mdW5jdGlvbic7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvaW50KGxpbmU6IExpbmVHZW9tZXRyeSwgbWVhc3VyZTogbnVtYmVyKTogbnVtYmVyW10ge1xuICBjb25zdCBwb2ludENvbXBhcmlzaW9uRGV0YWlsczogUG9pbnRDb21wYXJpc29uRGV0YWlsc1tdID0gW107XG4gIGNvbnN0IHBhdGhzOiBudW1iZXJbXVtdW10gPSB0b011bHRpUGFydFBhdGhzKGxpbmUpO1xuXG4gIHBhdGhzLmZvckVhY2goKGNvb3JkaW5hdGVzOiBudW1iZXJbXVtdKSA9PiB7XG4gICAgY29uc3QgZGV0YWlscyA9IGNvbXBhcmVQYXRoV2l0aE1lYXN1cmUoY29vcmRpbmF0ZXMsIG1lYXN1cmUpO1xuICAgIGFkZFJhbmdlKHBvaW50Q29tcGFyaXNpb25EZXRhaWxzLCBkZXRhaWxzKTtcbiAgfSk7XG5cbiAgY29uc3QgbWluUG9pbnQgPSBwb2ludENvbXBhcmlzaW9uRGV0YWlscy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCB2YWx1ZSkgPT4gbWluUG9pbnRDbG9zZXJUb01lYXN1cmUoYWNjdW11bGF0b3IsIHZhbHVlLCBtZWFzdXJlKSk7XG4gIGNvbnN0IG1heFBvaW50ID0gcG9pbnRDb21wYXJpc2lvbkRldGFpbHMucmVkdWNlKChhY2N1bXVsYXRvciwgdmFsdWUpID0+IG1heFBvaW50Q2xvc2VyVG9NZWFzdXJlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgbWVhc3VyZSkpO1xuICBjb25zdCBtZWFzdXJlRGVsdGFQZXJjZW50ID0gY2FsY3VsYXRlTWVhc3VyZURlbHRhKG1pblBvaW50LnBvaW50TWVhc3VyZSwgbWF4UG9pbnQucG9pbnRNZWFzdXJlLCBtZWFzdXJlKTtcbiAgY29uc3QgeCA9IGludGVycG9sYXRlWChtaW5Qb2ludC5wb2ludENvb3JkaW5hdGUsIG1heFBvaW50LnBvaW50Q29vcmRpbmF0ZSwgbWVhc3VyZURlbHRhUGVyY2VudCk7XG4gIGNvbnN0IHkgPSBpbnRlcnBvbGF0ZVkobWluUG9pbnQucG9pbnRDb29yZGluYXRlLCBtYXhQb2ludC5wb2ludENvb3JkaW5hdGUsIG1lYXN1cmVEZWx0YVBlcmNlbnQpO1xuXG4gIHJldHVybiBbeCwgeSwgMCwgbWVhc3VyZV07XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlWChbbWluWF06IG51bWJlcltdLCBbbWF4WF06IG51bWJlcltdLCBkZWx0YTogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIG1pblggKyBkZWx0YSAqIChtYXhYIC0gbWluWCk7XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlWShbLCBtaW5ZXTogbnVtYmVyW10sIFssIG1heFldOiBudW1iZXJbXSwgZGVsdGE6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBtaW5ZICsgZGVsdGEgKiAobWF4WSAtIG1pblkpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVNZWFzdXJlRGVsdGEobWluTWVhc3VyZTogbnVtYmVyLCBtYXhNZWFzdXJlOiBudW1iZXIsIG1lYXN1cmU6IG51bWJlcik6IG51bWJlciB7XG4gIGlmIChtYXhNZWFzdXJlID09PSBtaW5NZWFzdXJlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gKG1lYXN1cmUgLSBtaW5NZWFzdXJlKSAvIChtYXhNZWFzdXJlIC0gbWluTWVhc3VyZSk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVQYXRoV2l0aE1lYXN1cmUoY29vcmRpbmF0ZXM6IG51bWJlcltdW10sIG1lYXN1cmVUb0NvbXBhcmU6IG51bWJlcik6IFBvaW50Q29tcGFyaXNvbkRldGFpbHNbXSB7XG4gIGNvbnN0IHBvaW50Q29tcGFyaXNpb25EZXRhaWxzRnJvbVBhdGg6IFBvaW50Q29tcGFyaXNvbkRldGFpbHNbXSA9IGNvb3JkaW5hdGVzXG4gICAgLm1hcChcbiAgICAgIChjb29yZGluYXRlOiBudW1iZXJbXSwgaW5kZXg6IG51bWJlcikgPT4gY29tcGFyZUNvb3JkaW5hdGVXaXRoTWVhc3VyZShjb29yZGluYXRlLCBtZWFzdXJlVG9Db21wYXJlLCBpbmRleClcbiAgICApO1xuXG4gIHJldHVybiBwb2ludENvbXBhcmlzaW9uRGV0YWlsc0Zyb21QYXRoO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlQ29vcmRpbmF0ZVdpdGhNZWFzdXJlKGNvb3JkaW5hdGU6IG51bWJlcltdLCBtZWFzdXJlVG9Db21wYXJlOiBudW1iZXIsIGluZGV4OiBudW1iZXIpOiBQb2ludENvbXBhcmlzb25EZXRhaWxzIHtcbiAgY29uc3QgbWVhc3VyZUZyb21Db29yZGluYXRlID0gZ2V0TWVhc3VyZUZyb21Qb2ludChjb29yZGluYXRlKTtcbiAgY29uc3QgcG9pbnREZXRhaWxzOiBQb2ludENvbXBhcmlzb25EZXRhaWxzID0ge1xuICAgIHBvaW50Q29vcmRpbmF0ZTogY29vcmRpbmF0ZSxcbiAgICBkaXN0YW5jZTogTWF0aC5hYnMobWVhc3VyZUZyb21Db29yZGluYXRlIC0gbWVhc3VyZVRvQ29tcGFyZSksXG4gICAgcG9pbnRNZWFzdXJlOiBtZWFzdXJlRnJvbUNvb3JkaW5hdGUsXG4gICAgaW5kZXhcbiAgfTtcblxuICByZXR1cm4gcG9pbnREZXRhaWxzO1xufVxuXG5mdW5jdGlvbiBtaW5Qb2ludENsb3NlclRvTWVhc3VyZShcbiAgYWNjdW11bGF0b3I6IFBvaW50Q29tcGFyaXNvbkRldGFpbHMsXG4gIHZhbHVlOiBQb2ludENvbXBhcmlzb25EZXRhaWxzLFxuICBtZWFzdXJlVG9Db21wYXJlOiBudW1iZXJcbik6IFBvaW50Q29tcGFyaXNvbkRldGFpbHMge1xuICBjb25zdCBpc1BvaW50Q2xvc2VyVG9NZWFzdXJlID0gdmFsdWUuZGlzdGFuY2UgPD0gYWNjdW11bGF0b3IuZGlzdGFuY2U7XG4gIGNvbnN0IGlzUG9pbnRMZXNzVGhhbk1lYXN1cmUgPSB2YWx1ZS5wb2ludE1lYXN1cmUgPD0gbWVhc3VyZVRvQ29tcGFyZTtcblxuICByZXR1cm4gaXNQb2ludENsb3NlclRvTWVhc3VyZSAmJiBpc1BvaW50TGVzc1RoYW5NZWFzdXJlXG4gICAgPyB2YWx1ZVxuICAgIDogYWNjdW11bGF0b3I7XG59XG5cbmZ1bmN0aW9uIG1heFBvaW50Q2xvc2VyVG9NZWFzdXJlKFxuICBwb2ludDE6IFBvaW50Q29tcGFyaXNvbkRldGFpbHMsXG4gIHBvaW50MjogUG9pbnRDb21wYXJpc29uRGV0YWlscyxcbiAgbWVhc3VyZVRvQ29tcGFyZTogbnVtYmVyXG4pOiBQb2ludENvbXBhcmlzb25EZXRhaWxzIHtcbiAgY29uc3QgaXNQb2ludENsb3NlclRvTWVhc3VyZSA9IHBvaW50MS5kaXN0YW5jZSA8PSBwb2ludDIuZGlzdGFuY2U7XG4gIGNvbnN0IGlzUG9pbnRHcmVhdGVyVGhhbk1lYXN1cmUgPSBwb2ludDEucG9pbnRNZWFzdXJlID49IG1lYXN1cmVUb0NvbXBhcmU7XG5cbiAgcmV0dXJuIGlzUG9pbnRDbG9zZXJUb01lYXN1cmUgJiYgaXNQb2ludEdyZWF0ZXJUaGFuTWVhc3VyZVxuICAgID8gcG9pbnQxXG4gICAgOiBwb2ludDI7XG59XG4iXX0=