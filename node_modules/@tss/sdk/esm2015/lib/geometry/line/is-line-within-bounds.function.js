/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { isPointWithinButNotIncludingBounds } from '../point/bounds.function';
/**
 * Determines if two points (a line) are within a given bounds (line).
 * @param {?} boundStart The start of the restrcting bounds.
 * @param {?} boundEnd The end of the restricting bounds.
 * @param {?} testStartValue The start value of the line to check against the restricting bounds.
 * @param {?} testEndValue The end value of the line to check against the restricting bounds.
 * @return {?}
 */
export function isLineWithinBounds(boundStart, boundEnd, testStartValue, testEndValue) {
    /**
     * Runs through:
     * BOUNDS:   10---------15
     * TEST:   8---------------18
     *
     * Starts and runs through:
     * BOUNDS: 0---------15
     * TEST:   0---------------18
     *
     * Ends and runs through:
     * BOUNDS:       5---------18
     * TEST:   0---------------18
     * @type {?}
     */
    const runsThrough = testStartValue < boundStart && testEndValue > boundEnd;
    /** @type {?} */
    const isFullMatch = testStartValue === boundStart && testEndValue === boundEnd;
    /** @type {?} */
    const isStartInBounds = isPointWithinButNotIncludingBounds(boundStart, boundEnd, testStartValue);
    /** @type {?} */
    const isEndInBounds = isPointWithinButNotIncludingBounds(boundStart, boundEnd, testEndValue);
    /** @type {?} */
    const isStartMatch = boundStart === testStartValue;
    /** @type {?} */
    const isEndMatch = boundEnd === testEndValue;
    /** @type {?} */
    const startsAndRunsThrough = isStartMatch && boundStart <= testEndValue;
    /** @type {?} */
    const endsAndRunsThrough = isEndMatch && boundEnd >= testStartValue;
    return runsThrough
        || isFullMatch
        || isStartInBounds
        || isEndInBounds
        || startsAndRunsThrough
        || endsAndRunsThrough;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXMtbGluZS13aXRoaW4tYm91bmRzLmZ1bmN0aW9uLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRzcy9zZGsvIiwic291cmNlcyI6WyJsaWIvZ2VvbWV0cnkvbGluZS9pcy1saW5lLXdpdGhpbi1ib3VuZHMuZnVuY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxrQ0FBa0MsRUFBRSxNQUFNLDBCQUEwQixDQUFDOzs7Ozs7Ozs7QUFVOUUsTUFBTSxVQUFVLGtCQUFrQixDQUFDLFVBQWtCLEVBQUUsUUFBZ0IsRUFBRSxjQUFzQixFQUFFLFlBQW9COzs7Ozs7Ozs7Ozs7Ozs7VUFjN0csV0FBVyxHQUFHLGNBQWMsR0FBRyxVQUFVLElBQUksWUFBWSxHQUFHLFFBQVE7O1VBQ3BFLFdBQVcsR0FBRyxjQUFjLEtBQUssVUFBVSxJQUFJLFlBQVksS0FBSyxRQUFROztVQUN4RSxlQUFlLEdBQUcsa0NBQWtDLENBQUMsVUFBVSxFQUFFLFFBQVEsRUFBRSxjQUFjLENBQUM7O1VBQzFGLGFBQWEsR0FBRyxrQ0FBa0MsQ0FBQyxVQUFVLEVBQUUsUUFBUSxFQUFFLFlBQVksQ0FBQzs7VUFFdEYsWUFBWSxHQUFHLFVBQVUsS0FBSyxjQUFjOztVQUM1QyxVQUFVLEdBQUcsUUFBUSxLQUFLLFlBQVk7O1VBQ3RDLG9CQUFvQixHQUFHLFlBQVksSUFBSSxVQUFVLElBQUksWUFBWTs7VUFDakUsa0JBQWtCLEdBQUcsVUFBVSxJQUFJLFFBQVEsSUFBSSxjQUFjO0lBRW5FLE9BQU8sV0FBVztXQUNiLFdBQVc7V0FDWCxlQUFlO1dBQ2YsYUFBYTtXQUNiLG9CQUFvQjtXQUNwQixrQkFBa0IsQ0FBQztBQUMxQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQb2ludFdpdGhpbkJ1dE5vdEluY2x1ZGluZ0JvdW5kcyB9IGZyb20gJy4uL3BvaW50L2JvdW5kcy5mdW5jdGlvbic7XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHR3byBwb2ludHMgKGEgbGluZSkgYXJlIHdpdGhpbiBhIGdpdmVuIGJvdW5kcyAobGluZSkuXG4gKiBAcGFyYW0gYm91bmRTdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJlc3RyY3RpbmcgYm91bmRzLlxuICogQHBhcmFtIGJvdW5kRW5kIFRoZSBlbmQgb2YgdGhlIHJlc3RyaWN0aW5nIGJvdW5kcy5cbiAqIEBwYXJhbSB0ZXN0U3RhcnRWYWx1ZSBUaGUgc3RhcnQgdmFsdWUgb2YgdGhlIGxpbmUgdG8gY2hlY2sgYWdhaW5zdCB0aGUgcmVzdHJpY3RpbmcgYm91bmRzLlxuICogQHBhcmFtIHRlc3RFbmRWYWx1ZSBUaGUgZW5kIHZhbHVlIG9mIHRoZSBsaW5lIHRvIGNoZWNrIGFnYWluc3QgdGhlIHJlc3RyaWN0aW5nIGJvdW5kcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTGluZVdpdGhpbkJvdW5kcyhib3VuZFN0YXJ0OiBudW1iZXIsIGJvdW5kRW5kOiBudW1iZXIsIHRlc3RTdGFydFZhbHVlOiBudW1iZXIsIHRlc3RFbmRWYWx1ZTogbnVtYmVyKSB7XG4gIC8qKlxuICAgKiBSdW5zIHRocm91Z2g6XG4gICAqIEJPVU5EUzogICAxMC0tLS0tLS0tLTE1XG4gICAqIFRFU1Q6ICAgOC0tLS0tLS0tLS0tLS0tLTE4XG4gICAqXG4gICAqIFN0YXJ0cyBhbmQgcnVucyB0aHJvdWdoOlxuICAgKiBCT1VORFM6IDAtLS0tLS0tLS0xNVxuICAgKiBURVNUOiAgIDAtLS0tLS0tLS0tLS0tLS0xOFxuICAgKlxuICAgKiBFbmRzIGFuZCBydW5zIHRocm91Z2g6XG4gICAqIEJPVU5EUzogICAgICAgNS0tLS0tLS0tLTE4XG4gICAqIFRFU1Q6ICAgMC0tLS0tLS0tLS0tLS0tLTE4XG4gICAqL1xuICBjb25zdCBydW5zVGhyb3VnaCA9IHRlc3RTdGFydFZhbHVlIDwgYm91bmRTdGFydCAmJiB0ZXN0RW5kVmFsdWUgPiBib3VuZEVuZDtcbiAgY29uc3QgaXNGdWxsTWF0Y2ggPSB0ZXN0U3RhcnRWYWx1ZSA9PT0gYm91bmRTdGFydCAmJiB0ZXN0RW5kVmFsdWUgPT09IGJvdW5kRW5kO1xuICBjb25zdCBpc1N0YXJ0SW5Cb3VuZHMgPSBpc1BvaW50V2l0aGluQnV0Tm90SW5jbHVkaW5nQm91bmRzKGJvdW5kU3RhcnQsIGJvdW5kRW5kLCB0ZXN0U3RhcnRWYWx1ZSk7XG4gIGNvbnN0IGlzRW5kSW5Cb3VuZHMgPSBpc1BvaW50V2l0aGluQnV0Tm90SW5jbHVkaW5nQm91bmRzKGJvdW5kU3RhcnQsIGJvdW5kRW5kLCB0ZXN0RW5kVmFsdWUpO1xuXG4gIGNvbnN0IGlzU3RhcnRNYXRjaCA9IGJvdW5kU3RhcnQgPT09IHRlc3RTdGFydFZhbHVlO1xuICBjb25zdCBpc0VuZE1hdGNoID0gYm91bmRFbmQgPT09IHRlc3RFbmRWYWx1ZTtcbiAgY29uc3Qgc3RhcnRzQW5kUnVuc1Rocm91Z2ggPSBpc1N0YXJ0TWF0Y2ggJiYgYm91bmRTdGFydCA8PSB0ZXN0RW5kVmFsdWU7XG4gIGNvbnN0IGVuZHNBbmRSdW5zVGhyb3VnaCA9IGlzRW5kTWF0Y2ggJiYgYm91bmRFbmQgPj0gdGVzdFN0YXJ0VmFsdWU7XG5cbiAgcmV0dXJuIHJ1bnNUaHJvdWdoXG4gICAgfHwgaXNGdWxsTWF0Y2hcbiAgICB8fCBpc1N0YXJ0SW5Cb3VuZHNcbiAgICB8fCBpc0VuZEluQm91bmRzXG4gICAgfHwgc3RhcnRzQW5kUnVuc1Rocm91Z2hcbiAgICB8fCBlbmRzQW5kUnVuc1Rocm91Z2g7XG59XG4iXX0=