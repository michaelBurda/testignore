/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// 3rd party.
import distance from '@turf/distance';
import { toMultiPartPaths } from '../line/to-multi-part-paths.function';
import { getMeasureFromPoint } from '../point/get-measure-from-point.function';
import { sortAscending } from '../../core/sort/sort.function';
import { isNotNumber } from '../../core/type-check/is-not-number.function';
/** @type {?} */
const DEFAULT_EMPTY_Z_VALUE = 0;
/** @type {?} */
const DEFAULT_OPTIONS = {
    units: 'miles',
    hasZValues: true,
    calibrationPositions: []
};
/**
 * @param {?} line
 * @param {?=} options
 * @return {?}
 */
export function setMeasuresByGeometricLength(line, options) {
    /** @type {?} */
    const martiPart = toMultiPartPaths(line);
    options = Object.assign({}, DEFAULT_OPTIONS, options);
    /** @type {?} */
    let lastMeasure = 0;
    martiPart.forEach((/**
     * @param {?} linePart
     * @param {?} partIndex
     * @return {?}
     */
    (linePart, partIndex) => {
        setMeasureForLine(linePart, lastMeasure, partIndex, options);
        /** @type {?} */
        const lastCoordinateIndex = linePart.length - 1;
        /** @type {?} */
        const lastCoordinate = linePart[lastCoordinateIndex];
        lastMeasure += getMeasureFromPoint(lastCoordinate);
    }));
}
/**
 * @param {?} line
 * @param {?} startMeasure
 * @param {?} partIndex
 * @param {?} options
 * @return {?}
 */
function setMeasureForLine(line, startMeasure, partIndex, options) {
    /** @type {?} */
    const hasCalibrationPoints = options.calibrationPositions.some((/**
     * @param {?} calibrationPosition
     * @return {?}
     */
    calibrationPosition => calibrationPosition.partIndex === partIndex));
    if (hasCalibrationPoints) {
        calibrateLinePart(line, startMeasure, partIndex, options);
    }
    else {
        setLinePartMeasuresByGeometricLength(line, startMeasure, options);
    }
}
/**
 * @param {?} line
 * @param {?} startMeasure
 * @param {?} partIndex
 * @param {?} options
 * @return {?}
 */
function calibrateLinePart(line, startMeasure, partIndex, options) {
    /** @type {?} */
    const calibrationPositions = options.calibrationPositions.filter((/**
     * @param {?} position
     * @return {?}
     */
    position => position.partIndex === partIndex));
    /** @type {?} */
    let fromVertexIndex = 0;
    sortAscending(calibrationPositions, (/**
     * @param {?} calibration
     * @return {?}
     */
    calibration => calibration.measure));
    calibrationPositions.forEach((/**
     * @param {?} calibration
     * @return {?}
     */
    calibration => {
        /** @type {?} */
        const fromVertex = line[fromVertexIndex];
        /** @type {?} */
        const toVertex = line[calibration.vertexIndex];
        /** @type {?} */
        const numberOfVerticesInBetween = calibration.vertexIndex - fromVertexIndex;
        /** @type {?} */
        const distanceForSection = Math.abs(calibration.measure - startMeasure);
        /** @type {?} */
        const measureDistributionIncrement = distanceForSection / numberOfVerticesInBetween;
        setMeasure(fromVertex, startMeasure, options.hasZValues);
        setMeasure(toVertex, calibration.measure, options.hasZValues);
        /** @type {?} */
        const inBetweenVertices = getVerticesBetween(line, fromVertexIndex, calibration.vertexIndex);
        inBetweenVertices.forEach((/**
         * @param {?} vertice
         * @param {?} index
         * @return {?}
         */
        (vertice, index) => {
            /** @type {?} */
            const partNumber = index + 1;
            /** @type {?} */
            const verticeIncrement = partNumber * measureDistributionIncrement;
            /** @type {?} */
            const measure = startMeasure + verticeIncrement;
            setMeasure(vertice, measure, options.hasZValues);
        }));
        fromVertexIndex = calibration.vertexIndex;
        startMeasure = calibration.measure;
    }));
    /** @type {?} */
    const areMoreVertices = fromVertexIndex < line.length - 1;
    if (areMoreVertices) {
        /** @type {?} */
        const remainingPoints = getVerticesBetween(line, fromVertexIndex - 1, line.length);
        setLinePartMeasuresByGeometricLength(remainingPoints, startMeasure, options);
    }
}
/**
 * @param {?} line
 * @param {?} startRangeIndex
 * @param {?} endRangeIndex
 * @return {?}
 */
function getVerticesBetween(line, startRangeIndex, endRangeIndex) {
    /** @type {?} */
    let index = startRangeIndex + 1;
    /** @type {?} */
    const vertices = [];
    for (; index < endRangeIndex; index++) {
        /** @type {?} */
        const vertice = line[index];
        vertices.push(vertice);
    }
    return vertices;
}
/**
 * @param {?} line
 * @param {?} startMeasure
 * @param {?} options
 * @return {?}
 */
function setLinePartMeasuresByGeometricLength(line, startMeasure, options) {
    /** @type {?} */
    let previousVertex;
    /** @type {?} */
    let vertexMeasure = startMeasure;
    line.forEach((/**
     * @param {?} vertex
     * @param {?} index
     * @return {?}
     */
    (vertex, index) => {
        if (index !== 0) {
            /** @type {?} */
            const distanceBetweenVerticees = distance(previousVertex, vertex, options);
            vertexMeasure += distanceBetweenVerticees;
        }
        setMeasure(vertex, vertexMeasure, options.hasZValues);
        previousVertex = vertex;
    }));
}
/**
 * @param {?} coordinate
 * @param {?} measure
 * @param {?} hasZValues
 * @return {?}
 */
function setMeasure(coordinate, measure, hasZValues) {
    /** @type {?} */
    const accountForZValue = hasZValues || coordinate.length > 3;
    /** @type {?} */
    const measureIndex = accountForZValue ? 3 : 2;
    coordinate[measureIndex] = measure;
    if (accountForZValue) {
        ensureZValue(coordinate);
    }
}
/**
 * @param {?} coordinate
 * @return {?}
 */
function ensureZValue(coordinate) {
    if (isNotNumber(coordinate[2])) {
        coordinate[2] = DEFAULT_EMPTY_Z_VALUE;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0LW1lYXN1cmVzLWJ5LWdlb21ldHJpYy1sZW5ndGguZnVuY3Rpb24uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdHNzL3Nkay8iLCJzb3VyY2VzIjpbImxpYi9nZW9tZXRyeS9nZW9tZXRyeS9zZXQtbWVhc3VyZXMtYnktZ2VvbWV0cmljLWxlbmd0aC5mdW5jdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sUUFBUSxNQUFNLGdCQUFnQixDQUFDO0FBSXRDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBRS9FLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUM5RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sOENBQThDLENBQUM7O01BR3JFLHFCQUFxQixHQUFHLENBQUM7O01BQ3pCLGVBQWUsR0FBd0M7SUFDM0QsS0FBSyxFQUFFLE9BQU87SUFDZCxVQUFVLEVBQUUsSUFBSTtJQUNoQixvQkFBb0IsRUFBRSxFQUFFO0NBQ3pCOzs7Ozs7QUFFRCxNQUFNLFVBQVUsNEJBQTRCLENBQUMsSUFBa0IsRUFBRSxPQUE2Qzs7VUFDdEcsU0FBUyxHQUFpQixnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7SUFDdEQsT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLGVBQWUsRUFBRSxPQUFPLENBQUMsQ0FBQzs7UUFDbEQsV0FBVyxHQUFHLENBQUM7SUFFbkIsU0FBUyxDQUFDLE9BQU87Ozs7O0lBQUMsQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLEVBQUU7UUFDeEMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7O2NBQ3ZELG1CQUFtQixHQUFHLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQzs7Y0FDekMsY0FBYyxHQUFHLFFBQVEsQ0FB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QVMsWUFBWSxDQUFDLFVBQW9CO0lBQ3hDLElBQUksV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQzlCLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxxQkFBcUIsQ0FBQztLQUN2QztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAzcmQgcGFydHkuXG5pbXBvcnQgZGlzdGFuY2UgZnJvbSAnQHR1cmYvZGlzdGFuY2UnO1xuXG4vLyBUU1MuXG5pbXBvcnQgeyBMaW5lR2VvbWV0cnkgfSBmcm9tICcuLi9saW5lL2xpbmUtZ2VvbWV0cnknO1xuaW1wb3J0IHsgdG9NdWx0aVBhcnRQYXRocyB9IGZyb20gJy4uL2xpbmUvdG8tbXVsdGktcGFydC1wYXRocy5mdW5jdGlvbic7XG5pbXBvcnQgeyBnZXRNZWFzdXJlRnJvbVBvaW50IH0gZnJvbSAnLi4vcG9pbnQvZ2V0LW1lYXN1cmUtZnJvbS1wb2ludC5mdW5jdGlvbic7XG5pbXBvcnQgeyBTZXRNZWFzdXJlc0J5R2VvbWV0cmljTGVuZ3RoT3B0aW9ucyB9IGZyb20gJy4vc2V0LW1lYXN1cmVzLWJ5LWdlb21ldHJpYy1sZW5ndGgtb3B0aW9ucyc7XG5pbXBvcnQgeyBzb3J0QXNjZW5kaW5nIH0gZnJvbSAnLi4vLi4vY29yZS9zb3J0L3NvcnQuZnVuY3Rpb24nO1xuaW1wb3J0IHsgaXNOb3ROdW1iZXIgfSBmcm9tICcuLi8uLi9jb3JlL3R5cGUtY2hlY2svaXMtbm90LW51bWJlci5mdW5jdGlvbic7XG5cblxuY29uc3QgREVGQVVMVF9FTVBUWV9aX1ZBTFVFID0gMDtcbmNvbnN0IERFRkFVTFRfT1BUSU9OUzogU2V0TWVhc3VyZXNCeUdlb21ldHJpY0xlbmd0aE9wdGlvbnMgPSB7XG4gIHVuaXRzOiAnbWlsZXMnLFxuICBoYXNaVmFsdWVzOiB0cnVlLFxuICBjYWxpYnJhdGlvblBvc2l0aW9uczogW11cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRNZWFzdXJlc0J5R2VvbWV0cmljTGVuZ3RoKGxpbmU6IExpbmVHZW9tZXRyeSwgb3B0aW9ucz86IFNldE1lYXN1cmVzQnlHZW9tZXRyaWNMZW5ndGhPcHRpb25zKTogdm9pZCB7XG4gIGNvbnN0IG1hcnRpUGFydDogbnVtYmVyW11bXVtdID0gdG9NdWx0aVBhcnRQYXRocyhsaW5lKTtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gIGxldCBsYXN0TWVhc3VyZSA9IDA7XG5cbiAgbWFydGlQYXJ0LmZvckVhY2goKGxpbmVQYXJ0LCBwYXJ0SW5kZXgpID0+IHtcbiAgICBzZXRNZWFzdXJlRm9yTGluZShsaW5lUGFydCwgbGFzdE1lYXN1cmUsIHBhcnRJbmRleCwgb3B0aW9ucyk7XG4gICAgY29uc3QgbGFzdENvb3JkaW5hdGVJbmRleCA9IGxpbmVQYXJ0Lmxlbmd0aCAtIDE7XG4gICAgY29uc3QgbGFzdENvb3JkaW5hdGUgPSBsaW5lUGFydFtsYXN0Q29vcmRpbmF0ZUluZGV4XTtcblxuICAgIGxhc3RNZWFzdXJlICs9IGdldE1lYXN1cmVGcm9tUG9pbnQobGFzdENvb3JkaW5hdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0TWVhc3VyZUZvckxpbmUobGluZTogbnVtYmVyW11bXSwgc3RhcnRNZWFzdXJlOiBudW1iZXIsIHBhcnRJbmRleDogbnVtYmVyLCBvcHRpb25zOiBTZXRNZWFzdXJlc0J5R2VvbWV0cmljTGVuZ3RoT3B0aW9ucyk6IHZvaWQge1xuICBjb25zdCBoYXNDYWxpYnJhdGlvblBvaW50czogYm9vbGVhbiA9IG9wdGlvbnMuY2FsaWJyYXRpb25Qb3NpdGlvbnMuc29tZShcbiAgICBjYWxpYnJhdGlvblBvc2l0aW9uID0+XG4gICAgICBjYWxpYnJhdGlvblBvc2l0aW9uLnBhcnRJbmRleCA9PT0gcGFydEluZGV4XG4gICk7XG5cbiAgaWYgKGhhc0NhbGlicmF0aW9uUG9pbnRzKSB7XG4gICAgY2FsaWJyYXRlTGluZVBhcnQobGluZSwgc3RhcnRNZWFzdXJlLCBwYXJ0SW5kZXgsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHNldExpbmVQYXJ0TWVhc3VyZXNCeUdlb21ldHJpY0xlbmd0aChsaW5lLCBzdGFydE1lYXN1cmUsIG9wdGlvbnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGlicmF0ZUxpbmVQYXJ0KGxpbmU6IG51bWJlcltdW10sIHN0YXJ0TWVhc3VyZTogbnVtYmVyLCBwYXJ0SW5kZXg6IG51bWJlciwgb3B0aW9uczogU2V0TWVhc3VyZXNCeUdlb21ldHJpY0xlbmd0aE9wdGlvbnMpOiB2b2lkIHtcbiAgY29uc3QgY2FsaWJyYXRpb25Qb3NpdGlvbnMgPSBvcHRpb25zLmNhbGlicmF0aW9uUG9zaXRpb25zLmZpbHRlcihcbiAgICBwb3NpdGlvbiA9PiBwb3NpdGlvbi5wYXJ0SW5kZXggPT09IHBhcnRJbmRleFxuICApO1xuXG4gIGxldCBmcm9tVmVydGV4SW5kZXggPSAwO1xuICBzb3J0QXNjZW5kaW5nKGNhbGlicmF0aW9uUG9zaXRpb25zLCBjYWxpYnJhdGlvbiA9PiBjYWxpYnJhdGlvbi5tZWFzdXJlKTtcblxuICBjYWxpYnJhdGlvblBvc2l0aW9ucy5mb3JFYWNoKGNhbGlicmF0aW9uID0+IHtcbiAgICBjb25zdCBmcm9tVmVydGV4ID0gbGluZVtmcm9tVmVydGV4SW5kZXhdO1xuICAgIGNvbnN0IHRvVmVydGV4ID0gbGluZVtjYWxpYnJhdGlvbi52ZXJ0ZXhJbmRleF07XG4gICAgY29uc3QgbnVtYmVyT2ZWZXJ0aWNlc0luQmV0d2VlbiA9IGNhbGlicmF0aW9uLnZlcnRleEluZGV4IC0gZnJvbVZlcnRleEluZGV4O1xuICAgIGNvbnN0IGRpc3RhbmNlRm9yU2VjdGlvbiA9IE1hdGguYWJzKGNhbGlicmF0aW9uLm1lYXN1cmUgLSBzdGFydE1lYXN1cmUpO1xuICAgIGNvbnN0IG1lYXN1cmVEaXN0cmlidXRpb25JbmNyZW1lbnQgPSBkaXN0YW5jZUZvclNlY3Rpb24gLyBudW1iZXJPZlZlcnRpY2VzSW5CZXR3ZWVuO1xuXG4gICAgc2V0TWVhc3VyZShmcm9tVmVydGV4LCBzdGFydE1lYXN1cmUsIG9wdGlvbnMuaGFzWlZhbHVlcyk7XG4gICAgc2V0TWVhc3VyZSh0b1ZlcnRleCwgY2FsaWJyYXRpb24ubWVhc3VyZSwgb3B0aW9ucy5oYXNaVmFsdWVzKTtcbiAgICBjb25zdCBpbkJldHdlZW5WZXJ0aWNlcyA9IGdldFZlcnRpY2VzQmV0d2VlbihsaW5lLCBmcm9tVmVydGV4SW5kZXgsIGNhbGlicmF0aW9uLnZlcnRleEluZGV4KTtcblxuICAgIGluQmV0d2VlblZlcnRpY2VzLmZvckVhY2goKHZlcnRpY2UsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwYXJ0TnVtYmVyID0gaW5kZXggKyAxO1xuICAgICAgY29uc3QgdmVydGljZUluY3JlbWVudCA9IHBhcnROdW1iZXIgKiBtZWFzdXJlRGlzdHJpYnV0aW9uSW5jcmVtZW50O1xuICAgICAgY29uc3QgbWVhc3VyZSA9IHN0YXJ0TWVhc3VyZSArIHZlcnRpY2VJbmNyZW1lbnQ7XG4gICAgICBzZXRNZWFzdXJlKHZlcnRpY2UsIG1lYXN1cmUsIG9wdGlvbnMuaGFzWlZhbHVlcyk7XG4gICAgfSk7XG5cbiAgICBmcm9tVmVydGV4SW5kZXggPSBjYWxpYnJhdGlvbi52ZXJ0ZXhJbmRleDtcbiAgICBzdGFydE1lYXN1cmUgPSBjYWxpYnJhdGlvbi5tZWFzdXJlO1xuICB9KTtcblxuICBjb25zdCBhcmVNb3JlVmVydGljZXMgPSBmcm9tVmVydGV4SW5kZXggPCBsaW5lLmxlbmd0aCAtIDE7XG4gIGlmIChhcmVNb3JlVmVydGljZXMpIHtcbiAgICBjb25zdCByZW1haW5pbmdQb2ludHM6IG51bWJlcltdW10gPSBnZXRWZXJ0aWNlc0JldHdlZW4obGluZSwgZnJvbVZlcnRleEluZGV4IC0gMSwgbGluZS5sZW5ndGgpO1xuICAgIHNldExpbmVQYXJ0TWVhc3VyZXNCeUdlb21ldHJpY0xlbmd0aChyZW1haW5pbmdQb2ludHMsIHN0YXJ0TWVhc3VyZSwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VmVydGljZXNCZXR3ZWVuKGxpbmU6IG51bWJlcltdW10sIHN0YXJ0UmFuZ2VJbmRleDogbnVtYmVyLCBlbmRSYW5nZUluZGV4OiBudW1iZXIpOiBudW1iZXJbXVtdIHtcbiAgbGV0IGluZGV4ID0gc3RhcnRSYW5nZUluZGV4ICsgMTtcbiAgY29uc3QgdmVydGljZXM6IG51bWJlcltdW10gPSBbXTtcblxuICBmb3IgKDsgaW5kZXggPCBlbmRSYW5nZUluZGV4OyBpbmRleCsrKSB7XG4gICAgY29uc3QgdmVydGljZSA9IGxpbmVbaW5kZXhdO1xuICAgIHZlcnRpY2VzLnB1c2godmVydGljZSk7XG4gIH1cblxuICByZXR1cm4gdmVydGljZXM7XG59XG5cbmZ1bmN0aW9uIHNldExpbmVQYXJ0TWVhc3VyZXNCeUdlb21ldHJpY0xlbmd0aChsaW5lOiBudW1iZXJbXVtdLCBzdGFydE1lYXN1cmU6IG51bWJlciwgb3B0aW9uczogU2V0TWVhc3VyZXNCeUdlb21ldHJpY0xlbmd0aE9wdGlvbnMpOiB2b2lkIHtcbiAgbGV0IHByZXZpb3VzVmVydGV4O1xuICBsZXQgdmVydGV4TWVhc3VyZSA9IHN0YXJ0TWVhc3VyZTtcblxuICBsaW5lLmZvckVhY2goKHZlcnRleCwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgIGNvbnN0IGRpc3RhbmNlQmV0d2VlblZlcnRpY2VlczogbnVtYmVyID0gZGlzdGFuY2UocHJldmlvdXNWZXJ0ZXgsIHZlcnRleCwgb3B0aW9ucyk7XG4gICAgICB2ZXJ0ZXhNZWFzdXJlICs9IGRpc3RhbmNlQmV0d2VlblZlcnRpY2VlcztcbiAgICB9XG5cbiAgICBzZXRNZWFzdXJlKHZlcnRleCwgdmVydGV4TWVhc3VyZSwgb3B0aW9ucy5oYXNaVmFsdWVzKTtcbiAgICBwcmV2aW91c1ZlcnRleCA9IHZlcnRleDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldE1lYXN1cmUoY29vcmRpbmF0ZTogbnVtYmVyW10sIG1lYXN1cmU6IG51bWJlciwgaGFzWlZhbHVlczogYm9vbGVhbik6IHZvaWQge1xuICBjb25zdCBhY2NvdW50Rm9yWlZhbHVlID0gaGFzWlZhbHVlcyB8fCBjb29yZGluYXRlLmxlbmd0aCA+IDM7XG4gIGNvbnN0IG1lYXN1cmVJbmRleCA9IGFjY291bnRGb3JaVmFsdWUgPyAzIDogMjtcbiAgY29vcmRpbmF0ZVttZWFzdXJlSW5kZXhdID0gbWVhc3VyZTtcblxuICBpZiAoYWNjb3VudEZvclpWYWx1ZSkge1xuICAgIGVuc3VyZVpWYWx1ZShjb29yZGluYXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVaVmFsdWUoY29vcmRpbmF0ZTogbnVtYmVyW10pOiB2b2lkIHtcbiAgaWYgKGlzTm90TnVtYmVyKGNvb3JkaW5hdGVbMl0pKSB7XG4gICAgY29vcmRpbmF0ZVsyXSA9IERFRkFVTFRfRU1QVFlfWl9WQUxVRTtcbiAgfVxufVxuIl19