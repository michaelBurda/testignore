/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { LrsMetadata } from './lrs-metadata';
import { findLayer } from './layer-search';
import { LayerDrawingInfo } from '../maps/drawing/layer-drawing-info';
import { mergeDeep } from '../core/merge/merge-deep.function';
import { mergeDeepArray } from '../core/merge/merge-deep-array.function';
import { isNumber } from '../core/type-check/is-number.function';
/**
 * @param {?} layerId
 * @param {...?} layerList
 * @return {?}
 */
function find(layerId, ...layerList) {
    return findLayer(layerId, ...layerList);
}
/**
 * @param {?} layer
 * @return {?}
 */
function setLayerDefaults(layer) {
    layer.fields = layer.fields || [];
}
/**
 * @param {?} layer
 * @return {?}
 */
function setNetworkLayerDefaults(layer) {
    if (layer) {
        layer.hierarchyFilter = layer.hierarchyFilter || [];
    }
}
/**
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
export function mergeFieldDomains(target, source) {
    mergeDeep(target, source, { ignoreArrays: true });
    if (target && target.codedValues && source && source.codedValues) {
        mergeDeepArray(target.codedValues, source.codedValues, { identifier: 'code' });
    }
}
/**
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
export function mergeFields(target, source) {
    target = target || [];
    source = source || [];
    mergeDeepArray(target, source, {
        identifier: 'name',
        beforeMerge: (/**
         * @param {?} targetField
         * @param {?} sourceField
         * @return {?}
         */
        (targetField, sourceField) => {
            if (targetField.domain && sourceField.domain && sourceField.domain.codedValues) {
                /** @type {?} */
                const doValuesNeedMerged = sourceField.domain.codedValues.filter((/**
                 * @param {?} c
                 * @return {?}
                 */
                c => isNumber(c.order)));
                if (doValuesNeedMerged && doValuesNeedMerged.length) {
                    mergeFieldDomains(targetField.domain, sourceField.domain);
                    return false;
                }
            }
        })
    });
}
/**
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
export function mergeLayer(target, source) {
    if (!target || !source) {
        return;
    }
    /** @type {?} */
    const lrsTarget = (/** @type {?} */ (target));
    /** @type {?} */
    const lrsSource = (/** @type {?} */ (source));
    /** @type {?} */
    const targetCapturePositions = lrsTarget.capturePositions || [];
    /** @type {?} */
    const sourceCapturePositions = lrsSource.capturePositions || [];
    /** @type {?} */
    const targetDrawingInfo = (/** @type {?} */ (lrsTarget.drawingInfo));
    /** @type {?} */
    const sourceDrawingInfo = (/** @type {?} */ (lrsSource.drawingInfo));
    /** @type {?} */
    const hasDrawingInfo = Boolean(targetDrawingInfo || sourceDrawingInfo);
    /** @type {?} */
    const drawingInfo = new LayerDrawingInfo((/** @type {?} */ (lrsTarget.drawingInfo)), (/** @type {?} */ (lrsSource.drawingInfo)));
    mergeDeep(target, source, { ignoreArrays: true });
    mergeFields(target.fields, source.fields);
    if (hasDrawingInfo) {
        ((/** @type {?} */ (target))).drawingInfo = drawingInfo;
    }
    if (!targetCapturePositions.length && sourceCapturePositions.length) {
        lrsTarget.capturePositions = sourceCapturePositions;
    }
}
/**
 * @param {?} target
 * @param {?} source
 * @param {?=} sourceMetadata
 * @param {?=} sort
 * @param {?=} onMergeComplete
 * @return {?}
 */
export function mergeLayers(target, source, sourceMetadata, sort = true, onMergeComplete = null) {
    target = target || [];
    source = source || [];
    target.forEach((/**
     * @param {?} targetLayer
     * @return {?}
     */
    (targetLayer) => {
        setLayerDefaults(targetLayer);
        mergeLayer(targetLayer, source.find((/**
         * @param {?} sourceLayer
         * @return {?}
         */
        sourceLayer => sourceLayer.id === targetLayer.id)));
    }));
    // There will be occurences where the source has layers that the target doesn't, which
    // means that the merge will not happen above, because the target is the one being looped.
    source
        .filter((/**
     * @param {?} src
     * @return {?}
     */
    src => !target.find((/**
     * @param {?} x
     * @return {?}
     */
    x => src.id === x.id))))
        .forEach((/**
     * @param {?} missing
     * @return {?}
     */
    missing => {
        /** @type {?} */
        let newLayer = missing;
        if (sourceMetadata) {
            /** @type {?} */
            const merger = find(missing.id, sourceMetadata.tables, sourceMetadata.layers, sourceMetadata.nonLRSLayers);
            // We want to preseve the original table or layer, so we don't overwrite it here.
            newLayer = Object.assign({}, merger);
            mergeLayer(newLayer, missing);
        }
        setLayerDefaults(newLayer);
        target.push(newLayer);
    }));
    if (sort) {
        target.sort((/**
         * @param {?} layer1
         * @param {?} layer2
         * @return {?}
         */
        (layer1, layer2) => layer1.order - layer2.order));
    }
    if (onMergeComplete) {
        target.forEach((/**
         * @param {?} targetLayer
         * @return {?}
         */
        (targetLayer) => {
            onMergeComplete(targetLayer, source.find((/**
             * @param {?} sourceLayer
             * @return {?}
             */
            sourceLayer => sourceLayer.id === targetLayer.id)));
        }));
    }
}
/**
 * @param {?} target
 * @param {?} source
 * @param {?=} sourceMetadata
 * @return {?}
 */
export function mergeNetworkLayers(target, source, sourceMetadata) {
    /** @type {?} */
    const isSorted = true;
    mergeLayers(target, source, sourceMetadata, isSorted, onMergeNetworkLayerComplete);
}
/**
 * @param {?} targetLayer
 * @param {?} sourceLayer
 * @return {?}
 */
export function onMergeNetworkLayerComplete(targetLayer, sourceLayer) {
    setNetworkLayerDefaults(targetLayer);
    setNetworkLayerDefaults(sourceLayer);
    if (targetLayer && sourceLayer) {
        mergeDeepArray(targetLayer.hierarchyFilter, sourceLayer.hierarchyFilter, { identifier: 'name' });
    }
}
/**
 * @param {?} target
 * @param {...?} source
 * @return {?}
 */
export function mergeLrsMetadata(target, ...source) {
    source.forEach((/**
     * @param {?} srcMeta
     * @return {?}
     */
    srcMeta => {
        /** @type {?} */
        const dataSource = srcMeta.dataSource || target.dataSource;
        mergeDeep(target, srcMeta, { ignoreArrays: true });
        if (dataSource) {
            target.dataSource = dataSource;
        }
        mergeNetworkLayers(target.networkLayers, srcMeta.networkLayers, target);
        mergeLayers(target.eventLayers, srcMeta.eventLayers, target);
        mergeLayers(target.calibrationPointLayers, srcMeta.calibrationPointLayers, target);
        mergeLayers(target.intersectionLayers, srcMeta.intersectionLayers, target);
        mergeLayers(target.centerlineLayers, srcMeta.centerlineLayers, target);
        mergeLayers(target.redlineLayers, srcMeta.redlineLayers, target);
        mergeLayers(target.nonLRSLayers, srcMeta.nonLRSLayers, target);
        mergeLayers(target.layers, srcMeta.layers);
        mergeLayers(target.tables, srcMeta.tables);
    }));
}
/**
 * @param {?} target
 * @param {...?} source
 * @return {?}
 */
export function mergeMapMetadata(target, ...source) {
    source.forEach((/**
     * @param {?} meta
     * @return {?}
     */
    meta => {
        Object.assign(target, meta);
    }));
}
/**
 * @param {?} target
 * @param {...?} source
 * @return {?}
 */
export function deepMergeMapMetadata(target, ...source) {
    source.forEach((/**
     * @param {?} meta
     * @return {?}
     */
    meta => {
        meta.layers.forEach((/**
         * @param {?} nonLrsLayerInfo
         * @return {?}
         */
        nonLrsLayerInfo => {
            /** @type {?} */
            const targetLayer = target.getLrsLayer(nonLrsLayerInfo.id);
            if (targetLayer) {
                /** @type {?} */
                const baseFields = [...nonLrsLayerInfo.fields];
                mergeFields(baseFields, targetLayer.fields);
                targetLayer.fields = baseFields;
                if (nonLrsLayerInfo.geometryType) {
                    targetLayer.geometryType = nonLrsLayerInfo.geometryType;
                }
                targetLayer.drawingInfo = new LayerDrawingInfo(nonLrsLayerInfo.drawingInfo, targetLayer.drawingInfo);
            }
        }));
    }));
}
/**
 * @param {?} dataSource
 * @param {?} dataSourceLrsMetadata
 * @param {?} mapServerLrsMetadata
 * @param {?} mapServerMetadata
 * @return {?}
 */
export function mergeLrsMetadataSources(dataSource, dataSourceLrsMetadata, mapServerLrsMetadata, mapServerMetadata) {
    /** @type {?} */
    const hasMapServerLrsMetadata = Boolean(mapServerLrsMetadata);
    /** @type {?} */
    const fullLrsMeta = mapServerLrsMetadata
        || dataSourceLrsMetadata
        || new LrsMetadata(dataSource);
    fullLrsMeta.mergeMapMetadata(mapServerMetadata);
    fullLrsMeta.dataSource = fullLrsMeta.dataSource || dataSource;
    fullLrsMeta.dataSourceId = fullLrsMeta.dataSourceId || dataSource.id;
    if (hasMapServerLrsMetadata) {
        // If the map service has LRS metadata then we need to merge the
        // data source LRS metadata into the map service lrs metadata
        // because we want the data source metadata to be priority.
        fullLrsMeta.mergeLrsMetadata(dataSourceLrsMetadata);
    }
    else {
        // We only need to do a dep merge when there is no LRS metadata available in the map service because
        // the map service LRS metadata provides all of the same information as the map server metadata (like fields).
        fullLrsMeta.deepMergeMapMetadata(mapServerMetadata);
    }
    fullLrsMeta.rebuildLayers();
    return fullLrsMeta;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHJzLW1ldGFkYXRhLW1lcmdlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRzcy9zZGsvIiwic291cmNlcyI6WyJsaWIvbHJzL2xycy1tZXRhZGF0YS1tZXJnZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQ0EsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTdDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUkzQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUV0RSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDOUQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQzs7Ozs7O0FBSWpFLFNBQVMsSUFBSSxDQUFDLE9BQWUsRUFBRSxHQUFHLFNBQXVCO0lBQ3ZELE9BQU8sU0FBUyxDQUFDLE9BQU8sRUFBRSxHQUFHLFNBQVMsQ0FBQyxDQUFDO0FBQzFDLENBQUM7Ozs7O0FBRUQsU0FBUyxnQkFBZ0IsQ0FBQyxLQUFlO0lBQ3ZDLEtBQUssQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUM7QUFDcEMsQ0FBQzs7Ozs7QUFFRCxTQUFTLHVCQUF1QixDQUFDLEtBQW1CO0lBQ2xELElBQUksS0FBSyxFQUFFO1FBQ1QsS0FBSyxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUMsZUFBZSxJQUFJLEVBQUUsQ0FBQztLQUNyRDtBQUNILENBQUM7Ozs7OztBQUVELE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxNQUF3QixFQUFFLE1BQXdCO0lBQ2xGLFNBQVMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFFbEQsSUFBSSxNQUFNLElBQUksTUFBTSxDQUFDLFdBQVcsSUFBSSxNQUFNLElBQUksTUFBTSxDQUFDLFdBQVcsRUFBRTtRQUNoRSxjQUFjLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsV0FBVyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7S0FDaEY7QUFDSCxDQUFDOzs7Ozs7QUFFRCxNQUFNLFVBQVUsV0FBVyxDQUFDLE1BQW9CLEVBQUUsTUFBb0I7SUFDcEUsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDdEIsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFFdEIsY0FBYyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUU7UUFDN0IsVUFBVSxFQUFFLE1BQU07UUFDbEIsV0FBVzs7Ozs7UUFBRSxDQUFDLFdBQXVCLEVBQUUsV0FBdUIsRUFBRSxFQUFFO1lBQ2hFLElBQUksV0FBVyxDQUFDLE1BQU0sSUFBSSxXQUFXLENBQUMsTUFBTSxJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFOztzQkFDeEUsa0JBQWtCLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTTs7OztnQkFBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUM7Z0JBRXhGLElBQUksa0JBQWtCLElBQUksa0JBQWtCLENBQUMsTUFBTSxFQUFFO29CQUNuRCxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDMUQsT0FBTyxLQUFLLENBQUM7aUJBQ2Q7YUFDRjtRQUNILENBQUMsQ0FBQTtLQUNGLENBQUMsQ0FBQztBQUNMLENBQUM7Ozs7OztBQUVELE1BQU0sVUFBVSxVQUFVLENBQUMsTUFBZ0IsRUFBRSxNQUFnQjtJQUMzRCxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ3RCLE9BQU87S0FDUjs7VUFHSyxTQUFTLEdBQUcsbUJBQUEsTUFBTSxFQUFZOztVQUM5QixTQUFTLEdBQUcsbUJBQUEsTUFBTSxFQUFZOztVQUM5QixzQkFBc0IsR0FBRyxTQUFTLENBQUMsZ0JBQWdCLElBQUksRUFBRTs7VUFDekQsc0JBQXNCLEdBQUcsU0FBUyxDQUFDLGdCQUFnQixJQUFJLEVBQUU7O1VBQ3pELGlCQUFpQixHQUFHLG1CQUFBLFNBQVMsQ0FBQyxXQUFXLEVBQW9COztVQUM3RCxpQkFBaUIsR0FBRyxtQkFBQSxTQUFTLENBQUMsV0FBVyxFQUFvQjs7VUFDN0QsY0FBYyxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsSUFBSSxpQkFBaUIsQ0FBQzs7VUFDaEUsV0FBVyxHQUFHLElBQUksZ0JBQWdCLENBQUMsbUJBQUEsU0FBUyxDQUFDLFdBQVcsRUFBb0IsRUFBRSxtQkFBQSxTQUFTLENBQUMsV0FBVyxFQUFvQixDQUFDO0lBRTlILFNBQVMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFDbEQsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRTFDLElBQUksY0FBYyxFQUFFO1FBQ2xCLENBQUMsbUJBQUEsTUFBTSxFQUFxQixDQUFDLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztLQUN6RDtJQUVELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLElBQUksc0JBQXNCLENBQUMsTUFBTSxFQUFFO1FBQ25FLFNBQVMsQ0FBQyxnQkFBZ0IsR0FBRyxzQkFBc0IsQ0FBQztLQUNyRDtBQUNILENBQUM7Ozs7Ozs7OztBQUVELE1BQU0sVUFBVSxXQUFXLENBQ3pCLE1BQWtCLEVBQ2xCLE1BQWtCLEVBQ2xCLGNBQTRCLEVBQzVCLElBQUksR0FBRyxJQUFJLEVBQ1gsa0JBQStELElBQUk7SUFFbkUsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDdEIsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFFdEIsTUFBTSxDQUFDLE9BQU87Ozs7SUFBQyxDQUFDLFdBQXFCLEVBQUUsRUFBRTtRQUN2QyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM5QixVQUFVLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxJQUFJOzs7O1FBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsRUFBRSxLQUFLLFdBQVcsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDO0lBQ3pGLENBQUMsRUFBQyxDQUFDO0lBRUgsc0ZBQXNGO0lBQ3RGLDBGQUEwRjtJQUMxRixNQUFNO1NBQ0gsTUFBTTs7OztJQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSTs7OztJQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFDLEVBQUM7U0FDakQsT0FBTzs7OztJQUFDLE9BQU8sQ0FBQyxFQUFFOztZQUNiLFFBQVEsR0FBYSxPQUFPO1FBQ2hDLElBQUksY0FBYyxFQUFFOztrQkFDWixNQUFNLEdBQWEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsY0FBYyxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxZQUFZLENBQUM7WUFFcEgsaUZBQWlGO1lBQ2pGLFFBQVEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUNyQyxVQUFVLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQy9CO1FBRUQsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0IsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN4QixDQUFDLEVBQUMsQ0FBQztJQUVMLElBQUksSUFBSSxFQUFFO1FBQ1IsTUFBTSxDQUFDLElBQUk7Ozs7O1FBQUMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUMsQ0FBQztLQUM5RDtJQUVELElBQUksZUFBZSxFQUFFO1FBQ25CLE1BQU0sQ0FBQyxPQUFPOzs7O1FBQUMsQ0FBQyxXQUFxQixFQUFFLEVBQUU7WUFDdkMsZUFBZSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsSUFBSTs7OztZQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsS0FBSyxXQUFXLENBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQztRQUM5RixDQUFDLEVBQUMsQ0FBQztLQUNKO0FBQ0gsQ0FBQzs7Ozs7OztBQUVELE1BQU0sVUFBVSxrQkFBa0IsQ0FBQyxNQUFzQixFQUFFLE1BQXNCLEVBQUUsY0FBNEI7O1VBQ3ZHLFFBQVEsR0FBRyxJQUFJO0lBQ3JCLFdBQVcsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsMkJBQTJCLENBQUMsQ0FBQztBQUNyRixDQUFDOzs7Ozs7QUFFRCxNQUFNLFVBQVUsMkJBQTJCLENBQUMsV0FBeUIsRUFBRSxXQUF5QjtJQUM5Rix1QkFBdUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNyQyx1QkFBdUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUVyQyxJQUFJLFdBQVcsSUFBSSxXQUFXLEVBQUU7UUFDOUIsY0FBYyxDQUFDLFdBQVcsQ0FBQyxlQUFlLEVBQUUsV0FBVyxDQUFDLGVBQWUsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO0tBQ2xHO0FBQ0gsQ0FBQzs7Ozs7O0FBRUQsTUFBTSxVQUFVLGdCQUFnQixDQUFDLE1BQW1CLEVBQUUsR0FBRyxNQUFxQjtJQUM1RSxNQUFNLENBQUMsT0FBTzs7OztJQUFDLE9BQU8sQ0FBQyxFQUFFOztjQUNqQixVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsSUFBSSxNQUFNLENBQUMsVUFBVTtRQUMxRCxTQUFTLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRW5ELElBQUksVUFBVSxFQUFFO1lBQ2QsTUFBTSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7U0FDaEM7UUFFRCxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxhQUFhLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDeEUsV0FBVyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUM3RCxXQUFXLENBQUMsTUFBTSxDQUFDLHNCQUFzQixFQUFFLE9BQU8sQ0FBQyxzQkFBc0IsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNuRixXQUFXLENBQUMsTUFBTSxDQUFDLGtCQUFrQixFQUFFLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUMzRSxXQUFXLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN2RSxXQUFXLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ2pFLFdBQVcsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDL0QsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzNDLFdBQVcsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM3QyxDQUFDLEVBQUMsQ0FBQztBQUNMLENBQUM7Ozs7OztBQUVELE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxNQUFtQixFQUFFLEdBQUcsTUFBMkI7SUFDbEYsTUFBTSxDQUFDLE9BQU87Ozs7SUFBQyxJQUFJLENBQUMsRUFBRTtRQUNwQixNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDLEVBQUMsQ0FBQztBQUNMLENBQUM7Ozs7OztBQUVELE1BQU0sVUFBVSxvQkFBb0IsQ0FBQyxNQUFtQixFQUFFLEdBQUcsTUFBMkI7SUFDdEYsTUFBTSxDQUFDLE9BQU87Ozs7SUFBQyxJQUFJLENBQUMsRUFBRTtRQUNwQixJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU87Ozs7UUFBQyxlQUFlLENBQUMsRUFBRTs7a0JBQzlCLFdBQVcsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUM7WUFDMUQsSUFBSSxXQUFXLEVBQUU7O3NCQUNULFVBQVUsR0FBRyxDQUFDLEdBQUcsZUFBZSxDQUFDLE1BQU0sQ0FBQztnQkFDOUMsV0FBVyxDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzVDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDO2dCQUNoQyxJQUFJLGVBQWUsQ0FBQyxZQUFZLEVBQUU7b0JBQ2hDLFdBQVcsQ0FBQyxZQUFZLEdBQUcsZUFBZSxDQUFDLFlBQVksQ0FBQztpQkFDekQ7Z0JBRUQsV0FBVyxDQUFDLFdBQVcsR0FBRyxJQUFJLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ3RHO1FBQ0gsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDLEVBQUMsQ0FBQztBQUNMLENBQUM7Ozs7Ozs7O0FBRUQsTUFBTSxVQUFVLHVCQUF1QixDQUNyQyxVQUFzQixFQUN0QixxQkFBa0MsRUFDbEMsb0JBQWlDLEVBQ2pDLGlCQUFvQzs7VUFFOUIsdUJBQXVCLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDOztVQUN2RCxXQUFXLEdBQUcsb0JBQW9CO1dBQ25DLHFCQUFxQjtXQUNyQixJQUFJLFdBQVcsQ0FBQyxVQUFVLENBQUM7SUFFaEMsV0FBVyxDQUFDLGdCQUFnQixDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDaEQsV0FBVyxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsVUFBVSxJQUFJLFVBQVUsQ0FBQztJQUM5RCxXQUFXLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQyxZQUFZLElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQztJQUVyRSxJQUFJLHVCQUF1QixFQUFFO1FBQzNCLGdFQUFnRTtRQUNoRSw2REFBNkQ7UUFDN0QsMkRBQTJEO1FBQzNELFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0tBQ3JEO1NBQU07UUFDTCxvR0FBb0c7UUFDcEcsOEdBQThHO1FBQzlHLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0tBQ3JEO0lBRUQsV0FBVyxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBRTVCLE9BQU8sV0FBVyxDQUFDO0FBQ3JCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYXllckZpZWxkLCBMYXllckZpZWxkRG9tYWluIH0gZnJvbSAnLi4vbWFwcy9maWVsZHMvbGF5ZXItZmllbGQnO1xuaW1wb3J0IHsgTHJzTWV0YWRhdGEgfSBmcm9tICcuL2xycy1tZXRhZGF0YSc7XG5pbXBvcnQgeyBNYXBTZXJ2ZXJNZXRhZGF0YSB9IGZyb20gJy4uL21hcHMvbWFwLXNlcnZlci1tZXRhZGF0YSc7XG5pbXBvcnQgeyBmaW5kTGF5ZXIgfSBmcm9tICcuL2xheWVyLXNlYXJjaCc7XG5pbXBvcnQgeyBNYXBMYXllciB9IGZyb20gJy4uL21hcHMvbWFwLWxheWVyJztcbmltcG9ydCB7IE5ldHdvcmtMYXllciB9IGZyb20gJy4vbmV0d29ya3MvbmV0d29yay1sYXllcic7XG5pbXBvcnQgeyBEYXRhU291cmNlIH0gZnJvbSAnLi4vZGF0YS1zb3VyY2UvZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHsgTGF5ZXJEcmF3aW5nSW5mbyB9IGZyb20gJy4uL21hcHMvZHJhd2luZy9sYXllci1kcmF3aW5nLWluZm8nO1xuaW1wb3J0IHsgRmVhdHVyZUNsYXNzTGF5ZXIgfSBmcm9tICcuLi9tYXBzL2ZlYXR1cmUtY2xhc3MtbGF5ZXInO1xuaW1wb3J0IHsgbWVyZ2VEZWVwIH0gZnJvbSAnLi4vY29yZS9tZXJnZS9tZXJnZS1kZWVwLmZ1bmN0aW9uJztcbmltcG9ydCB7IG1lcmdlRGVlcEFycmF5IH0gZnJvbSAnLi4vY29yZS9tZXJnZS9tZXJnZS1kZWVwLWFycmF5LmZ1bmN0aW9uJztcbmltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSAnLi4vY29yZS90eXBlLWNoZWNrL2lzLW51bWJlci5mdW5jdGlvbic7XG5pbXBvcnQgeyBMcnNMYXllciB9IGZyb20gJy4vbHJzLWxheWVyJztcblxuXG5mdW5jdGlvbiBmaW5kKGxheWVySWQ6IG51bWJlciwgLi4ubGF5ZXJMaXN0OiBNYXBMYXllcltdW10pOiBNYXBMYXllciB7XG4gIHJldHVybiBmaW5kTGF5ZXIobGF5ZXJJZCwgLi4ubGF5ZXJMaXN0KTtcbn1cblxuZnVuY3Rpb24gc2V0TGF5ZXJEZWZhdWx0cyhsYXllcjogTWFwTGF5ZXIpOiB2b2lkIHtcbiAgbGF5ZXIuZmllbGRzID0gbGF5ZXIuZmllbGRzIHx8IFtdO1xufVxuXG5mdW5jdGlvbiBzZXROZXR3b3JrTGF5ZXJEZWZhdWx0cyhsYXllcjogTmV0d29ya0xheWVyKTogdm9pZCB7XG4gIGlmIChsYXllcikge1xuICAgIGxheWVyLmhpZXJhcmNoeUZpbHRlciA9IGxheWVyLmhpZXJhcmNoeUZpbHRlciB8fCBbXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VGaWVsZERvbWFpbnModGFyZ2V0OiBMYXllckZpZWxkRG9tYWluLCBzb3VyY2U6IExheWVyRmllbGREb21haW4pIHtcbiAgbWVyZ2VEZWVwKHRhcmdldCwgc291cmNlLCB7IGlnbm9yZUFycmF5czogdHJ1ZSB9KTtcblxuICBpZiAodGFyZ2V0ICYmIHRhcmdldC5jb2RlZFZhbHVlcyAmJiBzb3VyY2UgJiYgc291cmNlLmNvZGVkVmFsdWVzKSB7XG4gICAgbWVyZ2VEZWVwQXJyYXkodGFyZ2V0LmNvZGVkVmFsdWVzLCBzb3VyY2UuY29kZWRWYWx1ZXMsIHsgaWRlbnRpZmllcjogJ2NvZGUnIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUZpZWxkcyh0YXJnZXQ6IExheWVyRmllbGRbXSwgc291cmNlOiBMYXllckZpZWxkW10pIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IFtdO1xuICBzb3VyY2UgPSBzb3VyY2UgfHwgW107XG5cbiAgbWVyZ2VEZWVwQXJyYXkodGFyZ2V0LCBzb3VyY2UsIHtcbiAgICBpZGVudGlmaWVyOiAnbmFtZScsXG4gICAgYmVmb3JlTWVyZ2U6ICh0YXJnZXRGaWVsZDogTGF5ZXJGaWVsZCwgc291cmNlRmllbGQ6IExheWVyRmllbGQpID0+IHtcbiAgICAgIGlmICh0YXJnZXRGaWVsZC5kb21haW4gJiYgc291cmNlRmllbGQuZG9tYWluICYmIHNvdXJjZUZpZWxkLmRvbWFpbi5jb2RlZFZhbHVlcykge1xuICAgICAgICBjb25zdCBkb1ZhbHVlc05lZWRNZXJnZWQgPSBzb3VyY2VGaWVsZC5kb21haW4uY29kZWRWYWx1ZXMuZmlsdGVyKGMgPT4gaXNOdW1iZXIoYy5vcmRlcikpO1xuXG4gICAgICAgIGlmIChkb1ZhbHVlc05lZWRNZXJnZWQgJiYgZG9WYWx1ZXNOZWVkTWVyZ2VkLmxlbmd0aCkge1xuICAgICAgICAgIG1lcmdlRmllbGREb21haW5zKHRhcmdldEZpZWxkLmRvbWFpbiwgc291cmNlRmllbGQuZG9tYWluKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VMYXllcih0YXJnZXQ6IE1hcExheWVyLCBzb3VyY2U6IE1hcExheWVyKSB7XG4gIGlmICghdGFyZ2V0IHx8ICFzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuXG4gIGNvbnN0IGxyc1RhcmdldCA9IHRhcmdldCBhcyBMcnNMYXllcjtcbiAgY29uc3QgbHJzU291cmNlID0gc291cmNlIGFzIExyc0xheWVyO1xuICBjb25zdCB0YXJnZXRDYXB0dXJlUG9zaXRpb25zID0gbHJzVGFyZ2V0LmNhcHR1cmVQb3NpdGlvbnMgfHwgW107XG4gIGNvbnN0IHNvdXJjZUNhcHR1cmVQb3NpdGlvbnMgPSBscnNTb3VyY2UuY2FwdHVyZVBvc2l0aW9ucyB8fCBbXTtcbiAgY29uc3QgdGFyZ2V0RHJhd2luZ0luZm8gPSBscnNUYXJnZXQuZHJhd2luZ0luZm8gYXMgTGF5ZXJEcmF3aW5nSW5mbztcbiAgY29uc3Qgc291cmNlRHJhd2luZ0luZm8gPSBscnNTb3VyY2UuZHJhd2luZ0luZm8gYXMgTGF5ZXJEcmF3aW5nSW5mbztcbiAgY29uc3QgaGFzRHJhd2luZ0luZm8gPSBCb29sZWFuKHRhcmdldERyYXdpbmdJbmZvIHx8IHNvdXJjZURyYXdpbmdJbmZvKTtcbiAgY29uc3QgZHJhd2luZ0luZm8gPSBuZXcgTGF5ZXJEcmF3aW5nSW5mbyhscnNUYXJnZXQuZHJhd2luZ0luZm8gYXMgTGF5ZXJEcmF3aW5nSW5mbywgbHJzU291cmNlLmRyYXdpbmdJbmZvIGFzIExheWVyRHJhd2luZ0luZm8pO1xuXG4gIG1lcmdlRGVlcCh0YXJnZXQsIHNvdXJjZSwgeyBpZ25vcmVBcnJheXM6IHRydWUgfSk7XG4gIG1lcmdlRmllbGRzKHRhcmdldC5maWVsZHMsIHNvdXJjZS5maWVsZHMpO1xuXG4gIGlmIChoYXNEcmF3aW5nSW5mbykge1xuICAgICh0YXJnZXQgYXMgRmVhdHVyZUNsYXNzTGF5ZXIpLmRyYXdpbmdJbmZvID0gZHJhd2luZ0luZm87XG4gIH1cblxuICBpZiAoIXRhcmdldENhcHR1cmVQb3NpdGlvbnMubGVuZ3RoICYmIHNvdXJjZUNhcHR1cmVQb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgbHJzVGFyZ2V0LmNhcHR1cmVQb3NpdGlvbnMgPSBzb3VyY2VDYXB0dXJlUG9zaXRpb25zO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUxheWVycyhcbiAgdGFyZ2V0OiBNYXBMYXllcltdLFxuICBzb3VyY2U6IE1hcExheWVyW10sXG4gIHNvdXJjZU1ldGFkYXRhPzogTHJzTWV0YWRhdGEsXG4gIHNvcnQgPSB0cnVlLFxuICBvbk1lcmdlQ29tcGxldGU6ICh0YXJnZXQ6IE1hcExheWVyLCBzb3VyY2U6IE1hcExheWVyKSA9PiBhbnkgPSBudWxsXG4pIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IFtdO1xuICBzb3VyY2UgPSBzb3VyY2UgfHwgW107XG5cbiAgdGFyZ2V0LmZvckVhY2goKHRhcmdldExheWVyOiBNYXBMYXllcikgPT4ge1xuICAgIHNldExheWVyRGVmYXVsdHModGFyZ2V0TGF5ZXIpO1xuICAgIG1lcmdlTGF5ZXIodGFyZ2V0TGF5ZXIsIHNvdXJjZS5maW5kKHNvdXJjZUxheWVyID0+IHNvdXJjZUxheWVyLmlkID09PSB0YXJnZXRMYXllci5pZCkpO1xuICB9KTtcblxuICAvLyBUaGVyZSB3aWxsIGJlIG9jY3VyZW5jZXMgd2hlcmUgdGhlIHNvdXJjZSBoYXMgbGF5ZXJzIHRoYXQgdGhlIHRhcmdldCBkb2Vzbid0LCB3aGljaFxuICAvLyBtZWFucyB0aGF0IHRoZSBtZXJnZSB3aWxsIG5vdCBoYXBwZW4gYWJvdmUsIGJlY2F1c2UgdGhlIHRhcmdldCBpcyB0aGUgb25lIGJlaW5nIGxvb3BlZC5cbiAgc291cmNlXG4gICAgLmZpbHRlcihzcmMgPT4gIXRhcmdldC5maW5kKHggPT4gc3JjLmlkID09PSB4LmlkKSlcbiAgICAuZm9yRWFjaChtaXNzaW5nID0+IHtcbiAgICAgIGxldCBuZXdMYXllcjogTWFwTGF5ZXIgPSBtaXNzaW5nO1xuICAgICAgaWYgKHNvdXJjZU1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlcjogTWFwTGF5ZXIgPSBmaW5kKG1pc3NpbmcuaWQsIHNvdXJjZU1ldGFkYXRhLnRhYmxlcywgc291cmNlTWV0YWRhdGEubGF5ZXJzLCBzb3VyY2VNZXRhZGF0YS5ub25MUlNMYXllcnMpO1xuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gcHJlc2V2ZSB0aGUgb3JpZ2luYWwgdGFibGUgb3IgbGF5ZXIsIHNvIHdlIGRvbid0IG92ZXJ3cml0ZSBpdCBoZXJlLlxuICAgICAgICBuZXdMYXllciA9IE9iamVjdC5hc3NpZ24oe30sIG1lcmdlcik7XG4gICAgICAgIG1lcmdlTGF5ZXIobmV3TGF5ZXIsIG1pc3NpbmcpO1xuICAgICAgfVxuXG4gICAgICBzZXRMYXllckRlZmF1bHRzKG5ld0xheWVyKTtcbiAgICAgIHRhcmdldC5wdXNoKG5ld0xheWVyKTtcbiAgICB9KTtcblxuICBpZiAoc29ydCkge1xuICAgIHRhcmdldC5zb3J0KChsYXllcjEsIGxheWVyMikgPT4gbGF5ZXIxLm9yZGVyIC0gbGF5ZXIyLm9yZGVyKTtcbiAgfVxuXG4gIGlmIChvbk1lcmdlQ29tcGxldGUpIHtcbiAgICB0YXJnZXQuZm9yRWFjaCgodGFyZ2V0TGF5ZXI6IE1hcExheWVyKSA9PiB7XG4gICAgICBvbk1lcmdlQ29tcGxldGUodGFyZ2V0TGF5ZXIsIHNvdXJjZS5maW5kKHNvdXJjZUxheWVyID0+IHNvdXJjZUxheWVyLmlkID09PSB0YXJnZXRMYXllci5pZCkpO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZU5ldHdvcmtMYXllcnModGFyZ2V0OiBOZXR3b3JrTGF5ZXJbXSwgc291cmNlOiBOZXR3b3JrTGF5ZXJbXSwgc291cmNlTWV0YWRhdGE/OiBMcnNNZXRhZGF0YSkge1xuICBjb25zdCBpc1NvcnRlZCA9IHRydWU7XG4gIG1lcmdlTGF5ZXJzKHRhcmdldCwgc291cmNlLCBzb3VyY2VNZXRhZGF0YSwgaXNTb3J0ZWQsIG9uTWVyZ2VOZXR3b3JrTGF5ZXJDb21wbGV0ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbk1lcmdlTmV0d29ya0xheWVyQ29tcGxldGUodGFyZ2V0TGF5ZXI6IE5ldHdvcmtMYXllciwgc291cmNlTGF5ZXI6IE5ldHdvcmtMYXllcik6IHZvaWQge1xuICBzZXROZXR3b3JrTGF5ZXJEZWZhdWx0cyh0YXJnZXRMYXllcik7XG4gIHNldE5ldHdvcmtMYXllckRlZmF1bHRzKHNvdXJjZUxheWVyKTtcblxuICBpZiAodGFyZ2V0TGF5ZXIgJiYgc291cmNlTGF5ZXIpIHtcbiAgICBtZXJnZURlZXBBcnJheSh0YXJnZXRMYXllci5oaWVyYXJjaHlGaWx0ZXIsIHNvdXJjZUxheWVyLmhpZXJhcmNoeUZpbHRlciwgeyBpZGVudGlmaWVyOiAnbmFtZScgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTHJzTWV0YWRhdGEodGFyZ2V0OiBMcnNNZXRhZGF0YSwgLi4uc291cmNlOiBMcnNNZXRhZGF0YVtdKTogdm9pZCB7XG4gIHNvdXJjZS5mb3JFYWNoKHNyY01ldGEgPT4ge1xuICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBzcmNNZXRhLmRhdGFTb3VyY2UgfHwgdGFyZ2V0LmRhdGFTb3VyY2U7XG4gICAgbWVyZ2VEZWVwKHRhcmdldCwgc3JjTWV0YSwgeyBpZ25vcmVBcnJheXM6IHRydWUgfSk7XG5cbiAgICBpZiAoZGF0YVNvdXJjZSkge1xuICAgICAgdGFyZ2V0LmRhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuICAgIH1cblxuICAgIG1lcmdlTmV0d29ya0xheWVycyh0YXJnZXQubmV0d29ya0xheWVycywgc3JjTWV0YS5uZXR3b3JrTGF5ZXJzLCB0YXJnZXQpO1xuICAgIG1lcmdlTGF5ZXJzKHRhcmdldC5ldmVudExheWVycywgc3JjTWV0YS5ldmVudExheWVycywgdGFyZ2V0KTtcbiAgICBtZXJnZUxheWVycyh0YXJnZXQuY2FsaWJyYXRpb25Qb2ludExheWVycywgc3JjTWV0YS5jYWxpYnJhdGlvblBvaW50TGF5ZXJzLCB0YXJnZXQpO1xuICAgIG1lcmdlTGF5ZXJzKHRhcmdldC5pbnRlcnNlY3Rpb25MYXllcnMsIHNyY01ldGEuaW50ZXJzZWN0aW9uTGF5ZXJzLCB0YXJnZXQpO1xuICAgIG1lcmdlTGF5ZXJzKHRhcmdldC5jZW50ZXJsaW5lTGF5ZXJzLCBzcmNNZXRhLmNlbnRlcmxpbmVMYXllcnMsIHRhcmdldCk7XG4gICAgbWVyZ2VMYXllcnModGFyZ2V0LnJlZGxpbmVMYXllcnMsIHNyY01ldGEucmVkbGluZUxheWVycywgdGFyZ2V0KTtcbiAgICBtZXJnZUxheWVycyh0YXJnZXQubm9uTFJTTGF5ZXJzLCBzcmNNZXRhLm5vbkxSU0xheWVycywgdGFyZ2V0KTtcbiAgICBtZXJnZUxheWVycyh0YXJnZXQubGF5ZXJzLCBzcmNNZXRhLmxheWVycyk7XG4gICAgbWVyZ2VMYXllcnModGFyZ2V0LnRhYmxlcywgc3JjTWV0YS50YWJsZXMpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTWFwTWV0YWRhdGEodGFyZ2V0OiBMcnNNZXRhZGF0YSwgLi4uc291cmNlOiBNYXBTZXJ2ZXJNZXRhZGF0YVtdKTogdm9pZCB7XG4gIHNvdXJjZS5mb3JFYWNoKG1ldGEgPT4ge1xuICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBtZXRhKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWVyZ2VNYXBNZXRhZGF0YSh0YXJnZXQ6IExyc01ldGFkYXRhLCAuLi5zb3VyY2U6IE1hcFNlcnZlck1ldGFkYXRhW10pOiB2b2lkIHtcbiAgc291cmNlLmZvckVhY2gobWV0YSA9PiB7XG4gICAgbWV0YS5sYXllcnMuZm9yRWFjaChub25McnNMYXllckluZm8gPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0TGF5ZXIgPSB0YXJnZXQuZ2V0THJzTGF5ZXIobm9uTHJzTGF5ZXJJbmZvLmlkKTtcbiAgICAgIGlmICh0YXJnZXRMYXllcikge1xuICAgICAgICBjb25zdCBiYXNlRmllbGRzID0gWy4uLm5vbkxyc0xheWVySW5mby5maWVsZHNdO1xuICAgICAgICBtZXJnZUZpZWxkcyhiYXNlRmllbGRzLCB0YXJnZXRMYXllci5maWVsZHMpO1xuICAgICAgICB0YXJnZXRMYXllci5maWVsZHMgPSBiYXNlRmllbGRzO1xuICAgICAgICBpZiAobm9uTHJzTGF5ZXJJbmZvLmdlb21ldHJ5VHlwZSkge1xuICAgICAgICAgIHRhcmdldExheWVyLmdlb21ldHJ5VHlwZSA9IG5vbkxyc0xheWVySW5mby5nZW9tZXRyeVR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRMYXllci5kcmF3aW5nSW5mbyA9IG5ldyBMYXllckRyYXdpbmdJbmZvKG5vbkxyc0xheWVySW5mby5kcmF3aW5nSW5mbywgdGFyZ2V0TGF5ZXIuZHJhd2luZ0luZm8pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTHJzTWV0YWRhdGFTb3VyY2VzKFxuICBkYXRhU291cmNlOiBEYXRhU291cmNlLFxuICBkYXRhU291cmNlTHJzTWV0YWRhdGE6IExyc01ldGFkYXRhLFxuICBtYXBTZXJ2ZXJMcnNNZXRhZGF0YTogTHJzTWV0YWRhdGEsXG4gIG1hcFNlcnZlck1ldGFkYXRhOiBNYXBTZXJ2ZXJNZXRhZGF0YVxuKTogTHJzTWV0YWRhdGEge1xuICBjb25zdCBoYXNNYXBTZXJ2ZXJMcnNNZXRhZGF0YSA9IEJvb2xlYW4obWFwU2VydmVyTHJzTWV0YWRhdGEpO1xuICBjb25zdCBmdWxsTHJzTWV0YSA9IG1hcFNlcnZlckxyc01ldGFkYXRhXG4gICAgfHwgZGF0YVNvdXJjZUxyc01ldGFkYXRhXG4gICAgfHwgbmV3IExyc01ldGFkYXRhKGRhdGFTb3VyY2UpO1xuXG4gIGZ1bGxMcnNNZXRhLm1lcmdlTWFwTWV0YWRhdGEobWFwU2VydmVyTWV0YWRhdGEpO1xuICBmdWxsTHJzTWV0YS5kYXRhU291cmNlID0gZnVsbExyc01ldGEuZGF0YVNvdXJjZSB8fCBkYXRhU291cmNlO1xuICBmdWxsTHJzTWV0YS5kYXRhU291cmNlSWQgPSBmdWxsTHJzTWV0YS5kYXRhU291cmNlSWQgfHwgZGF0YVNvdXJjZS5pZDtcblxuICBpZiAoaGFzTWFwU2VydmVyTHJzTWV0YWRhdGEpIHtcbiAgICAvLyBJZiB0aGUgbWFwIHNlcnZpY2UgaGFzIExSUyBtZXRhZGF0YSB0aGVuIHdlIG5lZWQgdG8gbWVyZ2UgdGhlXG4gICAgLy8gZGF0YSBzb3VyY2UgTFJTIG1ldGFkYXRhIGludG8gdGhlIG1hcCBzZXJ2aWNlIGxycyBtZXRhZGF0YVxuICAgIC8vIGJlY2F1c2Ugd2Ugd2FudCB0aGUgZGF0YSBzb3VyY2UgbWV0YWRhdGEgdG8gYmUgcHJpb3JpdHkuXG4gICAgZnVsbExyc01ldGEubWVyZ2VMcnNNZXRhZGF0YShkYXRhU291cmNlTHJzTWV0YWRhdGEpO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBkbyBhIGRlcCBtZXJnZSB3aGVuIHRoZXJlIGlzIG5vIExSUyBtZXRhZGF0YSBhdmFpbGFibGUgaW4gdGhlIG1hcCBzZXJ2aWNlIGJlY2F1c2VcbiAgICAvLyB0aGUgbWFwIHNlcnZpY2UgTFJTIG1ldGFkYXRhIHByb3ZpZGVzIGFsbCBvZiB0aGUgc2FtZSBpbmZvcm1hdGlvbiBhcyB0aGUgbWFwIHNlcnZlciBtZXRhZGF0YSAobGlrZSBmaWVsZHMpLlxuICAgIGZ1bGxMcnNNZXRhLmRlZXBNZXJnZU1hcE1ldGFkYXRhKG1hcFNlcnZlck1ldGFkYXRhKTtcbiAgfVxuXG4gIGZ1bGxMcnNNZXRhLnJlYnVpbGRMYXllcnMoKTtcblxuICByZXR1cm4gZnVsbExyc01ldGE7XG59XG4iXX0=