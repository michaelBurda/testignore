/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { MISSING_ROLE_PARAM_EXCEPTION_MSG } from './role';
import { SecurityConfig } from '../security-config';
import { BaseResourceService } from '../../core/resource/base-resource.service';
import { join } from '../../core/url/join.function';
import { UNSUPPORTED_GET_EXCEPTION_MSG, UNSUPPORTED_CREATE_EXCEPTION_MSG } from '../../core/resource/resource.constants';
import { MISSING_USER_PARAM_EXCEPTION_MSG } from '../security.constants';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "../security-config";
/**
 * Service to provide all CRUD operations for user/role assignment.
 *
 * \@example
 * ## Gets roles for a given user:
 * service.rolesByUser('879e27e1-b139-4348-86ca-ec4d5651475f')
 *
 * // Which is just a shortcut for:
 * service.query({ userId: '879e27e1-b139-4348-86ca-ec4d5651475f' });
 *
 */
export class UserRoleService extends BaseResourceService {
    /**
     * @param {?} http
     * @param {?} config
     */
    constructor(http, config) {
        super(http, {
            url: join(config.serviceUrl, config.userRolesEndpoint),
            idFieldName: 'userId'
        });
        this.http = http;
    }
    /**
     * Retrieves a list of roles for a given user ID.
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    query(routeTokens, params) {
        if (!routeTokens || !routeTokens.userId) {
            throw new Error(MISSING_USER_PARAM_EXCEPTION_MSG);
        }
        return super.query(routeTokens, params);
    }
    /**
     * This method is not supported for this resource. Please use "rolesByUser".
     * @param {?} id
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    get(id, routeTokens, params) {
        throw new Error(UNSUPPORTED_GET_EXCEPTION_MSG);
    }
    /**
     * This method is not supported for this resource. Please use "addUserToRole".
     * @param {?} entity
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    create(entity, routeTokens, params) {
        throw new Error(UNSUPPORTED_CREATE_EXCEPTION_MSG);
    }
    /**
     * Updates a users role assignment (adds a role to a user).
     * @param {?} entity
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    update(entity, routeTokens, params) {
        if (!routeTokens || !routeTokens.userId) {
            throw new Error(MISSING_USER_PARAM_EXCEPTION_MSG);
        }
        else if (!routeTokens.roleName) {
            throw new Error(MISSING_ROLE_PARAM_EXCEPTION_MSG);
        }
        return super.update(null, routeTokens, params);
    }
    /**
     * Removes a user from a role assignment.
     * @param {?} id
     * @param {?=} routeTokens
     * @param {?=} params
     * @return {?}
     */
    delete(id, routeTokens, params) {
        if (!routeTokens || !routeTokens.userId) {
            throw new Error(MISSING_USER_PARAM_EXCEPTION_MSG);
        }
        else if (!routeTokens.roleName) {
            throw new Error(MISSING_ROLE_PARAM_EXCEPTION_MSG);
        }
        return super.delete(id, routeTokens, params);
    }
    /**
     * Retrieves all roles assigned to the given user ID.
     * @param {?} userId
     * @param {?=} params
     * @return {?}
     */
    rolesByUser(userId, params) {
        return this.query({ userId }, params);
    }
    /**
     * Adds a user to role.
     * @param {?} userId
     * @param {?} role
     * @param {?=} params
     * @return {?}
     */
    addUserToRole(userId, role, params) {
        // NOTE: We pass an arbitrary "_" role name because the route requires a role name,
        // however the role's name is going to be pulled from the role entity on the server.
        // The reason we don't pass "role.name" here is because of issues with IIS not
        // handling decoded backslashes (ex: TSS\TSS Users).
        return super.update(role, { userId, roleName: '_' }, params);
    }
    /**
     * Adds a user to role.
     * @param {?} userId
     * @param {?} roleName
     * @param {?=} params
     * @return {?}
     */
    addUserToRoleByName(userId, roleName, params) {
        roleName = decodeURIComponent(roleName);
        return this.update(null, { userId, roleName }, params);
    }
    /**
     * Removes a user from the given role.
     * @param {?} userId
     * @param {?} role
     * @param {?=} params
     * @return {?}
     */
    removeUserFromRole(userId, role, params) {
        return this.removeUserFromRoleByName(userId, role.name, params);
    }
    /**
     * Removes a user from the given role.
     * @param {?} userId
     * @param {?} roleName
     * @param {?=} params
     * @return {?}
     */
    removeUserFromRoleByName(userId, roleName, params) {
        roleName = decodeURIComponent(roleName);
        return this.delete(userId, { userId, roleName }, params);
    }
}
UserRoleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
UserRoleService.ctorParameters = () => [
    { type: HttpClient },
    { type: SecurityConfig }
];
/** @nocollapse */ UserRoleService.ngInjectableDef = i0.defineInjectable({ factory: function UserRoleService_Factory() { return new UserRoleService(i0.inject(i1.HttpClient), i0.inject(i2.SecurityConfig)); }, token: UserRoleService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserRoleService.prototype.http;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXNlci1yb2xlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdHNzL3Nkay8iLCJzb3VyY2VzIjpbImxpYi9zZWN1cml0eS9yb2xlcy91c2VyLXJvbGUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBYyxNQUFNLHNCQUFzQixDQUFDO0FBQzlELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFJM0MsT0FBTyxFQUFRLGdDQUFnQyxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUNoRixPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDcEQsT0FBTyxFQUFFLDZCQUE2QixFQUFFLGdDQUFnQyxFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFDekgsT0FBTyxFQUFFLGdDQUFnQyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQWlCekUsTUFBTSxPQUFPLGVBQWdCLFNBQVEsbUJBQXlCOzs7OztJQUM1RCxZQUFzQixJQUFnQixFQUFFLE1BQXNCO1FBQzVELEtBQUssQ0FBQyxJQUFJLEVBQUU7WUFDVixHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLGlCQUFpQixDQUFDO1lBQ3RELFdBQVcsRUFBRSxRQUFRO1NBQ3RCLENBQUMsQ0FBQztRQUppQixTQUFJLEdBQUosSUFBSSxDQUFZO0lBS3RDLENBQUM7Ozs7Ozs7SUFLRCxLQUFLLENBQUMsV0FBaUIsRUFBRSxNQUFtQjtRQUMxQyxJQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRTtZQUN2QyxNQUFNLElBQUksS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7U0FDbkQ7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QWM7Ozs7Ozs7O0lBc0JULCtCQUEwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0dHBDbGllbnQsIEh0dHBQYXJhbXMgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgUm9sZSwgTUlTU0lOR19ST0xFX1BBUkFNX0VYQ0VQVElPTl9NU0cgfSBmcm9tICcuL3JvbGUnO1xuaW1wb3J0IHsgU2VjdXJpdHlDb25maWcgfSBmcm9tICcuLi9zZWN1cml0eS1jb25maWcnO1xuaW1wb3J0IHsgQmFzZVJlc291cmNlU2VydmljZSB9IGZyb20gJy4uLy4uL2NvcmUvcmVzb3VyY2UvYmFzZS1yZXNvdXJjZS5zZXJ2aWNlJztcbmltcG9ydCB7IGpvaW4gfSBmcm9tICcuLi8uLi9jb3JlL3VybC9qb2luLmZ1bmN0aW9uJztcbmltcG9ydCB7IFVOU1VQUE9SVEVEX0dFVF9FWENFUFRJT05fTVNHLCBVTlNVUFBPUlRFRF9DUkVBVEVfRVhDRVBUSU9OX01TRyB9IGZyb20gJy4uLy4uL2NvcmUvcmVzb3VyY2UvcmVzb3VyY2UuY29uc3RhbnRzJztcbmltcG9ydCB7IE1JU1NJTkdfVVNFUl9QQVJBTV9FWENFUFRJT05fTVNHIH0gZnJvbSAnLi4vc2VjdXJpdHkuY29uc3RhbnRzJztcblxuXG4vKipcbiAqIFNlcnZpY2UgdG8gcHJvdmlkZSBhbGwgQ1JVRCBvcGVyYXRpb25zIGZvciB1c2VyL3JvbGUgYXNzaWdubWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMgR2V0cyByb2xlcyBmb3IgYSBnaXZlbiB1c2VyOlxuICogc2VydmljZS5yb2xlc0J5VXNlcignODc5ZTI3ZTEtYjEzOS00MzQ4LTg2Y2EtZWM0ZDU2NTE0NzVmJylcbiAqXG4gKiAvLyBXaGljaCBpcyBqdXN0IGEgc2hvcnRjdXQgZm9yOlxuICogc2VydmljZS5xdWVyeSh7IHVzZXJJZDogJzg3OWUyN2UxLWIxMzktNDM0OC04NmNhLWVjNGQ1NjUxNDc1ZicgfSk7XG4gKlxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBVc2VyUm9sZVNlcnZpY2UgZXh0ZW5kcyBCYXNlUmVzb3VyY2VTZXJ2aWNlPFJvbGU+IHtcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGh0dHA6IEh0dHBDbGllbnQsIGNvbmZpZzogU2VjdXJpdHlDb25maWcpIHtcbiAgICBzdXBlcihodHRwLCB7XG4gICAgICB1cmw6IGpvaW4oY29uZmlnLnNlcnZpY2VVcmwsIGNvbmZpZy51c2VyUm9sZXNFbmRwb2ludCksXG4gICAgICBpZEZpZWxkTmFtZTogJ3VzZXJJZCdcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIHJvbGVzIGZvciBhIGdpdmVuIHVzZXIgSUQuXG4gICAqL1xuICBxdWVyeShyb3V0ZVRva2Vucz86IGFueSwgcGFyYW1zPzogSHR0cFBhcmFtcyk6IE9ic2VydmFibGU8Um9sZVtdPiB7XG4gICAgaWYgKCFyb3V0ZVRva2VucyB8fCAhcm91dGVUb2tlbnMudXNlcklkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoTUlTU0lOR19VU0VSX1BBUkFNX0VYQ0VQVElPTl9NU0cpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5xdWVyeShyb3V0ZVRva2VucywgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIHJlc291cmNlLiBQbGVhc2UgdXNlIFwicm9sZXNCeVVzZXJcIi5cbiAgICovXG4gIGdldChpZDogc3RyaW5nIHwgbnVtYmVyLCByb3V0ZVRva2Vucz86IGFueSwgcGFyYW1zPzogSHR0cFBhcmFtcyk6IE9ic2VydmFibGU8Um9sZT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihVTlNVUFBPUlRFRF9HRVRfRVhDRVBUSU9OX01TRyk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyByZXNvdXJjZS4gUGxlYXNlIHVzZSBcImFkZFVzZXJUb1JvbGVcIi5cbiAgICovXG4gIGNyZWF0ZShlbnRpdHk6IFJvbGUsIHJvdXRlVG9rZW5zPzogYW55LCBwYXJhbXM/OiBIdHRwUGFyYW1zKTogT2JzZXJ2YWJsZTxSb2xlPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFVOU1VQUE9SVEVEX0NSRUFURV9FWENFUFRJT05fTVNHKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgdXNlcnMgcm9sZSBhc3NpZ25tZW50IChhZGRzIGEgcm9sZSB0byBhIHVzZXIpLlxuICAgKi9cbiAgdXBkYXRlKGVudGl0eTogUm9sZSwgcm91dGVUb2tlbnM/OiBhbnksIHBhcmFtcz86IEh0dHBQYXJhbXMpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIGlmICghcm91dGVUb2tlbnMgfHwgIXJvdXRlVG9rZW5zLnVzZXJJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKE1JU1NJTkdfVVNFUl9QQVJBTV9FWENFUFRJT05fTVNHKTtcbiAgICB9IGVsc2UgaWYgKCFyb3V0ZVRva2Vucy5yb2xlTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKE1JU1NJTkdfUk9MRV9QQVJBTV9FWENFUFRJT05fTVNHKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIudXBkYXRlKG51bGwsIHJvdXRlVG9rZW5zLCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSB1c2VyIGZyb20gYSByb2xlIGFzc2lnbm1lbnQuXG4gICAqL1xuICBkZWxldGUoaWQ6IHN0cmluZyB8IG51bWJlciwgcm91dGVUb2tlbnM/OiBhbnksIHBhcmFtcz86IEh0dHBQYXJhbXMpOiBPYnNlcnZhYmxlPFJvbGU+IHtcbiAgICBpZiAoIXJvdXRlVG9rZW5zIHx8ICFyb3V0ZVRva2Vucy51c2VySWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX1VTRVJfUEFSQU1fRVhDRVBUSU9OX01TRyk7XG4gICAgfSBlbHNlIGlmICghcm91dGVUb2tlbnMucm9sZU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX1JPTEVfUEFSQU1fRVhDRVBUSU9OX01TRyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmRlbGV0ZShpZCwgcm91dGVUb2tlbnMsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGFsbCByb2xlcyBhc3NpZ25lZCB0byB0aGUgZ2l2ZW4gdXNlciBJRC5cbiAgICovXG4gIHJvbGVzQnlVc2VyKHVzZXJJZDogc3RyaW5nLCBwYXJhbXM/OiBIdHRwUGFyYW1zKTogT2JzZXJ2YWJsZTxSb2xlW10+IHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeSh7IHVzZXJJZCB9LCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB1c2VyIHRvIHJvbGUuXG4gICAqL1xuICBhZGRVc2VyVG9Sb2xlKHVzZXJJZDogc3RyaW5nLCByb2xlOiBSb2xlLCBwYXJhbXM/OiBIdHRwUGFyYW1zKTogT2JzZXJ2YWJsZTxSb2xlPiB7XG4gICAgLy8gTk9URTogV2UgcGFzcyBhbiBhcmJpdHJhcnkgXCJfXCIgcm9sZSBuYW1lIGJlY2F1c2UgdGhlIHJvdXRlIHJlcXVpcmVzIGEgcm9sZSBuYW1lLFxuICAgIC8vIGhvd2V2ZXIgdGhlIHJvbGUncyBuYW1lIGlzIGdvaW5nIHRvIGJlIHB1bGxlZCBmcm9tIHRoZSByb2xlIGVudGl0eSBvbiB0aGUgc2VydmVyLlxuICAgIC8vIFRoZSByZWFzb24gd2UgZG9uJ3QgcGFzcyBcInJvbGUubmFtZVwiIGhlcmUgaXMgYmVjYXVzZSBvZiBpc3N1ZXMgd2l0aCBJSVMgbm90XG4gICAgLy8gaGFuZGxpbmcgZGVjb2RlZCBiYWNrc2xhc2hlcyAoZXg6IFRTU1xcVFNTIFVzZXJzKS5cbiAgICByZXR1cm4gc3VwZXIudXBkYXRlKHJvbGUsIHsgdXNlcklkLCByb2xlTmFtZTogJ18nIH0sIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHVzZXIgdG8gcm9sZS5cbiAgICovXG4gIGFkZFVzZXJUb1JvbGVCeU5hbWUodXNlcklkOiBzdHJpbmcsIHJvbGVOYW1lOiBzdHJpbmcsIHBhcmFtcz86IEh0dHBQYXJhbXMpOiBPYnNlcnZhYmxlPFJvbGU+IHtcbiAgICByb2xlTmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudChyb2xlTmFtZSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlKG51bGwsIHsgdXNlcklkLCByb2xlTmFtZSB9LCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSB1c2VyIGZyb20gdGhlIGdpdmVuIHJvbGUuXG4gICAqL1xuICByZW1vdmVVc2VyRnJvbVJvbGUodXNlcklkOiBzdHJpbmcsIHJvbGU6IFJvbGUsIHBhcmFtcz86IEh0dHBQYXJhbXMpOiBPYnNlcnZhYmxlPFJvbGU+IHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVVc2VyRnJvbVJvbGVCeU5hbWUodXNlcklkLCByb2xlLm5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHVzZXIgZnJvbSB0aGUgZ2l2ZW4gcm9sZS5cbiAgICovXG4gIHJlbW92ZVVzZXJGcm9tUm9sZUJ5TmFtZSh1c2VySWQ6IHN0cmluZywgcm9sZU5hbWU6IHN0cmluZywgcGFyYW1zPzogSHR0cFBhcmFtcyk6IE9ic2VydmFibGU8Um9sZT4ge1xuICAgIHJvbGVOYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KHJvbGVOYW1lKTtcbiAgICByZXR1cm4gdGhpcy5kZWxldGUodXNlcklkLCB7IHVzZXJJZCwgcm9sZU5hbWUgfSwgcGFyYW1zKTtcbiAgfVxufVxuIl19